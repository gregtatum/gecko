// THIS IS A GENERATED FILE, DO NOT EDIT DIRECTLY
var WorkshopBackend = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = (x) => {
    if (typeof require !== "undefined")
      return require(x);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  };
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // src/vendor/evt.js
  var require_evt = __commonJS({
    "src/vendor/evt.js"(exports, module) {
      (function(root, factory) {
        "use strict";
        if (typeof define === "function" && define.amd) {
          define(factory);
        } else if (typeof exports === "object") {
          module.exports = factory();
        } else {
          root.evt = factory();
        }
      })(exports, function() {
        "use strict";
        var evt12, slice = Array.prototype.slice, props = [
          "_events",
          "_pendingEvents",
          "on",
          "once",
          "latest",
          "latestOnce",
          "removeObjectListener",
          "removeListener",
          "emitWhenListener",
          "emit"
        ];
        function objFnPair(obj, fn) {
          if (!fn) {
            fn = obj;
            obj = void 0;
            if (!(fn instanceof Function)) {
              throw new Error("You did not provide a function!");
            }
          } else {
            if (typeof fn === "string") {
              if (!(obj[fn] instanceof Function)) {
                throw new Error(`String ${fn} does not reference a function on obj!`);
              }
            } else if (!(fn instanceof Function)) {
              throw new Error("fn is neither a function or a string!");
            }
          }
          return [obj, fn];
        }
        function callApply(applyPair, args) {
          var obj = applyPair[0], fn = applyPair[1];
          if (typeof fn === "string") {
            fn = obj[fn];
          }
          return fn.apply(obj, args);
        }
        function cleanEventEntry(emitter, id) {
          var listeners2 = emitter._events[id];
          if (listeners2 && !listeners2.length) {
            delete emitter._events[id];
          }
        }
        function emitError(err) {
          if (evt12._events.hasOwnProperty("error")) {
            evt12.emit("error", err);
          } else {
            console.error(err, err.stack);
          }
        }
        function Emitter() {
          this._events = {};
          this._pendingEvents = {};
        }
        Emitter.prototype = {
          on: function(id, obj, fnName) {
            var applyPair = objFnPair(obj, fnName);
            var listeners2 = this._events[id], pending = this._pendingEvents[id];
            if (!listeners2) {
              listeners2 = this._events[id] = [];
            }
            listeners2.push(applyPair);
            if (pending) {
              pending.forEach(function(args) {
                callApply(applyPair, args);
              });
              delete this._pendingEvents[id];
            }
            return this;
          },
          once: function(id, obj, fnName) {
            var self2 = this, fired = false, applyPair = objFnPair(obj, fnName);
            function one() {
              if (fired) {
                return;
              }
              fired = true;
              callApply(applyPair, arguments);
              setTimeout(function() {
                self2.removeListener(id, one);
              });
            }
            return this.on(id, applyPair[0], one);
          },
          latest: function(id, obj, fnName) {
            var applyPair = objFnPair(obj, fnName);
            if (this[id] && !this._pendingEvents[id]) {
              callApply(applyPair, [this[id]]);
            }
            this.on(id, applyPair[0], applyPair[1]);
          },
          latestOnce: function(id, obj, fnName) {
            var applyPair = objFnPair(obj, fnName);
            if (this[id] && !this._pendingEvents[id]) {
              callApply(applyPair, [this[id]]);
            } else {
              this.once(id, applyPair[0], applyPair[1]);
            }
          },
          removeObjectListener: function(obj) {
            Object.keys(this._events).forEach(function(eventId) {
              var listeners2 = this._events[eventId];
              for (var i = 0; i < listeners2.length; i++) {
                var applyPair = listeners2[i];
                if (applyPair[0] === obj) {
                  listeners2.splice(i, 1);
                  i -= 1;
                }
              }
              cleanEventEntry(this, eventId);
            }.bind(this));
          },
          removeListener: function(id, obj, fnName) {
            var listeners2 = this._events[id], applyPair = objFnPair(obj, fnName);
            if (listeners2) {
              listeners2.some(function(listener, i) {
                if (listener[0] === applyPair[0] && listener[1] === applyPair[1]) {
                  listeners2.splice(i, 1);
                  return true;
                }
              });
              cleanEventEntry(this, id);
            }
          },
          emitWhenListener: function(id) {
            var listeners2 = this._events[id];
            if (listeners2) {
              this.emit.apply(this, arguments);
            } else {
              if (!this._pendingEvents[id]) {
                this._pendingEvents[id] = [];
              }
              this._pendingEvents[id].push(slice.call(arguments, 1));
            }
          },
          emit: function(id) {
            var args = slice.call(arguments, 1), listeners2 = this._events[id];
            if (listeners2) {
              for (var i = 0; i < listeners2.length; i++) {
                var thisObj = listeners2[i][0], fn = listeners2[i][1];
                try {
                  callApply(listeners2[i], args);
                } catch (e) {
                  emitError(e);
                }
                if (!listeners2[i] || listeners2[i][0] !== thisObj || listeners2[i][1] !== fn) {
                  i -= 1;
                }
              }
            }
          }
        };
        evt12 = new Emitter();
        evt12.Emitter = Emitter;
        evt12.mix = function(obj) {
          var e = new Emitter();
          props.forEach(function(prop) {
            if (obj.hasOwnProperty(prop)) {
              throw new Error('Object already has a property "' + prop + '"');
            }
            obj[prop] = e[prop];
          });
          return obj;
        };
        return evt12;
      });
    }
  });

  // src/vendor/equal.js
  function boundedCmpObjs(a, b, depthLeft) {
    var aAttrCount = 0, bAttrCount = 0, key, nextDepth = depthLeft - 1;
    if ("toJSON" in a)
      a = a.toJSON();
    if ("toJSON" in b)
      b = b.toJSON();
    for (key in a) {
      aAttrCount++;
      if (!(key in b))
        return false;
      if (depthLeft) {
        if (!equal(a[key], b[key], nextDepth))
          return false;
      } else {
        if (a[key] !== b[key])
          return false;
      }
    }
    for (key in b) {
      bAttrCount++;
    }
    if (aAttrCount !== bAttrCount)
      return false;
    return true;
  }
  function equal(a, b, depthLeft) {
    if (depthLeft === void 0) {
      depthLeft = COMPARE_DEPTH;
    }
    var ta = typeof a, tb = typeof b;
    if (ta !== "object" || tb !== ta || a == null || b == null)
      return a === b;
    if (a === b)
      return true;
    if (Array.isArray(a)) {
      if (!Array.isArray(b))
        return false;
      if (a.length !== b.length)
        return false;
      for (var iArr = 0; iArr < a.length; iArr++) {
        if (!equal(a[iArr], b[iArr], depthLeft - 1))
          return false;
      }
      return true;
    }
    return boundedCmpObjs(a, b, depthLeft);
  }
  var COMPARE_DEPTH;
  var init_equal = __esm({
    "src/vendor/equal.js"() {
      COMPARE_DEPTH = 6;
    }
  });

  // src/shared/logic.js
  function logic() {
    return logic.event.apply(logic, arguments);
  }
  function toScope(scope4) {
    if (!(scope4 instanceof Scope)) {
      scope4 = objectToScope.get(scope4);
      if (!scope4) {
        throw new Error("Invalid scope " + scope4 + " passed to logic.event(); did you remember to call logic.defineScope()? " + new Error().stack);
      }
    }
    return scope4;
  }
  function MismatchError(matcher, event) {
    this.matcher = matcher;
    this.event = event;
  }
  function LogicMatcher(opts) {
    this.matchedLogs = opts.prevMatcher ? opts.prevMatcher.matchedLogs : [];
    this.capturedLogs = [];
    this.ns = opts.ns;
    this.type = opts.type;
    this.detailPredicate = opts.detailPredicate;
    this.failOnMismatchedDetails = true;
    this.not = opts.not;
    this.timeoutMS = 2e3;
    this.resolved = false;
    this.anotherMatcherNeedsMyLogs = false;
    if (opts.prevMatcher) {
      opts.prevMatcher.anotherMatcherNeedsMyLogs = true;
    }
    logic.defineScope(this, "LogicMatcher");
    var hasPrevPromise = !!opts.prevPromise;
    var normalizedPrevPromise = opts.prevPromise || Promise.resolve();
    if (this.not) {
      this.promise = normalizedPrevPromise.then(() => {
        this.capturedLogs.some((event) => {
          if ((!this.ns || event.namespace === this.ns) && event.matches(this.type, this.detailPredicate)) {
            throw new MismatchError(this, event);
          }
        });
      });
    } else if (this.type) {
      this.promise = new Promise((resolve, reject) => {
        var subscribeToNextMatch = () => {
          var timeoutId = setTimeout(() => {
            logic(this, "failedMatch", {
              ns: this.ns,
              type: this.type,
              detailPredicate: this.detailPredicate,
              capturedLogs: this.capturedLogs
            });
            reject(new Error("LogicMatcherTimeout: " + this));
          }, this.timeoutMS);
          var resolveThisMatcher = (event) => {
            this.resolved = true;
            this.capturedLogs = [];
            if (!this.anotherMatcherNeedsMyLogs) {
              this.removeMatchListener();
            }
          };
          var matchFn = (event) => {
            this.capturedLogs.push(event);
            if (this.resolved) {
              return true;
            }
            if (this.ns && event.namespace !== this.ns || event.type !== this.type) {
              return false;
            }
            if (event.matches(this.type, this.detailPredicate)) {
              resolveThisMatcher(event);
              this.matchedLogs.push(event);
              clearTimeout(timeoutId);
              logic(this, "match", {
                ns: this.ns,
                type: this.type,
                event
              });
              resolve(event);
              return true;
            } else if (this.failOnMismatchedDetails) {
              resolveThisMatcher(event);
              reject(new MismatchError(this, event));
              return true;
            }
            return false;
          };
          this.removeMatchListener = () => {
            logic.removeListener("event", matchFn);
          };
          logic.on("event", matchFn);
          if (opts.prevMatcher) {
            var prevLogs = opts.prevMatcher.capturedLogs;
            var matchIndex = prevLogs.findIndex(matchFn);
            if (matchIndex !== -1) {
              this.capturedLogs = prevLogs.slice(matchIndex + 1);
            }
            opts.prevMatcher.removeMatchListener();
          }
        };
        if (hasPrevPromise) {
          normalizedPrevPromise.then(subscribeToNextMatch, (e) => reject(e));
        } else {
          try {
            subscribeToNextMatch();
          } catch (e) {
            reject(e);
          }
        }
      });
    } else {
      this.promise = normalizedPrevPromise;
    }
  }
  function Scope(namespace, defaultDetails) {
    this.namespace = namespace;
    if (defaultDetails && !isPlainObject(defaultDetails)) {
      throw new Error("Invalid defaultDetails; expected a plain-old object: " + defaultDetails);
    }
    this.defaultDetails = defaultDetails;
  }
  function ObjectSimplifier(opts) {
    opts = opts || {};
    this.maxDepth = opts.maxDepth || 10;
    this.maxStringLength = opts.maxStringLength || 1e3;
    this.maxArrayLength = opts.maxArrayLength || 1e3;
    this.maxObjectLength = opts.maxObjectLength || 100;
  }
  function LogicEvent(scope4, type, details) {
    if (!(scope4 instanceof Scope)) {
      throw new Error('Invalid "scope" passed to LogicEvent(); did you remember to call logic.defineScope()?');
    }
    this.scope = scope4;
    this.type = type;
    this.details = details;
    this.time = Date.now();
    this.id = logic.uniqueId();
    this.jsonRepresentation = {
      namespace: this.scope.namespace,
      type: this.type,
      details: new ObjectSimplifier().simplify(this.details),
      time: this.time,
      id: this.id
    };
  }
  function isPlainObject(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (obj.toString && obj.toString() !== "[object Object]") {
      return false;
    }
    for (var k in obj) {
      if (typeof k === "function") {
        return false;
      }
    }
    return true;
  }
  function shallowClone(x) {
    if (isPlainObject(x)) {
      var ret = {};
      for (var key in x) {
        ret[key] = x[key];
      }
      return ret;
    }
    return x;
  }
  function into(target, source) {
    if (!target) {
      target = {};
    }
    for (var key in source) {
      target[key] = source[key];
    }
    return target;
  }
  var import_evt, objectToScope, nextId, interceptions, promiseToStartEventMap, promiseToResultEventMap;
  var init_logic = __esm({
    "src/shared/logic.js"() {
      import_evt = __toModule(require_evt());
      init_equal();
      import_evt.default.mix(logic);
      logic.scope = function(namespace, defaultDetails) {
        return new Scope(namespace, defaultDetails);
      };
      objectToScope = new WeakMap();
      logic.defineScope = function(obj, namespace, defaultDetails) {
        if (!namespace && obj && obj.constructor && obj.constructor.name) {
          namespace = obj.constructor.name;
        }
        var scope4 = new Scope(namespace, defaultDetails);
        objectToScope.set(obj, scope4);
        return scope4;
      };
      logic.subscope = function(scope4, defaultDetails) {
        scope4 = toScope(scope4);
        return new Scope(scope4.namespace, into(shallowClone(scope4.defaultDetails), shallowClone(defaultDetails)));
      };
      logic.event = function(scope4, type, details) {
        scope4 = toScope(scope4);
        var isDefaultPrevented = false;
        var preprocessEvent = {
          scope: scope4,
          namespace: scope4.namespace,
          type,
          details,
          preventDefault() {
            isDefaultPrevented = true;
          }
        };
        logic.emit("preprocessEvent", preprocessEvent);
        if (isDefaultPrevented) {
          return { id: 0 };
        }
        type = preprocessEvent.type;
        details = preprocessEvent.details;
        if (typeof type !== "string") {
          throw new Error('Invalid "type" passed to logic.event(); expected a string, got "' + type + '"');
        }
        if (scope4.defaultDetails) {
          if (isPlainObject(details)) {
            details = into(shallowClone(scope4.defaultDetails), shallowClone(details));
          } else {
            details = shallowClone(scope4.defaultDetails);
          }
        } else {
          details = shallowClone(details);
        }
        var event = new LogicEvent(scope4, type, details);
        logic.emit("censorEvent", event);
        logic.emit("event", event);
        if (logic.bc) {
          logic.bc.postMessage({ mode: "append", event: event.jsonRepresentation });
        }
        if (logic.realtimeLogEverything) {
          dump("logic: " + JSON.stringify(event) + "\n");
        }
        return event;
      };
      logic.underTest = false;
      logic._currentTestRejectFunction = null;
      logic.fail = function(ex) {
        if (logic.underTest) {
          if (logic._currentTestRejectFunction) {
            logic._currentTestRejectFunction(ex);
          } else {
            throw ex;
          }
        } else {
          console.error("Logic fail:", ex);
        }
      };
      nextId = 1;
      logic.uniqueId = function() {
        return nextId++;
      };
      logic.isCensored = false;
      logic.realtimeLogEverything = false;
      logic.bc = null;
      interceptions = {};
      logic.interceptable = function(type, fn) {
        if (interceptions[type]) {
          return interceptions[type]();
        }
        return fn();
      };
      logic.interceptOnce = function(type, replacementFn) {
        var prevFn = interceptions[type];
        interceptions[type] = function() {
          interceptions[type] = prevFn;
          return replacementFn();
        };
      };
      logic.match = function(ns, type, detailPredicate) {
        return new LogicMatcher(LogicMatcher.normalizeMatchArgs(ns, type, detailPredicate));
      };
      MismatchError.prototype = Object.create(Error.prototype, {
        constructor: { value: MismatchError },
        toString: {
          value() {
            if (this.matcher.not) {
              return "MismatchError: expected " + this.event + " to not occur (failIfMatched " + this.matcher + ").";
            }
            return "MismatchError: expected " + this.event + " to match " + JSON.stringify(this.matcher.detailPredicate) + ".";
          }
        }
      });
      LogicMatcher.normalizeMatchArgs = function(ns, type, details) {
        if (typeof type === "object") {
          details = type;
          type = ns;
          ns = null;
        }
        return { ns, type, detailPredicate: details };
      };
      LogicMatcher.prototype = {
        match(ns, type, details) {
          var args = LogicMatcher.normalizeMatchArgs(ns, type, details);
          args.prevMatcher = this;
          args.prevPromise = this.promise;
          return new LogicMatcher(args);
        },
        failIfMatched(ns, type, details) {
          var args = LogicMatcher.normalizeMatchArgs(ns, type, details);
          args.not = true;
          args.prevMatcher = this;
          args.prevPromise = this.promise;
          return new LogicMatcher(args);
        },
        then(fn, catchFn) {
          return new LogicMatcher({
            prevPromise: this.promise.then(() => {
              var ret = fn(this.matchedLogs.slice());
              if (ret instanceof Promise) {
                ret = new LogicMatcher({
                  prevPromise: ret
                });
              }
              return ret;
            }, catchFn)
          });
        },
        toString() {
          return "<LogicMatcher " + (this.ns ? this.ns + "/" : "") + this.type + " " + new ObjectSimplifier().simplify(this.detailPredicate) + ">";
        }
      };
      ObjectSimplifier.prototype = {
        simplify(x) {
          return this._simplify(x, 0, new WeakSet());
        },
        _simplify(x, depth, cacheSet) {
          if (cacheSet.has(x)) {
            return "(cycle)";
          }
          if (typeof x === "number") {
            return x;
          } else if (typeof x === "string") {
            return x.slice(0, this.maxStringLength);
          } else if (x && x.BYTES_PER_ELEMENT) {
            return x.slice(0, this.maxArrayLength);
          } else if (Array.isArray(x)) {
            if (depth < this.maxDepth) {
              return x.slice(0, this.maxArrayLength).map((element) => this._simplify(element, depth + 1, cacheSet));
            }
            return "[Array length=" + x.length + "]";
          } else if (x && typeof x === "object") {
            cacheSet.add(x);
            if (!isPlainObject(x)) {
              if (x.toJSON) {
                return this._simplify(x.toJSON(), depth, cacheSet);
              } else if (x.toString) {
                return this._simplify(x.toString(), depth, cacheSet);
              } else if (x instanceof Map) {
                return this._simplify([...Map.prototype.entries.call(x)].toJSON(), depth, cacheSet);
              } else if (x instanceof Set) {
                return this._simplify([...Set.prototype.entries.call(x)].toJSON(), depth, cacheSet);
              }
              return "(?)";
            }
            if (depth < this.maxDepth) {
              var retObj = {};
              var idx = 0;
              for (var key in x) {
                if (idx > this.maxObjectLength) {
                  break;
                }
                retObj[key] = this._simplify(x[key], depth + 1, cacheSet);
                idx++;
              }
              return retObj;
            } else if (x.toString) {
              return this._simplify(x.toString(), depth, cacheSet);
            }
            return "(object?)";
          } else if (typeof x === "function") {
            return "(function)";
          }
          return x;
        }
      };
      LogicEvent.fromJSON = function(data) {
        var event = new LogicEvent(new Scope(data.namespace), data.type, data.details);
        event.time = data.time;
        event.id = data.id;
        return event;
      };
      LogicEvent.prototype = {
        get namespace() {
          return this.scope.namespace;
        },
        toJSON() {
          return this.jsonRepresentation;
        },
        toString() {
          return "<LogicEvent [34m" + this.namespace + "[0m/[36m" + this.type + "[0m\n[37m" + JSON.stringify(this.jsonRepresentation.details, null, 2) + "[0m>";
        },
        matches(type, detailPredicate) {
          if (this.type !== type) {
            return false;
          }
          if (typeof detailPredicate === "function") {
            return !!detailPredicate(this.details);
          } else if (isPlainObject(detailPredicate)) {
            for (var key in detailPredicate) {
              var expected = detailPredicate && detailPredicate[key];
              var actual = this.details && this.details[key];
              if (actual === void 0) {
                actual = null;
              }
              if (expected === void 0) {
                continue;
              } else if (!this.details || !equal(expected, actual)) {
                return false;
              }
            }
            return true;
          } else if (detailPredicate != null) {
            return equal(this.details, detailPredicate);
          }
          return true;
        }
      };
      logic.isPlainObject = isPlainObject;
      promiseToStartEventMap = new WeakMap();
      promiseToResultEventMap = new WeakMap();
      logic.startAsync = function(scope4, type, details) {
        var resolve, reject;
        logic.async(scope4, type, details, (_resolve, _reject) => {
          resolve = _resolve;
          reject = _reject;
        });
        return {
          resolve,
          reject
        };
      };
      logic.async = function(scope4, type, details, fn) {
        if (!fn && typeof details === "function") {
          fn = details;
          details = null;
        }
        scope4 = logic.subscope(scope4, details);
        var startEvent;
        var promise = new Promise((resolve, reject) => {
          startEvent = logic(scope4, "begin " + type, {
            asyncStatus: 0,
            asyncName: type
          });
          fn((result) => {
            promiseToResultEventMap.set(promise, logic(scope4, type, {
              asyncStatus: 1,
              sourceEventIds: [startEvent.id],
              result
            }));
            resolve(result);
          }, (error) => {
            promiseToResultEventMap.set(promise, logic(scope4, type, {
              asyncStatus: 2,
              sourceEventIds: [startEvent.id],
              error
            }));
            reject(error);
          });
        });
        promiseToStartEventMap.set(promise, startEvent);
        return promise;
      };
      logic.await = function(scope4, type, details, promise) {
        if (!promise && details.then) {
          promise = details;
          details = null;
        }
        scope4 = logic.subscope(scope4, details);
        var startEvent = promiseToStartEventMap.get(promise);
        var awaitEvent = logic.event(scope4, "await " + type, {
          awaitStatus: 0,
          sourceEventIds: startEvent ? [startEvent.id] : null,
          awaitName: type
        });
        return promise.then((result) => {
          var resultEvent = promiseToResultEventMap.get(promise);
          logic(scope4, type, {
            awaitStatus: 1,
            result,
            sourceEventIds: resultEvent ? [resultEvent.id, awaitEvent.id] : [awaitEvent.id]
          });
          return result;
        }, (error) => {
          var resultEvent = promiseToResultEventMap.get(promise);
          logic(scope4, type, {
            awaitStatus: 2,
            error,
            stack: error && error.stack,
            sourceEventIds: resultEvent ? [resultEvent.id, awaitEvent.id] : [awaitEvent.id]
          });
          throw error;
        });
      };
    }
  });

  // src/backend/bodies/mailchew_strings.js
  function set(_strings) {
    strings = _strings;
    events.emit("strings", strings);
  }
  var import_evt2, events, strings;
  var init_mailchew_strings = __esm({
    "src/backend/bodies/mailchew_strings.js"() {
      import_evt2 = __toModule(require_evt());
      events = new import_evt2.default.Emitter();
      strings = null;
    }
  });

  // src/shared/a64.js
  function encodeInt(v, padTo) {
    var sbits = [];
    do {
      sbits.push(ORDERED_ARBITRARY_BASE64_CHARS[v & 63]);
      v = Math.floor(v / 64);
    } while (v > 0);
    sbits.reverse();
    var estr = sbits.join("");
    if (padTo && estr.length < padTo) {
      return ZERO_PADDING.substring(0, padTo - estr.length) + estr;
    }
    return estr;
  }
  function decodeA64Int(es) {
    return parseInt(decodeUI64(es), 10);
  }
  function decodeUI64(es) {
    var iNonZero = 0;
    for (; es.charCodeAt(iNonZero) === 48; iNonZero++) {
    }
    if (iNonZero) {
      es = es.substring(iNonZero);
    }
    var v, i;
    if (es.length <= 8) {
      v = 0;
      for (i = 0; i < es.length; i++) {
        v = v * 64 + ORDERED_ARBITRARY_BASE64_CHARS.indexOf(es[i]);
      }
      return v.toString(10);
    }
    var ues = es.substring(0, es.length - 6), uv = 0, les = es.substring(es.length - 6), lv = 0;
    for (i = 0; i < ues.length; i++) {
      uv = uv * 64 + ORDERED_ARBITRARY_BASE64_CHARS.indexOf(ues[i]);
    }
    for (i = 0; i < les.length; i++) {
      lv = lv * 64 + ORDERED_ARBITRARY_BASE64_CHARS.indexOf(les[i]);
    }
    var rsh14val = uv * P2_22 + Math.floor(lv / P2_14), uraw = rsh14val / E10_14_RSH_14, udv = Math.floor(uraw), uds = udv.toString();
    var rsh14Leftover = rsh14val - udv * E10_14_RSH_14, lowBitsRemoved = rsh14Leftover * P2_14 + lv % P2_14;
    var lds = lowBitsRemoved.toString();
    if (lds.length < 14) {
      lds = ZERO_PADDING.substring(0, 14 - lds.length) + lds;
    }
    return uds + lds;
  }
  var ORDERED_ARBITRARY_BASE64_CHARS, ZERO_PADDING, E10_14_RSH_14, P2_14, P2_22, P2_36;
  var init_a64 = __esm({
    "src/shared/a64.js"() {
      ORDERED_ARBITRARY_BASE64_CHARS = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "{",
        "}"
      ];
      ZERO_PADDING = "0000000000000000";
      E10_14_RSH_14 = Math.pow(10, 14) / Math.pow(2, 14);
      P2_14 = Math.pow(2, 14);
      P2_22 = Math.pow(2, 22);
      P2_36 = Math.pow(2, 36);
    }
  });

  // src/shared/id_conversions.js
  function accountIdFromIdentityId(identityId) {
    return identityId.split(/\./g, 1)[0];
  }
  function accountIdFromFolderId(folderId) {
    return folderId.split(/\./g, 1)[0];
  }
  function decodeSpecificFolderIdFromFolderId(folderId) {
    let idxFirst = folderId.indexOf(".");
    return decodeA64Int(folderId.substring(idxFirst + 1));
  }
  function accountIdFromConvId(convId) {
    return convId.split(/\./g, 1)[0];
  }
  function accountIdFromMessageId(messageId) {
    return messageId.split(/\./g, 1)[0];
  }
  function convIdFromMessageId(messageId) {
    let idxFirst = messageId.indexOf(".");
    let idxSecond = messageId.indexOf(".", idxFirst + 1);
    return messageId.substring(0, idxSecond);
  }
  function messageSpecificIdFromMessageId(messageId) {
    return messageId.split(/\./g, 3)[2];
  }
  function messageIdComponentFromUmid(umid) {
    let idxFirst = umid.indexOf(".");
    return umid.substring(idxFirst + 1).replace(/\./g, "_");
  }
  var init_id_conversions = __esm({
    "src/shared/id_conversions.js"() {
      init_a64();
    }
  });

  // src/backend/accounts/activesync/configurator.js
  var configurator_exports = {};
  __export(configurator_exports, {
    default: () => configurator_default
  });
  function makeUniqueDeviceId() {
    return Math.random().toString(36).substr(2);
  }
  function configurator_default(userDetails, domainInfo) {
    let deviceId = makeUniqueDeviceId();
    let credentials;
    let connInfo;
    if (domainInfo.incoming.autodiscoverEndpoint) {
      credentials = {
        emailAddress: userDetails.emailAddress,
        password: userDetails.password
      };
      connInfo = {
        autodiscoverEndpoint: domainInfo.incoming.autodiscoverEndpoint,
        deviceId
      };
    } else {
      credentials = {
        username: domainInfo.incoming.username,
        password: userDetails.password
      };
      connInfo = {
        server: domainInfo.incoming.server,
        deviceId
      };
    }
    return {
      credentials,
      typeFields: {},
      connInfoFields: {
        connInfo
      }
    };
  }
  var init_configurator = __esm({
    "src/backend/accounts/activesync/configurator.js"() {
    }
  });

  // src/backend/accounts/feed/configurator.js
  var configurator_exports2 = {};
  __export(configurator_exports2, {
    default: () => configurateFeed
  });
  function configurateFeed(userDetails) {
    return {
      userDetails,
      credentials: {},
      typeFields: {},
      connInfoFields: {
        feedUrl: userDetails.feedUrl
      }
    };
  }
  var init_configurator2 = __esm({
    "src/backend/accounts/feed/configurator.js"() {
    }
  });

  // src/backend/accounts/ical/configurator.js
  var configurator_exports3 = {};
  __export(configurator_exports3, {
    default: () => configurateICal
  });
  function configurateICal(userDetails) {
    return {
      userDetails,
      credentials: {},
      typeFields: {},
      connInfoFields: {
        calendarUrl: userDetails.calendarUrl
      }
    };
  }
  var init_configurator3 = __esm({
    "src/backend/accounts/ical/configurator.js"() {
    }
  });

  // src/shared/date.js
  function NOW() {
    return TIME_WARPED_NOW || Date.now();
  }
  function makeDaysAgo(numDays) {
    var past = quantizeDate(TIME_WARPED_NOW || Date.now()) - numDays * DAY_MILLIS;
    return past;
  }
  function quantizeDate(date) {
    if (date === null) {
      return null;
    }
    if (typeof date === "number") {
      date = new Date(date);
    }
    return date.setUTCHours(0, 0, 0, 0).valueOf();
  }
  var HOUR_MILLIS, DAY_MILLIS, TIME_WARPED_NOW;
  var init_date = __esm({
    "src/shared/date.js"() {
      HOUR_MILLIS = 60 * 60 * 1e3;
      DAY_MILLIS = 24 * 60 * 60 * 1e3;
      TIME_WARPED_NOW = null;
    }
  });

  // src/backend/syncbase.js
  var AUTOCONFIG_TIMEOUT_MS, ISPDB_AUTOCONFIG_ROOT, POP3_INFER_ATTACHMENTS_SIZE, POP3_SNIPPET_SIZE_GOAL, OLDEST_SYNC_DATE, SYNC_WHOLE_FOLDER_AT_N_MESSAGES, BYTES_PER_BLOB_CHUNK, BYTES_PER_IMAP_FETCH_CHUNK_REQUEST, CHECK_INTERVALS_ENUMS_TO_MS, SYNC_RANGE_ENUMS_TO_MS, DESIRED_SNIPPET_LENGTH, DEFAULT_SEARCH_EXCERPT_SETTINGS, BLOB_BASE64_BATCH_CONVERT_SIZE, CRONSYNC_MAX_DURATION_MS;
  var init_syncbase = __esm({
    "src/backend/syncbase.js"() {
      init_date();
      AUTOCONFIG_TIMEOUT_MS = 30 * 1e3;
      ISPDB_AUTOCONFIG_ROOT = "https://live.mozillamessaging.com/autoconfig/v1.1/";
      POP3_INFER_ATTACHMENTS_SIZE = 512 * 1024;
      POP3_SNIPPET_SIZE_GOAL = 4 * 1024;
      OLDEST_SYNC_DATE = Date.UTC(1990, 0, 1);
      SYNC_WHOLE_FOLDER_AT_N_MESSAGES = 40;
      BYTES_PER_BLOB_CHUNK = 1024 * 1024;
      BYTES_PER_IMAP_FETCH_CHUNK_REQUEST = 1024 * 1024;
      CHECK_INTERVALS_ENUMS_TO_MS = {
        manual: 0,
        "3min": 3 * 60 * 1e3,
        "5min": 5 * 60 * 1e3,
        "10min": 10 * 60 * 1e3,
        "15min": 15 * 60 * 1e3,
        "30min": 30 * 60 * 1e3,
        "60min": 60 * 60 * 1e3
      };
      SYNC_RANGE_ENUMS_TO_MS = {
        auto: 30 * DAY_MILLIS,
        "1d": 1 * DAY_MILLIS,
        "3d": 3 * DAY_MILLIS,
        "1w": 7 * DAY_MILLIS,
        "2w": 14 * DAY_MILLIS,
        "1m": 30 * DAY_MILLIS,
        all: 30 * 365 * DAY_MILLIS
      };
      DESIRED_SNIPPET_LENGTH = 160;
      DEFAULT_SEARCH_EXCERPT_SETTINGS = {
        charsBefore: 16,
        charsAfter: 40
      };
      BLOB_BASE64_BATCH_CONVERT_SIZE = 9198 * 57;
      CRONSYNC_MAX_DURATION_MS = 60 * 1e3;
    }
  });

  // src/vendor/wbxml.js
  function makeError(name, parent2, extraArgs) {
    function CustomError() {
      var self2 = this instanceof CustomError ? this : Object.create(CustomError.prototype);
      var tmp = Error();
      var offset = 1;
      self2.stack = tmp.stack.substring(tmp.stack.indexOf("\n") + 1);
      self2.message = arguments[0] || tmp.message;
      if (extraArgs) {
        offset += extraArgs.length;
        for (var i = 0; i < extraArgs.length; i++)
          self2[extraArgs[i]] = arguments[i + 1];
      }
      var m = /@(.+):(.+)/.exec(self2.stack);
      self2.fileName = arguments[offset] || m && m[1] || "";
      self2.lineNumber = arguments[offset + 1] || m && m[2] || 0;
      return self2;
    }
    CustomError.prototype = Object.create((parent2 || Error).prototype);
    CustomError.prototype.name = name;
    CustomError.prototype.constructor = CustomError;
    return CustomError;
  }
  function StringTable(data, decoder) {
    this.strings = [];
    this.offsets = {};
    var start = 0;
    for (var i = 0; i < data.length; i++) {
      if (data[i] === 0) {
        this.offsets[start] = this.strings.length;
        this.strings.push(decoder.decode(data.subarray(start, i)));
        start = i + 1;
      }
    }
  }
  function CompileCodepages(codepages2) {
    codepages2.__nsnames__ = {};
    codepages2.__tagnames__ = {};
    codepages2.__attrdata__ = {};
    for (var name in codepages2) {
      var page = codepages2[name];
      if (name.match(/^__/))
        continue;
      if (page.Tags) {
        var tagName, tagValue;
        for (tagName in page.Tags) {
          tagValue = page.Tags[tagName];
          codepages2.__nsnames__[tagValue >> 8] = name;
          break;
        }
        for (tagName in page.Tags) {
          tagValue = page.Tags[tagName];
          codepages2.__tagnames__[tagValue] = tagName;
        }
      }
      if (page.Attrs) {
        for (var attrName in page.Attrs) {
          var attrData = page.Attrs[attrName];
          if (!("name" in attrData))
            attrData.name = attrName;
          codepages2.__attrdata__[attrData.value] = attrData;
          page.Attrs[attrName] = attrData.value;
        }
      }
    }
  }
  function Element(ownerDocument, type, tag) {
    this.ownerDocument = ownerDocument;
    this.type = type;
    this._attrs = {};
    if (typeof tag === "string") {
      var pieces = tag.split(":");
      if (pieces.length === 1) {
        this.localTagName = pieces[0];
      } else {
        this.namespaceName = pieces[0];
        this.localTagName = pieces[1];
      }
    } else {
      this.tag = tag;
      Object.defineProperties(this, {
        "namespace": { get: function() {
          return this.tag >> 8;
        } },
        "localTag": { get: function() {
          return this.tag & 255;
        } },
        "namespaceName": { get: function() {
          return this.ownerDocument._codepages.__nsnames__[this.namespace];
        } },
        "localTagName": { get: function() {
          return this.ownerDocument._codepages.__tagnames__[this.tag];
        } }
      });
    }
  }
  function EndTag(ownerDocument) {
    this.ownerDocument = ownerDocument;
  }
  function Text(ownerDocument, textContent) {
    this.ownerDocument = ownerDocument;
    this.textContent = textContent;
  }
  function Extension(ownerDocument, subtype, index, value) {
    this.ownerDocument = ownerDocument;
    this.subtype = subtype;
    this.index = index;
    this.value = value;
  }
  function ProcessingInstruction(ownerDocument) {
    this.ownerDocument = ownerDocument;
  }
  function Opaque(ownerDocument, data) {
    this.ownerDocument = ownerDocument;
    this.data = data;
  }
  function Reader(data, codepages2) {
    this._data = data instanceof Writer ? data.bytes : data;
    this._codepages = codepages2;
    this.rewind();
  }
  function Writer(version, pid, charset, strings2, dataType) {
    if (dataType === "blob")
      this._blobs = [];
    else
      this._blobs = null;
    this.dataType = dataType || "arraybuffer";
    this._rawbuf = new ArrayBuffer(1024);
    this._buffer = new Uint8Array(this._rawbuf);
    this._pos = 0;
    this._codepage = 0;
    this._tagStack = [];
    this._rootTagValue = null;
    var infos = version.split(".").map(function(x) {
      return parseInt(x);
    });
    var major = infos[0], minor = infos[1];
    var v = (major - 1 << 4) + minor;
    var charsetNum = charset;
    if (typeof charset === "string") {
      charsetNum = str2mib[charset];
      if (charsetNum === void 0)
        throw new Error("unknown charset " + charset);
    }
    var encoder = this._encoder = new TextEncoder(charset);
    this._write(v);
    this._write(pid);
    this._write(charsetNum);
    if (strings2) {
      var bytes = strings2.map(function(s) {
        return encoder.encode(s);
      });
      var len = bytes.reduce(function(x, y) {
        return x + y.length + 1;
      }, 0);
      this._write_mb_uint32(len);
      for (var i = 0; i < bytes.length; i++) {
        var b = bytes[i];
        this._write_bytes(b);
        this._write(0);
      }
    } else {
      this._write(0);
    }
  }
  function EventParser() {
    this.listeners = [];
    this.onerror = function(e) {
      throw e;
    };
  }
  var Tokens, EndOfData, ParseError, mib2str, str2mib, mibStr;
  var init_wbxml = __esm({
    "src/vendor/wbxml.js"() {
      Tokens = {
        SWITCH_PAGE: 0,
        END: 1,
        ENTITY: 2,
        STR_I: 3,
        LITERAL: 4,
        EXT_I_0: 64,
        EXT_I_1: 65,
        EXT_I_2: 66,
        PI: 67,
        LITERAL_C: 68,
        EXT_T_0: 128,
        EXT_T_1: 129,
        EXT_T_2: 130,
        STR_T: 131,
        LITERAL_A: 132,
        EXT_0: 192,
        EXT_1: 193,
        EXT_2: 194,
        OPAQUE: 195,
        LITERAL_AC: 196
      };
      EndOfData = {
        message: "THIS IS AN INTERNAL CONTROL FLOW HACK THAT YOU SHOULD NOT SEE"
      };
      ParseError = makeError("WBXML.ParseError");
      StringTable.prototype = {
        get: function(offset) {
          if (offset in this.offsets)
            return this.strings[this.offsets[offset]];
          else {
            if (offset < 0)
              throw new ParseError("offset must be >= 0");
            var curr = 0;
            for (var i = 0; i < this.strings.length; i++) {
              if (offset < curr + this.strings[i].length + 1)
                return this.strings[i].slice(offset - curr);
              curr += this.strings[i].length + 1;
            }
          }
          throw new ParseError("invalid offset");
        }
      };
      mib2str = {
        3: "US-ASCII",
        4: "ISO-8859-1",
        5: "ISO-8859-2",
        6: "ISO-8859-3",
        7: "ISO-8859-4",
        8: "ISO-8859-5",
        9: "ISO-8859-6",
        10: "ISO-8859-7",
        11: "ISO-8859-8",
        12: "ISO-8859-9",
        13: "ISO-8859-10",
        106: "UTF-8"
      };
      str2mib = {};
      for (var mibId in mib2str) {
        mibStr = mib2str[mibId];
        str2mib[mibStr] = mibId;
      }
      Element.prototype = {
        get tagName() {
          var ns = this.namespaceName;
          ns = ns ? ns + ":" : "";
          return ns + this.localTagName;
        },
        getAttributes: function() {
          var attributes = [];
          for (var name in this._attrs) {
            var pieces = this._attrs[name];
            var data = name.split(":");
            attributes.push({
              name,
              namespace: data[0],
              localName: data[1],
              value: this._getAttribute(pieces)
            });
          }
          return attributes;
        },
        getAttribute: function(attr) {
          if (typeof attr === "number")
            attr = this.ownerDocument._codepages.__attrdata__[attr].name;
          else if (!(attr in this._attrs) && this.namespace !== null && attr.indexOf(":") === -1)
            attr = this.namespaceName + ":" + attr;
          return this._getAttribute(this._attrs[attr]);
        },
        _getAttribute: function(pieces) {
          var strValue = "";
          var array = [];
          for (var i = 0; i < pieces.length; i++) {
            var hunk = pieces[i];
            if (hunk instanceof Extension) {
              if (strValue) {
                array.push(strValue);
                strValue = "";
              }
              array.push(hunk);
            } else if (typeof hunk === "number") {
              strValue += this.ownerDocument._codepages.__attrdata__[hunk].data || "";
            } else {
              strValue += hunk;
            }
          }
          if (strValue)
            array.push(strValue);
          return array.length === 1 ? array[0] : array;
        },
        _addAttribute: function(attr) {
          if (typeof attr === "string") {
            if (attr in this._attrs)
              throw new ParseError("attribute " + attr + " is repeated");
            return this._attrs[attr] = [];
          } else {
            var namespace = attr >> 8;
            var localAttr = attr & 255;
            var localName = this.ownerDocument._codepages.__attrdata__[localAttr].name;
            var nsName = this.ownerDocument._codepages.__nsnames__[namespace];
            var name = nsName + ":" + localName;
            if (name in this._attrs)
              throw new ParseError("attribute " + name + " is repeated");
            return this._attrs[name] = [attr];
          }
        }
      };
      EndTag.prototype = {
        get type() {
          return "ETAG";
        }
      };
      Text.prototype = {
        get type() {
          return "TEXT";
        }
      };
      Extension.prototype = {
        get type() {
          return "EXT";
        }
      };
      ProcessingInstruction.prototype = {
        get type() {
          return "PI";
        },
        get target() {
          if (typeof this.targetID === "string")
            return this.targetID;
          else
            return this.ownerDocument._codepages.__attrdata__[this.targetID].name;
        },
        _setTarget: function(target) {
          this.targetID = target;
          if (typeof target === "string")
            return this._data = [];
          else
            return this._data = [target];
        },
        _getAttribute: Element.prototype._getAttribute,
        get data() {
          return this._getAttribute(this._data);
        }
      };
      Opaque.prototype = {
        get type() {
          return "OPAQUE";
        }
      };
      Reader.prototype = {
        _get_uint8: function() {
          if (this._index === this._data.length)
            throw EndOfData;
          return this._data[this._index++];
        },
        _get_mb_uint32: function() {
          var b;
          var result = 0;
          do {
            b = this._get_uint8();
            result = result * 128 + (b & 127);
          } while (b & 128);
          return result;
        },
        _get_slice: function(length) {
          var start = this._index;
          this._index += length;
          return this._data.subarray(start, this._index);
        },
        _get_c_string: function() {
          var start = this._index;
          while (this._get_uint8())
            ;
          return this._data.subarray(start, this._index - 1);
        },
        rewind: function() {
          this._index = 0;
          var v = this._get_uint8();
          this.version = ((v & 240) + 1).toString() + "." + (v & 15).toString();
          this.pid = this._get_mb_uint32();
          this.charset = mib2str[this._get_mb_uint32()] || "unknown";
          this._decoder = new TextDecoder(this.charset);
          var tbl_len = this._get_mb_uint32();
          this.strings = new StringTable(this._get_slice(tbl_len), this._decoder);
          this.document = this._getDocument();
        },
        _getDocument: function() {
          var States = {
            BODY: 0,
            ATTRIBUTES: 1,
            ATTRIBUTE_PI: 2
          };
          var state = States.BODY;
          var currentNode;
          var currentAttr;
          var codepage = 0;
          var depth = 0;
          var foundRoot = false;
          var doc = [];
          var appendString = function(s) {
            if (state === States.BODY) {
              if (!currentNode)
                currentNode = new Text(this, s);
              else
                currentNode.textContent += s;
            } else {
              currentAttr.push(s);
            }
          }.bind(this);
          try {
            while (true) {
              var tok = this._get_uint8();
              if (tok === Tokens.SWITCH_PAGE) {
                codepage = this._get_uint8();
                if (!(codepage in this._codepages.__nsnames__))
                  throw new ParseError("unknown codepage " + codepage);
              } else if (tok === Tokens.END) {
                if (state === States.BODY && depth-- > 0) {
                  if (currentNode) {
                    doc.push(currentNode);
                    currentNode = null;
                  }
                  doc.push(new EndTag(this));
                } else if (state === States.ATTRIBUTES || state === States.ATTRIBUTE_PI) {
                  state = States.BODY;
                  doc.push(currentNode);
                  currentNode = null;
                  currentAttr = null;
                } else {
                  throw new ParseError("unexpected END token");
                }
              } else if (tok === Tokens.ENTITY) {
                if (state === States.BODY && depth === 0)
                  throw new ParseError("unexpected ENTITY token");
                var e = this._get_mb_uint32();
                appendString("&#" + e + ";");
              } else if (tok === Tokens.STR_I) {
                if (state === States.BODY && depth === 0)
                  throw new ParseError("unexpected STR_I token");
                appendString(this._decoder.decode(this._get_c_string()));
              } else if (tok === Tokens.PI) {
                if (state !== States.BODY)
                  throw new ParseError("unexpected PI token");
                state = States.ATTRIBUTE_PI;
                if (currentNode)
                  doc.push(currentNode);
                currentNode = new ProcessingInstruction(this);
              } else if (tok === Tokens.STR_T) {
                if (state === States.BODY && depth === 0)
                  throw new ParseError("unexpected STR_T token");
                var r = this._get_mb_uint32();
                appendString(this.strings.get(r));
              } else if (tok === Tokens.OPAQUE) {
                if (state !== States.BODY)
                  throw new ParseError("unexpected OPAQUE token");
                var len = this._get_mb_uint32();
                var data = this._get_slice(len);
                if (currentNode) {
                  doc.push(currentNode);
                  currentNode = null;
                }
                doc.push(new Opaque(this, data));
              } else if ((tok & 64 || tok & 128) && (tok & 63) < 3) {
                var hi = tok & 192;
                var lo = tok & 63;
                var subtype;
                var value;
                if (hi === Tokens.EXT_I_0) {
                  subtype = "string";
                  value = this._decoder.decode(this._get_c_string());
                } else if (hi === Tokens.EXT_T_0) {
                  subtype = "integer";
                  value = this._get_mb_uint32();
                } else {
                  subtype = "byte";
                  value = null;
                }
                var ext = new Extension(this, subtype, lo, value);
                if (state === States.BODY) {
                  if (currentNode) {
                    doc.push(currentNode);
                    currentNode = null;
                  }
                  doc.push(ext);
                } else {
                  currentAttr.push(ext);
                }
              } else if (state === States.BODY) {
                if (depth === 0) {
                  if (foundRoot)
                    throw new ParseError("multiple root nodes found");
                  foundRoot = true;
                }
                var tag = (codepage << 8) + (tok & 63);
                if ((tok & 63) === Tokens.LITERAL) {
                  var r = this._get_mb_uint32();
                  tag = this.strings.get(r);
                }
                if (currentNode)
                  doc.push(currentNode);
                currentNode = new Element(this, tok & 64 ? "STAG" : "TAG", tag);
                if (tok & 64)
                  depth++;
                if (tok & 128) {
                  state = States.ATTRIBUTES;
                } else {
                  state = States.BODY;
                  doc.push(currentNode);
                  currentNode = null;
                }
              } else {
                var attr = (codepage << 8) + tok;
                if (!(tok & 128)) {
                  if (tok === Tokens.LITERAL) {
                    var r = this._get_mb_uint32();
                    attr = this.strings.get(r);
                  }
                  if (state === States.ATTRIBUTE_PI) {
                    if (currentAttr)
                      throw new ParseError("unexpected attribute in PI");
                    currentAttr = currentNode._setTarget(attr);
                  } else {
                    currentAttr = currentNode._addAttribute(attr);
                  }
                } else {
                  currentAttr.push(attr);
                }
              }
            }
          } catch (e2) {
            if (e2 !== EndOfData)
              throw e2;
          }
          return doc;
        },
        dump: function(indentation, header) {
          var result = "";
          if (indentation === void 0)
            indentation = 2;
          var indent = function(level) {
            return new Array(level * indentation + 1).join(" ");
          };
          var tagstack = [];
          if (header) {
            result += "Version: " + this.version + "\n";
            result += "Public ID: " + this.pid + "\n";
            result += "Charset: " + this.charset + "\n";
            result += 'String table:\n  "' + this.strings.strings.join('"\n  "') + '"\n\n';
          }
          var newline = false;
          var doc = this.document;
          var doclen = doc.length;
          for (var iNode = 0; iNode < doclen; iNode++) {
            var node = doc[iNode];
            if (node.type === "TAG" || node.type === "STAG") {
              result += indent(tagstack.length) + "<" + node.tagName;
              var attributes = node.getAttributes();
              for (var i = 0; i < attributes.length; i++) {
                var attr = attributes[i];
                result += " " + attr.name + '="' + attr.value + '"';
              }
              if (node.type === "STAG") {
                tagstack.push(node.tagName);
                result += ">\n";
              } else
                result += "/>\n";
            } else if (node.type === "ETAG") {
              var tag = tagstack.pop();
              result += indent(tagstack.length) + "</" + tag + ">\n";
            } else if (node.type === "TEXT") {
              result += indent(tagstack.length) + node.textContent + "\n";
            } else if (node.type === "PI") {
              result += indent(tagstack.length) + "<?" + node.target;
              if (node.data)
                result += " " + node.data;
              result += "?>\n";
            } else if (node.type === "OPAQUE") {
              result += indent(tagstack.length) + "<![CDATA[" + node.data + "]]>\n";
            } else {
              throw new Error('Unknown node type "' + node.type + '"');
            }
          }
          return result;
        }
      };
      Writer.Attribute = function(name, value) {
        this.isValue = typeof name === "number" && name & 128;
        if (this.isValue && value !== void 0)
          throw new Error("Can't specify a value for attribute value constants");
        this.name = name;
        this.value = value;
      };
      Writer.StringTableRef = function(index) {
        this.index = index;
      };
      Writer.Entity = function(code) {
        this.code = code;
      };
      Writer.Extension = function(subtype, index, data) {
        var validTypes = {
          "string": {
            value: Tokens.EXT_I_0,
            validator: function(data2) {
              return typeof data2 === "string";
            }
          },
          "integer": {
            value: Tokens.EXT_T_0,
            validator: function(data2) {
              return typeof data2 === "number";
            }
          },
          "byte": {
            value: Tokens.EXT_0,
            validator: function(data2) {
              return data2 === null || data2 === void 0;
            }
          }
        };
        var info = validTypes[subtype];
        if (!info)
          throw new Error("Invalid WBXML Extension type");
        if (!info.validator(data))
          throw new Error("Data for WBXML Extension does not match type");
        if (index !== 0 && index !== 1 && index !== 2)
          throw new Error("Invalid WBXML Extension index");
        this.subtype = info.value;
        this.index = index;
        this.data = data;
      };
      Writer.a = function(name, val) {
        return new Writer.Attribute(name, val);
      };
      Writer.str_t = function(index) {
        return new Writer.StringTableRef(index);
      };
      Writer.ent = function(code) {
        return new Writer.Entity(code);
      };
      Writer.ext = function(subtype, index, data) {
        return new Writer.Extension(subtype, index, data);
      };
      Writer.prototype = {
        _write: function(tok) {
          if (this._pos === this._buffer.length - 1) {
            this._rawbuf = new ArrayBuffer(this._rawbuf.byteLength * 2);
            var buffer = new Uint8Array(this._rawbuf);
            for (var i = 0; i < this._buffer.length; i++)
              buffer[i] = this._buffer[i];
            this._buffer = buffer;
          }
          this._buffer[this._pos++] = tok;
        },
        _write_mb_uint32: function(value) {
          var bytes = [];
          bytes.push(value % 128);
          while (value >= 128) {
            value >>= 7;
            bytes.push(128 + value % 128);
          }
          for (var i = bytes.length - 1; i >= 0; i--)
            this._write(bytes[i]);
        },
        _write_bytes: function(bytes) {
          for (var i = 0; i < bytes.length; i++)
            this._write(bytes[i]);
        },
        _write_str: function(str) {
          this._write_bytes(this._encoder.encode(str));
        },
        _setCodepage: function(codepage) {
          if (this._codepage !== codepage) {
            this._write(Tokens.SWITCH_PAGE);
            this._write(codepage);
            this._codepage = codepage;
          }
        },
        _writeTag: function(tag, stag, attrs) {
          if (tag === void 0)
            throw new Error("unknown tag");
          var flags = 0;
          if (stag)
            flags += 64;
          if (attrs.length)
            flags += 128;
          if (tag instanceof Writer.StringTableRef) {
            this._write(Tokens.LITERAL + flags);
            this._write_mb_uint32(tag.index);
          } else {
            this._setCodepage(tag >> 8);
            this._write((tag & 255) + flags);
            if (!this._rootTagValue)
              this._rootTagValue = tag;
          }
          if (attrs.length) {
            for (var i = 0; i < attrs.length; i++) {
              var attr = attrs[i];
              this._writeAttr(attr);
            }
            this._write(Tokens.END);
          }
        },
        _writeAttr: function(attr) {
          if (!(attr instanceof Writer.Attribute))
            throw new Error("Expected an Attribute object, not: " + attr);
          if (attr.isValue)
            throw new Error("Can't use attribute value constants here");
          if (attr.name instanceof Writer.StringTableRef) {
            this._write(Tokens.LITERAL);
            this._write(attr.name.index);
          } else {
            this._setCodepage(attr.name >> 8);
            this._write(attr.name & 255);
          }
          this._writeText(attr.value, true);
        },
        _writeText: function(value, inAttr) {
          if (Array.isArray(value)) {
            for (var i = 0; i < value.length; i++) {
              var piece = value[i];
              this._writeText(piece, inAttr);
            }
          } else if (value instanceof Writer.StringTableRef) {
            this._write(Tokens.STR_T);
            this._write_mb_uint32(value.index);
          } else if (value instanceof Writer.Entity) {
            this._write(Tokens.ENTITY);
            this._write_mb_uint32(value.code);
          } else if (value instanceof Writer.Extension) {
            this._write(value.subtype + value.index);
            if (value.subtype === Tokens.EXT_I_0) {
              this._write_str(value.data);
              this._write(0);
            } else if (value.subtype === Tokens.EXT_T_0) {
              this._write_mb_uint32(value.data);
            }
          } else if (value instanceof Writer.Attribute) {
            if (!value.isValue)
              throw new Error("Unexpected Attribute object");
            if (!inAttr)
              throw new Error("Can't use attribute value constants outside of attributes");
            this._setCodepage(value.name >> 8);
            this._write(value.name & 255);
          } else if (value !== null && value !== void 0) {
            this._write(Tokens.STR_I);
            this._write_str(value.toString());
            this._write(0);
          }
        },
        tag: function(tag) {
          var tail = arguments.length > 1 ? arguments[arguments.length - 1] : null;
          if (tail === null || tail instanceof Writer.Attribute) {
            var rest = Array.prototype.slice.call(arguments, 1);
            this._writeTag(tag, false, rest);
            return this;
          } else {
            var head = Array.prototype.slice.call(arguments, 0, -1);
            return this.stag.apply(this, head).text(tail).etag();
          }
        },
        stag: function(tag) {
          var rest = Array.prototype.slice.call(arguments, 1);
          this._writeTag(tag, true, rest);
          this._tagStack.push(tag);
          return this;
        },
        etag: function(tag) {
          if (this._tagStack.length === 0)
            throw new Error("Spurious etag() call!");
          var expectedTag = this._tagStack.pop();
          if (tag !== void 0 && tag !== expectedTag)
            throw new Error("Closed the wrong tag");
          this._write(Tokens.END);
          return this;
        },
        text: function(value) {
          this._writeText(value);
          return this;
        },
        pi: function(target, data) {
          this._write(Tokens.PI);
          this._writeAttr(Writer.a(target, data));
          this._write(Tokens.END);
          return this;
        },
        ext: function(subtype, index, data) {
          return this.text(Writer.ext(subtype, index, data));
        },
        opaque: function(data) {
          this._write(Tokens.OPAQUE);
          if (data instanceof Blob) {
            if (!this._blobs)
              throw new Error("Writer not opened in blob mode");
            this._write_mb_uint32(data.size);
            this._blobs.push(this.bytes);
            this._blobs.push(data);
            this._rawbuf = new ArrayBuffer(1024);
            this._buffer = new Uint8Array(this._rawbuf);
            this._pos = 0;
          } else if (typeof data === "string") {
            this._write_mb_uint32(data.length);
            this._write_str(data);
          } else {
            this._write_mb_uint32(data.length);
            for (var i = 0; i < data.length; i++)
              this._write(data[i]);
          }
          return this;
        },
        get buffer() {
          return this._rawbuf.slice(0, this._pos);
        },
        get bytes() {
          return new Uint8Array(this._rawbuf, 0, this._pos);
        },
        get blob() {
          if (!this._blobs)
            throw new Error("No blobs!");
          var useBlobs = this._blobs;
          if (this._pos)
            useBlobs = useBlobs.concat([this.bytes]);
          var superBlob = new Blob(useBlobs);
          return superBlob;
        },
        get rootTag() {
          return this._rootTagValue;
        }
      };
      EventParser.prototype = {
        addEventListener: function(path, callback) {
          this.listeners.push({ path, callback });
        },
        _pathMatches: function(a, b) {
          return a.length === b.length && a.every(function(val, i) {
            if (b[i] === "*")
              return true;
            else if (Array.isArray(b[i])) {
              return b[i].indexOf(val) !== -1;
            } else
              return val === b[i];
          });
        },
        run: function(reader) {
          var fullPath = [];
          var recPath = [];
          var recording = 0;
          var doc = reader.document;
          var doclen = doc.length;
          var listeners2 = this.listeners, iListener, listener;
          for (var iNode = 0; iNode < doclen; iNode++) {
            var node = doc[iNode];
            if (node.type === "TAG") {
              fullPath.push(node.tag);
              for (iListener = 0; iListener < listeners2.length; iListener++) {
                listener = listeners2[iListener];
                if (this._pathMatches(fullPath, listener.path)) {
                  node.children = [];
                  try {
                    listener.callback(node);
                  } catch (e) {
                    if (this.onerror)
                      this.onerror(e);
                  }
                }
              }
              fullPath.pop();
            } else if (node.type === "STAG") {
              fullPath.push(node.tag);
              for (iListener = 0; iListener < listeners2.length; iListener++) {
                listener = listeners2[iListener];
                if (this._pathMatches(fullPath, listener.path)) {
                  recording++;
                }
              }
            } else if (node.type === "ETAG") {
              for (iListener = 0; iListener < listeners2.length; iListener++) {
                listener = listeners2[iListener];
                if (this._pathMatches(fullPath, listener.path)) {
                  recording--;
                  try {
                    listener.callback(recPath[recPath.length - 1]);
                  } catch (e) {
                    if (this.onerror)
                      this.onerror(e);
                  }
                }
              }
              fullPath.pop();
            }
            if (recording) {
              if (node.type === "STAG") {
                node.type = "TAG";
                node.children = [];
                if (recPath.length)
                  recPath[recPath.length - 1].children.push(node);
                recPath.push(node);
              } else if (node.type === "ETAG") {
                recPath.pop();
              } else {
                node.children = [];
                recPath[recPath.length - 1].children.push(node);
              }
            }
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Common.js
  var Common_default;
  var init_Common = __esm({
    "src/vendor/activesync/codepages/Common.js"() {
      Common_default = {
        Enums: {
          Status: {
            InvalidContent: "101",
            InvalidWBXML: "102",
            InvalidXML: "103",
            InvalidDateTime: "104",
            InvalidCombinationOfIDs: "105",
            InvalidIDs: "106",
            InvalidMIME: "107",
            DeviceIdMissingOrInvalid: "108",
            DeviceTypeMissingOrInvalid: "109",
            ServerError: "110",
            ServerErrorRetryLater: "111",
            ActiveDirectoryAccessDenied: "112",
            MailboxQuotaExceeded: "113",
            MailboxServerOffline: "114",
            SendQuotaExceeded: "115",
            MessageRecipientUnresolved: "116",
            MessageReplyNotAllowed: "117",
            MessagePreviouslySent: "118",
            MessageHasNoRecipient: "119",
            MailSubmissionFailed: "120",
            MessageReplyFailed: "121",
            AttachmentIsTooLarge: "122",
            UserHasNoMailbox: "123",
            UserCannotBeAnonymous: "124",
            UserPrincipalCouldNotBeFound: "125",
            UserDisabledForSync: "126",
            UserOnNewMailboxCannotSync: "127",
            UserOnLegacyMailboxCannotSync: "128",
            DeviceIsBlockedForThisUser: "129",
            AccessDenied: "130",
            AccountDisabled: "131",
            SyncStateNotFound: "132",
            SyncStateLocked: "133",
            SyncStateCorrupt: "134",
            SyncStateAlreadyExists: "135",
            SyncStateVersionInvalid: "136",
            CommandNotSupported: "137",
            VersionNotSupported: "138",
            DeviceNotFullyProvisionable: "139",
            RemoteWipeRequested: "140",
            LegacyDeviceOnStrictPolicy: "141",
            DeviceNotProvisioned: "142",
            PolicyRefresh: "143",
            InvalidPolicyKey: "144",
            ExternallyManagedDevicesNotAllowed: "145",
            NoRecurrenceInCalendar: "146",
            UnexpectedItemClass: "147",
            RemoteServerHasNoSSL: "148",
            InvalidStoredRequest: "149",
            ItemNotFound: "150",
            TooManyFolders: "151",
            NoFoldersFounds: "152",
            ItemsLostAfterMove: "153",
            FailureInMoveOperation: "154",
            MoveCommandDisallowedForNonPersistentMoveAction: "155",
            MoveCommandInvalidDestinationFolder: "156",
            AvailabilityTooManyRecipients: "160",
            AvailabilityDLLimitReached: "161",
            AvailabilityTransientFailure: "162",
            AvailabilityFailure: "163",
            BodyPartPreferenceTypeNotSupported: "164",
            DeviceInformationRequired: "165",
            InvalidAccountId: "166",
            AccountSendDisabled: "167",
            IRM_FeatureDisabled: "168",
            IRM_TransientError: "169",
            IRM_PermanentError: "170",
            IRM_InvalidTemplateID: "171",
            IRM_OperationNotPermitted: "172",
            NoPicture: "173",
            PictureTooLarge: "174",
            PictureLimitReached: "175",
            BodyPart_ConversationTooLarge: "176",
            MaximumDevicesReached: "177"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/AirSync.js
  var AirSync_default;
  var init_AirSync = __esm({
    "src/vendor/activesync/codepages/AirSync.js"() {
      AirSync_default = {
        Tags: {
          Sync: 5,
          Responses: 6,
          Add: 7,
          Change: 8,
          Delete: 9,
          Fetch: 10,
          SyncKey: 11,
          ClientId: 12,
          ServerId: 13,
          Status: 14,
          Collection: 15,
          Class: 16,
          Version: 17,
          CollectionId: 18,
          GetChanges: 19,
          MoreAvailable: 20,
          WindowSize: 21,
          Commands: 22,
          Options: 23,
          FilterType: 24,
          Truncation: 25,
          RtfTruncation: 26,
          Conflict: 27,
          Collections: 28,
          ApplicationData: 29,
          DeletesAsMoves: 30,
          NotifyGUID: 31,
          Supported: 32,
          SoftDelete: 33,
          MIMESupport: 34,
          MIMETruncation: 35,
          Wait: 36,
          Limit: 37,
          Partial: 38,
          ConversationMode: 39,
          MaxItems: 40,
          HeartbeatInterval: 41
        },
        Enums: {
          Status: {
            Success: "1",
            InvalidSyncKey: "3",
            ProtocolError: "4",
            ServerError: "5",
            ConversionError: "6",
            MatchingConflict: "7",
            ObjectNotFound: "8",
            OutOfSpace: "9",
            HierarchyChanged: "12",
            IncompleteRequest: "13",
            InvalidInterval: "14",
            InvalidRequest: "15",
            Retry: "16"
          },
          FilterType: {
            NoFilter: "0",
            OneDayBack: "1",
            ThreeDaysBack: "2",
            OneWeekBack: "3",
            TwoWeeksBack: "4",
            OneMonthBack: "5",
            ThreeMonthsBack: "6",
            SixMonthsBack: "7",
            IncompleteTasks: "8"
          },
          Conflict: {
            ClientReplacesServer: "0",
            ServerReplacesClient: "1"
          },
          MIMESupport: {
            Never: "0",
            SMIMEOnly: "1",
            Always: "2"
          },
          MIMETruncation: {
            TruncateAll: "0",
            Truncate4K: "1",
            Truncate5K: "2",
            Truncate7K: "3",
            Truncate10K: "4",
            Truncate20K: "5",
            Truncate50K: "6",
            Truncate100K: "7",
            NoTruncate: "8"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Contacts.js
  var Contacts_default;
  var init_Contacts = __esm({
    "src/vendor/activesync/codepages/Contacts.js"() {
      Contacts_default = {
        Tags: {
          Anniversary: 261,
          AssistantName: 262,
          AssistantPhoneNumber: 263,
          Birthday: 264,
          Body: 265,
          BodySize: 266,
          BodyTruncated: 267,
          Business2PhoneNumber: 268,
          BusinessAddressCity: 269,
          BusinessAddressCountry: 270,
          BusinessAddressPostalCode: 271,
          BusinessAddressState: 272,
          BusinessAddressStreet: 273,
          BusinessFaxNumber: 274,
          BusinessPhoneNumber: 275,
          CarPhoneNumber: 276,
          Categories: 277,
          Category: 278,
          Children: 279,
          Child: 280,
          CompanyName: 281,
          Department: 282,
          Email1Address: 283,
          Email2Address: 284,
          Email3Address: 285,
          FileAs: 286,
          FirstName: 287,
          Home2PhoneNumber: 288,
          HomeAddressCity: 289,
          HomeAddressCountry: 290,
          HomeAddressPostalCode: 291,
          HomeAddressState: 292,
          HomeAddressStreet: 293,
          HomeFaxNumber: 294,
          HomePhoneNumber: 295,
          JobTitle: 296,
          LastName: 297,
          MiddleName: 298,
          MobilePhoneNumber: 299,
          OfficeLocation: 300,
          OtherAddressCity: 301,
          OtherAddressCountry: 302,
          OtherAddressPostalCode: 303,
          OtherAddressState: 304,
          OtherAddressStreet: 305,
          PagerNumber: 306,
          RadioPhoneNumber: 307,
          Spouse: 308,
          Suffix: 309,
          Title: 310,
          WebPage: 311,
          YomiCompanyName: 312,
          YomiFirstName: 313,
          YomiLastName: 314,
          CompressedRTF: 315,
          Picture: 316,
          Alias: 317,
          WeightedRank: 318
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Email.js
  var Email_default;
  var init_Email = __esm({
    "src/vendor/activesync/codepages/Email.js"() {
      Email_default = {
        Tags: {
          Attachment: 517,
          Attachments: 518,
          AttName: 519,
          AttSize: 520,
          Att0Id: 521,
          AttMethod: 522,
          AttRemoved: 523,
          Body: 524,
          BodySize: 525,
          BodyTruncated: 526,
          DateReceived: 527,
          DisplayName: 528,
          DisplayTo: 529,
          Importance: 530,
          MessageClass: 531,
          Subject: 532,
          Read: 533,
          To: 534,
          Cc: 535,
          From: 536,
          ReplyTo: 537,
          AllDayEvent: 538,
          Categories: 539,
          Category: 540,
          DTStamp: 541,
          EndTime: 542,
          InstanceType: 543,
          BusyStatus: 544,
          Location: 545,
          MeetingRequest: 546,
          Organizer: 547,
          RecurrenceId: 548,
          Reminder: 549,
          ResponseRequested: 550,
          Recurrences: 551,
          Recurrence: 552,
          Recurrence_Type: 553,
          Recurrence_Until: 554,
          Recurrence_Occurrences: 555,
          Recurrence_Interval: 556,
          Recurrence_DayOfWeek: 557,
          Recurrence_DayOfMonth: 558,
          Recurrence_WeekOfMonth: 559,
          Recurrence_MonthOfYear: 560,
          StartTime: 561,
          Sensitivity: 562,
          TimeZone: 563,
          GlobalObjId: 564,
          ThreadTopic: 565,
          MIMEData: 566,
          MIMETruncated: 567,
          MIMESize: 568,
          InternetCPID: 569,
          Flag: 570,
          Status: 571,
          ContentClass: 572,
          FlagType: 573,
          CompleteTime: 574,
          DisallowNewTimeProposal: 575
        },
        Enums: {
          Importance: {
            Low: "0",
            Normal: "1",
            High: "2"
          },
          InstanceType: {
            Single: "0",
            RecurringMaster: "1",
            RecurringInstance: "2",
            RecurringException: "3"
          },
          BusyStatus: {
            Free: "0",
            Tentative: "1",
            Busy: "2",
            Oof: "3"
          },
          Recurrence_Type: {
            Daily: "0",
            Weekly: "1",
            MonthlyNthDay: "2",
            Monthly: "3",
            YearlyNthDay: "5",
            YearlyNthDayOfWeek: "6"
          },
          Sensitivity: {
            Normal: "0",
            Personal: "1",
            Private: "2",
            Confidential: "3"
          },
          Status: {
            Cleared: "0",
            Complete: "1",
            Active: "2"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Calendar.js
  var Calendar_default;
  var init_Calendar = __esm({
    "src/vendor/activesync/codepages/Calendar.js"() {
      Calendar_default = {
        Tags: {
          TimeZone: 1029,
          AllDayEvent: 1030,
          Attendees: 1031,
          Attendee: 1032,
          Email: 1033,
          Name: 1034,
          Body: 1035,
          BodyTruncated: 1036,
          BusyStatus: 1037,
          Categories: 1038,
          Category: 1039,
          CompressedRTF: 1040,
          DtStamp: 1041,
          EndTime: 1042,
          Exception: 1043,
          Exceptions: 1044,
          Deleted: 1045,
          ExceptionStartTime: 1046,
          Location: 1047,
          MeetingStatus: 1048,
          OrganizerEmail: 1049,
          OrganizerName: 1050,
          Recurrence: 1051,
          Type: 1052,
          Until: 1053,
          Occurrences: 1054,
          Interval: 1055,
          DayOfWeek: 1056,
          DayOfMonth: 1057,
          WeekOfMonth: 1058,
          MonthOfYear: 1059,
          Reminder: 1060,
          Sensitivity: 1061,
          Subject: 1062,
          StartTime: 1063,
          UID: 1064,
          AttendeeStatus: 1065,
          AttendeeType: 1066,
          Attachment: 1067,
          Attachments: 1068,
          AttName: 1069,
          AttSize: 1070,
          AttOid: 1071,
          AttMethod: 1072,
          AttRemoved: 1073,
          DisplayName: 1074,
          DisallowNewTimeProposal: 1075,
          ResponseRequested: 1076,
          AppointmentReplyTime: 1077,
          ResponseType: 1078,
          CalendarType: 1079,
          IsLeapMonth: 1080,
          FirstDayOfWeek: 1081,
          OnlineMeetingConfLink: 1082,
          OnlineMeetingExternalLink: 1083
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Move.js
  var Move_default;
  var init_Move = __esm({
    "src/vendor/activesync/codepages/Move.js"() {
      Move_default = {
        Tags: {
          MoveItems: 1285,
          Move: 1286,
          SrcMsgId: 1287,
          SrcFldId: 1288,
          DstFldId: 1289,
          Response: 1290,
          Status: 1291,
          DstMsgId: 1292
        },
        Enums: {
          Status: {
            InvalidSourceID: "1",
            InvalidDestID: "2",
            Success: "3",
            SourceIsDest: "4",
            MoveFailure: "5",
            ItemLocked: "7"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/ItemEstimate.js
  var ItemEstimate_default;
  var init_ItemEstimate = __esm({
    "src/vendor/activesync/codepages/ItemEstimate.js"() {
      ItemEstimate_default = {
        Tags: {
          GetItemEstimate: 1541,
          Version: 1542,
          Collections: 1543,
          Collection: 1544,
          Class: 1545,
          CollectionId: 1546,
          DateTime: 1547,
          Estimate: 1548,
          Response: 1549,
          Status: 1550
        },
        Enums: {
          Status: {
            Success: "1",
            InvalidCollection: "2",
            NoSyncState: "3",
            InvalidSyncKey: "4"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/FolderHierarchy.js
  var FolderHierarchy_default;
  var init_FolderHierarchy = __esm({
    "src/vendor/activesync/codepages/FolderHierarchy.js"() {
      FolderHierarchy_default = {
        Tags: {
          Folders: 1797,
          Folder: 1798,
          DisplayName: 1799,
          ServerId: 1800,
          ParentId: 1801,
          Type: 1802,
          Response: 1803,
          Status: 1804,
          ContentClass: 1805,
          Changes: 1806,
          Add: 1807,
          Delete: 1808,
          Update: 1809,
          SyncKey: 1810,
          FolderCreate: 1811,
          FolderDelete: 1812,
          FolderUpdate: 1813,
          FolderSync: 1814,
          Count: 1815
        },
        Enums: {
          Type: {
            Generic: "1",
            DefaultInbox: "2",
            DefaultDrafts: "3",
            DefaultDeleted: "4",
            DefaultSent: "5",
            DefaultOutbox: "6",
            DefaultTasks: "7",
            DefaultCalendar: "8",
            DefaultContacts: "9",
            DefaultNotes: "10",
            DefaultJournal: "11",
            Mail: "12",
            Calendar: "13",
            Contacts: "14",
            Tasks: "15",
            Journal: "16",
            Notes: "17",
            Unknown: "18",
            RecipientCache: "19"
          },
          Status: {
            Success: "1",
            FolderExists: "2",
            SystemFolder: "3",
            FolderNotFound: "4",
            ParentFolderNotFound: "5",
            ServerError: "6",
            InvalidSyncKey: "9",
            MalformedRequest: "10",
            UnknownError: "11",
            CodeUnknown: "12"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/MeetingResponse.js
  var MeetingResponse_default;
  var init_MeetingResponse = __esm({
    "src/vendor/activesync/codepages/MeetingResponse.js"() {
      MeetingResponse_default = {
        Tags: {
          CalendarId: 2053,
          CollectionId: 2054,
          MeetingResponse: 2055,
          RequestId: 2056,
          Request: 2057,
          Result: 2058,
          Status: 2059,
          UserResponse: 2060,
          InstanceId: 2062
        },
        Enums: {
          Status: {
            Success: "1",
            InvalidRequest: "2",
            MailboxError: "3",
            ServerError: "4"
          },
          UserResponse: {
            Accepted: "1",
            Tentative: "2",
            Declined: "3"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Tasks.js
  var Tasks_default;
  var init_Tasks = __esm({
    "src/vendor/activesync/codepages/Tasks.js"() {
      Tasks_default = {
        Tags: {
          Body: 2309,
          BodySize: 2310,
          BodyTruncated: 2311,
          Categories: 2312,
          Category: 2313,
          Complete: 2314,
          DateCompleted: 2315,
          DueDate: 2316,
          UtcDueDate: 2317,
          Importance: 2318,
          Recurrence: 2319,
          Recurrence_Type: 2320,
          Recurrence_Start: 2321,
          Recurrence_Until: 2322,
          Recurrence_Occurrences: 2323,
          Recurrence_Interval: 2324,
          Recurrence_DayOfMonth: 2325,
          Recurrence_DayOfWeek: 2326,
          Recurrence_WeekOfMonth: 2327,
          Recurrence_MonthOfYear: 2328,
          Recurrence_Regenerate: 2329,
          Recurrence_DeadOccur: 2330,
          ReminderSet: 2331,
          ReminderTime: 2332,
          Sensitivity: 2333,
          StartDate: 2334,
          UtcStartDate: 2335,
          Subject: 2336,
          CompressedRTF: 2337,
          OrdinalDate: 2338,
          SubOrdinalDate: 2339,
          CalendarType: 2340,
          IsLeapMonth: 2341,
          FirstDayOfWeek: 2342
        }
      };
    }
  });

  // src/vendor/activesync/codepages/ResolveRecipients.js
  var ResolveRecipients_default;
  var init_ResolveRecipients = __esm({
    "src/vendor/activesync/codepages/ResolveRecipients.js"() {
      ResolveRecipients_default = {
        Tags: {
          ResolveRecipients: 2565,
          Response: 2566,
          Status: 2567,
          Type: 2568,
          Recipient: 2569,
          DisplayName: 2570,
          EmailAddress: 2571,
          Certificates: 2572,
          Certificate: 2573,
          MiniCertificate: 2574,
          Options: 2575,
          To: 2576,
          CertificateRetrieval: 2577,
          RecipientCount: 2578,
          MaxCertificates: 2579,
          MaxAmbiguousRecipients: 2580,
          CertificateCount: 2581,
          Availability: 2582,
          StartTime: 2583,
          EndTime: 2584,
          MergedFreeBusy: 2585,
          Picture: 2586,
          MaxSize: 2587,
          Data: 2588,
          MaxPictures: 2589
        },
        Enums: {
          Status: {
            Success: "1",
            AmbiguousRecipientFull: "2",
            AmbiguousRecipientPartial: "3",
            RecipientNotFound: "4",
            ProtocolError: "5",
            ServerError: "6",
            InvalidSMIMECert: "7",
            CertLimitReached: "8"
          },
          CertificateRetrieval: {
            None: "1",
            Full: "2",
            Mini: "3"
          },
          MergedFreeBusy: {
            Free: "0",
            Tentative: "1",
            Busy: "2",
            Oof: "3",
            NoData: "4"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/ValidateCert.js
  var ValidateCert_default;
  var init_ValidateCert = __esm({
    "src/vendor/activesync/codepages/ValidateCert.js"() {
      ValidateCert_default = {
        Tags: {
          ValidateCert: 2821,
          Certificates: 2822,
          Certificate: 2823,
          CertificateChain: 2824,
          CheckCRL: 2825,
          Status: 2826
        },
        Enums: {
          Status: {
            Success: "1",
            ProtocolError: "2",
            InvalidSignature: "3",
            UntrustedSource: "4",
            InvalidChain: "5",
            NotForEmail: "6",
            Expired: "7",
            InconsistentTimes: "8",
            IdMisused: "9",
            MissingInformation: "10",
            CAEndMismatch: "11",
            EmailAddressMismatch: "12",
            Revoked: "13",
            ServerOffline: "14",
            ChainRevoked: "15",
            RevocationUnknown: "16",
            UnknownError: "17"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Contacts2.js
  var Contacts2_default;
  var init_Contacts2 = __esm({
    "src/vendor/activesync/codepages/Contacts2.js"() {
      Contacts2_default = {
        Tags: {
          CustomerId: 3077,
          GovernmentId: 3078,
          IMAddress: 3079,
          IMAddress2: 3080,
          IMAddress3: 3081,
          ManagerName: 3082,
          CompanyMainPhone: 3083,
          AccountName: 3084,
          NickName: 3085,
          MMS: 3086
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Ping.js
  var Ping_default;
  var init_Ping = __esm({
    "src/vendor/activesync/codepages/Ping.js"() {
      Ping_default = {
        Tags: {
          Ping: 3333,
          AutdState: 3334,
          Status: 3335,
          HeartbeatInterval: 3336,
          Folders: 3337,
          Folder: 3338,
          Id: 3339,
          Class: 3340,
          MaxFolders: 3341
        },
        Enums: {
          Status: {
            Expired: "1",
            Changed: "2",
            MissingParameters: "3",
            SyntaxError: "4",
            InvalidInterval: "5",
            TooManyFolders: "6",
            SyncFolders: "7",
            ServerError: "8"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Provision.js
  var Provision_default;
  var init_Provision = __esm({
    "src/vendor/activesync/codepages/Provision.js"() {
      Provision_default = {
        Tags: {
          Provision: 3589,
          Policies: 3590,
          Policy: 3591,
          PolicyType: 3592,
          PolicyKey: 3593,
          Data: 3594,
          Status: 3595,
          RemoteWipe: 3596,
          EASProvisionDoc: 3597,
          DevicePasswordEnabled: 3598,
          AlphanumericDevicePasswordRequired: 3599,
          DeviceEncryptionEnabled: 3600,
          RequireStorageCardEncryption: 3600,
          PasswordRecoveryEnabled: 3601,
          AttachmentsEnabled: 3603,
          MinDevicePasswordLength: 3604,
          MaxInactivityTimeDeviceLock: 3605,
          MaxDevicePasswordFailedAttempts: 3606,
          MaxAttachmentSize: 3607,
          AllowSimpleDevicePassword: 3608,
          DevicePasswordExpiration: 3609,
          DevicePasswordHistory: 3610,
          AllowStorageCard: 3611,
          AllowCamera: 3612,
          RequireDeviceEncryption: 3613,
          AllowUnsignedApplications: 3614,
          AllowUnsignedInstallationPackages: 3615,
          MinDevicePasswordComplexCharacters: 3616,
          AllowWiFi: 3617,
          AllowTextMessaging: 3618,
          AllowPOPIMAPEmail: 3619,
          AllowBluetooth: 3620,
          AllowIrDA: 3621,
          RequireManualSyncWhenRoaming: 3622,
          AllowDesktopSync: 3623,
          MaxCalendarAgeFilter: 3624,
          AllowHTMLEmail: 3625,
          MaxEmailAgeFilter: 3626,
          MaxEmailBodyTruncationSize: 3627,
          MaxEmailHTMLBodyTruncationSize: 3628,
          RequireSignedSMIMEMessages: 3629,
          RequireEncryptedSMIMEMessages: 3630,
          RequireSignedSMIMEAlgorithm: 3631,
          RequireEncryptionSMIMEAlgorithm: 3632,
          AllowSMIMEEncryptionAlgorithmNegotiation: 3633,
          AllowSMIMESoftCerts: 3634,
          AllowBrowser: 3635,
          AllowConsumerEmail: 3636,
          AllowRemoteDesktop: 3637,
          AllowInternetSharing: 3638,
          UnapprovedInROMApplicationList: 3639,
          ApplicationName: 3640,
          ApprovedApplicationList: 3641,
          Hash: 3642
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Search.js
  var Search_default;
  var init_Search = __esm({
    "src/vendor/activesync/codepages/Search.js"() {
      Search_default = {
        Tags: {
          Search: 3845,
          Stores: 3846,
          Store: 3847,
          Name: 3848,
          Query: 3849,
          Options: 3850,
          Range: 3851,
          Status: 3852,
          Response: 3853,
          Result: 3854,
          Properties: 3855,
          Total: 3856,
          EqualTo: 3857,
          Value: 3858,
          And: 3859,
          Or: 3860,
          FreeText: 3861,
          DeepTraversal: 3863,
          LongId: 3864,
          RebuildResults: 3865,
          LessThan: 3866,
          GreaterThan: 3867,
          Schema: 3868,
          Supported: 3869,
          UserName: 3870,
          Password: 3871,
          ConversationId: 3872,
          Picture: 3873,
          MaxSize: 3874,
          MaxPictures: 3875
        },
        Enums: {
          Status: {
            Success: "1",
            InvalidRequest: "2",
            ServerError: "3",
            BadLink: "4",
            AccessDenied: "5",
            NotFound: "6",
            ConnectionFailure: "7",
            TooComplex: "8",
            Timeout: "10",
            SyncFolders: "11",
            EndOfRange: "12",
            AccessBlocked: "13",
            CredentialsRequired: "14"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/GAL.js
  var GAL_default;
  var init_GAL = __esm({
    "src/vendor/activesync/codepages/GAL.js"() {
      GAL_default = {
        Tags: {
          DisplayName: 4101,
          Phone: 4102,
          Office: 4103,
          Title: 4104,
          Company: 4105,
          Alias: 4106,
          FirstName: 4107,
          LastName: 4108,
          HomePhone: 4109,
          MobilePhone: 4110,
          EmailAddress: 4111,
          Picture: 4112,
          Status: 4113,
          Data: 4114
        }
      };
    }
  });

  // src/vendor/activesync/codepages/AirSyncBase.js
  var AirSyncBase_default;
  var init_AirSyncBase = __esm({
    "src/vendor/activesync/codepages/AirSyncBase.js"() {
      AirSyncBase_default = {
        Tags: {
          BodyPreference: 4357,
          Type: 4358,
          TruncationSize: 4359,
          AllOrNone: 4360,
          Reserved: 4361,
          Body: 4362,
          Data: 4363,
          EstimatedDataSize: 4364,
          Truncated: 4365,
          Attachments: 4366,
          Attachment: 4367,
          DisplayName: 4368,
          FileReference: 4369,
          Method: 4370,
          ContentId: 4371,
          ContentLocation: 4372,
          IsInline: 4373,
          NativeBodyType: 4374,
          ContentType: 4375,
          Preview: 4376,
          BodyPartPreference: 4377,
          BodyPart: 4378,
          Status: 4379
        },
        Enums: {
          Type: {
            PlainText: "1",
            HTML: "2",
            RTF: "3",
            MIME: "4"
          },
          Method: {
            Normal: "1",
            EmbeddedMessage: "5",
            AttachOLE: "6"
          },
          NativeBodyType: {
            PlainText: "1",
            HTML: "2",
            RTF: "3"
          },
          Status: {
            Success: "1"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Settings.js
  var Settings_default;
  var init_Settings = __esm({
    "src/vendor/activesync/codepages/Settings.js"() {
      Settings_default = {
        Tags: {
          Settings: 4613,
          Status: 4614,
          Get: 4615,
          Set: 4616,
          Oof: 4617,
          OofState: 4618,
          StartTime: 4619,
          EndTime: 4620,
          OofMessage: 4621,
          AppliesToInternal: 4622,
          AppliesToExternalKnown: 4623,
          AppliesToExternalUnknown: 4624,
          Enabled: 4625,
          ReplyMessage: 4626,
          BodyType: 4627,
          DevicePassword: 4628,
          Password: 4629,
          DeviceInformation: 4630,
          Model: 4631,
          IMEI: 4632,
          FriendlyName: 4633,
          OS: 4634,
          OSLanguage: 4635,
          PhoneNumber: 4636,
          UserInformation: 4637,
          EmailAddresses: 4638,
          SmtpAddress: 4639,
          UserAgent: 4640,
          EnableOutboundSMS: 4641,
          MobileOperator: 4642,
          PrimarySmtpAddress: 4643,
          Accounts: 4644,
          Account: 4645,
          AccountId: 4646,
          AccountName: 4647,
          UserDisplayName: 4648,
          SendDisabled: 4649,
          RightsManagementInformation: 4651
        },
        Enums: {
          Status: {
            Success: "1",
            ProtocolError: "2",
            AccessDenied: "3",
            ServerError: "4",
            InvalidArguments: "5",
            ConflictingArguments: "6",
            DeniedByPolicy: "7"
          },
          OofState: {
            Disabled: "0",
            Global: "1",
            TimeBased: "2"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/DocumentLibrary.js
  var DocumentLibrary_default;
  var init_DocumentLibrary = __esm({
    "src/vendor/activesync/codepages/DocumentLibrary.js"() {
      DocumentLibrary_default = {
        Tags: {
          LinkId: 4869,
          DisplayName: 4870,
          IsFolder: 4871,
          CreationDate: 4872,
          LastModifiedDate: 4873,
          IsHidden: 4874,
          ContentLength: 4875,
          ContentType: 4876
        }
      };
    }
  });

  // src/vendor/activesync/codepages/ItemOperations.js
  var ItemOperations_default;
  var init_ItemOperations = __esm({
    "src/vendor/activesync/codepages/ItemOperations.js"() {
      ItemOperations_default = {
        Tags: {
          ItemOperations: 5125,
          Fetch: 5126,
          Store: 5127,
          Options: 5128,
          Range: 5129,
          Total: 5130,
          Properties: 5131,
          Data: 5132,
          Status: 5133,
          Response: 5134,
          Version: 5135,
          Schema: 5136,
          Part: 5137,
          EmptyFolderContents: 5138,
          DeleteSubFolders: 5139,
          UserName: 5140,
          Password: 5141,
          Move: 5142,
          DstFldId: 5143,
          ConversationId: 5144,
          MoveAlways: 5145
        },
        Enums: {
          Status: {
            Success: "1",
            ProtocolError: "2",
            ServerError: "3",
            BadURI: "4",
            AccessDenied: "5",
            ObjectNotFound: "6",
            ConnectionFailure: "7",
            InvalidByteRange: "8",
            UnknownStore: "9",
            EmptyFile: "10",
            DataTooLarge: "11",
            IOFailure: "12",
            ConversionFailure: "14",
            InvalidAttachment: "15",
            ResourceAccessDenied: "16"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/ComposeMail.js
  var ComposeMail_default;
  var init_ComposeMail = __esm({
    "src/vendor/activesync/codepages/ComposeMail.js"() {
      ComposeMail_default = {
        Tags: {
          SendMail: 5381,
          SmartForward: 5382,
          SmartReply: 5383,
          SaveInSentItems: 5384,
          ReplaceMime: 5385,
          Source: 5387,
          FolderId: 5388,
          ItemId: 5389,
          LongId: 5390,
          InstanceId: 5391,
          Mime: 5392,
          ClientId: 5393,
          Status: 5394,
          AccountId: 5395
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Email2.js
  var Email2_default;
  var init_Email2 = __esm({
    "src/vendor/activesync/codepages/Email2.js"() {
      Email2_default = {
        Tags: {
          UmCallerID: 5637,
          UmUserNotes: 5638,
          UmAttDuration: 5639,
          UmAttOrder: 5640,
          ConversationId: 5641,
          ConversationIndex: 5642,
          LastVerbExecuted: 5643,
          LastVerbExecutionTime: 5644,
          ReceivedAsBcc: 5645,
          Sender: 5646,
          CalendarType: 5647,
          IsLeapMonth: 5648,
          AccountId: 5649,
          FirstDayOfWeek: 5650,
          MeetingMessageType: 5651
        },
        Enums: {
          LastVerbExecuted: {
            Unknown: "0",
            ReplyToSender: "1",
            ReplyToAll: "2",
            Forward: "3"
          },
          CalendarType: {
            Default: "0",
            Gregorian: "1",
            GregorianUS: "2",
            Japan: "3",
            Taiwan: "4",
            Korea: "5",
            Hijri: "6",
            Thai: "7",
            Hebrew: "8",
            GregorianMeFrench: "9",
            GregorianArabic: "10",
            GregorianTranslatedEnglish: "11",
            GregorianTranslatedFrench: "12",
            JapaneseLunar: "14",
            ChineseLunar: "15",
            KoreanLunar: "20"
          },
          FirstDayOfWeek: {
            Sunday: "0",
            Monday: "1",
            Tuesday: "2",
            Wednesday: "3",
            Thursday: "4",
            Friday: "5",
            Saturday: "6"
          },
          MeetingMessageType: {
            Unspecified: "0",
            InitialRequest: "1",
            FullUpdate: "2",
            InformationalUpdate: "3",
            Outdated: "4",
            DelegatorsCopy: "5",
            Delegated: "6"
          }
        }
      };
    }
  });

  // src/vendor/activesync/codepages/Notes.js
  var Notes_default;
  var init_Notes = __esm({
    "src/vendor/activesync/codepages/Notes.js"() {
      Notes_default = {
        Tags: {
          Subject: 5893,
          MessageClass: 5894,
          LastModifiedDate: 5895,
          Categories: 5896,
          Category: 5897
        }
      };
    }
  });

  // src/vendor/activesync/codepages/RightsManagement.js
  var RightsManagement_default;
  var init_RightsManagement = __esm({
    "src/vendor/activesync/codepages/RightsManagement.js"() {
      RightsManagement_default = {
        Tags: {
          RightsManagementSupport: 6149,
          RightsManagementTemplates: 6150,
          RightsManagementTemplate: 6151,
          RightsManagementLicense: 6152,
          EditAllowed: 6153,
          ReplyAllowed: 6154,
          ReplyAllAllowed: 6155,
          ForwardAllowed: 6156,
          ModifyRecipientsAllowed: 6157,
          ExtractAllowed: 6158,
          PrintAllowed: 6159,
          ExportAllowed: 6160,
          ProgrammaticAccessAllowed: 6161,
          Owner: 6162,
          ContentExpiryDate: 6163,
          TemplateID: 6164,
          TemplateName: 6165,
          TemplateDescription: 6166,
          ContentOwner: 6167,
          RemoveRightsManagementDistribution: 6168
        }
      };
    }
  });

  // src/vendor/activesync/codepages.js
  var codepages, codepages_default;
  var init_codepages = __esm({
    "src/vendor/activesync/codepages.js"() {
      init_wbxml();
      init_Common();
      init_AirSync();
      init_Contacts();
      init_Email();
      init_Calendar();
      init_Move();
      init_ItemEstimate();
      init_FolderHierarchy();
      init_MeetingResponse();
      init_Tasks();
      init_ResolveRecipients();
      init_ValidateCert();
      init_Contacts2();
      init_Ping();
      init_Provision();
      init_Search();
      init_GAL();
      init_AirSyncBase();
      init_Settings();
      init_DocumentLibrary();
      init_ItemOperations();
      init_ComposeMail();
      init_Email2();
      init_Notes();
      init_RightsManagement();
      codepages = {
        Common: Common_default,
        AirSync: AirSync_default,
        Contacts: Contacts_default,
        Email: Email_default,
        Calendar: Calendar_default,
        Move: Move_default,
        ItemEstimate: ItemEstimate_default,
        FolderHierarchy: FolderHierarchy_default,
        MeetingResponse: MeetingResponse_default,
        Tasks: Tasks_default,
        ResolveRecipients: ResolveRecipients_default,
        ValidateCert: ValidateCert_default,
        Contacts2: Contacts2_default,
        Ping: Ping_default,
        Provision: Provision_default,
        Search: Search_default,
        GAL: GAL_default,
        AirSyncBase: AirSyncBase_default,
        Settings: Settings_default,
        DocumentLibrary: DocumentLibrary_default,
        ItemOperations: ItemOperations_default,
        ComposeMail: ComposeMail_default,
        Email2: Email2_default,
        Notes: Notes_default,
        RightsManagement: RightsManagement_default
      };
      CompileCodepages(codepages);
      codepages_default = codepages;
    }
  });

  // src/vendor/activesync/protocol.js
  function nullCallback() {
  }
  function makeError2(name, parent2, extraArgs) {
    function CustomError() {
      var self2 = this instanceof CustomError ? this : Object.create(CustomError.prototype);
      var tmp = Error();
      var offset = 1;
      self2.stack = tmp.stack.substring(tmp.stack.indexOf("\n") + 1);
      self2.message = arguments[0] || tmp.message;
      if (extraArgs) {
        offset += extraArgs.length;
        for (var i = 0; i < extraArgs.length; i++)
          self2[extraArgs[i]] = arguments[i + 1];
      }
      var m = /@(.+):(.+)/.exec(self2.stack);
      self2.fileName = arguments[offset] || m && m[1] || "";
      self2.lineNumber = arguments[offset + 1] || m && m[2] || 0;
      return self2;
    }
    CustomError.prototype = Object.create((parent2 || Error).prototype);
    CustomError.prototype.name = name;
    CustomError.prototype.constructor = CustomError;
    return CustomError;
  }
  function nsResolver(prefix) {
    var baseUrl = "http://schemas.microsoft.com/exchange/autodiscover/";
    var ns = {
      rq: baseUrl + "mobilesync/requestschema/2006",
      ad: baseUrl + "responseschema/2006",
      ms: baseUrl + "mobilesync/responseschema/2006"
    };
    return ns[prefix] || null;
  }
  function Version(str) {
    var details = str.split(".").map(function(x) {
      return parseInt(x);
    });
    this.major = details[0], this.minor = details[1];
  }
  function setAuthHeader(xhr, username, password) {
    var authorization = "Basic " + btoa(username + ":" + password);
    xhr.setRequestHeader("Authorization", authorization);
  }
  function autodiscover(aEmailAddress, aPassword, aTimeout, aCallback, aNoRedirect) {
    if (!aCallback)
      aCallback = nullCallback;
    var domain = aEmailAddress.substring(aEmailAddress.indexOf("@") + 1);
    do_autodiscover(domain, aEmailAddress, aPassword, aTimeout, aNoRedirect, function(aError, aConfig) {
      if (aError instanceof AutodiscoverDomainError || aError instanceof HttpError)
        do_autodiscover("autodiscover." + domain, aEmailAddress, aPassword, aTimeout, aNoRedirect, aCallback);
      else
        aCallback(aError, aConfig);
    });
  }
  function do_autodiscover(aHost, aEmailAddress, aPassword, aTimeout, aNoRedirect, aCallback) {
    var url = "https://" + aHost + "/autodiscover/autodiscover.xml";
    return raw_autodiscover(url, aEmailAddress, aPassword, aTimeout, aNoRedirect, aCallback);
  }
  function raw_autodiscover(aUrl, aEmailAddress, aPassword, aTimeout, aNoRedirect, aCallback) {
    var xhr = new XMLHttpRequest({ mozSystem: true, mozAnon: true });
    xhr.open("POST", aUrl, true);
    setAuthHeader(xhr, aEmailAddress, aPassword);
    xhr.setRequestHeader("Content-Type", "text/xml");
    xhr.setRequestHeader("User-Agent", USER_AGENT);
    xhr.timeout = aTimeout;
    xhr.upload.onprogress = xhr.upload.onload = function() {
      xhr.timeout = 0;
    };
    xhr.onload = function() {
      if (xhr.status < 200 || xhr.status >= 300)
        return aCallback(new HttpError(xhr.statusText, xhr.status));
      var uid = Math.random();
      self.postMessage({
        uid,
        type: "configparser",
        cmd: "accountactivesync",
        args: [xhr.responseText, aNoRedirect]
      });
      self.addEventListener("message", function onworkerresponse(evt12) {
        var data = evt12.data;
        if (data.type != "configparser" || data.cmd != "accountactivesync" || data.uid != uid) {
          return;
        }
        self.removeEventListener(evt12.type, onworkerresponse);
        var args = data.args;
        var config = args[0], error = args[1], redirectedEmail = args[2];
        if (error) {
          aCallback(new AutodiscoverDomainError(error), config);
        } else if (redirectedEmail) {
          autodiscover(redirectedEmail, aPassword, aTimeout, aCallback, true);
        } else {
          aCallback(null, config);
        }
      });
    };
    xhr.ontimeout = xhr.onerror = function() {
      aCallback(new HttpError("Error getting Autodiscover URL", null));
    };
    var postdata = '<?xml version="1.0" encoding="utf-8"?>\n<Autodiscover xmlns="' + nsResolver("rq") + '">\n  <Request>\n    <EMailAddress>' + aEmailAddress + "</EMailAddress>\n    <AcceptableResponseSchema>" + nsResolver("ms") + "</AcceptableResponseSchema>\n  </Request>\n</Autodiscover>";
    xhr.send(postdata);
  }
  function Connection(aDeviceId, aDeviceType) {
    this._deviceId = aDeviceId || "v140Device";
    this._deviceType = aDeviceType || "SmartPhone";
    this.timeout = 0;
    this._connected = false;
    this._waitingForConnection = false;
    this._connectionError = null;
    this._connectionCallbacks = [];
    this.baseUrl = null;
    this._username = null;
    this._password = null;
    this.versions = [];
    this.supportedCommands = [];
    this.currentVersion = null;
    this.onmessage = null;
  }
  var USER_AGENT, AutodiscoverError, AutodiscoverDomainError, HttpError;
  var init_protocol = __esm({
    "src/vendor/activesync/protocol.js"() {
      init_wbxml();
      init_codepages();
      USER_AGENT = "JavaScript ActiveSync (jsas) Client";
      AutodiscoverError = makeError2("ActiveSync.AutodiscoverError");
      AutodiscoverDomainError = makeError2("ActiveSync.AutodiscoverDomainError", AutodiscoverError);
      HttpError = makeError2("ActiveSync.HttpError", null, ["status"]);
      Version.prototype = {
        eq: function(other) {
          if (!(other instanceof Version))
            other = new Version(other);
          return this.major === other.major && this.minor === other.minor;
        },
        ne: function(other) {
          return !this.eq(other);
        },
        gt: function(other) {
          if (!(other instanceof Version))
            other = new Version(other);
          return this.major > other.major || this.major === other.major && this.minor > other.minor;
        },
        gte: function(other) {
          if (!(other instanceof Version))
            other = new Version(other);
          return this.major >= other.major || this.major === other.major && this.minor >= other.minor;
        },
        lt: function(other) {
          return !this.gte(other);
        },
        lte: function(other) {
          return !this.gt(other);
        },
        toString: function() {
          return this.major + "." + this.minor;
        }
      };
      Connection.prototype = {
        _notifyConnected: function(aError) {
          if (aError)
            this.disconnect();
          for (const callback of this._connectionCallbacks) {
            callback.apply(callback, arguments);
          }
          this._connectionCallbacks = [];
        },
        get connected() {
          return this._connected;
        },
        open: function(aURL, aUsername, aPassword) {
          var servicePath = "/Microsoft-Server-ActiveSync";
          this.baseUrl = aURL;
          if (!this.baseUrl.endsWith(servicePath))
            this.baseUrl += servicePath;
          this._username = aUsername;
          this._password = aPassword;
        },
        connect: function(aCallback) {
          if (this.connected) {
            if (aCallback)
              aCallback(null);
            return;
          }
          if (aCallback)
            this._connectionCallbacks.push(aCallback);
          if (this._waitingForConnection)
            return;
          this._waitingForConnection = true;
          this._connectionError = null;
          this.getOptions(function(aError, aOptions) {
            this._waitingForConnection = false;
            this._connectionError = aError;
            if (aError) {
              console.error("Error connecting to ActiveSync:", aError);
              return this._notifyConnected(aError, aOptions);
            }
            this._connected = true;
            this.versions = aOptions.versions;
            this.supportedCommands = aOptions.commands;
            this.currentVersion = new Version(aOptions.versions.slice(-1)[0]);
            return this._notifyConnected(null, aOptions);
          }.bind(this));
        },
        disconnect: function() {
          if (this._waitingForConnection)
            throw new Error("Can't disconnect while waiting for server response");
          this._connected = false;
          this.versions = [];
          this.supportedCommands = [];
          this.currentVersion = null;
        },
        provision: function() {
          var pv = codepages_default.Provision.Tags;
          var w = new Writer("1.3", 1, "UTF-8");
          w.stag(pv.Provision).etag();
          return this.postCommand(w);
        },
        getOptions: function(aCallback) {
          if (!aCallback)
            aCallback = nullCallback;
          var conn = this;
          var xhr = new XMLHttpRequest({ mozSystem: true, mozAnon: true });
          xhr.open("OPTIONS", this.baseUrl, true);
          setAuthHeader(xhr, this._username, this._password);
          xhr.setRequestHeader("User-Agent", USER_AGENT);
          xhr.timeout = this.timeout;
          xhr.upload.onprogress = xhr.upload.onload = function() {
            xhr.timeout = 0;
          };
          xhr.onload = function() {
            if (xhr.status < 200 || xhr.status >= 300) {
              console.error("ActiveSync options request failed with response " + xhr.status);
              if (conn.onmessage)
                conn.onmessage("options", "error", xhr, null, null, null, null);
              aCallback(new HttpError(xhr.statusText, xhr.status));
              return;
            }
            var result = {
              versions: xhr.getResponseHeader("MS-ASProtocolVersions").split(/\s*,\s*/),
              commands: xhr.getResponseHeader("MS-ASProtocolCommands").split(/\s*,\s*/)
            };
            if (conn.onmessage)
              conn.onmessage("options", "ok", xhr, null, null, null, result);
            aCallback(null, result);
          };
          xhr.ontimeout = xhr.onerror = function() {
            var error = new Error("Error getting OPTIONS URL");
            console.error(error);
            if (conn.onmessage)
              conn.onmessage("options", "timeout", xhr, null, null, null, null);
            aCallback(error);
          };
          xhr.responseType = "text";
          xhr.send();
        },
        supportsCommand: function(aCommand) {
          if (!this.connected)
            throw new Error("Connection required to get command");
          if (typeof aCommand === "number")
            aCommand = codepages_default.__tagnames__[aCommand];
          return this.supportedCommands.indexOf(aCommand) !== -1;
        },
        postCommand: function(aCommand, aOpts) {
          var contentType = "application/vnd.ms-sync.wbxml";
          if (typeof aCommand === "string" || typeof aCommand === "number") {
            return this.postData(aCommand, contentType, null, aOpts);
          } else {
            var commandName = codepages_default.__tagnames__[aCommand.rootTag];
            return this.postData(commandName, contentType, aCommand.dataType === "blob" ? aCommand.blob : aCommand.buffer, aOpts);
          }
        },
        postData: function(aCommand, aContentType, aData, aOpts) {
          var parentArgs = arguments;
          return new Promise((resolve, reject) => {
            if (typeof aCommand === "number") {
              aCommand = codepages_default.__tagnames__[aCommand];
            }
            if (!this.supportsCommand(aCommand)) {
              var error = new Error("This server doesn't support the command " + aCommand);
              console.error(error);
              reject(error);
              return;
            }
            var isMultipart = aOpts && aOpts.extraHeaders && aOpts.extraHeaders["MS-ASAcceptMultiPart"] === "T";
            var params = [
              ["Cmd", aCommand],
              ["User", this._username],
              ["DeviceId", this._deviceId],
              ["DeviceType", this._deviceType]
            ];
            if (aOpts && aOpts.extraParams) {
              for (let [paramName] of params) {
                if (paramName in aOpts.extraParams) {
                  throw new TypeError("reserved URL parameter found");
                }
              }
              for (let paramName in aOpts.extraParams) {
                params.push([paramName, aOpts.extraParams[paramName]]);
              }
            }
            var paramsStr = params.map(function(i) {
              return encodeURIComponent(i[0]) + "=" + encodeURIComponent(i[1]);
            }).join("&");
            var xhr = new XMLHttpRequest({ mozSystem: true, mozAnon: true });
            xhr.open("POST", this.baseUrl + "?" + paramsStr, true);
            setAuthHeader(xhr, this._username, this._password);
            xhr.setRequestHeader("MS-ASProtocolVersion", this.currentVersion);
            xhr.setRequestHeader("Content-Type", aContentType);
            xhr.setRequestHeader("User-Agent", USER_AGENT);
            if (aOpts && aOpts.extraHeaders) {
              for (let key in aOpts.extraHeaders) {
                let value = aOpts.extraHeaders[key];
                xhr.setRequestHeader(key, value);
              }
            }
            xhr.timeout = this.timeout;
            var downloadProgress = aOpts && aOpts.downloadProgress;
            var uploadProgress = aOpts && aOpts.uploadProgerss;
            xhr.upload.onprogress = function(event) {
              xhr.timeout = 0;
              if (uploadProgress) {
                uploadProgress(event.loaded, event.total);
              }
            };
            xhr.upload.onload = function() {
              xhr.timeout = 0;
            };
            xhr.onprogress = function(event) {
              if (downloadProgress) {
                downloadProgress(event.loaded, event.total);
              }
            };
            var conn = this;
            xhr.onload = function() {
              if (xhr.status === 451) {
                conn.baseUrl = xhr.getResponseHeader("X-MS-Location");
                if (conn.onmessage) {
                  conn.onmessage(aCommand, "redirect", xhr, params, aOpts && aOpts.extraHeaders, aData, null);
                }
                resolve(conn.postData.apply(conn, parentArgs));
                return;
              }
              if (xhr.status < 200 || xhr.status >= 300) {
                console.error("ActiveSync command " + aCommand + " failed with response " + xhr.status);
                if (conn.onmessage) {
                  conn.onmessage(aCommand, "error", xhr, params, aOpts && aOpts.extraHeaders, aData, null);
                }
                reject(new HttpError(xhr.statusText, xhr.status));
                return;
              }
              if (isMultipart) {
                resolve(null);
              } else {
                var response = null;
                if (xhr.response.byteLength > 0) {
                  response = new Reader(new Uint8Array(xhr.response), codepages_default);
                }
                if (conn.onmessage) {
                  conn.onmessage(aCommand, "ok", xhr, params, aOpts && aOpts.extraHeaders, aData, response);
                }
                resolve(response);
              }
            };
            xhr.ontimeout = xhr.onerror = function(evt12) {
              var errObj = new Error("Command URL " + evt12.type + " for command " + aCommand + " at baseUrl " + this.baseUrl);
              console.error(errObj);
              if (conn.onmessage) {
                conn.onmessage(aCommand, evt12.type, xhr, params, aOpts && aOpts.extraHeaders, aData, null);
              }
              reject(errObj);
            }.bind(this);
            xhr.responseType = isMultipart ? "moz-chunked-arraybuffer" : "arraybuffer";
            xhr.send(aData);
          });
        }
      };
    }
  });

  // src/backend/accounts/activesync/probe.js
  function checkServerCertificate(url) {
    return new Promise((resolve) => {
      resolve(null);
    });
  }
  function probe({ connInfo, credentials }) {
    return new Promise((resolve) => {
      var conn = new Connection(connInfo.deviceId);
      conn.open(connInfo.server, credentials.username, credentials.password);
      conn.timeout = AUTOCONFIG_TIMEOUT_MS;
      conn.connect((error) => {
        if (error) {
          var failureType, failureDetails = { server: connInfo.server };
          if (error instanceof HttpError) {
            if (error.status === 401) {
              failureType = "bad-user-or-pass";
            } else if (error.status === 403) {
              failureType = "not-authorized";
            } else {
              failureType = "server-problem";
              failureDetails.status = error.status;
            }
          } else {
            resolve(checkServerCertificate(connInfo.server).then((securityError) => {
              return {
                error: securityError ? "bad-security" : "unresponsive-server",
                errorDetails: failureDetails
              };
            }));
            return;
          }
          resolve({
            error: failureType,
            errorDetails: failureDetails
          });
          return;
        }
        resolve({ conn, error: null, errorDetails: null });
      });
    });
  }
  var init_probe = __esm({
    "src/backend/accounts/activesync/probe.js"() {
      init_syncbase();
      init_protocol();
    }
  });

  // src/backend/accounts/activesync/validator.js
  var validator_exports = {};
  __export(validator_exports, {
    default: () => validator_default
  });
  function getFullDetailsFromAutodiscover(userDetails, url) {
    return new Promise((resolve) => {
      logic(scope, "autodiscover:begin", { url });
      raw_autodiscover(url, userDetails.emailAddress, userDetails.password, AUTOCONFIG_TIMEOUT_MS, false, function(error, config) {
        if (error) {
          var failureType = "no-config-info", failureDetails = {};
          if (error instanceof HttpError) {
            if (error.status === 401) {
              failureType = "bad-user-or-pass";
            } else if (error.status === 403) {
              failureType = "not-authorized";
            } else {
              failureDetails.status = error.status;
            }
          } else if (error instanceof AutodiscoverDomainError) {
            logic(scope, "autodiscover.error", { message: error.message });
          }
          logic(scope, "autodiscover:end", { url, error: failureType });
          resolve({
            error: failureType,
            errorDetails: failureDetails
          });
          return;
        }
        logic(scope, "autodiscover:end", {
          url,
          server: config.mobileSyncServer.url
        });
        var autoconfig = {
          type: "activesync",
          displayName: config.user.name,
          incoming: {
            server: config.mobileSyncServer.url,
            username: config.user.email
          }
        };
        resolve({
          fullConfigInfo: autoconfig
        });
      });
    });
  }
  async function validator_default(fragments) {
    let { credentials, connInfoFields } = fragments;
    if (connInfoFields.connInfo.autodiscoverEndpoint) {
      let {
        error: error2,
        errorDetails: errorDetails2,
        fullConfigInfo
      } = await getFullDetailsFromAutodiscover(credentials, connInfoFields.connInfo.autodiscoverEndpoint);
      if (error2) {
        return { error: error2, errorDetails: errorDetails2 };
      }
      fragments.credentials = credentials = {
        username: fullConfigInfo.incoming.username,
        password: credentials.password
      };
      connInfoFields.connInfo = {
        server: fullConfigInfo.incoming.server,
        deviceId: connInfoFields.connInfo.deviceId
      };
    }
    let { conn, error, errorDetails } = await probe({
      connInfo: connInfoFields.connInfo,
      credentials
    });
    if (error) {
      return { error, errorDetails };
    }
    return {
      engineFields: {
        engine: "activesync",
        engineData: {}
      },
      receiveProtoConn: conn
    };
  }
  var scope;
  var init_validator = __esm({
    "src/backend/accounts/activesync/validator.js"() {
      init_logic();
      init_probe();
      init_syncbase();
      init_protocol();
      scope = logic.scope("ActivesyncConfigurator");
    }
  });

  // src/backend/parsers/xml/namespaces.js
  var NamespaceIds;
  var init_namespaces = __esm({
    "src/backend/parsers/xml/namespaces.js"() {
      NamespaceIds = new Map([
        [
          "local",
          {
            id: 0,
            check: (ns) => false
          }
        ],
        [
          "atom",
          {
            id: 1,
            check: (ns) => ns === "http://www.w3.org/2005/Atom"
          }
        ],
        [
          "xhtml",
          {
            id: 2,
            check: (ns) => ns === "http://www.w3.org/1999/xhtml"
          }
        ]
      ]);
    }
  });

  // src/backend/parsers/xml/utils.js
  function validateString({ data, defaultValue, validate, convert = null }) {
    if (!data) {
      return defaultValue;
    }
    data = data.trim();
    if (validate(data)) {
      return convert ? convert(data) : data;
    }
    return defaultValue;
  }
  function encodeToXmlString(str) {
    const buffer = [];
    let start = 0;
    for (let i = 0, ii = str.length; i < ii; i++) {
      const char = str.codePointAt(i);
      if (32 <= char && char <= 126) {
        const entity = XMLEntities[char];
        if (entity) {
          if (start < i) {
            buffer.push(str.substring(start, i));
          }
          buffer.push(entity);
          start = i + 1;
        }
      } else {
        if (start < i) {
          buffer.push(str.substring(start, i));
        }
        buffer.push(`&#x${char.toString(16).toUpperCase()};`);
        if (char > 55295 && (char < 57344 || char > 65533)) {
          i++;
        }
        start = i + 1;
      }
    }
    if (buffer.length === 0) {
      return str;
    }
    if (start < str.length) {
      buffer.push(str.substring(start, str.length));
    }
    return buffer.join("");
  }
  var XMLEntities;
  var init_utils = __esm({
    "src/backend/parsers/xml/utils.js"() {
      XMLEntities = {
        60: "&lt;",
        62: "&gt;",
        38: "&amp;",
        34: "&quot;",
        39: "&apos;"
      };
    }
  });

  // src/backend/parsers/xml/xml_object.js
  var XMLObject, XMLObjectArray, StringObject, XmlNodeObject;
  var init_xml_object = __esm({
    "src/backend/parsers/xml/xml_object.js"() {
      init_utils();
      XMLObject = class {
        constructor(nsId, name) {
          this.$namespaceId = nsId;
          this.$nodeName = name;
        }
        $onChild(child) {
          if (!this.$onChildCheck(child)) {
            return;
          }
          const name = child.$nodeName;
          const node = this[name];
          if (node instanceof XMLObjectArray) {
            node.push(child);
          } else {
            this[name] = child;
          }
        }
        $onChildCheck(child) {
          return this.hasOwnProperty(child.$nodeName) && child.$namespaceId === this.$namespaceId;
        }
        $onText(_) {
        }
        $finalize() {
        }
        $clean(builder) {
          if (this.$cleanup) {
            builder.clean(this.$cleanup);
            delete this.$cleanup;
          }
        }
        $dump() {
          const dumped = Object.create(null);
          let empty = true;
          for (const name of Object.getOwnPropertyNames(this)) {
            if (name.startsWith("$")) {
              continue;
            }
            const value = this[name];
            const dumpedValue = value?.$dump?.() || value;
            if (dumpedValue === null || dumpedValue === void 0 || dumpedValue === "" || Array.isArray(dumpedValue) && dumpedValue.length === 0) {
              continue;
            }
            empty = false;
            dumped[name] = dumpedValue;
          }
          if (!this.$content) {
            return empty ? null : dumped;
          }
          const content = this.$content?.$dump?.() || this.$content;
          if (empty) {
            return content;
          }
          dumped["#content"] = content;
          return dumped;
        }
      };
      XMLObjectArray = class {
        #max;
        constructor(max = Infinity) {
          this.#max = max;
          this.children = [];
        }
        push(child) {
          if (this.children.length <= this.#max) {
            this.children.push(child);
          }
        }
        isEmpty() {
          return this.children.length === 0;
        }
        $dump() {
          return this.children.map((v) => v.$dump());
        }
      };
      StringObject = class extends XMLObject {
        constructor(nsId, name) {
          super(nsId, name);
          this.$content = "";
        }
        $onChild(child) {
        }
        $onText(text) {
          this.$content += text;
        }
      };
      XmlNodeObject = class extends XMLObject {
        constructor(nsId, name, attributes = {}) {
          super(nsId, name);
          this.$content = "";
          if (name !== "#text") {
            this.$attributes = attributes;
          }
          this.$children = [];
        }
        $serialize(buf) {
          const tagName = this.$nodeName;
          if (tagName === "#text") {
            buf.push(encodeToXmlString(this.$content));
            return;
          }
          buf.push(`<${tagName}`);
          for (const [name, value] of this.$attributes) {
            buf.push(` ${name}="${encodeToXmlString(value.$content)}"`);
          }
          if (!this.$content && this.$children.length === 0) {
            buf.push("/>");
            return;
          }
          buf.push(">");
          if (this.$content) {
            if (typeof this.$content === "string") {
              buf.push(encodeToXmlString(this.$content));
            } else {
              this.$content.$serialize(buf);
            }
          } else {
            for (const child of this.$children) {
              child.$serialize(buf);
            }
          }
          buf.push(`</${tagName}>`);
        }
        $onChild(child) {
          if (this.$content) {
            const node = new XmlNodeObject(this.$namespaceId, "#text");
            this.$children.push(node);
            node.$content = this.$content;
            this.$content = "";
          }
          this.$children.push(child);
        }
        $onText(str) {
          this.$content += str;
        }
        $finalize() {
          if (this.$content && this.$children.length) {
            const node = new XmlNodeObject(this.$namespaceId, "#text");
            this.$children.push(node);
            node.$content = this.$content;
            delete this.$content;
          }
        }
        $dump() {
          return this.$serialize().join("");
        }
      };
    }
  });

  // src/backend/parsers/xml/atom.js
  var ATOM_NS_ID, XHTML_NS_ID, Atom, StringAtom, PlainTextConstruct, XHTMLTextConstruct, PersonConstruct, Name, Uri, Email, DateConstruct, Feed, Entry, InlineTextContent, InlineXHTMLContent, InlineOtherContent, OutOfLineContent, Author, Category, Contributor, Generator, Icon, Id, Link, Logo, Published, Source, Updated, AtomNamespace;
  var init_atom = __esm({
    "src/backend/parsers/xml/atom.js"() {
      init_namespaces();
      init_xml_object();
      init_utils();
      ATOM_NS_ID = NamespaceIds.get("atom").id;
      XHTML_NS_ID = NamespaceIds.get("xhtml").id;
      Atom = class extends XMLObject {
        constructor(name, attributes) {
          super(ATOM_NS_ID, name);
          this.base = attributes.get("base") || "";
          this.lang = validateString({
            data: attributes.get("lang"),
            defaultValue: "",
            validate: (s) => s.match(/^[A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*$/)
          });
        }
        $onChildCheck(child) {
          return !child.$isInvalid && super.$onChildCheck(child);
        }
      };
      StringAtom = class extends Atom {
        constructor(name, attributes) {
          super(name, attributes);
          this.$content = "";
        }
        $onChild(child) {
        }
        $onText(text) {
          this.$content += text;
        }
      };
      PlainTextConstruct = class extends StringAtom {
        constructor(name, attributes) {
          super(name, attributes);
          this.$content = "";
          this.type = validateString({
            data: attributes.get("type"),
            defaultValue: "",
            validate: (s) => s === "text" || s === "html"
          });
        }
      };
      XHTMLTextConstruct = class extends Atom {
        constructor(name, attributes) {
          super(name, attributes);
          this.type = validateString({
            data: attributes.get("type"),
            defaultValue: "xhtml",
            validate: (s) => false
          });
          this.div = null;
        }
        $onChild(child) {
          if (child.$namespaceId === XHTML_NS_ID && child.$nodeName === "div") {
            this.div = child;
          }
        }
      };
      PersonConstruct = class extends Atom {
        constructor(name, attributes) {
          super(name, attributes);
          this.name = null;
          this.uri = null;
          this.email = null;
        }
        $finalize() {
          for (const propr of ["name", "uri", "email"]) {
            if (this[propr]) {
              this[propr] = this[propr].$content;
            }
          }
        }
      };
      Name = class extends StringObject {
        constructor() {
          super(ATOM_NS_ID, "name");
        }
      };
      Uri = class extends StringObject {
        constructor() {
          super(ATOM_NS_ID, "uri");
        }
      };
      Email = class extends StringObject {
        constructor() {
          super(ATOM_NS_ID, "email");
        }
        $finalize() {
          if (!this.$content.match(/^.+@.+$/)) {
            this.$content = "";
          }
        }
      };
      DateConstruct = class extends StringAtom {
        $finalize() {
          try {
            this.$content = new Date(this.$content);
          } catch {
            this.$isInvalid = true;
          }
        }
      };
      Feed = class extends Atom {
        constructor(attributes) {
          super("feed", attributes);
          this.author = new XMLObjectArray();
          this.category = new XMLObjectArray();
          this.contributor = new XMLObjectArray();
          this.generator = null;
          this.icon = null;
          this.id = null;
          this.link = new XMLObjectArray();
          this.logo = null;
          this.rights = null;
          this.subtitle = null;
          this.title = null;
          this.updated = null;
          this.entry = new XMLObjectArray();
        }
        $finalize() {
          for (const propr of ["id", "title", "updated"]) {
            if (this[propr] === null) {
              console.warn(`Atom - Required field ${propr} is not present.`);
            }
          }
          if (this.author.isEmpty() && this.entry.children.some((e) => e.author.isEmpty())) {
            console.warn("An atom:feed must have an atom:author unless all of its atom:entry children have an atom:author.");
          }
        }
      };
      Entry = class extends Atom {
        constructor(attributes) {
          super("entry", attributes);
          this.author = new XMLObjectArray();
          this.category = new XMLObjectArray();
          this.content = null;
          this.contributor = new XMLObjectArray();
          this.id = null;
          this.link = new XMLObjectArray();
          this.published = null;
          this.rights = null;
          this.source = null;
          this.summary = null;
          this.title = null;
          this.updated = null;
        }
        $finalize() {
          for (const propr of ["id", "title", "updated"]) {
            if (this[propr] === null) {
              console.warn(`Atom - Required field ${propr} is not present.`);
            }
          }
          if (!this.link.children.some((e) => e.rel === "alternate") && this.content === null) {
            console.warn("An atom:entry must have at least one atom:link element with a rel attribute of 'alternate' or an atom:content.");
          }
        }
      };
      InlineTextContent = class extends PlainTextConstruct {
        constructor(attributes) {
          super("content", attributes);
        }
      };
      InlineXHTMLContent = class extends XHTMLTextConstruct {
        constructor(attributes) {
          super("content", attributes);
        }
      };
      InlineOtherContent = class extends Atom {
        constructor(attributes) {
          super("content", attributes);
          this.$content = "";
          this.type = validateString({
            data: attributes.get("type"),
            defaultValue: "",
            validate: (s) => s.match(/^.+\/.+$/)
          });
        }
        $onText(text) {
          if (typeof this.$content === "string") {
            this.$content += text;
          } else {
            this.$content = text;
          }
        }
        $onChild(child) {
          this.$content = child;
        }
      };
      OutOfLineContent = class extends Atom {
        constructor(attributes) {
          super("content", attributes);
          this.type = validateString({
            data: attributes.get("type"),
            defaultValue: "",
            validate: (s) => s.match(/^.+\/.+$/)
          });
          this.src = attributes.get("src") || "";
        }
      };
      Author = class extends PersonConstruct {
        constructor(attributes) {
          super("author", attributes);
        }
      };
      Category = class extends Atom {
        constructor(attributes) {
          super("category", attributes);
          this.term = attributes.get("term") || "";
          this.scheme = attributes.get("scheme") || "";
          this.label = attributes.get("label") || "";
        }
        $onChild(child) {
        }
      };
      Contributor = class extends PersonConstruct {
        constructor(attributes) {
          super("contributor", attributes);
        }
      };
      Generator = class extends StringAtom {
        constructor(attributes) {
          super("generator", attributes);
          this.uri = attributes.get("uri") || "";
          this.version = attributes.get("version") || "";
        }
      };
      Icon = class extends StringAtom {
        constructor(attributes) {
          super("icon", attributes);
        }
      };
      Id = class extends StringAtom {
        constructor(attributes) {
          super("id", attributes);
        }
      };
      Link = class extends Atom {
        constructor(attributes) {
          super("link", attributes);
          this.href = attributes.get("href") || "";
          this.rel = attributes.get("rel") || "";
          this.type = attributes.get("type") || "";
          this.title = attributes.get("title") || "";
          this.length = attributes.get("length") || "";
        }
      };
      Logo = class extends StringAtom {
        constructor(attributes) {
          super("logo", attributes);
        }
      };
      Published = class extends DateConstruct {
        constructor(attributes) {
          super("published", attributes);
        }
      };
      Source = class extends Atom {
        constructor(attributes) {
          super("source", attributes);
          this.author = new XMLObjectArray();
          this.category = new XMLObjectArray();
          this.contributor = new XMLObjectArray();
          this.generator = null;
          this.icon = null;
          this.link = new XMLObjectArray();
          this.logo = null;
          this.rights = null;
          this.subtitle = null;
          this.updated = null;
        }
      };
      Updated = class extends DateConstruct {
        constructor(attributes) {
          super("updated", attributes);
        }
      };
      AtomNamespace = class {
        static $buildXMLObject(name, attributes) {
          attributes = attributes.get("");
          if (AtomNamespace.hasOwnProperty(name)) {
            return AtomNamespace[name](attributes);
          }
          if (["rights", "subtitle", "summary", "title"].includes(name)) {
            if (attributes.get("type") === "xhtml") {
              return new XHTMLTextConstruct(name, attributes);
            }
            return new PlainTextConstruct(name, attributes);
          }
          return void 0;
        }
        static name(attributes) {
          return new Name(attributes);
        }
        static uri(attributes) {
          return new Uri(attributes);
        }
        static email(attributes) {
          return new Email(attributes);
        }
        static feed(attributes) {
          return new Feed(attributes);
        }
        static entry(attributes) {
          return new Entry(attributes);
        }
        static content(attributes) {
          switch (attributes.get("type")) {
            case "text":
            case "html":
              return new InlineTextContent(attributes);
            case "xhtml":
              return new InlineXHTMLContent(attributes);
          }
          if (attributes.has("src")) {
            return new OutOfLineContent(attributes);
          }
          return new InlineOtherContent(attributes);
        }
        static author(attributes) {
          return new Author(attributes);
        }
        static category(attributes) {
          return new Category(attributes);
        }
        static contributor(attributes) {
          return new Contributor(attributes);
        }
        static generator(attributes) {
          return new Generator(attributes);
        }
        static icon(attributes) {
          return new Icon(attributes);
        }
        static id(attributes) {
          return new Id(attributes);
        }
        static logo(attributes) {
          return new Logo(attributes);
        }
        static link(attributes) {
          return new Link(attributes);
        }
        static published(attributes) {
          return new Published(attributes);
        }
        static source(attributes) {
          return new Source(attributes);
        }
        static updated(attributes) {
          return new Updated(attributes);
        }
      };
    }
  });

  // src/backend/parsers/xml/node_builder.js
  var Empty, NodeBuilder;
  var init_node_builder = __esm({
    "src/backend/parsers/xml/node_builder.js"() {
      init_namespaces();
      init_xml_object();
      Empty = class extends XMLObject {
        constructor() {
          super(-1, "");
        }
        $onChild() {
        }
      };
      NodeBuilder = class {
        #namespaceStack;
        #namespaceSetup;
        #rootNode;
        #currentNamespace;
        #namespacePrefixes;
        #namespaces;
        constructor(namespaceSetup, rootNode, localNamespace = null) {
          this.#namespaceStack = [];
          this.#namespaceSetup = namespaceSetup;
          this.#rootNode = rootNode;
          this.#currentNamespace = localNamespace;
          this.#namespacePrefixes = new Map();
          this.#namespaces = new Map();
        }
        buildRoot() {
          return this.#rootNode;
        }
        build({ nsPrefix, name, attributes }) {
          const namespace = attributes.get("").get("xmlns");
          const prefixes = attributes.get("xmlns");
          if (namespace) {
            this.#namespaceStack.push(this.#currentNamespace);
            this.#currentNamespace = this.#searchNamespace(namespace);
          }
          if (prefixes) {
            this.#addNamespacePrefix(prefixes);
          }
          const namespaceToUse = this.#getNamespaceToUse(nsPrefix);
          const node = namespaceToUse?.$buildXMLObject(name, attributes) || new Empty();
          if (namespace || prefixes) {
            node.$cleanup = {
              hasNamespace: !!namespace,
              prefixes
            };
          }
          return node;
        }
        #searchNamespace(nsName) {
          let ns = this.#namespaces.get(nsName);
          if (ns) {
            return ns;
          }
          for (const [name, { check }] of NamespaceIds) {
            if (!check(nsName)) {
              continue;
            }
            ns = this.#namespaceSetup[name];
            if (ns) {
              this.#namespaces.set(nsName, ns);
              return ns;
            }
            break;
          }
          return null;
        }
        #addNamespacePrefix(prefixes) {
          for (const [prefix, value] of prefixes) {
            const namespace = this.#searchNamespace(value);
            let prefixStack = this.#namespacePrefixes.get(prefix);
            if (!prefixStack) {
              prefixStack = [];
              this.#namespacePrefixes.set(prefix, prefixStack);
            }
            prefixStack.push(namespace);
          }
        }
        #getNamespaceToUse(prefix) {
          if (!prefix) {
            return this.#currentNamespace;
          }
          const prefixStack = this.#namespacePrefixes.get(prefix);
          if (prefixStack?.length) {
            return prefixStack[prefixStack.length - 1];
          }
          return null;
        }
        clean(data) {
          const { hasNamespace, prefixes } = data;
          if (hasNamespace) {
            this.#currentNamespace = this.#namespaceStack.pop();
          }
          if (prefixes) {
            for (const prefix of prefixes.keys()) {
              this.#namespacePrefixes.get(prefix).pop();
            }
          }
        }
      };
    }
  });

  // src/backend/parsers/xml/rss.js
  var RSS_NS_ID, DEFAULT_IMG_WIDTH, DEFAULT_IMG_HEIGHT, MAX_IMG_WIDTH, MAX_IMG_HEIGHT, Rss, Channel, PubDate, LastBuildDate, Category2, Cloud, Ttl, Image, Width, Height, TextInput, Item, Enclosure, Guid, Source2, RssNamespace;
  var init_rss = __esm({
    "src/backend/parsers/xml/rss.js"() {
      init_namespaces();
      init_xml_object();
      RSS_NS_ID = NamespaceIds.get("local").id;
      DEFAULT_IMG_WIDTH = 88;
      DEFAULT_IMG_HEIGHT = 31;
      MAX_IMG_WIDTH = 144;
      MAX_IMG_HEIGHT = 400;
      Rss = class extends XMLObject {
        constructor(attributes) {
          super(RSS_NS_ID, "rss");
          this.version = attributes.get("version") || "";
          this.channel = null;
        }
        $onChildCheck(child) {
          return !child.$isInvalid && super.$onChildCheck(child);
        }
      };
      Channel = class extends XMLObject {
        constructor(attributges) {
          super(RSS_NS_ID, "channel");
          this.title = null;
          this.link = null;
          this.description = null;
          this.language = null;
          this.copyright = null;
          this.managingEditor = null;
          this.webMaster = null;
          this.pubDate = null;
          this.lastBuildDate = null;
          this.category = null;
          this.generator = null;
          this.docs = null;
          this.cloud = null;
          this.ttl = null;
          this.image = null;
          this.textInput = null;
          this.skipHours = null;
          this.skipDays = null;
          this.item = new XMLObjectArray();
        }
        $onChildCheck(child) {
          return !child.$isInvalid && super.$onChildCheck(child);
        }
        $finalize() {
          this.$isInvalid = !(this.title && this.link && this.description);
        }
      };
      PubDate = class extends StringObject {
        constructor() {
          super(RSS_NS_ID, "pubDate");
        }
        $finalize() {
          try {
            this.$content = new Date(this.$content);
          } catch {
            this.$isInvalid = true;
          }
        }
      };
      LastBuildDate = class extends StringObject {
        constructor() {
          super(RSS_NS_ID, "lastBuildDate");
        }
        $finalize() {
          try {
            this.$content = new Date(this.$content);
          } catch {
            this.$isInvalid = true;
          }
        }
      };
      Category2 = class extends StringObject {
        constructor(attributes) {
          super(RSS_NS_ID, "category");
          this.domain = attributes.get("domain") || "";
        }
      };
      Cloud = class extends StringObject {
        constructor(attributes) {
          super(RSS_NS_ID, "cloud");
          this.domain = attributes.get("domain") || "";
          this.port = attributes.get("port") || "";
          this.path = attributes.get("path") || "";
          this.registerProcedure = attributes.get("registerProcedure") || "";
          this.protocol = attributes.get("protocol") || "";
        }
        $onText(text) {
        }
      };
      Ttl = class extends StringObject {
        constructor(attributes) {
          super(RSS_NS_ID, "ttl");
        }
        $finalize() {
          this.$content = parseInt(this.$content);
          if (isNaN(this.$content)) {
            this.$isInvalid = true;
          }
        }
      };
      Image = class extends XMLObject {
        constructor(attributes) {
          super(RSS_NS_ID, "image");
          this.url = null;
          this.title = null;
          this.link = null;
          this.width = null;
          this.height = null;
          this.description = null;
        }
        $onChild(child) {
          if (!this.$onChildCheck(child)) {
            return;
          }
          switch (child.$nodeName) {
            case "width":
              this.width = child.$content || DEFAULT_IMG_WIDTH;
              break;
            case "height":
              this.height = child.$content || DEFAULT_IMG_HEIGHT;
              break;
          }
        }
        $finalize() {
          this.$isInvalid = !(this.url && this.title && this.link);
        }
      };
      Width = class extends StringObject {
        constructor() {
          super(RSS_NS_ID, "width");
        }
        $finalize() {
          this.$content = parseInt(this.$content);
          this.$content = isNaN(this.$content) ? null : Math.min(MAX_IMG_WIDTH, Math.max(0, this.$content));
        }
      };
      Height = class extends StringObject {
        constructor() {
          super(RSS_NS_ID, "height");
        }
        $finalize() {
          this.$content = parseInt(this.$content);
          this.$content = isNaN(this.$content) ? null : Math.min(MAX_IMG_HEIGHT, Math.max(0, this.$content));
        }
      };
      TextInput = class extends XMLObject {
        constructor(attributes) {
          super(RSS_NS_ID, "textInput");
          this.title = null;
          this.description = null;
          this.name = null;
          this.link = null;
        }
      };
      Item = class extends XMLObject {
        constructor(attributes) {
          super(RSS_NS_ID, "item");
          this.title = null;
          this.description = null;
          this.link = null;
          this.author = null;
          this.category = new XMLObjectArray();
          this.comments = null;
          this.enclosure = null;
          this.guid = null;
          this.pubDate = null;
          this.source = null;
        }
      };
      Enclosure = class extends XMLObject {
        constructor(attributes) {
          super(RSS_NS_ID, "enclosure");
          this.url = attributes.get("url") || "";
          this.length = attributes.get("length") || "";
          this.type = attributes.get("type") || "";
        }
      };
      Guid = class extends StringObject {
        constructor(attributes) {
          super(RSS_NS_ID, "guid");
          this.isPermaLink = attributes.get("isPermaLink") || "";
        }
      };
      Source2 = class extends StringObject {
        constructor(attributes) {
          super(RSS_NS_ID, "source");
          this.url = attributes.get("url") || "";
        }
      };
      RssNamespace = class {
        static $buildXMLObject(name, attributes) {
          attributes = attributes.get("");
          if (RssNamespace.hasOwnProperty(name)) {
            return RssNamespace[name](attributes);
          }
          if ([
            "title",
            "link",
            "description",
            "name",
            "language",
            "copyright",
            "webMaster",
            "generator",
            "docs",
            "author",
            "comments"
          ].includes(name)) {
            return new StringObject(RSS_NS_ID, name);
          }
          return void 0;
        }
        static rss(attributes) {
          return new Rss(attributes);
        }
        static channel(attributes) {
          return new Channel(attributes);
        }
        static pubDate(attributes) {
          return new PubDate(attributes);
        }
        static lastBuildDate(attributes) {
          return new LastBuildDate(attributes);
        }
        static category(attributes) {
          return new Category2(attributes);
        }
        static cloud(attributes) {
          return new Cloud(attributes);
        }
        static ttl(attributes) {
          return new Ttl(attributes);
        }
        static image(attributes) {
          return new Image(attributes);
        }
        static width(attributes) {
          return new Width(attributes);
        }
        static height(attributes) {
          return new Height(attributes);
        }
        static textInput(attributes) {
          return new TextInput(attributes);
        }
        static item(attributes) {
          return new Item(attributes);
        }
        static enclosure(attributes) {
          return new Enclosure(attributes);
        }
        static guid(attributes) {
          return new Guid(attributes);
        }
        static source(attributes) {
          return new Source2(attributes);
        }
      };
    }
  });

  // src/backend/parsers/xml/xhtml.js
  var XHTML_NS_ID2, XhtmlNamespace;
  var init_xhtml = __esm({
    "src/backend/parsers/xml/xhtml.js"() {
      init_xml_object();
      init_namespaces();
      XHTML_NS_ID2 = NamespaceIds.get("xhtml").id;
      XhtmlNamespace = class {
        static $buildXFAObject(name, attributes) {
          return new XmlNodeObject(XHTML_NS_ID2, name, attributes);
        }
      };
    }
  });

  // src/vendor/xml/basic_xml_parser.js
  function isWhitespace(s, index) {
    const ch = s[index];
    return ch === " " || ch === "\n" || ch === "\r" || ch === "	";
  }
  var XMLParserErrorCode, XMLParserBase;
  var init_basic_xml_parser = __esm({
    "src/vendor/xml/basic_xml_parser.js"() {
      XMLParserErrorCode = {
        NoError: 0,
        EndOfDocument: -1,
        UnterminatedCdat: -2,
        UnterminatedXmlDeclaration: -3,
        UnterminatedDoctypeDeclaration: -4,
        UnterminatedComment: -5,
        MalformedElement: -6,
        OutOfMemory: -7,
        UnterminatedAttributeValue: -8,
        UnterminatedElement: -9,
        ElementNeverBegun: -10
      };
      XMLParserBase = class {
        _resolveEntities(s) {
          return s.replace(/&([^;]+);/g, (all, entity) => {
            if (entity.substring(0, 2) === "#x") {
              return String.fromCodePoint(parseInt(entity.substring(2), 16));
            } else if (entity.substring(0, 1) === "#") {
              return String.fromCodePoint(parseInt(entity.substring(1), 10));
            }
            switch (entity) {
              case "lt":
                return "<";
              case "gt":
                return ">";
              case "amp":
                return "&";
              case "quot":
                return '"';
              case "apos":
                return "'";
            }
            return this.onResolveEntity(entity);
          });
        }
        _parseContent(s, start) {
          const attributes = [];
          let pos = start;
          function skipWs() {
            while (pos < s.length && isWhitespace(s, pos)) {
              ++pos;
            }
          }
          while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
            ++pos;
          }
          const name = s.substring(start, pos);
          skipWs();
          while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
            skipWs();
            let attrName = "", attrValue = "";
            while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
              attrName += s[pos];
              ++pos;
            }
            skipWs();
            if (s[pos] !== "=") {
              return null;
            }
            ++pos;
            skipWs();
            const attrEndChar = s[pos];
            if (attrEndChar !== '"' && attrEndChar !== "'") {
              return null;
            }
            const attrEndIndex = s.indexOf(attrEndChar, ++pos);
            if (attrEndIndex < 0) {
              return null;
            }
            attrValue = s.substring(pos, attrEndIndex);
            attributes.push({
              name: attrName,
              value: this._resolveEntities(attrValue)
            });
            pos = attrEndIndex + 1;
            skipWs();
          }
          return {
            name,
            attributes,
            parsed: pos - start
          };
        }
        _parseProcessingInstruction(s, start) {
          let pos = start;
          function skipWs() {
            while (pos < s.length && isWhitespace(s, pos)) {
              ++pos;
            }
          }
          while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "?" && s[pos] !== "/") {
            ++pos;
          }
          const name = s.substring(start, pos);
          skipWs();
          const attrStart = pos;
          while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
            ++pos;
          }
          const value = s.substring(attrStart, pos);
          return {
            name,
            value,
            parsed: pos - start
          };
        }
        parseXml(s) {
          let i = 0;
          while (i < s.length) {
            const ch = s[i];
            let j = i;
            if (ch === "<") {
              ++j;
              const ch2 = s[j];
              let q;
              switch (ch2) {
                case "/":
                  ++j;
                  q = s.indexOf(">", j);
                  if (q < 0) {
                    this.onError(XMLParserErrorCode.UnterminatedElement);
                    return;
                  }
                  this.onEndElement(s.substring(j, q));
                  j = q + 1;
                  break;
                case "?":
                  ++j;
                  const pi = this._parseProcessingInstruction(s, j);
                  if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
                    this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                    return;
                  }
                  this.onPi(pi.name, pi.value);
                  j += pi.parsed + 2;
                  break;
                case "!":
                  if (s.substring(j + 1, j + 3) === "--") {
                    q = s.indexOf("-->", j + 3);
                    if (q < 0) {
                      this.onError(XMLParserErrorCode.UnterminatedComment);
                      return;
                    }
                    this.onComment(s.substring(j + 3, q));
                    j = q + 3;
                  } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                    q = s.indexOf("]]>", j + 8);
                    if (q < 0) {
                      this.onError(XMLParserErrorCode.UnterminatedCdat);
                      return;
                    }
                    this.onCdata(s.substring(j + 8, q));
                    j = q + 3;
                  } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                    const q2 = s.indexOf("[", j + 8);
                    let complexDoctype = false;
                    q = s.indexOf(">", j + 8);
                    if (q < 0) {
                      this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                      return;
                    }
                    if (q2 > 0 && q > q2) {
                      q = s.indexOf("]>", j + 8);
                      if (q < 0) {
                        this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                        return;
                      }
                      complexDoctype = true;
                    }
                    const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                    this.onDoctype(doctypeContent);
                    j = q + (complexDoctype ? 2 : 1);
                  } else {
                    this.onError(XMLParserErrorCode.MalformedElement);
                    return;
                  }
                  break;
                default:
                  const content = this._parseContent(s, j);
                  if (content === null) {
                    this.onError(XMLParserErrorCode.MalformedElement);
                    return;
                  }
                  let isClosed = false;
                  if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                    isClosed = true;
                  } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                    this.onError(XMLParserErrorCode.UnterminatedElement);
                    return;
                  }
                  this.onBeginElement(content.name, content.attributes, isClosed);
                  j += content.parsed + (isClosed ? 2 : 1);
                  break;
              }
            } else {
              while (j < s.length && s[j] !== "<") {
                j++;
              }
              const text = s.substring(i, j);
              this.onText(this._resolveEntities(text));
            }
            i = j;
          }
        }
        onResolveEntity(name) {
          return `&${name};`;
        }
        onPi(name, value) {
        }
        onComment(text) {
        }
        onCdata(text) {
        }
        onDoctype(doctypeContent) {
        }
        onText(text) {
        }
        onBeginElement(name, attributes, isEmpty) {
        }
        onEndElement(name) {
        }
        onError(code) {
        }
      };
    }
  });

  // src/backend/parsers/xml/xml_parser.js
  var XMLParser;
  var init_xml_parser = __esm({
    "src/backend/parsers/xml/xml_parser.js"() {
      init_basic_xml_parser();
      XMLParser = class extends XMLParserBase {
        #builder;
        #stack;
        #current;
        #errorCode;
        constructor(builder) {
          super();
          this.#builder = builder;
          this.#stack = [];
          this.#current = this.#builder.buildRoot();
          this.#errorCode = XMLParserErrorCode.NoError;
        }
        parse(data) {
          this.parseXml(data);
          if (this.#errorCode !== XMLParserErrorCode.NoError) {
            return null;
          }
          this.#current.$finalize();
          return this.#current.$dump();
        }
        onText(text) {
          this.#current.$onText(text.trim());
        }
        onCdata(text) {
          this.onText(text);
        }
        #getNameAndPrefix(name) {
          const i = name.indexOf(":");
          return [name.substring(i + 1), name.substring(0, i)];
        }
        #mkAttributes(attributes) {
          const attributesMap = new Map();
          attributesMap.set("", new Map());
          for (const { name, value } of attributes) {
            const [attribute, prefix] = this.#getNameAndPrefix(name);
            let attrs = attributesMap.get(prefix);
            if (!attrs) {
              attrs = new Map();
              attributesMap.set(prefix, attrs);
            }
            attrs.set(attribute, value);
          }
          return attributesMap;
        }
        onBeginElement(tagName, attributes, isEmpty) {
          const attributesMap = this.#mkAttributes(attributes);
          const [name, nsPrefix] = this.#getNameAndPrefix(tagName);
          const node = this.#builder.build({
            nsPrefix,
            name,
            attributes: attributesMap
          });
          if (isEmpty) {
            node.$finalize();
            this.#current.$onChild(node);
            node.$clean(this.#builder);
            return;
          }
          this.#stack.push(this.#current);
          this.#current = node;
        }
        onEndElement(name) {
          const node = this.#current;
          node.$finalize();
          this.#current = this.#stack.pop();
          this.#current.$onChild(node);
          node.$clean(this.#builder);
        }
        onError(code) {
          this.#errorCode = code;
        }
      };
    }
  });

  // src/backend/parsers/xml/feed_parser.js
  function parseFeed(str) {
    const nsSetUp = {
      atom: AtomNamespace,
      xhtml: XhtmlNamespace
    };
    const nodeBuilder = new NodeBuilder(nsSetUp, new Root(), RssNamespace);
    const parser2 = new XMLParser(nodeBuilder);
    return parser2.parse(str);
  }
  var Root;
  var init_feed_parser = __esm({
    "src/backend/parsers/xml/feed_parser.js"() {
      init_atom();
      init_namespaces();
      init_node_builder();
      init_rss();
      init_xhtml();
      init_xml_object();
      init_xml_parser();
      Root = class extends XMLObject {
        constructor() {
          super(-1, "root");
        }
        $onChild(child) {
          const name = child.$nodeName;
          switch (name) {
            case "feed":
            case "entry":
              if (child.$namespaceId === NamespaceIds.get("atom").id && !this[name]) {
                this[name] = child;
              }
              break;
            case "rss":
              if (child.$namespaceId === NamespaceIds.get("local").id) {
                this.rss = child;
              }
              break;
          }
        }
      };
    }
  });

  // src/backend/accounts/feed/validator.js
  var validator_exports2 = {};
  __export(validator_exports2, {
    default: () => validateFeed
  });
  async function validateFeed({
    userDetails,
    credentials,
    connInfoFields
  }) {
    const { feedUrl } = connInfoFields;
    try {
      const feedReq = new Request(feedUrl, {});
      const feedResp = await fetch(feedReq);
      if (feedResp.status >= 400) {
        return {
          error: "unknown",
          errorDetails: {
            status: feedResp.status,
            feedUrl
          }
        };
      }
      const feedText = await feedResp.text();
      const parsed = parseFeed(feedText);
      if (!parsed) {
        throw new Error("Cannot parse the feed stream");
      }
    } catch (ex) {
      return {
        error: "unknown",
        errorDetails: {
          message: ex.toString()
        }
      };
    }
    return {
      engineFields: {
        engine: "feed",
        engineData: {},
        receiveProtoConn: null
      }
    };
  }
  var init_validator2 = __esm({
    "src/backend/accounts/feed/validator.js"() {
      init_feed_parser();
    }
  });

  // src/vendor/ical.js
  var require_ical = __commonJS({
    "src/vendor/ical.js"(exports, module) {
      if (typeof module === "object") {
        ICAL = module.exports;
      } else if (typeof ICAL !== "object") {
        exports.ICAL = {};
      }
      ICAL.foldLength = 75;
      ICAL.newLineChar = "\r\n";
      ICAL.helpers = {
        updateTimezones: function(vcal) {
          var allsubs, properties, vtimezones, reqTzid, i, tzid;
          if (!vcal || vcal.name !== "vcalendar") {
            return vcal;
          }
          allsubs = vcal.getAllSubcomponents();
          properties = [];
          vtimezones = {};
          for (i = 0; i < allsubs.length; i++) {
            if (allsubs[i].name === "vtimezone") {
              tzid = allsubs[i].getFirstProperty("tzid").getFirstValue();
              vtimezones[tzid] = allsubs[i];
            } else {
              properties = properties.concat(allsubs[i].getAllProperties());
            }
          }
          reqTzid = {};
          for (i = 0; i < properties.length; i++) {
            if (tzid = properties[i].getParameter("tzid")) {
              reqTzid[tzid] = true;
            }
          }
          for (i in vtimezones) {
            if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {
              vcal.removeSubcomponent(vtimezones[i]);
            }
          }
          for (i in reqTzid) {
            if (reqTzid.hasOwnProperty(i) && !vtimezones[i] && ICAL.TimezoneService.has(i)) {
              vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);
            }
          }
          return vcal;
        },
        isStrictlyNaN: function(number) {
          return typeof number === "number" && isNaN(number);
        },
        strictParseInt: function(string) {
          var result = parseInt(string, 10);
          if (ICAL.helpers.isStrictlyNaN(result)) {
            throw new Error('Could not extract integer from "' + string + '"');
          }
          return result;
        },
        formatClassType: function formatClassType(data, type) {
          if (typeof data === "undefined") {
            return void 0;
          }
          if (data instanceof type) {
            return data;
          }
          return new type(data);
        },
        unescapedIndexOf: function(buffer, search, pos) {
          while ((pos = buffer.indexOf(search, pos)) !== -1) {
            if (pos > 0 && buffer[pos - 1] === "\\") {
              pos += 1;
            } else {
              return pos;
            }
          }
          return -1;
        },
        binsearchInsert: function(list, seekVal, cmpfunc) {
          if (!list.length)
            return 0;
          var low = 0, high = list.length - 1, mid, cmpval;
          while (low <= high) {
            mid = low + Math.floor((high - low) / 2);
            cmpval = cmpfunc(seekVal, list[mid]);
            if (cmpval < 0)
              high = mid - 1;
            else if (cmpval > 0)
              low = mid + 1;
            else
              break;
          }
          if (cmpval < 0)
            return mid;
          else if (cmpval > 0)
            return mid + 1;
          else
            return mid;
        },
        dumpn: function() {
          if (!ICAL.debug) {
            return;
          }
          if (typeof console !== "undefined" && "log" in console) {
            ICAL.helpers.dumpn = function consoleDumpn(input) {
              console.log(input);
            };
          } else {
            ICAL.helpers.dumpn = function geckoDumpn(input) {
              dump(input + "\n");
            };
          }
          ICAL.helpers.dumpn(arguments[0]);
        },
        clone: function(aSrc, aDeep) {
          if (!aSrc || typeof aSrc != "object") {
            return aSrc;
          } else if (aSrc instanceof Date) {
            return new Date(aSrc.getTime());
          } else if ("clone" in aSrc) {
            return aSrc.clone();
          } else if (Array.isArray(aSrc)) {
            var arr = [];
            for (var i = 0; i < aSrc.length; i++) {
              arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);
            }
            return arr;
          } else {
            var obj = {};
            for (var name in aSrc) {
              if (Object.prototype.hasOwnProperty.call(aSrc, name)) {
                if (aDeep) {
                  obj[name] = ICAL.helpers.clone(aSrc[name], true);
                } else {
                  obj[name] = aSrc[name];
                }
              }
            }
            return obj;
          }
        },
        foldline: function foldline(aLine) {
          var result = "";
          var line = aLine || "";
          while (line.length) {
            result += ICAL.newLineChar + " " + line.substr(0, ICAL.foldLength);
            line = line.substr(ICAL.foldLength);
          }
          return result.substr(ICAL.newLineChar.length + 1);
        },
        pad2: function pad(data) {
          if (typeof data !== "string") {
            if (typeof data === "number") {
              data = parseInt(data);
            }
            data = String(data);
          }
          var len = data.length;
          switch (len) {
            case 0:
              return "00";
            case 1:
              return "0" + data;
            default:
              return data;
          }
        },
        trunc: function trunc(number) {
          return number < 0 ? Math.ceil(number) : Math.floor(number);
        },
        inherits: function(base, child, extra) {
          function F() {
          }
          F.prototype = base.prototype;
          child.prototype = new F();
          if (extra) {
            ICAL.helpers.extend(extra, child.prototype);
          }
        },
        extend: function(source, target) {
          for (var key in source) {
            var descr = Object.getOwnPropertyDescriptor(source, key);
            if (descr && !Object.getOwnPropertyDescriptor(target, key)) {
              Object.defineProperty(target, key, descr);
            }
          }
          return target;
        }
      };
      ICAL.design = function() {
        "use strict";
        var FROM_ICAL_NEWLINE = /\\\\|\\;|\\,|\\[Nn]/g;
        var TO_ICAL_NEWLINE = /\\|;|,|\n/g;
        var FROM_VCARD_NEWLINE = /\\\\|\\,|\\[Nn]/g;
        var TO_VCARD_NEWLINE = /\\|,|\n/g;
        function createTextType(fromNewline, toNewline) {
          var result = {
            matches: /.*/,
            fromICAL: function(aValue, structuredEscape) {
              return replaceNewline(aValue, fromNewline, structuredEscape);
            },
            toICAL: function(aValue, structuredEscape) {
              var regEx = toNewline;
              if (structuredEscape)
                regEx = new RegExp(regEx.source + "|" + structuredEscape);
              return aValue.replace(regEx, function(str) {
                switch (str) {
                  case "\\":
                    return "\\\\";
                  case ";":
                    return "\\;";
                  case ",":
                    return "\\,";
                  case "\n":
                    return "\\n";
                  default:
                    return str;
                }
              });
            }
          };
          return result;
        }
        var DEFAULT_TYPE_TEXT = { defaultType: "text" };
        var DEFAULT_TYPE_TEXT_MULTI = { defaultType: "text", multiValue: "," };
        var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: "text", structuredValue: ";" };
        var DEFAULT_TYPE_INTEGER = { defaultType: "integer" };
        var DEFAULT_TYPE_DATETIME_DATE = { defaultType: "date-time", allowedTypes: ["date-time", "date"] };
        var DEFAULT_TYPE_DATETIME = { defaultType: "date-time" };
        var DEFAULT_TYPE_URI = { defaultType: "uri" };
        var DEFAULT_TYPE_UTCOFFSET = { defaultType: "utc-offset" };
        var DEFAULT_TYPE_RECUR = { defaultType: "recur" };
        var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: "date-and-or-time", allowedTypes: ["date-time", "date", "text"] };
        function replaceNewlineReplace(string) {
          switch (string) {
            case "\\\\":
              return "\\";
            case "\\;":
              return ";";
            case "\\,":
              return ",";
            case "\\n":
            case "\\N":
              return "\n";
            default:
              return string;
          }
        }
        function replaceNewline(value, newline, structuredEscape) {
          if (value.indexOf("\\") === -1) {
            return value;
          }
          if (structuredEscape)
            newline = new RegExp(newline.source + "|\\\\" + structuredEscape);
          return value.replace(newline, replaceNewlineReplace);
        }
        var commonProperties = {
          "categories": DEFAULT_TYPE_TEXT_MULTI,
          "url": DEFAULT_TYPE_URI,
          "version": DEFAULT_TYPE_TEXT,
          "uid": DEFAULT_TYPE_TEXT
        };
        var commonValues = {
          "boolean": {
            values: ["TRUE", "FALSE"],
            fromICAL: function(aValue) {
              switch (aValue) {
                case "TRUE":
                  return true;
                case "FALSE":
                  return false;
                default:
                  return false;
              }
            },
            toICAL: function(aValue) {
              if (aValue) {
                return "TRUE";
              }
              return "FALSE";
            }
          },
          float: {
            matches: /^[+-]?\d+\.\d+$/,
            fromICAL: function(aValue) {
              var parsed = parseFloat(aValue);
              if (ICAL.helpers.isStrictlyNaN(parsed)) {
                return 0;
              }
              return parsed;
            },
            toICAL: function(aValue) {
              return String(aValue);
            }
          },
          integer: {
            fromICAL: function(aValue) {
              var parsed = parseInt(aValue);
              if (ICAL.helpers.isStrictlyNaN(parsed)) {
                return 0;
              }
              return parsed;
            },
            toICAL: function(aValue) {
              return String(aValue);
            }
          },
          "utc-offset": {
            toICAL: function(aValue) {
              if (aValue.length < 7) {
                return aValue.substr(0, 3) + aValue.substr(4, 2);
              } else {
                return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);
              }
            },
            fromICAL: function(aValue) {
              if (aValue.length < 6) {
                return aValue.substr(0, 3) + ":" + aValue.substr(3, 2);
              } else {
                return aValue.substr(0, 3) + ":" + aValue.substr(3, 2) + ":" + aValue.substr(5, 2);
              }
            },
            decorate: function(aValue) {
              return ICAL.UtcOffset.fromString(aValue);
            },
            undecorate: function(aValue) {
              return aValue.toString();
            }
          }
        };
        var icalParams = {
          "cutype": {
            values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"],
            allowXName: true,
            allowIanaToken: true
          },
          "delegated-from": {
            valueType: "cal-address",
            multiValue: ",",
            multiValueSeparateDQuote: true
          },
          "delegated-to": {
            valueType: "cal-address",
            multiValue: ",",
            multiValueSeparateDQuote: true
          },
          "encoding": {
            values: ["8BIT", "BASE64"]
          },
          "fbtype": {
            values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"],
            allowXName: true,
            allowIanaToken: true
          },
          "member": {
            valueType: "cal-address",
            multiValue: ",",
            multiValueSeparateDQuote: true
          },
          "partstat": {
            values: [
              "NEEDS-ACTION",
              "ACCEPTED",
              "DECLINED",
              "TENTATIVE",
              "DELEGATED",
              "COMPLETED",
              "IN-PROCESS"
            ],
            allowXName: true,
            allowIanaToken: true
          },
          "range": {
            values: ["THISANDFUTURE"]
          },
          "related": {
            values: ["START", "END"]
          },
          "reltype": {
            values: ["PARENT", "CHILD", "SIBLING"],
            allowXName: true,
            allowIanaToken: true
          },
          "role": {
            values: [
              "REQ-PARTICIPANT",
              "CHAIR",
              "OPT-PARTICIPANT",
              "NON-PARTICIPANT"
            ],
            allowXName: true,
            allowIanaToken: true
          },
          "rsvp": {
            values: ["TRUE", "FALSE"]
          },
          "sent-by": {
            valueType: "cal-address"
          },
          "tzid": {
            matches: /^\//
          },
          "value": {
            values: [
              "binary",
              "boolean",
              "cal-address",
              "date",
              "date-time",
              "duration",
              "float",
              "integer",
              "period",
              "recur",
              "text",
              "time",
              "uri",
              "utc-offset"
            ],
            allowXName: true,
            allowIanaToken: true
          }
        };
        var icalValues = ICAL.helpers.extend(commonValues, {
          text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),
          uri: {},
          "binary": {
            decorate: function(aString) {
              return ICAL.Binary.fromString(aString);
            },
            undecorate: function(aBinary) {
              return aBinary.toString();
            }
          },
          "cal-address": {},
          "date": {
            decorate: function(aValue, aProp) {
              if (design.strict) {
                return ICAL.Time.fromDateString(aValue, aProp);
              } else {
                return ICAL.Time.fromString(aValue, aProp);
              }
            },
            undecorate: function(aValue) {
              return aValue.toString();
            },
            fromICAL: function(aValue) {
              if (!design.strict && aValue.length >= 15) {
                return icalValues["date-time"].fromICAL(aValue);
              } else {
                return aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2);
              }
            },
            toICAL: function(aValue) {
              var len = aValue.length;
              if (len == 10) {
                return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);
              } else if (len >= 19) {
                return icalValues["date-time"].toICAL(aValue);
              } else {
                return aValue;
              }
            }
          },
          "date-time": {
            fromICAL: function(aValue) {
              if (!design.strict && aValue.length == 8) {
                return icalValues.date.fromICAL(aValue);
              } else {
                var result = aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2) + "T" + aValue.substr(9, 2) + ":" + aValue.substr(11, 2) + ":" + aValue.substr(13, 2);
                if (aValue[15] && aValue[15] === "Z") {
                  result += "Z";
                }
                return result;
              }
            },
            toICAL: function(aValue) {
              var len = aValue.length;
              if (len == 10 && !design.strict) {
                return icalValues.date.toICAL(aValue);
              } else if (len >= 19) {
                var result = aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 5) + aValue.substr(14, 2) + aValue.substr(17, 2);
                if (aValue[19] && aValue[19] === "Z") {
                  result += "Z";
                }
                return result;
              } else {
                return aValue;
              }
            },
            decorate: function(aValue, aProp) {
              if (design.strict) {
                return ICAL.Time.fromDateTimeString(aValue, aProp);
              } else {
                return ICAL.Time.fromString(aValue, aProp);
              }
            },
            undecorate: function(aValue) {
              return aValue.toString();
            }
          },
          duration: {
            decorate: function(aValue) {
              return ICAL.Duration.fromString(aValue);
            },
            undecorate: function(aValue) {
              return aValue.toString();
            }
          },
          period: {
            fromICAL: function(string) {
              var parts = string.split("/");
              parts[0] = icalValues["date-time"].fromICAL(parts[0]);
              if (!ICAL.Duration.isValueString(parts[1])) {
                parts[1] = icalValues["date-time"].fromICAL(parts[1]);
              }
              return parts;
            },
            toICAL: function(parts) {
              if (!design.strict && parts[0].length == 10) {
                parts[0] = icalValues.date.toICAL(parts[0]);
              } else {
                parts[0] = icalValues["date-time"].toICAL(parts[0]);
              }
              if (!ICAL.Duration.isValueString(parts[1])) {
                if (!design.strict && parts[1].length == 10) {
                  parts[1] = icalValues.date.toICAL(parts[1]);
                } else {
                  parts[1] = icalValues["date-time"].toICAL(parts[1]);
                }
              }
              return parts.join("/");
            },
            decorate: function(aValue, aProp) {
              return ICAL.Period.fromJSON(aValue, aProp, !design.strict);
            },
            undecorate: function(aValue) {
              return aValue.toJSON();
            }
          },
          recur: {
            fromICAL: function(string) {
              return ICAL.Recur._stringToData(string, true);
            },
            toICAL: function(data) {
              var str = "";
              for (var k in data) {
                if (!Object.prototype.hasOwnProperty.call(data, k)) {
                  continue;
                }
                var val = data[k];
                if (k == "until") {
                  if (val.length > 10) {
                    val = icalValues["date-time"].toICAL(val);
                  } else {
                    val = icalValues.date.toICAL(val);
                  }
                } else if (k == "wkst") {
                  if (typeof val === "number") {
                    val = ICAL.Recur.numericDayToIcalDay(val);
                  }
                } else if (Array.isArray(val)) {
                  val = val.join(",");
                }
                str += k.toUpperCase() + "=" + val + ";";
              }
              return str.substr(0, str.length - 1);
            },
            decorate: function decorate(aValue) {
              return ICAL.Recur.fromData(aValue);
            },
            undecorate: function(aRecur) {
              return aRecur.toJSON();
            }
          },
          time: {
            fromICAL: function(aValue) {
              if (aValue.length < 6) {
                return aValue;
              }
              var result = aValue.substr(0, 2) + ":" + aValue.substr(2, 2) + ":" + aValue.substr(4, 2);
              if (aValue[6] === "Z") {
                result += "Z";
              }
              return result;
            },
            toICAL: function(aValue) {
              if (aValue.length < 8) {
                return aValue;
              }
              var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);
              if (aValue[8] === "Z") {
                result += "Z";
              }
              return result;
            }
          }
        });
        var icalProperties = ICAL.helpers.extend(commonProperties, {
          "action": DEFAULT_TYPE_TEXT,
          "attach": { defaultType: "uri" },
          "attendee": { defaultType: "cal-address" },
          "calscale": DEFAULT_TYPE_TEXT,
          "class": DEFAULT_TYPE_TEXT,
          "comment": DEFAULT_TYPE_TEXT,
          "completed": DEFAULT_TYPE_DATETIME,
          "contact": DEFAULT_TYPE_TEXT,
          "created": DEFAULT_TYPE_DATETIME,
          "description": DEFAULT_TYPE_TEXT,
          "dtend": DEFAULT_TYPE_DATETIME_DATE,
          "dtstamp": DEFAULT_TYPE_DATETIME,
          "dtstart": DEFAULT_TYPE_DATETIME_DATE,
          "due": DEFAULT_TYPE_DATETIME_DATE,
          "duration": { defaultType: "duration" },
          "exdate": {
            defaultType: "date-time",
            allowedTypes: ["date-time", "date"],
            multiValue: ","
          },
          "exrule": DEFAULT_TYPE_RECUR,
          "freebusy": { defaultType: "period", multiValue: "," },
          "geo": { defaultType: "float", structuredValue: ";" },
          "last-modified": DEFAULT_TYPE_DATETIME,
          "location": DEFAULT_TYPE_TEXT,
          "method": DEFAULT_TYPE_TEXT,
          "organizer": { defaultType: "cal-address" },
          "percent-complete": DEFAULT_TYPE_INTEGER,
          "priority": DEFAULT_TYPE_INTEGER,
          "prodid": DEFAULT_TYPE_TEXT,
          "related-to": DEFAULT_TYPE_TEXT,
          "repeat": DEFAULT_TYPE_INTEGER,
          "rdate": {
            defaultType: "date-time",
            allowedTypes: ["date-time", "date", "period"],
            multiValue: ",",
            detectType: function(string) {
              if (string.indexOf("/") !== -1) {
                return "period";
              }
              return string.indexOf("T") === -1 ? "date" : "date-time";
            }
          },
          "recurrence-id": DEFAULT_TYPE_DATETIME_DATE,
          "resources": DEFAULT_TYPE_TEXT_MULTI,
          "request-status": DEFAULT_TYPE_TEXT_STRUCTURED,
          "rrule": DEFAULT_TYPE_RECUR,
          "sequence": DEFAULT_TYPE_INTEGER,
          "status": DEFAULT_TYPE_TEXT,
          "summary": DEFAULT_TYPE_TEXT,
          "transp": DEFAULT_TYPE_TEXT,
          "trigger": { defaultType: "duration", allowedTypes: ["duration", "date-time"] },
          "tzoffsetfrom": DEFAULT_TYPE_UTCOFFSET,
          "tzoffsetto": DEFAULT_TYPE_UTCOFFSET,
          "tzurl": DEFAULT_TYPE_URI,
          "tzid": DEFAULT_TYPE_TEXT,
          "tzname": DEFAULT_TYPE_TEXT
        });
        var vcardValues = ICAL.helpers.extend(commonValues, {
          text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
          uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
          date: {
            decorate: function(aValue) {
              return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date");
            },
            undecorate: function(aValue) {
              return aValue.toString();
            },
            fromICAL: function(aValue) {
              if (aValue.length == 8) {
                return icalValues.date.fromICAL(aValue);
              } else if (aValue[0] == "-" && aValue.length == 6) {
                return aValue.substr(0, 4) + "-" + aValue.substr(4);
              } else {
                return aValue;
              }
            },
            toICAL: function(aValue) {
              if (aValue.length == 10) {
                return icalValues.date.toICAL(aValue);
              } else if (aValue[0] == "-" && aValue.length == 7) {
                return aValue.substr(0, 4) + aValue.substr(5);
              } else {
                return aValue;
              }
            }
          },
          time: {
            decorate: function(aValue) {
              return ICAL.VCardTime.fromDateAndOrTimeString("T" + aValue, "time");
            },
            undecorate: function(aValue) {
              return aValue.toString();
            },
            fromICAL: function(aValue) {
              var splitzone = vcardValues.time._splitZone(aValue, true);
              var zone = splitzone[0], value = splitzone[1];
              if (value.length == 6) {
                value = value.substr(0, 2) + ":" + value.substr(2, 2) + ":" + value.substr(4, 2);
              } else if (value.length == 4 && value[0] != "-") {
                value = value.substr(0, 2) + ":" + value.substr(2, 2);
              } else if (value.length == 5) {
                value = value.substr(0, 3) + ":" + value.substr(3, 2);
              }
              if (zone.length == 5 && (zone[0] == "-" || zone[0] == "+")) {
                zone = zone.substr(0, 3) + ":" + zone.substr(3);
              }
              return value + zone;
            },
            toICAL: function(aValue) {
              var splitzone = vcardValues.time._splitZone(aValue);
              var zone = splitzone[0], value = splitzone[1];
              if (value.length == 8) {
                value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);
              } else if (value.length == 5 && value[0] != "-") {
                value = value.substr(0, 2) + value.substr(3, 2);
              } else if (value.length == 6) {
                value = value.substr(0, 3) + value.substr(4, 2);
              }
              if (zone.length == 6 && (zone[0] == "-" || zone[0] == "+")) {
                zone = zone.substr(0, 3) + zone.substr(4);
              }
              return value + zone;
            },
            _splitZone: function(aValue, isFromIcal) {
              var lastChar = aValue.length - 1;
              var signChar = aValue.length - (isFromIcal ? 5 : 6);
              var sign = aValue[signChar];
              var zone, value;
              if (aValue[lastChar] == "Z") {
                zone = aValue[lastChar];
                value = aValue.substr(0, lastChar);
              } else if (aValue.length > 6 && (sign == "-" || sign == "+")) {
                zone = aValue.substr(signChar);
                value = aValue.substr(0, signChar);
              } else {
                zone = "";
                value = aValue;
              }
              return [zone, value];
            }
          },
          "date-time": {
            decorate: function(aValue) {
              return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date-time");
            },
            undecorate: function(aValue) {
              return aValue.toString();
            },
            fromICAL: function(aValue) {
              return vcardValues["date-and-or-time"].fromICAL(aValue);
            },
            toICAL: function(aValue) {
              return vcardValues["date-and-or-time"].toICAL(aValue);
            }
          },
          "date-and-or-time": {
            decorate: function(aValue) {
              return ICAL.VCardTime.fromDateAndOrTimeString(aValue, "date-and-or-time");
            },
            undecorate: function(aValue) {
              return aValue.toString();
            },
            fromICAL: function(aValue) {
              var parts = aValue.split("T");
              return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : "") + (parts[1] ? "T" + vcardValues.time.fromICAL(parts[1]) : "");
            },
            toICAL: function(aValue) {
              var parts = aValue.split("T");
              return vcardValues.date.toICAL(parts[0]) + (parts[1] ? "T" + vcardValues.time.toICAL(parts[1]) : "");
            }
          },
          timestamp: icalValues["date-time"],
          "language-tag": {
            matches: /^[a-zA-Z0-9-]+$/
          }
        });
        var vcardParams = {
          "type": {
            valueType: "text",
            multiValue: ","
          },
          "value": {
            values: [
              "text",
              "uri",
              "date",
              "time",
              "date-time",
              "date-and-or-time",
              "timestamp",
              "boolean",
              "integer",
              "float",
              "utc-offset",
              "language-tag"
            ],
            allowXName: true,
            allowIanaToken: true
          }
        };
        var vcardProperties = ICAL.helpers.extend(commonProperties, {
          "adr": { defaultType: "text", structuredValue: ";", multiValue: "," },
          "anniversary": DEFAULT_TYPE_DATE_ANDOR_TIME,
          "bday": DEFAULT_TYPE_DATE_ANDOR_TIME,
          "caladruri": DEFAULT_TYPE_URI,
          "caluri": DEFAULT_TYPE_URI,
          "clientpidmap": DEFAULT_TYPE_TEXT_STRUCTURED,
          "email": DEFAULT_TYPE_TEXT,
          "fburl": DEFAULT_TYPE_URI,
          "fn": DEFAULT_TYPE_TEXT,
          "gender": DEFAULT_TYPE_TEXT_STRUCTURED,
          "geo": DEFAULT_TYPE_URI,
          "impp": DEFAULT_TYPE_URI,
          "key": DEFAULT_TYPE_URI,
          "kind": DEFAULT_TYPE_TEXT,
          "lang": { defaultType: "language-tag" },
          "logo": DEFAULT_TYPE_URI,
          "member": DEFAULT_TYPE_URI,
          "n": { defaultType: "text", structuredValue: ";", multiValue: "," },
          "nickname": DEFAULT_TYPE_TEXT_MULTI,
          "note": DEFAULT_TYPE_TEXT,
          "org": { defaultType: "text", structuredValue: ";" },
          "photo": DEFAULT_TYPE_URI,
          "related": DEFAULT_TYPE_URI,
          "rev": { defaultType: "timestamp" },
          "role": DEFAULT_TYPE_TEXT,
          "sound": DEFAULT_TYPE_URI,
          "source": DEFAULT_TYPE_URI,
          "tel": { defaultType: "uri", allowedTypes: ["uri", "text"] },
          "title": DEFAULT_TYPE_TEXT,
          "tz": { defaultType: "text", allowedTypes: ["text", "utc-offset", "uri"] },
          "xml": DEFAULT_TYPE_TEXT
        });
        var vcard3Values = ICAL.helpers.extend(commonValues, {
          binary: icalValues.binary,
          date: vcardValues.date,
          "date-time": vcardValues["date-time"],
          "phone-number": {},
          uri: icalValues.uri,
          text: icalValues.text,
          time: icalValues.time,
          vcard: icalValues.text,
          "utc-offset": {
            toICAL: function(aValue) {
              return aValue.substr(0, 7);
            },
            fromICAL: function(aValue) {
              return aValue.substr(0, 7);
            },
            decorate: function(aValue) {
              return ICAL.UtcOffset.fromString(aValue);
            },
            undecorate: function(aValue) {
              return aValue.toString();
            }
          }
        });
        var vcard3Params = {
          "type": {
            valueType: "text",
            multiValue: ","
          },
          "value": {
            values: [
              "text",
              "uri",
              "date",
              "date-time",
              "phone-number",
              "time",
              "boolean",
              "integer",
              "float",
              "utc-offset",
              "vcard",
              "binary"
            ],
            allowXName: true,
            allowIanaToken: true
          }
        };
        var vcard3Properties = ICAL.helpers.extend(commonProperties, {
          fn: DEFAULT_TYPE_TEXT,
          n: { defaultType: "text", structuredValue: ";", multiValue: "," },
          nickname: DEFAULT_TYPE_TEXT_MULTI,
          photo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
          bday: {
            defaultType: "date-time",
            allowedTypes: ["date-time", "date"],
            detectType: function(string) {
              return string.indexOf("T") === -1 ? "date" : "date-time";
            }
          },
          adr: { defaultType: "text", structuredValue: ";", multiValue: "," },
          label: DEFAULT_TYPE_TEXT,
          tel: { defaultType: "phone-number" },
          email: DEFAULT_TYPE_TEXT,
          mailer: DEFAULT_TYPE_TEXT,
          tz: { defaultType: "utc-offset", allowedTypes: ["utc-offset", "text"] },
          geo: { defaultType: "float", structuredValue: ";" },
          title: DEFAULT_TYPE_TEXT,
          role: DEFAULT_TYPE_TEXT,
          logo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
          agent: { defaultType: "vcard", allowedTypes: ["vcard", "text", "uri"] },
          org: DEFAULT_TYPE_TEXT_STRUCTURED,
          note: DEFAULT_TYPE_TEXT_MULTI,
          prodid: DEFAULT_TYPE_TEXT,
          rev: {
            defaultType: "date-time",
            allowedTypes: ["date-time", "date"],
            detectType: function(string) {
              return string.indexOf("T") === -1 ? "date" : "date-time";
            }
          },
          "sort-string": DEFAULT_TYPE_TEXT,
          sound: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
          class: DEFAULT_TYPE_TEXT,
          key: { defaultType: "binary", allowedTypes: ["binary", "text"] }
        });
        var icalSet = {
          value: icalValues,
          param: icalParams,
          property: icalProperties
        };
        var vcardSet = {
          value: vcardValues,
          param: vcardParams,
          property: vcardProperties
        };
        var vcard3Set = {
          value: vcard3Values,
          param: vcard3Params,
          property: vcard3Properties
        };
        var design = {
          strict: true,
          defaultSet: icalSet,
          defaultType: "unknown",
          components: {
            vcard: vcardSet,
            vcard3: vcard3Set,
            vevent: icalSet,
            vtodo: icalSet,
            vjournal: icalSet,
            valarm: icalSet,
            vtimezone: icalSet,
            daylight: icalSet,
            standard: icalSet
          },
          icalendar: icalSet,
          vcard: vcardSet,
          vcard3: vcard3Set,
          getDesignSet: function(componentName) {
            var isInDesign = componentName && componentName in design.components;
            return isInDesign ? design.components[componentName] : design.defaultSet;
          }
        };
        return design;
      }();
      ICAL.stringify = function() {
        "use strict";
        var LINE_ENDING = "\r\n";
        var DEFAULT_VALUE_TYPE = "unknown";
        var design = ICAL.design;
        var helpers = ICAL.helpers;
        function stringify(jCal) {
          if (typeof jCal[0] == "string") {
            jCal = [jCal];
          }
          var i = 0;
          var len = jCal.length;
          var result = "";
          for (; i < len; i++) {
            result += stringify.component(jCal[i]) + LINE_ENDING;
          }
          return result;
        }
        stringify.component = function(component, designSet) {
          var name = component[0].toUpperCase();
          var result = "BEGIN:" + name + LINE_ENDING;
          var props = component[1];
          var propIdx = 0;
          var propLen = props.length;
          var designSetName = component[0];
          if (designSetName === "vcard" && component[1].length > 0 && !(component[1][0][0] === "version" && component[1][0][3] === "4.0")) {
            designSetName = "vcard3";
          }
          designSet = designSet || design.getDesignSet(designSetName);
          for (; propIdx < propLen; propIdx++) {
            result += stringify.property(props[propIdx], designSet) + LINE_ENDING;
          }
          var comps = component[2] || [];
          var compIdx = 0;
          var compLen = comps.length;
          for (; compIdx < compLen; compIdx++) {
            result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;
          }
          result += "END:" + name;
          return result;
        };
        stringify.property = function(property, designSet, noFold) {
          var name = property[0].toUpperCase();
          var jsName = property[0];
          var params = property[1];
          var line = name;
          var paramName;
          for (paramName in params) {
            var value = params[paramName];
            if (params.hasOwnProperty(paramName)) {
              var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;
              if (multiValue && Array.isArray(value)) {
                if (designSet.param[paramName].multiValueSeparateDQuote) {
                  multiValue = '"' + multiValue + '"';
                }
                value = value.map(stringify._rfc6868Unescape);
                value = stringify.multiValue(value, multiValue, "unknown", null, designSet);
              } else {
                value = stringify._rfc6868Unescape(value);
              }
              line += ";" + paramName.toUpperCase();
              line += "=" + stringify.propertyValue(value);
            }
          }
          if (property.length === 3) {
            return line + ":";
          }
          var valueType = property[2];
          if (!designSet) {
            designSet = design.defaultSet;
          }
          var propDetails;
          var multiValue = false;
          var structuredValue = false;
          var isDefault = false;
          if (jsName in designSet.property) {
            propDetails = designSet.property[jsName];
            if ("multiValue" in propDetails) {
              multiValue = propDetails.multiValue;
            }
            if ("structuredValue" in propDetails && Array.isArray(property[3])) {
              structuredValue = propDetails.structuredValue;
            }
            if ("defaultType" in propDetails) {
              if (valueType === propDetails.defaultType) {
                isDefault = true;
              }
            } else {
              if (valueType === DEFAULT_VALUE_TYPE) {
                isDefault = true;
              }
            }
          } else {
            if (valueType === DEFAULT_VALUE_TYPE) {
              isDefault = true;
            }
          }
          if (!isDefault) {
            line += ";VALUE=" + valueType.toUpperCase();
          }
          line += ":";
          if (multiValue && structuredValue) {
            line += stringify.multiValue(property[3], structuredValue, valueType, multiValue, designSet, structuredValue);
          } else if (multiValue) {
            line += stringify.multiValue(property.slice(3), multiValue, valueType, null, designSet, false);
          } else if (structuredValue) {
            line += stringify.multiValue(property[3], structuredValue, valueType, null, designSet, structuredValue);
          } else {
            line += stringify.value(property[3], valueType, designSet, false);
          }
          return noFold ? line : ICAL.helpers.foldline(line);
        };
        stringify.propertyValue = function(value) {
          if (helpers.unescapedIndexOf(value, ",") === -1 && helpers.unescapedIndexOf(value, ":") === -1 && helpers.unescapedIndexOf(value, ";") === -1) {
            return value;
          }
          return '"' + value + '"';
        };
        stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {
          var result = "";
          var len = values.length;
          var i = 0;
          for (; i < len; i++) {
            if (innerMulti && Array.isArray(values[i])) {
              result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);
            } else {
              result += stringify.value(values[i], type, designSet, structuredValue);
            }
            if (i !== len - 1) {
              result += delim;
            }
          }
          return result;
        };
        stringify.value = function(value, type, designSet, structuredValue) {
          if (type in designSet.value && "toICAL" in designSet.value[type]) {
            return designSet.value[type].toICAL(value, structuredValue);
          }
          return value;
        };
        stringify._rfc6868Unescape = function(val) {
          return val.replace(/[\n^"]/g, function(x) {
            return RFC6868_REPLACE_MAP[x];
          });
        };
        var RFC6868_REPLACE_MAP = { '"': "^'", "\n": "^n", "^": "^^" };
        return stringify;
      }();
      ICAL.parse = function() {
        "use strict";
        var CHAR = /[^ \t]/;
        var MULTIVALUE_DELIMITER = ",";
        var VALUE_DELIMITER = ":";
        var PARAM_DELIMITER = ";";
        var PARAM_NAME_DELIMITER = "=";
        var DEFAULT_VALUE_TYPE = "unknown";
        var DEFAULT_PARAM_TYPE = "text";
        var design = ICAL.design;
        var helpers = ICAL.helpers;
        function ParserError(message) {
          this.message = message;
          this.name = "ParserError";
          try {
            throw new Error();
          } catch (e) {
            if (e.stack) {
              var split = e.stack.split("\n");
              split.shift();
              this.stack = split.join("\n");
            }
          }
        }
        ParserError.prototype = Error.prototype;
        function parser2(input) {
          var state = {};
          var root = state.component = [];
          state.stack = [root];
          parser2._eachLine(input, function(err, line) {
            parser2._handleContentLine(line, state);
          });
          if (state.stack.length > 1) {
            throw new ParserError("invalid ical body. component began but did not end");
          }
          state = null;
          return root.length == 1 ? root[0] : root;
        }
        parser2.property = function(str, designSet) {
          var state = {
            component: [[], []],
            designSet: designSet || design.defaultSet
          };
          parser2._handleContentLine(str, state);
          return state.component[1][0];
        };
        parser2.component = function(str) {
          return parser2(str);
        };
        parser2.ParserError = ParserError;
        parser2._handleContentLine = function(line, state) {
          var valuePos = line.indexOf(VALUE_DELIMITER);
          var paramPos = line.indexOf(PARAM_DELIMITER);
          var lastParamIndex;
          var lastValuePos;
          var name;
          var value;
          var params = {};
          if (paramPos !== -1 && valuePos !== -1) {
            if (paramPos > valuePos) {
              paramPos = -1;
            }
          }
          var parsedParams;
          if (paramPos !== -1) {
            name = line.substring(0, paramPos).toLowerCase();
            parsedParams = parser2._parseParameters(line.substring(paramPos), 0, state.designSet);
            if (parsedParams[2] == -1) {
              throw new ParserError("Invalid parameters in '" + line + "'");
            }
            params = parsedParams[0];
            lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;
            if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {
              value = line.substring(lastParamIndex + lastValuePos + 1);
            } else {
              throw new ParserError("Missing parameter value in '" + line + "'");
            }
          } else if (valuePos !== -1) {
            name = line.substring(0, valuePos).toLowerCase();
            value = line.substring(valuePos + 1);
            if (name === "begin") {
              var newComponent = [value.toLowerCase(), [], []];
              if (state.stack.length === 1) {
                state.component.push(newComponent);
              } else {
                state.component[2].push(newComponent);
              }
              state.stack.push(state.component);
              state.component = newComponent;
              if (!state.designSet) {
                state.designSet = design.getDesignSet(state.component[0]);
              }
              return;
            } else if (name === "end") {
              state.component = state.stack.pop();
              return;
            }
          } else {
            throw new ParserError('invalid line (no token ";" or ":") "' + line + '"');
          }
          var valueType;
          var multiValue = false;
          var structuredValue = false;
          var propertyDetails;
          if (name in state.designSet.property) {
            propertyDetails = state.designSet.property[name];
            if ("multiValue" in propertyDetails) {
              multiValue = propertyDetails.multiValue;
            }
            if ("structuredValue" in propertyDetails) {
              structuredValue = propertyDetails.structuredValue;
            }
            if (value && "detectType" in propertyDetails) {
              valueType = propertyDetails.detectType(value);
            }
          }
          if (!valueType) {
            if (!("value" in params)) {
              if (propertyDetails) {
                valueType = propertyDetails.defaultType;
              } else {
                valueType = DEFAULT_VALUE_TYPE;
              }
            } else {
              valueType = params.value.toLowerCase();
            }
          }
          delete params.value;
          var result;
          if (multiValue && structuredValue) {
            value = parser2._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);
            result = [name, params, valueType, value];
          } else if (multiValue) {
            result = [name, params, valueType];
            parser2._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);
          } else if (structuredValue) {
            value = parser2._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);
            result = [name, params, valueType, value];
          } else {
            value = parser2._parseValue(value, valueType, state.designSet, false);
            result = [name, params, valueType, value];
          }
          if (state.component[0] === "vcard" && state.component[1].length === 0 && !(name === "version" && value === "4.0")) {
            state.designSet = design.getDesignSet("vcard3");
          }
          state.component[1].push(result);
        };
        parser2._parseValue = function(value, type, designSet, structuredValue) {
          if (type in designSet.value && "fromICAL" in designSet.value[type]) {
            return designSet.value[type].fromICAL(value, structuredValue);
          }
          return value;
        };
        parser2._parseParameters = function(line, start, designSet) {
          var lastParam = start;
          var pos = 0;
          var delim = PARAM_NAME_DELIMITER;
          var result = {};
          var name, lcname;
          var value, valuePos = -1;
          var type, multiValue, mvdelim;
          while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {
            name = line.substr(lastParam + 1, pos - lastParam - 1);
            if (name.length == 0) {
              throw new ParserError("Empty parameter name in '" + line + "'");
            }
            lcname = name.toLowerCase();
            mvdelim = false;
            multiValue = false;
            if (lcname in designSet.param && designSet.param[lcname].valueType) {
              type = designSet.param[lcname].valueType;
            } else {
              type = DEFAULT_PARAM_TYPE;
            }
            if (lcname in designSet.param) {
              multiValue = designSet.param[lcname].multiValue;
              if (designSet.param[lcname].multiValueSeparateDQuote) {
                mvdelim = parser2._rfc6868Escape('"' + multiValue + '"');
              }
            }
            var nextChar = line[pos + 1];
            if (nextChar === '"') {
              valuePos = pos + 2;
              pos = helpers.unescapedIndexOf(line, '"', valuePos);
              if (multiValue && pos != -1) {
                var extendedValue = true;
                while (extendedValue) {
                  if (line[pos + 1] == multiValue && line[pos + 2] == '"') {
                    pos = helpers.unescapedIndexOf(line, '"', pos + 3);
                  } else {
                    extendedValue = false;
                  }
                }
              }
              if (pos === -1) {
                throw new ParserError('invalid line (no matching double quote) "' + line + '"');
              }
              value = line.substr(valuePos, pos - valuePos);
              lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);
              if (lastParam === -1) {
                pos = false;
              }
            } else {
              valuePos = pos + 1;
              var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);
              var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);
              if (propValuePos !== -1 && nextPos > propValuePos) {
                nextPos = propValuePos;
                pos = false;
              } else if (nextPos === -1) {
                if (propValuePos === -1) {
                  nextPos = line.length;
                } else {
                  nextPos = propValuePos;
                }
                pos = false;
              } else {
                lastParam = nextPos;
                pos = nextPos;
              }
              value = line.substr(valuePos, nextPos - valuePos);
            }
            value = parser2._rfc6868Escape(value);
            if (multiValue) {
              var delimiter = mvdelim || multiValue;
              value = parser2._parseMultiValue(value, delimiter, type, [], null, designSet);
            } else {
              value = parser2._parseValue(value, type, designSet);
            }
            if (multiValue && lcname in result) {
              if (Array.isArray(result[lcname])) {
                result[lcname].push(value);
              } else {
                result[lcname] = [
                  result[lcname],
                  value
                ];
              }
            } else {
              result[lcname] = value;
            }
          }
          return [result, value, valuePos];
        };
        parser2._rfc6868Escape = function(val) {
          return val.replace(/\^['n^]/g, function(x) {
            return RFC6868_REPLACE_MAP[x];
          });
        };
        var RFC6868_REPLACE_MAP = { "^'": '"', "^n": "\n", "^^": "^" };
        parser2._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {
          var pos = 0;
          var lastPos = 0;
          var value;
          if (delim.length === 0) {
            return buffer;
          }
          while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {
            value = buffer.substr(lastPos, pos - lastPos);
            if (innerMulti) {
              value = parser2._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
            } else {
              value = parser2._parseValue(value, type, designSet, structuredValue);
            }
            result.push(value);
            lastPos = pos + delim.length;
          }
          value = buffer.substr(lastPos);
          if (innerMulti) {
            value = parser2._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
          } else {
            value = parser2._parseValue(value, type, designSet, structuredValue);
          }
          result.push(value);
          return result.length == 1 ? result[0] : result;
        };
        parser2._eachLine = function(buffer, callback) {
          var len = buffer.length;
          var lastPos = buffer.search(CHAR);
          var pos = lastPos;
          var line;
          var firstChar;
          var newlineOffset;
          do {
            pos = buffer.indexOf("\n", lastPos) + 1;
            if (pos > 1 && buffer[pos - 2] === "\r") {
              newlineOffset = 2;
            } else {
              newlineOffset = 1;
            }
            if (pos === 0) {
              pos = len;
              newlineOffset = 0;
            }
            firstChar = buffer[lastPos];
            if (firstChar === " " || firstChar === "	") {
              line += buffer.substr(lastPos + 1, pos - lastPos - (newlineOffset + 1));
            } else {
              if (line)
                callback(null, line);
              line = buffer.substr(lastPos, pos - lastPos - newlineOffset);
            }
            lastPos = pos;
          } while (pos !== len);
          line = line.trim();
          if (line.length)
            callback(null, line);
        };
        return parser2;
      }();
      ICAL.Component = function() {
        "use strict";
        var PROPERTY_INDEX = 1;
        var COMPONENT_INDEX = 2;
        var NAME_INDEX = 0;
        function Component(jCal, parent2) {
          if (typeof jCal === "string") {
            jCal = [jCal, [], []];
          }
          this.jCal = jCal;
          this.parent = parent2 || null;
        }
        Component.prototype = {
          _hydratedPropertyCount: 0,
          _hydratedComponentCount: 0,
          get name() {
            return this.jCal[NAME_INDEX];
          },
          get _designSet() {
            var parentDesign = this.parent && this.parent._designSet;
            return parentDesign || ICAL.design.getDesignSet(this.name);
          },
          _hydrateComponent: function(index) {
            if (!this._components) {
              this._components = [];
              this._hydratedComponentCount = 0;
            }
            if (this._components[index]) {
              return this._components[index];
            }
            var comp = new Component(this.jCal[COMPONENT_INDEX][index], this);
            this._hydratedComponentCount++;
            return this._components[index] = comp;
          },
          _hydrateProperty: function(index) {
            if (!this._properties) {
              this._properties = [];
              this._hydratedPropertyCount = 0;
            }
            if (this._properties[index]) {
              return this._properties[index];
            }
            var prop = new ICAL.Property(this.jCal[PROPERTY_INDEX][index], this);
            this._hydratedPropertyCount++;
            return this._properties[index] = prop;
          },
          getFirstSubcomponent: function(name) {
            if (name) {
              var i = 0;
              var comps = this.jCal[COMPONENT_INDEX];
              var len = comps.length;
              for (; i < len; i++) {
                if (comps[i][NAME_INDEX] === name) {
                  var result = this._hydrateComponent(i);
                  return result;
                }
              }
            } else {
              if (this.jCal[COMPONENT_INDEX].length) {
                return this._hydrateComponent(0);
              }
            }
            return null;
          },
          getAllSubcomponents: function(name) {
            var jCalLen = this.jCal[COMPONENT_INDEX].length;
            var i = 0;
            if (name) {
              var comps = this.jCal[COMPONENT_INDEX];
              var result = [];
              for (; i < jCalLen; i++) {
                if (name === comps[i][NAME_INDEX]) {
                  result.push(this._hydrateComponent(i));
                }
              }
              return result;
            } else {
              if (!this._components || this._hydratedComponentCount !== jCalLen) {
                for (; i < jCalLen; i++) {
                  this._hydrateComponent(i);
                }
              }
              return this._components || [];
            }
          },
          hasProperty: function(name) {
            var props = this.jCal[PROPERTY_INDEX];
            var len = props.length;
            var i = 0;
            for (; i < len; i++) {
              if (props[i][NAME_INDEX] === name) {
                return true;
              }
            }
            return false;
          },
          getFirstProperty: function(name) {
            if (name) {
              var i = 0;
              var props = this.jCal[PROPERTY_INDEX];
              var len = props.length;
              for (; i < len; i++) {
                if (props[i][NAME_INDEX] === name) {
                  var result = this._hydrateProperty(i);
                  return result;
                }
              }
            } else {
              if (this.jCal[PROPERTY_INDEX].length) {
                return this._hydrateProperty(0);
              }
            }
            return null;
          },
          getFirstPropertyValue: function(name) {
            var prop = this.getFirstProperty(name);
            if (prop) {
              return prop.getFirstValue();
            }
            return null;
          },
          getAllProperties: function(name) {
            var jCalLen = this.jCal[PROPERTY_INDEX].length;
            var i = 0;
            if (name) {
              var props = this.jCal[PROPERTY_INDEX];
              var result = [];
              for (; i < jCalLen; i++) {
                if (name === props[i][NAME_INDEX]) {
                  result.push(this._hydrateProperty(i));
                }
              }
              return result;
            } else {
              if (!this._properties || this._hydratedPropertyCount !== jCalLen) {
                for (; i < jCalLen; i++) {
                  this._hydrateProperty(i);
                }
              }
              return this._properties || [];
            }
          },
          _removeObjectByIndex: function(jCalIndex, cache, index) {
            cache = cache || [];
            if (cache[index]) {
              var obj = cache[index];
              if ("parent" in obj) {
                obj.parent = null;
              }
            }
            cache.splice(index, 1);
            this.jCal[jCalIndex].splice(index, 1);
          },
          _removeObject: function(jCalIndex, cache, nameOrObject) {
            var i = 0;
            var objects = this.jCal[jCalIndex];
            var len = objects.length;
            var cached = this[cache];
            if (typeof nameOrObject === "string") {
              for (; i < len; i++) {
                if (objects[i][NAME_INDEX] === nameOrObject) {
                  this._removeObjectByIndex(jCalIndex, cached, i);
                  return true;
                }
              }
            } else if (cached) {
              for (; i < len; i++) {
                if (cached[i] && cached[i] === nameOrObject) {
                  this._removeObjectByIndex(jCalIndex, cached, i);
                  return true;
                }
              }
            }
            return false;
          },
          _removeAllObjects: function(jCalIndex, cache, name) {
            var cached = this[cache];
            var objects = this.jCal[jCalIndex];
            var i = objects.length - 1;
            for (; i >= 0; i--) {
              if (!name || objects[i][NAME_INDEX] === name) {
                this._removeObjectByIndex(jCalIndex, cached, i);
              }
            }
          },
          addSubcomponent: function(component) {
            if (!this._components) {
              this._components = [];
              this._hydratedComponentCount = 0;
            }
            if (component.parent) {
              component.parent.removeSubcomponent(component);
            }
            var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);
            this._components[idx - 1] = component;
            this._hydratedComponentCount++;
            component.parent = this;
            return component;
          },
          removeSubcomponent: function(nameOrComp) {
            var removed = this._removeObject(COMPONENT_INDEX, "_components", nameOrComp);
            if (removed) {
              this._hydratedComponentCount--;
            }
            return removed;
          },
          removeAllSubcomponents: function(name) {
            var removed = this._removeAllObjects(COMPONENT_INDEX, "_components", name);
            this._hydratedComponentCount = 0;
            return removed;
          },
          addProperty: function(property) {
            if (!(property instanceof ICAL.Property)) {
              throw new TypeError("must instance of ICAL.Property");
            }
            if (!this._properties) {
              this._properties = [];
              this._hydratedPropertyCount = 0;
            }
            if (property.parent) {
              property.parent.removeProperty(property);
            }
            var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);
            this._properties[idx - 1] = property;
            this._hydratedPropertyCount++;
            property.parent = this;
            return property;
          },
          addPropertyWithValue: function(name, value) {
            var prop = new ICAL.Property(name);
            prop.setValue(value);
            this.addProperty(prop);
            return prop;
          },
          updatePropertyWithValue: function(name, value) {
            var prop = this.getFirstProperty(name);
            if (prop) {
              prop.setValue(value);
            } else {
              prop = this.addPropertyWithValue(name, value);
            }
            return prop;
          },
          removeProperty: function(nameOrProp) {
            var removed = this._removeObject(PROPERTY_INDEX, "_properties", nameOrProp);
            if (removed) {
              this._hydratedPropertyCount--;
            }
            return removed;
          },
          removeAllProperties: function(name) {
            var removed = this._removeAllObjects(PROPERTY_INDEX, "_properties", name);
            this._hydratedPropertyCount = 0;
            return removed;
          },
          toJSON: function() {
            return this.jCal;
          },
          toString: function() {
            return ICAL.stringify.component(this.jCal, this._designSet);
          }
        };
        Component.fromString = function(str) {
          return new Component(ICAL.parse.component(str));
        };
        return Component;
      }();
      ICAL.Property = function() {
        "use strict";
        var NAME_INDEX = 0;
        var PROP_INDEX = 1;
        var TYPE_INDEX = 2;
        var VALUE_INDEX = 3;
        var design = ICAL.design;
        function Property(jCal, parent2) {
          this._parent = parent2 || null;
          if (typeof jCal === "string") {
            this.jCal = [jCal, {}, design.defaultType];
            this.jCal[TYPE_INDEX] = this.getDefaultType();
          } else {
            this.jCal = jCal;
          }
          this._updateType();
        }
        Property.prototype = {
          get type() {
            return this.jCal[TYPE_INDEX];
          },
          get name() {
            return this.jCal[NAME_INDEX];
          },
          get parent() {
            return this._parent;
          },
          set parent(p) {
            var designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;
            this._parent = p;
            if (this.type == design.defaultType && designSetChanged) {
              this.jCal[TYPE_INDEX] = this.getDefaultType();
              this._updateType();
            }
            return p;
          },
          get _designSet() {
            return this.parent ? this.parent._designSet : design.defaultSet;
          },
          _updateType: function() {
            var designSet = this._designSet;
            if (this.type in designSet.value) {
              var designType = designSet.value[this.type];
              if ("decorate" in designSet.value[this.type]) {
                this.isDecorated = true;
              } else {
                this.isDecorated = false;
              }
              if (this.name in designSet.property) {
                this.isMultiValue = "multiValue" in designSet.property[this.name];
                this.isStructuredValue = "structuredValue" in designSet.property[this.name];
              }
            }
          },
          _hydrateValue: function(index) {
            if (this._values && this._values[index]) {
              return this._values[index];
            }
            if (this.jCal.length <= VALUE_INDEX + index) {
              return null;
            }
            if (this.isDecorated) {
              if (!this._values) {
                this._values = [];
              }
              return this._values[index] = this._decorate(this.jCal[VALUE_INDEX + index]);
            } else {
              return this.jCal[VALUE_INDEX + index];
            }
          },
          _decorate: function(value) {
            return this._designSet.value[this.type].decorate(value, this);
          },
          _undecorate: function(value) {
            return this._designSet.value[this.type].undecorate(value, this);
          },
          _setDecoratedValue: function(value, index) {
            if (!this._values) {
              this._values = [];
            }
            if (typeof value === "object" && "icaltype" in value) {
              this.jCal[VALUE_INDEX + index] = this._undecorate(value);
              this._values[index] = value;
            } else {
              this.jCal[VALUE_INDEX + index] = value;
              this._values[index] = this._decorate(value);
            }
          },
          getParameter: function(name) {
            if (name in this.jCal[PROP_INDEX]) {
              return this.jCal[PROP_INDEX][name];
            } else {
              return void 0;
            }
          },
          getFirstParameter: function(name) {
            var parameters = this.getParameter(name);
            if (Array.isArray(parameters)) {
              return parameters[0];
            }
            return parameters;
          },
          setParameter: function(name, value) {
            var lcname = name.toLowerCase();
            if (typeof value === "string" && lcname in this._designSet.param && "multiValue" in this._designSet.param[lcname]) {
              value = [value];
            }
            this.jCal[PROP_INDEX][name] = value;
          },
          removeParameter: function(name) {
            delete this.jCal[PROP_INDEX][name];
          },
          getDefaultType: function() {
            var name = this.jCal[NAME_INDEX];
            var designSet = this._designSet;
            if (name in designSet.property) {
              var details = designSet.property[name];
              if ("defaultType" in details) {
                return details.defaultType;
              }
            }
            return design.defaultType;
          },
          resetType: function(type) {
            this.removeAllValues();
            this.jCal[TYPE_INDEX] = type;
            this._updateType();
          },
          getFirstValue: function() {
            return this._hydrateValue(0);
          },
          getValues: function() {
            var len = this.jCal.length - VALUE_INDEX;
            if (len < 1) {
              return [];
            }
            var i = 0;
            var result = [];
            for (; i < len; i++) {
              result[i] = this._hydrateValue(i);
            }
            return result;
          },
          removeAllValues: function() {
            if (this._values) {
              this._values.length = 0;
            }
            this.jCal.length = 3;
          },
          setValues: function(values) {
            if (!this.isMultiValue) {
              throw new Error(this.name + ": does not not support mulitValue.\noverride isMultiValue");
            }
            var len = values.length;
            var i = 0;
            this.removeAllValues();
            if (len > 0 && typeof values[0] === "object" && "icaltype" in values[0]) {
              this.resetType(values[0].icaltype);
            }
            if (this.isDecorated) {
              for (; i < len; i++) {
                this._setDecoratedValue(values[i], i);
              }
            } else {
              for (; i < len; i++) {
                this.jCal[VALUE_INDEX + i] = values[i];
              }
            }
          },
          setValue: function(value) {
            this.removeAllValues();
            if (typeof value === "object" && "icaltype" in value) {
              this.resetType(value.icaltype);
            }
            if (this.isDecorated) {
              this._setDecoratedValue(value, 0);
            } else {
              this.jCal[VALUE_INDEX] = value;
            }
          },
          toJSON: function() {
            return this.jCal;
          },
          toICALString: function() {
            return ICAL.stringify.property(this.jCal, this._designSet, true);
          }
        };
        Property.fromString = function(str, designSet) {
          return new Property(ICAL.parse.property(str, designSet));
        };
        return Property;
      }();
      ICAL.UtcOffset = function() {
        function UtcOffset(aData) {
          this.fromData(aData);
        }
        UtcOffset.prototype = {
          hours: 0,
          minutes: 0,
          factor: 1,
          icaltype: "utc-offset",
          clone: function() {
            return ICAL.UtcOffset.fromSeconds(this.toSeconds());
          },
          fromData: function(aData) {
            if (aData) {
              for (var key in aData) {
                if (aData.hasOwnProperty(key)) {
                  this[key] = aData[key];
                }
              }
            }
            this._normalize();
          },
          fromSeconds: function(aSeconds) {
            var secs = Math.abs(aSeconds);
            this.factor = aSeconds < 0 ? -1 : 1;
            this.hours = ICAL.helpers.trunc(secs / 3600);
            secs -= this.hours * 3600;
            this.minutes = ICAL.helpers.trunc(secs / 60);
            return this;
          },
          toSeconds: function() {
            return this.factor * (60 * this.minutes + 3600 * this.hours);
          },
          compare: function icaltime_compare(other) {
            var a = this.toSeconds();
            var b = other.toSeconds();
            return (a > b) - (b > a);
          },
          _normalize: function() {
            var secs = this.toSeconds();
            var factor = this.factor;
            while (secs < -43200) {
              secs += 97200;
            }
            while (secs > 50400) {
              secs -= 97200;
            }
            this.fromSeconds(secs);
            if (secs == 0) {
              this.factor = factor;
            }
          },
          toICALString: function() {
            return ICAL.design.icalendar.value["utc-offset"].toICAL(this.toString());
          },
          toString: function toString() {
            return (this.factor == 1 ? "+" : "-") + ICAL.helpers.pad2(this.hours) + ":" + ICAL.helpers.pad2(this.minutes);
          }
        };
        UtcOffset.fromString = function(aString) {
          var options = {};
          options.factor = aString[0] === "+" ? 1 : -1;
          options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));
          options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));
          return new ICAL.UtcOffset(options);
        };
        UtcOffset.fromSeconds = function(aSeconds) {
          var instance = new UtcOffset();
          instance.fromSeconds(aSeconds);
          return instance;
        };
        return UtcOffset;
      }();
      ICAL.Binary = function() {
        function Binary(aValue) {
          this.value = aValue;
        }
        Binary.prototype = {
          icaltype: "binary",
          decodeValue: function decodeValue() {
            return this._b64_decode(this.value);
          },
          setEncodedValue: function setEncodedValue(aValue) {
            this.value = this._b64_encode(aValue);
          },
          _b64_encode: function base64_encode(data) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = "", tmp_arr = [];
            if (!data) {
              return data;
            }
            do {
              o1 = data.charCodeAt(i++);
              o2 = data.charCodeAt(i++);
              o3 = data.charCodeAt(i++);
              bits = o1 << 16 | o2 << 8 | o3;
              h1 = bits >> 18 & 63;
              h2 = bits >> 12 & 63;
              h3 = bits >> 6 & 63;
              h4 = bits & 63;
              tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while (i < data.length);
            enc = tmp_arr.join("");
            var r = data.length % 3;
            return (r ? enc.slice(0, r - 3) : enc) + "===".slice(r || 3);
          },
          _b64_decode: function base64_decode(data) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, dec = "", tmp_arr = [];
            if (!data) {
              return data;
            }
            data += "";
            do {
              h1 = b64.indexOf(data.charAt(i++));
              h2 = b64.indexOf(data.charAt(i++));
              h3 = b64.indexOf(data.charAt(i++));
              h4 = b64.indexOf(data.charAt(i++));
              bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;
              o1 = bits >> 16 & 255;
              o2 = bits >> 8 & 255;
              o3 = bits & 255;
              if (h3 == 64) {
                tmp_arr[ac++] = String.fromCharCode(o1);
              } else if (h4 == 64) {
                tmp_arr[ac++] = String.fromCharCode(o1, o2);
              } else {
                tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
              }
            } while (i < data.length);
            dec = tmp_arr.join("");
            return dec;
          },
          toString: function() {
            return this.value;
          }
        };
        Binary.fromString = function(aString) {
          return new Binary(aString);
        };
        return Binary;
      }();
      (function() {
        ICAL.Period = function icalperiod(aData) {
          this.wrappedJSObject = this;
          if (aData && "start" in aData) {
            if (aData.start && !(aData.start instanceof ICAL.Time)) {
              throw new TypeError(".start must be an instance of ICAL.Time");
            }
            this.start = aData.start;
          }
          if (aData && aData.end && aData.duration) {
            throw new Error("cannot accept both end and duration");
          }
          if (aData && "end" in aData) {
            if (aData.end && !(aData.end instanceof ICAL.Time)) {
              throw new TypeError(".end must be an instance of ICAL.Time");
            }
            this.end = aData.end;
          }
          if (aData && "duration" in aData) {
            if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {
              throw new TypeError(".duration must be an instance of ICAL.Duration");
            }
            this.duration = aData.duration;
          }
        };
        ICAL.Period.prototype = {
          start: null,
          end: null,
          duration: null,
          icalclass: "icalperiod",
          icaltype: "period",
          clone: function() {
            return ICAL.Period.fromData({
              start: this.start ? this.start.clone() : null,
              end: this.end ? this.end.clone() : null,
              duration: this.duration ? this.duration.clone() : null
            });
          },
          getDuration: function duration() {
            if (this.duration) {
              return this.duration;
            } else {
              return this.end.subtractDate(this.start);
            }
          },
          getEnd: function() {
            if (this.end) {
              return this.end;
            } else {
              var end = this.start.clone();
              end.addDuration(this.duration);
              return end;
            }
          },
          toString: function toString() {
            return this.start + "/" + (this.end || this.duration);
          },
          toJSON: function() {
            return [this.start.toString(), (this.end || this.duration).toString()];
          },
          toICALString: function() {
            return this.start.toICALString() + "/" + (this.end || this.duration).toICALString();
          }
        };
        ICAL.Period.fromString = function fromString(str, prop) {
          var parts = str.split("/");
          if (parts.length !== 2) {
            throw new Error('Invalid string value: "' + str + '" must contain a "/" char.');
          }
          var options = {
            start: ICAL.Time.fromDateTimeString(parts[0], prop)
          };
          var end = parts[1];
          if (ICAL.Duration.isValueString(end)) {
            options.duration = ICAL.Duration.fromString(end);
          } else {
            options.end = ICAL.Time.fromDateTimeString(end, prop);
          }
          return new ICAL.Period(options);
        };
        ICAL.Period.fromData = function fromData(aData) {
          return new ICAL.Period(aData);
        };
        ICAL.Period.fromJSON = function(aData, aProp, aLenient) {
          function fromDateOrDateTimeString(aValue, aProp2) {
            if (aLenient) {
              return ICAL.Time.fromString(aValue, aProp2);
            } else {
              return ICAL.Time.fromDateTimeString(aValue, aProp2);
            }
          }
          if (ICAL.Duration.isValueString(aData[1])) {
            return ICAL.Period.fromData({
              start: fromDateOrDateTimeString(aData[0], aProp),
              duration: ICAL.Duration.fromString(aData[1])
            });
          } else {
            return ICAL.Period.fromData({
              start: fromDateOrDateTimeString(aData[0], aProp),
              end: fromDateOrDateTimeString(aData[1], aProp)
            });
          }
        };
      })();
      (function() {
        var DURATION_LETTERS = /([PDWHMTS]{1,1})/;
        ICAL.Duration = function icalduration(data) {
          this.wrappedJSObject = this;
          this.fromData(data);
        };
        ICAL.Duration.prototype = {
          weeks: 0,
          days: 0,
          hours: 0,
          minutes: 0,
          seconds: 0,
          isNegative: false,
          icalclass: "icalduration",
          icaltype: "duration",
          clone: function clone() {
            return ICAL.Duration.fromData(this);
          },
          toSeconds: function toSeconds() {
            var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;
            return this.isNegative ? -seconds : seconds;
          },
          fromSeconds: function fromSeconds(aSeconds) {
            var secs = Math.abs(aSeconds);
            this.isNegative = aSeconds < 0;
            this.days = ICAL.helpers.trunc(secs / 86400);
            if (this.days % 7 == 0) {
              this.weeks = this.days / 7;
              this.days = 0;
            } else {
              this.weeks = 0;
            }
            secs -= (this.days + 7 * this.weeks) * 86400;
            this.hours = ICAL.helpers.trunc(secs / 3600);
            secs -= this.hours * 3600;
            this.minutes = ICAL.helpers.trunc(secs / 60);
            secs -= this.minutes * 60;
            this.seconds = secs;
            return this;
          },
          fromData: function fromData(aData) {
            var propsToCopy = [
              "weeks",
              "days",
              "hours",
              "minutes",
              "seconds",
              "isNegative"
            ];
            for (var key in propsToCopy) {
              if (!propsToCopy.hasOwnProperty(key)) {
                continue;
              }
              var prop = propsToCopy[key];
              if (aData && prop in aData) {
                this[prop] = aData[prop];
              } else {
                this[prop] = 0;
              }
            }
          },
          reset: function reset() {
            this.isNegative = false;
            this.weeks = 0;
            this.days = 0;
            this.hours = 0;
            this.minutes = 0;
            this.seconds = 0;
          },
          compare: function compare(aOther) {
            var thisSeconds = this.toSeconds();
            var otherSeconds = aOther.toSeconds();
            return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);
          },
          normalize: function normalize() {
            this.fromSeconds(this.toSeconds());
          },
          toString: function toString() {
            if (this.toSeconds() == 0) {
              return "PT0S";
            } else {
              var str = "";
              if (this.isNegative)
                str += "-";
              str += "P";
              if (this.weeks)
                str += this.weeks + "W";
              if (this.days)
                str += this.days + "D";
              if (this.hours || this.minutes || this.seconds) {
                str += "T";
                if (this.hours)
                  str += this.hours + "H";
                if (this.minutes)
                  str += this.minutes + "M";
                if (this.seconds)
                  str += this.seconds + "S";
              }
              return str;
            }
          },
          toICALString: function() {
            return this.toString();
          }
        };
        ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {
          return new ICAL.Duration().fromSeconds(aSeconds);
        };
        function parseDurationChunk(letter, number, object) {
          var type;
          switch (letter) {
            case "P":
              if (number && number === "-") {
                object.isNegative = true;
              } else {
                object.isNegative = false;
              }
              break;
            case "D":
              type = "days";
              break;
            case "W":
              type = "weeks";
              break;
            case "H":
              type = "hours";
              break;
            case "M":
              type = "minutes";
              break;
            case "S":
              type = "seconds";
              break;
            default:
              return 0;
          }
          if (type) {
            if (!number && number !== 0) {
              throw new Error('invalid duration value: Missing number before "' + letter + '"');
            }
            var num = parseInt(number, 10);
            if (ICAL.helpers.isStrictlyNaN(num)) {
              throw new Error('invalid duration value: Invalid number "' + number + '" before "' + letter + '"');
            }
            object[type] = num;
          }
          return 1;
        }
        ICAL.Duration.isValueString = function(string) {
          return string[0] === "P" || string[1] === "P";
        };
        ICAL.Duration.fromString = function icalduration_from_string(aStr) {
          var pos = 0;
          var dict = Object.create(null);
          var chunks = 0;
          while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {
            var type = aStr[pos];
            var numeric = aStr.substr(0, pos);
            aStr = aStr.substr(pos + 1);
            chunks += parseDurationChunk(type, numeric, dict);
          }
          if (chunks < 2) {
            throw new Error('invalid duration value: Not enough duration components in "' + aStr + '"');
          }
          return new ICAL.Duration(dict);
        };
        ICAL.Duration.fromData = function icalduration_from_data(aData) {
          return new ICAL.Duration(aData);
        };
      })();
      (function() {
        var OPTIONS = [
          "tzid",
          "location",
          "tznames",
          "latitude",
          "longitude"
        ];
        ICAL.Timezone = function icaltimezone(data) {
          this.wrappedJSObject = this;
          this.fromData(data);
        };
        ICAL.Timezone.prototype = {
          tzid: "",
          location: "",
          tznames: "",
          latitude: 0,
          longitude: 0,
          component: null,
          expandedUntilYear: 0,
          icalclass: "icaltimezone",
          fromData: function fromData(aData) {
            this.expandedUntilYear = 0;
            this.changes = [];
            if (aData instanceof ICAL.Component) {
              this.component = aData;
            } else {
              if (aData && "component" in aData) {
                if (typeof aData.component == "string") {
                  var jCal = ICAL.parse(aData.component);
                  this.component = new ICAL.Component(jCal);
                } else if (aData.component instanceof ICAL.Component) {
                  this.component = aData.component;
                } else {
                  this.component = null;
                }
              }
              for (var key in OPTIONS) {
                if (OPTIONS.hasOwnProperty(key)) {
                  var prop = OPTIONS[key];
                  if (aData && prop in aData) {
                    this[prop] = aData[prop];
                  }
                }
              }
            }
            if (this.component instanceof ICAL.Component && !this.tzid) {
              this.tzid = this.component.getFirstPropertyValue("tzid");
            }
            return this;
          },
          utcOffset: function utcOffset(tt) {
            if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {
              return 0;
            }
            this._ensureCoverage(tt.year);
            if (!this.changes.length) {
              return 0;
            }
            var tt_change = {
              year: tt.year,
              month: tt.month,
              day: tt.day,
              hour: tt.hour,
              minute: tt.minute,
              second: tt.second
            };
            var change_num = this._findNearbyChange(tt_change);
            var change_num_to_use = -1;
            var step = 1;
            for (; ; ) {
              var change = ICAL.helpers.clone(this.changes[change_num], true);
              if (change.utcOffset < change.prevUtcOffset) {
                ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);
              } else {
                ICAL.Timezone.adjust_change(change, 0, 0, 0, change.prevUtcOffset);
              }
              var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);
              if (cmp >= 0) {
                change_num_to_use = change_num;
              } else {
                step = -1;
              }
              if (step == -1 && change_num_to_use != -1) {
                break;
              }
              change_num += step;
              if (change_num < 0) {
                return 0;
              }
              if (change_num >= this.changes.length) {
                break;
              }
            }
            var zone_change = this.changes[change_num_to_use];
            var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;
            if (utcOffset_change < 0 && change_num_to_use > 0) {
              var tmp_change = ICAL.helpers.clone(zone_change, true);
              ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0, tmp_change.prevUtcOffset);
              if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {
                var prev_zone_change = this.changes[change_num_to_use - 1];
                var want_daylight = false;
                if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {
                  zone_change = prev_zone_change;
                }
              }
            }
            return zone_change.utcOffset;
          },
          _findNearbyChange: function icaltimezone_find_nearby_change(change) {
            var idx = ICAL.helpers.binsearchInsert(this.changes, change, ICAL.Timezone._compare_change_fn);
            if (idx >= this.changes.length) {
              return this.changes.length - 1;
            }
            return idx;
          },
          _ensureCoverage: function(aYear) {
            if (ICAL.Timezone._minimumExpansionYear == -1) {
              var today = ICAL.Time.now();
              ICAL.Timezone._minimumExpansionYear = today.year;
            }
            var changesEndYear = aYear;
            if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {
              changesEndYear = ICAL.Timezone._minimumExpansionYear;
            }
            changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;
            if (changesEndYear > ICAL.Timezone.MAX_YEAR) {
              changesEndYear = ICAL.Timezone.MAX_YEAR;
            }
            if (!this.changes.length || this.expandedUntilYear < aYear) {
              var subcomps = this.component.getAllSubcomponents();
              var compLen = subcomps.length;
              var compIdx = 0;
              for (; compIdx < compLen; compIdx++) {
                this._expandComponent(subcomps[compIdx], changesEndYear, this.changes);
              }
              this.changes.sort(ICAL.Timezone._compare_change_fn);
              this.expandedUntilYear = changesEndYear;
            }
          },
          _expandComponent: function(aComponent, aYear, changes) {
            if (!aComponent.hasProperty("dtstart") || !aComponent.hasProperty("tzoffsetto") || !aComponent.hasProperty("tzoffsetfrom")) {
              return null;
            }
            var dtstart = aComponent.getFirstProperty("dtstart").getFirstValue();
            var change;
            function convert_tzoffset(offset) {
              return offset.factor * (offset.hours * 3600 + offset.minutes * 60);
            }
            function init_changes() {
              var changebase = {};
              changebase.is_daylight = aComponent.name == "daylight";
              changebase.utcOffset = convert_tzoffset(aComponent.getFirstProperty("tzoffsetto").getFirstValue());
              changebase.prevUtcOffset = convert_tzoffset(aComponent.getFirstProperty("tzoffsetfrom").getFirstValue());
              return changebase;
            }
            if (!aComponent.hasProperty("rrule") && !aComponent.hasProperty("rdate")) {
              change = init_changes();
              change.year = dtstart.year;
              change.month = dtstart.month;
              change.day = dtstart.day;
              change.hour = dtstart.hour;
              change.minute = dtstart.minute;
              change.second = dtstart.second;
              ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);
              changes.push(change);
            } else {
              var props = aComponent.getAllProperties("rdate");
              for (var rdatekey in props) {
                if (!props.hasOwnProperty(rdatekey)) {
                  continue;
                }
                var rdate = props[rdatekey];
                var time = rdate.getFirstValue();
                change = init_changes();
                change.year = time.year;
                change.month = time.month;
                change.day = time.day;
                if (time.isDate) {
                  change.hour = dtstart.hour;
                  change.minute = dtstart.minute;
                  change.second = dtstart.second;
                  if (dtstart.zone != ICAL.Timezone.utcTimezone) {
                    ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);
                  }
                } else {
                  change.hour = time.hour;
                  change.minute = time.minute;
                  change.second = time.second;
                  if (time.zone != ICAL.Timezone.utcTimezone) {
                    ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);
                  }
                }
                changes.push(change);
              }
              var rrule = aComponent.getFirstProperty("rrule");
              if (rrule) {
                rrule = rrule.getFirstValue();
                change = init_changes();
                if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {
                  rrule.until.adjust(0, 0, 0, change.prevUtcOffset);
                  rrule.until.zone = ICAL.Timezone.localTimezone;
                }
                var iterator = rrule.iterator(dtstart);
                var occ;
                while (occ = iterator.next()) {
                  change = init_changes();
                  if (occ.year > aYear || !occ) {
                    break;
                  }
                  change.year = occ.year;
                  change.month = occ.month;
                  change.day = occ.day;
                  change.hour = occ.hour;
                  change.minute = occ.minute;
                  change.second = occ.second;
                  change.isDate = occ.isDate;
                  ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);
                  changes.push(change);
                }
              }
            }
            return changes;
          },
          toString: function toString() {
            return this.tznames ? this.tznames : this.tzid;
          }
        };
        ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {
          if (a.year < b.year)
            return -1;
          else if (a.year > b.year)
            return 1;
          if (a.month < b.month)
            return -1;
          else if (a.month > b.month)
            return 1;
          if (a.day < b.day)
            return -1;
          else if (a.day > b.day)
            return 1;
          if (a.hour < b.hour)
            return -1;
          else if (a.hour > b.hour)
            return 1;
          if (a.minute < b.minute)
            return -1;
          else if (a.minute > b.minute)
            return 1;
          if (a.second < b.second)
            return -1;
          else if (a.second > b.second)
            return 1;
          return 0;
        };
        ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {
          if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL.Timezone.localTimezone || to_zone == ICAL.Timezone.localTimezone) {
            tt.zone = to_zone;
            return tt;
          }
          var utcOffset = from_zone.utcOffset(tt);
          tt.adjust(0, 0, 0, -utcOffset);
          utcOffset = to_zone.utcOffset(tt);
          tt.adjust(0, 0, 0, utcOffset);
          return null;
        };
        ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {
          var tt = new ICAL.Timezone();
          return tt.fromData(aData);
        };
        ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({
          tzid: "UTC"
        });
        ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({
          tzid: "floating"
        });
        ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {
          return ICAL.Time.prototype.adjust.call(change, days, hours, minutes, seconds, change);
        };
        ICAL.Timezone._minimumExpansionYear = -1;
        ICAL.Timezone.MAX_YEAR = 2035;
        ICAL.Timezone.EXTRA_COVERAGE = 5;
      })();
      ICAL.TimezoneService = function() {
        var zones;
        var TimezoneService = {
          get count() {
            return Object.keys(zones).length;
          },
          reset: function() {
            zones = Object.create(null);
            var utc = ICAL.Timezone.utcTimezone;
            zones.Z = utc;
            zones.UTC = utc;
            zones.GMT = utc;
          },
          has: function(tzid) {
            return !!zones[tzid];
          },
          get: function(tzid) {
            return zones[tzid];
          },
          register: function(name, timezone) {
            if (name instanceof ICAL.Component) {
              if (name.name === "vtimezone") {
                timezone = new ICAL.Timezone(name);
                name = timezone.tzid;
              }
            }
            if (timezone instanceof ICAL.Timezone) {
              zones[name] = timezone;
            } else {
              throw new TypeError("timezone must be ICAL.Timezone or ICAL.Component");
            }
          },
          remove: function(tzid) {
            return delete zones[tzid];
          }
        };
        TimezoneService.reset();
        return TimezoneService;
      }();
      (function() {
        ICAL.Time = function icaltime(data, zone) {
          this.wrappedJSObject = this;
          var time = this._time = Object.create(null);
          time.year = 0;
          time.month = 1;
          time.day = 1;
          time.hour = 0;
          time.minute = 0;
          time.second = 0;
          time.isDate = false;
          this.fromData(data, zone);
        };
        ICAL.Time._dowCache = {};
        ICAL.Time._wnCache = {};
        ICAL.Time.prototype = {
          icalclass: "icaltime",
          _cachedUnixTime: null,
          get icaltype() {
            return this.isDate ? "date" : "date-time";
          },
          zone: null,
          _pendingNormalization: false,
          clone: function() {
            return new ICAL.Time(this._time, this.zone);
          },
          reset: function icaltime_reset() {
            this.fromData(ICAL.Time.epochTime);
            this.zone = ICAL.Timezone.utcTimezone;
          },
          resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {
            this.fromData({
              year,
              month,
              day,
              hour,
              minute,
              second,
              zone: timezone
            });
          },
          fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {
            if (!aDate) {
              this.reset();
            } else {
              if (useUTC) {
                this.zone = ICAL.Timezone.utcTimezone;
                this.year = aDate.getUTCFullYear();
                this.month = aDate.getUTCMonth() + 1;
                this.day = aDate.getUTCDate();
                this.hour = aDate.getUTCHours();
                this.minute = aDate.getUTCMinutes();
                this.second = aDate.getUTCSeconds();
              } else {
                this.zone = ICAL.Timezone.localTimezone;
                this.year = aDate.getFullYear();
                this.month = aDate.getMonth() + 1;
                this.day = aDate.getDate();
                this.hour = aDate.getHours();
                this.minute = aDate.getMinutes();
                this.second = aDate.getSeconds();
              }
            }
            this._cachedUnixTime = null;
            return this;
          },
          fromData: function fromData(aData, aZone) {
            if (aData) {
              for (var key in aData) {
                if (Object.prototype.hasOwnProperty.call(aData, key)) {
                  if (key === "icaltype")
                    continue;
                  this[key] = aData[key];
                }
              }
            }
            if (aZone) {
              this.zone = aZone;
            }
            if (aData && !("isDate" in aData)) {
              this.isDate = !("hour" in aData);
            } else if (aData && "isDate" in aData) {
              this.isDate = aData.isDate;
            }
            if (aData && "timezone" in aData) {
              var zone = ICAL.TimezoneService.get(aData.timezone);
              this.zone = zone || ICAL.Timezone.localTimezone;
            }
            if (aData && "zone" in aData) {
              this.zone = aData.zone;
            }
            if (!this.zone) {
              this.zone = ICAL.Timezone.localTimezone;
            }
            this._cachedUnixTime = null;
            return this;
          },
          dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {
            var firstDow = aWeekStart || ICAL.Time.SUNDAY;
            var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;
            if (dowCacheKey in ICAL.Time._dowCache) {
              return ICAL.Time._dowCache[dowCacheKey];
            }
            var q = this.day;
            var m = this.month + (this.month < 3 ? 12 : 0);
            var Y = this.year - (this.month < 3 ? 1 : 0);
            var h = q + Y + ICAL.helpers.trunc((m + 1) * 26 / 10) + ICAL.helpers.trunc(Y / 4);
            if (true) {
              h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);
            } else {
              h += 5;
            }
            h = (h + 7 - firstDow) % 7 + 1;
            ICAL.Time._dowCache[dowCacheKey] = h;
            return h;
          },
          dayOfYear: function dayOfYear() {
            var is_leap = ICAL.Time.isLeapYear(this.year) ? 1 : 0;
            var diypm = ICAL.Time.daysInYearPassedMonth;
            return diypm[is_leap][this.month - 1] + this.day;
          },
          startOfWeek: function startOfWeek(aWeekStart) {
            var firstDow = aWeekStart || ICAL.Time.SUNDAY;
            var result = this.clone();
            result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;
            result.isDate = true;
            result.hour = 0;
            result.minute = 0;
            result.second = 0;
            return result;
          },
          endOfWeek: function endOfWeek(aWeekStart) {
            var firstDow = aWeekStart || ICAL.Time.SUNDAY;
            var result = this.clone();
            result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;
            result.isDate = true;
            result.hour = 0;
            result.minute = 0;
            result.second = 0;
            return result;
          },
          startOfMonth: function startOfMonth() {
            var result = this.clone();
            result.day = 1;
            result.isDate = true;
            result.hour = 0;
            result.minute = 0;
            result.second = 0;
            return result;
          },
          endOfMonth: function endOfMonth() {
            var result = this.clone();
            result.day = ICAL.Time.daysInMonth(result.month, result.year);
            result.isDate = true;
            result.hour = 0;
            result.minute = 0;
            result.second = 0;
            return result;
          },
          startOfYear: function startOfYear() {
            var result = this.clone();
            result.day = 1;
            result.month = 1;
            result.isDate = true;
            result.hour = 0;
            result.minute = 0;
            result.second = 0;
            return result;
          },
          endOfYear: function endOfYear() {
            var result = this.clone();
            result.day = 31;
            result.month = 12;
            result.isDate = true;
            result.hour = 0;
            result.minute = 0;
            result.second = 0;
            return result;
          },
          startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {
            var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;
            var delta = this.dayOfWeek() - firstDow;
            if (delta < 0)
              delta += 7;
            return this.dayOfYear() - delta;
          },
          getDominicalLetter: function() {
            return ICAL.Time.getDominicalLetter(this.year);
          },
          nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {
            var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);
            var weekday;
            var pos = aPos;
            var start = 0;
            var otherDay = this.clone();
            if (pos >= 0) {
              otherDay.day = 1;
              if (pos != 0) {
                pos--;
              }
              start = otherDay.day;
              var startDow = otherDay.dayOfWeek();
              var offset = aDayOfWeek - startDow;
              if (offset < 0)
                offset += 7;
              start += offset;
              start -= aDayOfWeek;
              weekday = aDayOfWeek;
            } else {
              otherDay.day = daysInMonth;
              var endDow = otherDay.dayOfWeek();
              pos++;
              weekday = endDow - aDayOfWeek;
              if (weekday < 0) {
                weekday += 7;
              }
              weekday = daysInMonth - weekday;
            }
            weekday += pos * 7;
            return start + weekday;
          },
          isNthWeekDay: function(aDayOfWeek, aPos) {
            var dow = this.dayOfWeek();
            if (aPos === 0 && dow === aDayOfWeek) {
              return true;
            }
            var day = this.nthWeekDay(aDayOfWeek, aPos);
            if (day === this.day) {
              return true;
            }
            return false;
          },
          weekNumber: function weekNumber(aWeekStart) {
            var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;
            if (wnCacheKey in ICAL.Time._wnCache) {
              return ICAL.Time._wnCache[wnCacheKey];
            }
            var week1;
            var dt = this.clone();
            dt.isDate = true;
            var isoyear = this.year;
            if (dt.month == 12 && dt.day > 25) {
              week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);
              if (dt.compare(week1) < 0) {
                week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);
              } else {
                isoyear++;
              }
            } else {
              week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);
              if (dt.compare(week1) < 0) {
                week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);
              }
            }
            var daysBetween = dt.subtractDate(week1).toSeconds() / 86400;
            var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;
            ICAL.Time._wnCache[wnCacheKey] = answer;
            return answer;
          },
          addDuration: function icaltime_add(aDuration) {
            var mult = aDuration.isNegative ? -1 : 1;
            var second = this.second;
            var minute = this.minute;
            var hour = this.hour;
            var day = this.day;
            second += mult * aDuration.seconds;
            minute += mult * aDuration.minutes;
            hour += mult * aDuration.hours;
            day += mult * aDuration.days;
            day += mult * 7 * aDuration.weeks;
            this.second = second;
            this.minute = minute;
            this.hour = hour;
            this.day = day;
            this._cachedUnixTime = null;
          },
          subtractDate: function icaltime_subtract(aDate) {
            var unixTime = this.toUnixTime() + this.utcOffset();
            var other = aDate.toUnixTime() + aDate.utcOffset();
            return ICAL.Duration.fromSeconds(unixTime - other);
          },
          subtractDateTz: function icaltime_subtract_abs(aDate) {
            var unixTime = this.toUnixTime();
            var other = aDate.toUnixTime();
            return ICAL.Duration.fromSeconds(unixTime - other);
          },
          compare: function icaltime_compare(other) {
            var a = this.toUnixTime();
            var b = other.toUnixTime();
            if (a > b)
              return 1;
            if (b > a)
              return -1;
            return 0;
          },
          compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {
            function cmp(attr) {
              return ICAL.Time._cmp_attr(a, b, attr);
            }
            var a = this.convertToZone(tz);
            var b = other.convertToZone(tz);
            var rc = 0;
            if ((rc = cmp("year")) != 0)
              return rc;
            if ((rc = cmp("month")) != 0)
              return rc;
            if ((rc = cmp("day")) != 0)
              return rc;
            return rc;
          },
          convertToZone: function convertToZone(zone) {
            var copy = this.clone();
            var zone_equals = this.zone.tzid == zone.tzid;
            if (!this.isDate && !zone_equals) {
              ICAL.Timezone.convert_time(copy, this.zone, zone);
            }
            copy.zone = zone;
            return copy;
          },
          utcOffset: function utc_offset() {
            if (this.zone == ICAL.Timezone.localTimezone || this.zone == ICAL.Timezone.utcTimezone) {
              return 0;
            } else {
              return this.zone.utcOffset(this);
            }
          },
          toICALString: function() {
            var string = this.toString();
            if (string.length > 10) {
              return ICAL.design.icalendar.value["date-time"].toICAL(string);
            } else {
              return ICAL.design.icalendar.value.date.toICAL(string);
            }
          },
          toString: function toString() {
            var result = this.year + "-" + ICAL.helpers.pad2(this.month) + "-" + ICAL.helpers.pad2(this.day);
            if (!this.isDate) {
              result += "T" + ICAL.helpers.pad2(this.hour) + ":" + ICAL.helpers.pad2(this.minute) + ":" + ICAL.helpers.pad2(this.second);
              if (this.zone === ICAL.Timezone.utcTimezone) {
                result += "Z";
              }
            }
            return result;
          },
          toJSDate: function toJSDate() {
            if (this.zone == ICAL.Timezone.localTimezone) {
              if (this.isDate) {
                return new Date(this.year, this.month - 1, this.day);
              } else {
                return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, 0);
              }
            } else {
              return new Date(this.toUnixTime() * 1e3);
            }
          },
          _normalize: function icaltime_normalize() {
            var isDate = this._time.isDate;
            if (this._time.isDate) {
              this._time.hour = 0;
              this._time.minute = 0;
              this._time.second = 0;
            }
            this.adjust(0, 0, 0, 0);
            return this;
          },
          adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {
            var minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;
            var second, minute, hour, day;
            var daysInMonth;
            var time = aTime || this._time;
            if (!time.isDate) {
              second = time.second + aExtraSeconds;
              time.second = second % 60;
              minutesOverflow = ICAL.helpers.trunc(second / 60);
              if (time.second < 0) {
                time.second += 60;
                minutesOverflow--;
              }
              minute = time.minute + aExtraMinutes + minutesOverflow;
              time.minute = minute % 60;
              hoursOverflow = ICAL.helpers.trunc(minute / 60);
              if (time.minute < 0) {
                time.minute += 60;
                hoursOverflow--;
              }
              hour = time.hour + aExtraHours + hoursOverflow;
              time.hour = hour % 24;
              daysOverflow = ICAL.helpers.trunc(hour / 24);
              if (time.hour < 0) {
                time.hour += 24;
                daysOverflow--;
              }
            }
            if (time.month > 12) {
              yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);
            } else if (time.month < 1) {
              yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;
            }
            time.year += yearsOverflow;
            time.month -= 12 * yearsOverflow;
            day = time.day + aExtraDays + daysOverflow;
            if (day > 0) {
              for (; ; ) {
                daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);
                if (day <= daysInMonth) {
                  break;
                }
                time.month++;
                if (time.month > 12) {
                  time.year++;
                  time.month = 1;
                }
                day -= daysInMonth;
              }
            } else {
              while (day <= 0) {
                if (time.month == 1) {
                  time.year--;
                  time.month = 12;
                } else {
                  time.month--;
                }
                day += ICAL.Time.daysInMonth(time.month, time.year);
              }
            }
            time.day = day;
            this._cachedUnixTime = null;
            return this;
          },
          fromUnixTime: function fromUnixTime(seconds) {
            this.zone = ICAL.Timezone.utcTimezone;
            var epoch = ICAL.Time.epochTime.clone();
            epoch.adjust(0, 0, 0, seconds);
            this.year = epoch.year;
            this.month = epoch.month;
            this.day = epoch.day;
            this.hour = epoch.hour;
            this.minute = epoch.minute;
            this.second = Math.floor(epoch.second);
            this._cachedUnixTime = null;
          },
          toUnixTime: function toUnixTime() {
            if (this._cachedUnixTime !== null) {
              return this._cachedUnixTime;
            }
            var offset = this.utcOffset();
            var ms = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second - offset);
            this._cachedUnixTime = ms / 1e3;
            return this._cachedUnixTime;
          },
          toJSON: function() {
            var copy = [
              "year",
              "month",
              "day",
              "hour",
              "minute",
              "second",
              "isDate"
            ];
            var result = Object.create(null);
            var i = 0;
            var len = copy.length;
            var prop;
            for (; i < len; i++) {
              prop = copy[i];
              result[prop] = this[prop];
            }
            if (this.zone) {
              result.timezone = this.zone.tzid;
            }
            return result;
          }
        };
        (function setupNormalizeAttributes() {
          function defineAttr(attr) {
            Object.defineProperty(ICAL.Time.prototype, attr, {
              get: function getTimeAttr() {
                if (this._pendingNormalization) {
                  this._normalize();
                  this._pendingNormalization = false;
                }
                return this._time[attr];
              },
              set: function setTimeAttr(val) {
                if (attr === "isDate" && val && !this._time.isDate) {
                  this.adjust(0, 0, 0, 0);
                }
                this._cachedUnixTime = null;
                this._pendingNormalization = true;
                this._time[attr] = val;
                return val;
              }
            });
          }
          if ("defineProperty" in Object) {
            defineAttr("year");
            defineAttr("month");
            defineAttr("day");
            defineAttr("hour");
            defineAttr("minute");
            defineAttr("second");
            defineAttr("isDate");
          }
        })();
        ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {
          var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var days = 30;
          if (month < 1 || month > 12)
            return days;
          days = _daysInMonth[month];
          if (month == 2) {
            days += ICAL.Time.isLeapYear(year);
          }
          return days;
        };
        ICAL.Time.isLeapYear = function isLeapYear(year) {
          if (year <= 1752) {
            return year % 4 == 0;
          } else {
            return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
          }
        };
        ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {
          var year = aYear;
          var doy = aDayOfYear;
          var tt = new ICAL.Time();
          tt.auto_normalize = false;
          var is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;
          if (doy < 1) {
            year--;
            is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;
            doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];
            return ICAL.Time.fromDayOfYear(doy, year);
          } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {
            is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;
            doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];
            year++;
            return ICAL.Time.fromDayOfYear(doy, year);
          }
          tt.year = year;
          tt.isDate = true;
          for (var month = 11; month >= 0; month--) {
            if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {
              tt.month = month + 1;
              tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];
              break;
            }
          }
          tt.auto_normalize = true;
          return tt;
        };
        ICAL.Time.fromStringv2 = function fromString(str) {
          return new ICAL.Time({
            year: parseInt(str.substr(0, 4), 10),
            month: parseInt(str.substr(5, 2), 10),
            day: parseInt(str.substr(8, 2), 10),
            isDate: true
          });
        };
        ICAL.Time.fromDateString = function(aValue) {
          return new ICAL.Time({
            year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),
            month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),
            day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),
            isDate: true
          });
        };
        ICAL.Time.fromDateTimeString = function(aValue, prop) {
          if (aValue.length < 19) {
            throw new Error('invalid date-time value: "' + aValue + '"');
          }
          var zone;
          if (aValue[19] && aValue[19] === "Z") {
            zone = "Z";
          } else if (prop) {
            zone = prop.getParameter("tzid");
          }
          var time = new ICAL.Time({
            year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),
            month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),
            day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),
            hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),
            minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),
            second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),
            timezone: zone
          });
          return time;
        };
        ICAL.Time.fromString = function fromString(aValue, aProperty) {
          if (aValue.length > 10) {
            return ICAL.Time.fromDateTimeString(aValue, aProperty);
          } else {
            return ICAL.Time.fromDateString(aValue);
          }
        };
        ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {
          var tt = new ICAL.Time();
          return tt.fromJSDate(aDate, useUTC);
        };
        ICAL.Time.fromData = function fromData(aData, aZone) {
          var t = new ICAL.Time();
          return t.fromData(aData, aZone);
        };
        ICAL.Time.now = function icaltime_now() {
          return ICAL.Time.fromJSDate(new Date(), false);
        };
        ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {
          var t = ICAL.Time.fromData({
            year: aYear,
            month: 1,
            day: 1,
            isDate: true
          });
          var dow = t.dayOfWeek();
          var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;
          if (dow > ICAL.Time.THURSDAY) {
            t.day += 7;
          }
          if (wkst > ICAL.Time.THURSDAY) {
            t.day -= 7;
          }
          t.day -= dow - wkst;
          return t;
        };
        ICAL.Time.getDominicalLetter = function(yr) {
          var LTRS = "GFEDCBA";
          var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;
          var isLeap = ICAL.Time.isLeapYear(yr);
          if (isLeap) {
            return LTRS[(dom + 6) % 7] + LTRS[dom];
          } else {
            return LTRS[dom];
          }
        };
        ICAL.Time.epochTime = ICAL.Time.fromData({
          year: 1970,
          month: 1,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          isDate: false,
          timezone: "Z"
        });
        ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {
          if (a[attr] > b[attr])
            return 1;
          if (a[attr] < b[attr])
            return -1;
          return 0;
        };
        ICAL.Time.daysInYearPassedMonth = [
          [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
          [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
        ];
        ICAL.Time.SUNDAY = 1;
        ICAL.Time.MONDAY = 2;
        ICAL.Time.TUESDAY = 3;
        ICAL.Time.WEDNESDAY = 4;
        ICAL.Time.THURSDAY = 5;
        ICAL.Time.FRIDAY = 6;
        ICAL.Time.SATURDAY = 7;
        ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;
      })();
      (function() {
        ICAL.VCardTime = function(data, zone, icaltype) {
          this.wrappedJSObject = this;
          var time = this._time = Object.create(null);
          time.year = null;
          time.month = null;
          time.day = null;
          time.hour = null;
          time.minute = null;
          time.second = null;
          this.icaltype = icaltype || "date-and-or-time";
          this.fromData(data, zone);
        };
        ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, {
          icalclass: "vcardtime",
          icaltype: "date-and-or-time",
          zone: null,
          clone: function() {
            return new ICAL.VCardTime(this._time, this.zone, this.icaltype);
          },
          _normalize: function() {
            return this;
          },
          utcOffset: function() {
            if (this.zone instanceof ICAL.UtcOffset) {
              return this.zone.toSeconds();
            } else {
              return ICAL.Time.prototype.utcOffset.apply(this, arguments);
            }
          },
          toICALString: function() {
            return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());
          },
          toString: function toString() {
            var p2 = ICAL.helpers.pad2;
            var y = this.year, m = this.month, d = this.day;
            var h = this.hour, mm = this.minute, s = this.second;
            var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;
            var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;
            var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? "-" : "") : hasMonth || hasDay ? "--" : "") + (hasMonth ? p2(m) : "") + (hasDay ? "-" + p2(d) : "");
            var timepart = (hasHour ? p2(h) : "-") + (hasHour && hasMinute ? ":" : "") + (hasMinute ? p2(mm) : "") + (!hasHour && !hasMinute ? "-" : "") + (hasMinute && hasSecond ? ":" : "") + (hasSecond ? p2(s) : "");
            var zone;
            if (this.zone === ICAL.Timezone.utcTimezone) {
              zone = "Z";
            } else if (this.zone instanceof ICAL.UtcOffset) {
              zone = this.zone.toString();
            } else if (this.zone === ICAL.Timezone.localTimezone) {
              zone = "";
            } else if (this.zone instanceof ICAL.Timezone) {
              var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));
              zone = offset.toString();
            } else {
              zone = "";
            }
            switch (this.icaltype) {
              case "time":
                return timepart + zone;
              case "date-and-or-time":
              case "date-time":
                return datepart + (timepart == "--" ? "" : "T" + timepart + zone);
              case "date":
                return datepart;
            }
            return null;
          }
        });
        ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {
          function part(v, s, e) {
            return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;
          }
          var parts = aValue.split("T");
          var dt = parts[0], tmz = parts[1];
          var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];
          var zone = splitzone[0], tm = splitzone[1];
          var stoi = ICAL.helpers.strictParseInt;
          var dtlen = dt ? dt.length : 0;
          var tmlen = tm ? tm.length : 0;
          var hasDashDate = dt && dt[0] == "-" && dt[1] == "-";
          var hasDashTime = tm && tm[0] == "-";
          var o = {
            year: hasDashDate ? null : part(dt, 0, 4),
            month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,
            day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,
            hour: hasDashTime ? null : part(tm, 0, 2),
            minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,
            second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null
          };
          if (zone == "Z") {
            zone = ICAL.Timezone.utcTimezone;
          } else if (zone && zone[3] == ":") {
            zone = ICAL.UtcOffset.fromString(zone);
          } else {
            zone = null;
          }
          return new ICAL.VCardTime(o, zone, aIcalType);
        };
      })();
      (function() {
        var DOW_MAP = {
          SU: ICAL.Time.SUNDAY,
          MO: ICAL.Time.MONDAY,
          TU: ICAL.Time.TUESDAY,
          WE: ICAL.Time.WEDNESDAY,
          TH: ICAL.Time.THURSDAY,
          FR: ICAL.Time.FRIDAY,
          SA: ICAL.Time.SATURDAY
        };
        var REVERSE_DOW_MAP = {};
        for (var key in DOW_MAP) {
          if (DOW_MAP.hasOwnProperty(key)) {
            REVERSE_DOW_MAP[DOW_MAP[key]] = key;
          }
        }
        var COPY_PARTS = [
          "BYSECOND",
          "BYMINUTE",
          "BYHOUR",
          "BYDAY",
          "BYMONTHDAY",
          "BYYEARDAY",
          "BYWEEKNO",
          "BYMONTH",
          "BYSETPOS"
        ];
        ICAL.Recur = function icalrecur(data) {
          this.wrappedJSObject = this;
          this.parts = {};
          if (data && typeof data === "object") {
            this.fromData(data);
          }
        };
        ICAL.Recur.prototype = {
          parts: null,
          interval: 1,
          wkst: ICAL.Time.MONDAY,
          until: null,
          count: null,
          freq: null,
          icalclass: "icalrecur",
          icaltype: "recur",
          iterator: function(aStart) {
            return new ICAL.RecurIterator({
              rule: this,
              dtstart: aStart
            });
          },
          clone: function clone() {
            return new ICAL.Recur(this.toJSON());
          },
          isFinite: function isfinite() {
            return !!(this.count || this.until);
          },
          isByCount: function isbycount() {
            return !!(this.count && !this.until);
          },
          addComponent: function addPart(aType, aValue) {
            var ucname = aType.toUpperCase();
            if (ucname in this.parts) {
              this.parts[ucname].push(aValue);
            } else {
              this.parts[ucname] = [aValue];
            }
          },
          setComponent: function setComponent(aType, aValues) {
            this.parts[aType.toUpperCase()] = aValues.slice();
          },
          getComponent: function getComponent(aType) {
            var ucname = aType.toUpperCase();
            return ucname in this.parts ? this.parts[ucname].slice() : [];
          },
          getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {
            var iter = this.iterator(aStartTime);
            var next, cdt;
            do {
              next = iter.next();
            } while (next && next.compare(aRecurrenceId) <= 0);
            if (next && aRecurrenceId.zone) {
              next.zone = aRecurrenceId.zone;
            }
            return next;
          },
          fromData: function(data) {
            for (var key2 in data) {
              var uckey = key2.toUpperCase();
              if (uckey in partDesign) {
                if (Array.isArray(data[key2])) {
                  this.parts[uckey] = data[key2];
                } else {
                  this.parts[uckey] = [data[key2]];
                }
              } else {
                this[key2] = data[key2];
              }
            }
            if (this.interval && typeof this.interval != "number") {
              optionDesign.INTERVAL(this.interval, this);
            }
            if (this.wkst && typeof this.wkst != "number") {
              this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);
            }
            if (this.until && !(this.until instanceof ICAL.Time)) {
              this.until = ICAL.Time.fromString(this.until);
            }
          },
          toJSON: function() {
            var res = Object.create(null);
            res.freq = this.freq;
            if (this.count) {
              res.count = this.count;
            }
            if (this.interval > 1) {
              res.interval = this.interval;
            }
            for (var k in this.parts) {
              if (!this.parts.hasOwnProperty(k)) {
                continue;
              }
              var kparts = this.parts[k];
              if (Array.isArray(kparts) && kparts.length == 1) {
                res[k.toLowerCase()] = kparts[0];
              } else {
                res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);
              }
            }
            if (this.until) {
              res.until = this.until.toString();
            }
            if ("wkst" in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {
              res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);
            }
            return res;
          },
          toString: function icalrecur_toString() {
            var str = "FREQ=" + this.freq;
            if (this.count) {
              str += ";COUNT=" + this.count;
            }
            if (this.interval > 1) {
              str += ";INTERVAL=" + this.interval;
            }
            for (var k in this.parts) {
              if (this.parts.hasOwnProperty(k)) {
                str += ";" + k + "=" + this.parts[k];
              }
            }
            if (this.until) {
              str += ";UNTIL=" + this.until.toICALString();
            }
            if ("wkst" in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {
              str += ";WKST=" + ICAL.Recur.numericDayToIcalDay(this.wkst);
            }
            return str;
          }
        };
        function parseNumericValue(type, min, max, value) {
          var result = value;
          if (value[0] === "+") {
            result = value.substr(1);
          }
          result = ICAL.helpers.strictParseInt(result);
          if (min !== void 0 && value < min) {
            throw new Error(type + ': invalid value "' + value + '" must be > ' + min);
          }
          if (max !== void 0 && value > max) {
            throw new Error(type + ': invalid value "' + value + '" must be < ' + min);
          }
          return result;
        }
        ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {
          var firstDow = aWeekStart || ICAL.Time.SUNDAY;
          return (DOW_MAP[string] - firstDow + 7) % 7 + 1;
        };
        ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {
          var firstDow = aWeekStart || ICAL.Time.SUNDAY;
          var dow = num + firstDow - ICAL.Time.SUNDAY;
          if (dow > 7) {
            dow -= 7;
          }
          return REVERSE_DOW_MAP[dow];
        };
        var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;
        var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
        var ALLOWED_FREQ = [
          "SECONDLY",
          "MINUTELY",
          "HOURLY",
          "DAILY",
          "WEEKLY",
          "MONTHLY",
          "YEARLY"
        ];
        var optionDesign = {
          FREQ: function(value, dict, fmtIcal) {
            if (ALLOWED_FREQ.indexOf(value) !== -1) {
              dict.freq = value;
            } else {
              throw new Error('invalid frequency "' + value + '" expected: "' + ALLOWED_FREQ.join(", ") + '"');
            }
          },
          COUNT: function(value, dict, fmtIcal) {
            dict.count = ICAL.helpers.strictParseInt(value);
          },
          INTERVAL: function(value, dict, fmtIcal) {
            dict.interval = ICAL.helpers.strictParseInt(value);
            if (dict.interval < 1) {
              dict.interval = 1;
            }
          },
          UNTIL: function(value, dict, fmtIcal) {
            if (value.length > 10) {
              dict.until = ICAL.design.icalendar.value["date-time"].fromICAL(value);
            } else {
              dict.until = ICAL.design.icalendar.value.date.fromICAL(value);
            }
            if (!fmtIcal) {
              dict.until = ICAL.Time.fromString(dict.until);
            }
          },
          WKST: function(value, dict, fmtIcal) {
            if (VALID_DAY_NAMES.test(value)) {
              dict.wkst = ICAL.Recur.icalDayToNumericDay(value);
            } else {
              throw new Error('invalid WKST value "' + value + '"');
            }
          }
        };
        var partDesign = {
          BYSECOND: parseNumericValue.bind(this, "BYSECOND", 0, 60),
          BYMINUTE: parseNumericValue.bind(this, "BYMINUTE", 0, 59),
          BYHOUR: parseNumericValue.bind(this, "BYHOUR", 0, 23),
          BYDAY: function(value) {
            if (VALID_BYDAY_PART.test(value)) {
              return value;
            } else {
              throw new Error('invalid BYDAY value "' + value + '"');
            }
          },
          BYMONTHDAY: parseNumericValue.bind(this, "BYMONTHDAY", -31, 31),
          BYYEARDAY: parseNumericValue.bind(this, "BYYEARDAY", -366, 366),
          BYWEEKNO: parseNumericValue.bind(this, "BYWEEKNO", -53, 53),
          BYMONTH: parseNumericValue.bind(this, "BYMONTH", 0, 12),
          BYSETPOS: parseNumericValue.bind(this, "BYSETPOS", -366, 366)
        };
        ICAL.Recur.fromString = function(string) {
          var data = ICAL.Recur._stringToData(string, false);
          return new ICAL.Recur(data);
        };
        ICAL.Recur.fromData = function(aData) {
          return new ICAL.Recur(aData);
        };
        ICAL.Recur._stringToData = function(string, fmtIcal) {
          var dict = Object.create(null);
          var values = string.split(";");
          var len = values.length;
          for (var i = 0; i < len; i++) {
            var parts = values[i].split("=");
            var ucname = parts[0].toUpperCase();
            var lcname = parts[0].toLowerCase();
            var name = fmtIcal ? lcname : ucname;
            var value = parts[1];
            if (ucname in partDesign) {
              var partArr = value.split(",");
              var partArrIdx = 0;
              var partArrLen = partArr.length;
              for (; partArrIdx < partArrLen; partArrIdx++) {
                partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);
              }
              dict[name] = partArr.length == 1 ? partArr[0] : partArr;
            } else if (ucname in optionDesign) {
              optionDesign[ucname](value, dict, fmtIcal);
            } else {
              dict[lcname] = value;
            }
          }
          return dict;
        };
      })();
      ICAL.RecurIterator = function() {
        function icalrecur_iterator(options) {
          this.fromData(options);
        }
        icalrecur_iterator.prototype = {
          completed: false,
          rule: null,
          dtstart: null,
          last: null,
          occurrence_number: 0,
          by_indices: null,
          initialized: false,
          by_data: null,
          days: null,
          days_index: 0,
          fromData: function(options) {
            this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);
            if (!this.rule) {
              throw new Error("iterator requires a (ICAL.Recur) rule");
            }
            this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);
            if (!this.dtstart) {
              throw new Error("iterator requires a (ICAL.Time) dtstart");
            }
            if (options.by_data) {
              this.by_data = options.by_data;
            } else {
              this.by_data = ICAL.helpers.clone(this.rule.parts, true);
            }
            if (options.occurrence_number)
              this.occurrence_number = options.occurrence_number;
            this.days = options.days || [];
            if (options.last) {
              this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);
            }
            this.by_indices = options.by_indices;
            if (!this.by_indices) {
              this.by_indices = {
                "BYSECOND": 0,
                "BYMINUTE": 0,
                "BYHOUR": 0,
                "BYDAY": 0,
                "BYMONTH": 0,
                "BYWEEKNO": 0,
                "BYMONTHDAY": 0
              };
            }
            this.initialized = options.initialized || false;
            if (!this.initialized) {
              this.init();
            }
          },
          init: function icalrecur_iterator_init() {
            this.initialized = true;
            this.last = this.dtstart.clone();
            var parts = this.by_data;
            if ("BYDAY" in parts) {
              this.sort_byday_rules(parts.BYDAY);
            }
            if ("BYYEARDAY" in parts) {
              if ("BYMONTH" in parts || "BYWEEKNO" in parts || "BYMONTHDAY" in parts || "BYDAY" in parts) {
                throw new Error("Invalid BYYEARDAY rule");
              }
            }
            if ("BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
              throw new Error("BYWEEKNO does not fit to BYMONTHDAY");
            }
            if (this.rule.freq == "MONTHLY" && ("BYYEARDAY" in parts || "BYWEEKNO" in parts)) {
              throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear");
            }
            if (this.rule.freq == "WEEKLY" && ("BYYEARDAY" in parts || "BYMONTHDAY" in parts)) {
              throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear");
            }
            if (this.rule.freq != "YEARLY" && "BYYEARDAY" in parts) {
              throw new Error("BYYEARDAY may only appear in YEARLY rules");
            }
            this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second);
            this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute);
            this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour);
            this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day);
            this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month);
            if (this.rule.freq == "WEEKLY") {
              if ("BYDAY" in parts) {
                var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);
                var pos = bydayParts[0];
                var dow = bydayParts[1];
                var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);
                if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {
                  this.last.day += wkdy;
                }
              } else {
                var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());
                parts.BYDAY = [dayName];
              }
            }
            if (this.rule.freq == "YEARLY") {
              for (; ; ) {
                this.expand_year_days(this.last.year);
                if (this.days.length > 0) {
                  break;
                }
                this.increment_year(this.rule.interval);
              }
              this._nextByYearDay();
            }
            if (this.rule.freq == "MONTHLY" && this.has_by_data("BYDAY")) {
              var tempLast = null;
              var initLast = this.last.clone();
              var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
              for (var i in this.by_data.BYDAY) {
                if (!this.by_data.BYDAY.hasOwnProperty(i)) {
                  continue;
                }
                this.last = initLast.clone();
                var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);
                var pos = bydayParts[0];
                var dow = bydayParts[1];
                var dayOfMonth = this.last.nthWeekDay(dow, pos);
                if (pos >= 6 || pos <= -6) {
                  throw new Error("Malformed values in BYDAY part");
                }
                if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                  if (tempLast && tempLast.month == initLast.month) {
                    continue;
                  }
                  while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                    this.increment_month();
                    daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
                    dayOfMonth = this.last.nthWeekDay(dow, pos);
                  }
                }
                this.last.day = dayOfMonth;
                if (!tempLast || this.last.compare(tempLast) < 0) {
                  tempLast = this.last.clone();
                }
              }
              this.last = tempLast.clone();
              if (this.has_by_data("BYMONTHDAY")) {
                this._byDayAndMonthDay(true);
              }
              if (this.last.day > daysInMonth || this.last.day == 0) {
                throw new Error("Malformed values in BYDAY part");
              }
            } else if (this.has_by_data("BYMONTHDAY")) {
              if (this.last.day < 0) {
                var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
                this.last.day = daysInMonth + this.last.day + 1;
              }
            }
          },
          next: function icalrecur_iterator_next() {
            var before = this.last ? this.last.clone() : null;
            if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {
              this.completed = true;
              return null;
            }
            if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {
              this.occurrence_number++;
              return this.last;
            }
            var valid;
            do {
              valid = 1;
              switch (this.rule.freq) {
                case "SECONDLY":
                  this.next_second();
                  break;
                case "MINUTELY":
                  this.next_minute();
                  break;
                case "HOURLY":
                  this.next_hour();
                  break;
                case "DAILY":
                  this.next_day();
                  break;
                case "WEEKLY":
                  this.next_week();
                  break;
                case "MONTHLY":
                  valid = this.next_month();
                  break;
                case "YEARLY":
                  this.next_year();
                  break;
                default:
                  return null;
              }
            } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);
            if (this.last.compare(before) == 0) {
              throw new Error("Same occurrence found twice, protecting you from death by recursion");
            }
            if (this.rule.until && this.last.compare(this.rule.until) > 0) {
              this.completed = true;
              return null;
            } else {
              this.occurrence_number++;
              return this.last;
            }
          },
          next_second: function next_second() {
            return this.next_generic("BYSECOND", "SECONDLY", "second", "minute");
          },
          increment_second: function increment_second(inc) {
            return this.increment_generic(inc, "second", 60, "minute");
          },
          next_minute: function next_minute() {
            return this.next_generic("BYMINUTE", "MINUTELY", "minute", "hour", "next_second");
          },
          increment_minute: function increment_minute(inc) {
            return this.increment_generic(inc, "minute", 60, "hour");
          },
          next_hour: function next_hour() {
            return this.next_generic("BYHOUR", "HOURLY", "hour", "monthday", "next_minute");
          },
          increment_hour: function increment_hour(inc) {
            this.increment_generic(inc, "hour", 24, "monthday");
          },
          next_day: function next_day() {
            var has_by_day = "BYDAY" in this.by_data;
            var this_freq = this.rule.freq == "DAILY";
            if (this.next_hour() == 0) {
              return 0;
            }
            if (this_freq) {
              this.increment_monthday(this.rule.interval);
            } else {
              this.increment_monthday(1);
            }
            return 0;
          },
          next_week: function next_week() {
            var end_of_data = 0;
            if (this.next_weekday_by_week() == 0) {
              return end_of_data;
            }
            if (this.has_by_data("BYWEEKNO")) {
              var idx = ++this.by_indices.BYWEEKNO;
              if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {
                this.by_indices.BYWEEKNO = 0;
                end_of_data = 1;
              }
              this.last.month = 1;
              this.last.day = 1;
              var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];
              this.last.day += 7 * week_no;
              if (end_of_data) {
                this.increment_year(1);
              }
            } else {
              this.increment_monthday(7 * this.rule.interval);
            }
            return end_of_data;
          },
          normalizeByMonthDayRules: function(year, month, rules) {
            var daysInMonth = ICAL.Time.daysInMonth(month, year);
            var newRules = [];
            var ruleIdx = 0;
            var len = rules.length;
            var rule;
            for (; ruleIdx < len; ruleIdx++) {
              rule = rules[ruleIdx];
              if (Math.abs(rule) > daysInMonth) {
                continue;
              }
              if (rule < 0) {
                rule = daysInMonth + (rule + 1);
              } else if (rule === 0) {
                continue;
              }
              if (newRules.indexOf(rule) === -1) {
                newRules.push(rule);
              }
            }
            return newRules.sort(function(a, b) {
              return a - b;
            });
          },
          _byDayAndMonthDay: function(isInit) {
            var byMonthDay;
            var byDay = this.by_data.BYDAY;
            var date;
            var dateIdx = 0;
            var dateLen;
            var dayLen = byDay.length;
            var dataIsValid = 0;
            var daysInMonth;
            var self2 = this;
            var lastDay = this.last.day;
            function initMonth() {
              daysInMonth = ICAL.Time.daysInMonth(self2.last.month, self2.last.year);
              byMonthDay = self2.normalizeByMonthDayRules(self2.last.year, self2.last.month, self2.by_data.BYMONTHDAY);
              dateLen = byMonthDay.length;
              while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {
                dateIdx++;
              }
            }
            function nextMonth() {
              lastDay = 0;
              self2.increment_month();
              dateIdx = 0;
              initMonth();
            }
            initMonth();
            if (isInit) {
              lastDay -= 1;
            }
            var monthsCounter = 48;
            while (!dataIsValid && monthsCounter) {
              monthsCounter--;
              date = lastDay + 1;
              if (date > daysInMonth) {
                nextMonth();
                continue;
              }
              var next = byMonthDay[dateIdx++];
              if (next >= date) {
                lastDay = next;
              } else {
                nextMonth();
                continue;
              }
              for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {
                var parts = this.ruleDayOfWeek(byDay[dayIdx]);
                var pos = parts[0];
                var dow = parts[1];
                this.last.day = lastDay;
                if (this.last.isNthWeekDay(dow, pos)) {
                  dataIsValid = 1;
                  break;
                }
              }
              if (!dataIsValid && dateIdx === dateLen) {
                nextMonth();
                continue;
              }
            }
            if (monthsCounter <= 0) {
              throw new Error("Malformed values in BYDAY combined with BYMONTHDAY parts");
            }
            return dataIsValid;
          },
          next_month: function next_month() {
            var this_freq = this.rule.freq == "MONTHLY";
            var data_valid = 1;
            if (this.next_hour() == 0) {
              return data_valid;
            }
            if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) {
              data_valid = this._byDayAndMonthDay();
            } else if (this.has_by_data("BYDAY")) {
              var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
              var setpos = 0;
              var setpos_total = 0;
              if (this.has_by_data("BYSETPOS")) {
                var last_day = this.last.day;
                for (var day = 1; day <= daysInMonth; day++) {
                  this.last.day = day;
                  if (this.is_day_in_byday(this.last)) {
                    setpos_total++;
                    if (day <= last_day) {
                      setpos++;
                    }
                  }
                }
                this.last.day = last_day;
              }
              data_valid = 0;
              for (var day = this.last.day + 1; day <= daysInMonth; day++) {
                this.last.day = day;
                if (this.is_day_in_byday(this.last)) {
                  if (!this.has_by_data("BYSETPOS") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {
                    data_valid = 1;
                    break;
                  }
                }
              }
              if (day > daysInMonth) {
                this.last.day = 1;
                this.increment_month();
                if (this.is_day_in_byday(this.last)) {
                  if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) {
                    data_valid = 1;
                  }
                } else {
                  data_valid = 0;
                }
              }
            } else if (this.has_by_data("BYMONTHDAY")) {
              this.by_indices.BYMONTHDAY++;
              if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
                this.by_indices.BYMONTHDAY = 0;
                this.increment_month();
              }
              var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
              var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];
              if (day < 0) {
                day = daysInMonth + day + 1;
              }
              if (day > daysInMonth) {
                this.last.day = 1;
                data_valid = this.is_day_in_byday(this.last);
              } else {
                this.last.day = day;
              }
            } else {
              this.increment_month();
              var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
              if (this.by_data.BYMONTHDAY[0] > daysInMonth) {
                data_valid = 0;
              } else {
                this.last.day = this.by_data.BYMONTHDAY[0];
              }
            }
            return data_valid;
          },
          next_weekday_by_week: function next_weekday_by_week() {
            var end_of_data = 0;
            if (this.next_hour() == 0) {
              return end_of_data;
            }
            if (!this.has_by_data("BYDAY")) {
              return 1;
            }
            for (; ; ) {
              var tt = new ICAL.Time();
              this.by_indices.BYDAY++;
              if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {
                this.by_indices.BYDAY = 0;
                end_of_data = 1;
              }
              var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];
              var parts = this.ruleDayOfWeek(coded_day);
              var dow = parts[1];
              dow -= this.rule.wkst;
              if (dow < 0) {
                dow += 7;
              }
              tt.year = this.last.year;
              tt.month = this.last.month;
              tt.day = this.last.day;
              var startOfWeek = tt.startDoyWeek(this.rule.wkst);
              if (dow + startOfWeek < 1) {
                if (!end_of_data) {
                  continue;
                }
              }
              var next = ICAL.Time.fromDayOfYear(startOfWeek + dow, this.last.year);
              this.last.year = next.year;
              this.last.month = next.month;
              this.last.day = next.day;
              return end_of_data;
            }
          },
          next_year: function next_year() {
            if (this.next_hour() == 0) {
              return 0;
            }
            if (++this.days_index == this.days.length) {
              this.days_index = 0;
              do {
                this.increment_year(this.rule.interval);
                this.expand_year_days(this.last.year);
              } while (this.days.length == 0);
            }
            this._nextByYearDay();
            return 1;
          },
          _nextByYearDay: function _nextByYearDay() {
            var doy = this.days[this.days_index];
            var year = this.last.year;
            if (doy < 1) {
              doy += 1;
              year += 1;
            }
            var next = ICAL.Time.fromDayOfYear(doy, year);
            this.last.day = next.day;
            this.last.month = next.month;
          },
          ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {
            var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);
            if (matches) {
              var pos = parseInt(matches[1] || 0, 10);
              dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);
              return [pos, dow];
            } else {
              return [0, 0];
            }
          },
          next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {
            var has_by_rule = aRuleType in this.by_data;
            var this_freq = this.rule.freq == aInterval;
            var end_of_data = 0;
            if (aPreviousIncr && this[aPreviousIncr]() == 0) {
              return end_of_data;
            }
            if (has_by_rule) {
              this.by_indices[aRuleType]++;
              var idx = this.by_indices[aRuleType];
              var dta = this.by_data[aRuleType];
              if (this.by_indices[aRuleType] == dta.length) {
                this.by_indices[aRuleType] = 0;
                end_of_data = 1;
              }
              this.last[aDateAttr] = dta[this.by_indices[aRuleType]];
            } else if (this_freq) {
              this["increment_" + aDateAttr](this.rule.interval);
            }
            if (has_by_rule && end_of_data && this_freq) {
              this["increment_" + aFollowingAttr](1);
            }
            return end_of_data;
          },
          increment_monthday: function increment_monthday(inc) {
            for (var i = 0; i < inc; i++) {
              var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);
              this.last.day++;
              if (this.last.day > daysInMonth) {
                this.last.day -= daysInMonth;
                this.increment_month();
              }
            }
          },
          increment_month: function increment_month() {
            this.last.day = 1;
            if (this.has_by_data("BYMONTH")) {
              this.by_indices.BYMONTH++;
              if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {
                this.by_indices.BYMONTH = 0;
                this.increment_year(1);
              }
              this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];
            } else {
              if (this.rule.freq == "MONTHLY") {
                this.last.month += this.rule.interval;
              } else {
                this.last.month++;
              }
              this.last.month--;
              var years = ICAL.helpers.trunc(this.last.month / 12);
              this.last.month %= 12;
              this.last.month++;
              if (years != 0) {
                this.increment_year(years);
              }
            }
          },
          increment_year: function increment_year(inc) {
            this.last.year += inc;
          },
          increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {
            this.last[aDateAttr] += inc;
            var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);
            this.last[aDateAttr] %= aFactor;
            if (nextunit != 0) {
              this["increment_" + aNextIncrement](nextunit);
            }
          },
          has_by_data: function has_by_data(aRuleType) {
            return aRuleType in this.rule.parts;
          },
          expand_year_days: function expand_year_days(aYear) {
            var t = new ICAL.Time();
            this.days = [];
            var parts = {};
            var rules = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"];
            for (var p in rules) {
              if (rules.hasOwnProperty(p)) {
                var part = rules[p];
                if (part in this.rule.parts) {
                  parts[part] = this.rule.parts[part];
                }
              }
            }
            if ("BYMONTH" in parts && "BYWEEKNO" in parts) {
              var valid = 1;
              var validWeeks = {};
              t.year = aYear;
              t.isDate = true;
              for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {
                var month = this.by_data.BYMONTH[monthIdx];
                t.month = month;
                t.day = 1;
                var first_week = t.weekNumber(this.rule.wkst);
                t.day = ICAL.Time.daysInMonth(month, aYear);
                var last_week = t.weekNumber(this.rule.wkst);
                for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {
                  validWeeks[monthIdx] = 1;
                }
              }
              for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {
                var weekno = this.by_data.BYWEEKNO[weekIdx];
                if (weekno < 52) {
                  valid &= validWeeks[weekIdx];
                } else {
                  valid = 0;
                }
              }
              if (valid) {
                delete parts.BYMONTH;
              } else {
                delete parts.BYWEEKNO;
              }
            }
            var partCount = Object.keys(parts).length;
            if (partCount == 0) {
              var t1 = this.dtstart.clone();
              t1.year = this.last.year;
              this.days.push(t1.dayOfYear());
            } else if (partCount == 1 && "BYMONTH" in parts) {
              for (var monthkey in this.by_data.BYMONTH) {
                if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                  continue;
                }
                var t2 = this.dtstart.clone();
                t2.year = aYear;
                t2.month = this.by_data.BYMONTH[monthkey];
                t2.isDate = true;
                this.days.push(t2.dayOfYear());
              }
            } else if (partCount == 1 && "BYMONTHDAY" in parts) {
              for (var monthdaykey in this.by_data.BYMONTHDAY) {
                if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                  continue;
                }
                var t3 = this.dtstart.clone();
                var day_ = this.by_data.BYMONTHDAY[monthdaykey];
                if (day_ < 0) {
                  var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);
                  day_ = day_ + daysInMonth + 1;
                }
                t3.day = day_;
                t3.year = aYear;
                t3.isDate = true;
                this.days.push(t3.dayOfYear());
              }
            } else if (partCount == 2 && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
              for (var monthkey in this.by_data.BYMONTH) {
                if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                  continue;
                }
                var month_ = this.by_data.BYMONTH[monthkey];
                var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);
                for (var monthdaykey in this.by_data.BYMONTHDAY) {
                  if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                    continue;
                  }
                  var day_ = this.by_data.BYMONTHDAY[monthdaykey];
                  if (day_ < 0) {
                    day_ = day_ + daysInMonth + 1;
                  }
                  t.day = day_;
                  t.month = month_;
                  t.year = aYear;
                  t.isDate = true;
                  this.days.push(t.dayOfYear());
                }
              }
            } else if (partCount == 1 && "BYWEEKNO" in parts) {
            } else if (partCount == 2 && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
            } else if (partCount == 1 && "BYDAY" in parts) {
              this.days = this.days.concat(this.expand_by_day(aYear));
            } else if (partCount == 2 && "BYDAY" in parts && "BYMONTH" in parts) {
              for (var monthkey in this.by_data.BYMONTH) {
                if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                  continue;
                }
                var month = this.by_data.BYMONTH[monthkey];
                var daysInMonth = ICAL.Time.daysInMonth(month, aYear);
                t.year = aYear;
                t.month = this.by_data.BYMONTH[monthkey];
                t.day = 1;
                t.isDate = true;
                var first_dow = t.dayOfWeek();
                var doy_offset = t.dayOfYear() - 1;
                t.day = daysInMonth;
                var last_dow = t.dayOfWeek();
                if (this.has_by_data("BYSETPOS")) {
                  var set_pos_counter = 0;
                  var by_month_day = [];
                  for (var day = 1; day <= daysInMonth; day++) {
                    t.day = day;
                    if (this.is_day_in_byday(t)) {
                      by_month_day.push(day);
                    }
                  }
                  for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {
                    if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {
                      this.days.push(doy_offset + by_month_day[spIndex]);
                    }
                  }
                } else {
                  for (var daycodedkey in this.by_data.BYDAY) {
                    if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {
                      continue;
                    }
                    var coded_day = this.by_data.BYDAY[daycodedkey];
                    var bydayParts = this.ruleDayOfWeek(coded_day);
                    var pos = bydayParts[0];
                    var dow = bydayParts[1];
                    var month_day;
                    var first_matching_day = (dow + 7 - first_dow) % 7 + 1;
                    var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;
                    if (pos == 0) {
                      for (var day = first_matching_day; day <= daysInMonth; day += 7) {
                        this.days.push(doy_offset + day);
                      }
                    } else if (pos > 0) {
                      month_day = first_matching_day + (pos - 1) * 7;
                      if (month_day <= daysInMonth) {
                        this.days.push(doy_offset + month_day);
                      }
                    } else {
                      month_day = last_matching_day + (pos + 1) * 7;
                      if (month_day > 0) {
                        this.days.push(doy_offset + month_day);
                      }
                    }
                  }
                }
              }
              this.days.sort(function(a, b) {
                return a - b;
              });
            } else if (partCount == 2 && "BYDAY" in parts && "BYMONTHDAY" in parts) {
              var expandedDays = this.expand_by_day(aYear);
              for (var daykey in expandedDays) {
                if (!expandedDays.hasOwnProperty(daykey)) {
                  continue;
                }
                var day = expandedDays[daykey];
                var tt = ICAL.Time.fromDayOfYear(day, aYear);
                if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                  this.days.push(day);
                }
              }
            } else if (partCount == 3 && "BYDAY" in parts && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
              var expandedDays = this.expand_by_day(aYear);
              for (var daykey in expandedDays) {
                if (!expandedDays.hasOwnProperty(daykey)) {
                  continue;
                }
                var day = expandedDays[daykey];
                var tt = ICAL.Time.fromDayOfYear(day, aYear);
                if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                  this.days.push(day);
                }
              }
            } else if (partCount == 2 && "BYDAY" in parts && "BYWEEKNO" in parts) {
              var expandedDays = this.expand_by_day(aYear);
              for (var daykey in expandedDays) {
                if (!expandedDays.hasOwnProperty(daykey)) {
                  continue;
                }
                var day = expandedDays[daykey];
                var tt = ICAL.Time.fromDayOfYear(day, aYear);
                var weekno = tt.weekNumber(this.rule.wkst);
                if (this.by_data.BYWEEKNO.indexOf(weekno)) {
                  this.days.push(day);
                }
              }
            } else if (partCount == 3 && "BYDAY" in parts && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
            } else if (partCount == 1 && "BYYEARDAY" in parts) {
              this.days = this.days.concat(this.by_data.BYYEARDAY);
            } else {
              this.days = [];
            }
            return 0;
          },
          expand_by_day: function expand_by_day(aYear) {
            var days_list = [];
            var tmp = this.last.clone();
            tmp.year = aYear;
            tmp.month = 1;
            tmp.day = 1;
            tmp.isDate = true;
            var start_dow = tmp.dayOfWeek();
            tmp.month = 12;
            tmp.day = 31;
            tmp.isDate = true;
            var end_dow = tmp.dayOfWeek();
            var end_year_day = tmp.dayOfYear();
            for (var daykey in this.by_data.BYDAY) {
              if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
                continue;
              }
              var day = this.by_data.BYDAY[daykey];
              var parts = this.ruleDayOfWeek(day);
              var pos = parts[0];
              var dow = parts[1];
              if (pos == 0) {
                var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;
                for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {
                  days_list.push(doy);
                }
              } else if (pos > 0) {
                var first;
                if (dow >= start_dow) {
                  first = dow - start_dow + 1;
                } else {
                  first = dow - start_dow + 8;
                }
                days_list.push(first + (pos - 1) * 7);
              } else {
                var last;
                pos = -pos;
                if (dow <= end_dow) {
                  last = end_year_day - end_dow + dow;
                } else {
                  last = end_year_day - end_dow + dow - 7;
                }
                days_list.push(last - (pos - 1) * 7);
              }
            }
            return days_list;
          },
          is_day_in_byday: function is_day_in_byday(tt) {
            for (var daykey in this.by_data.BYDAY) {
              if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
                continue;
              }
              var day = this.by_data.BYDAY[daykey];
              var parts = this.ruleDayOfWeek(day);
              var pos = parts[0];
              var dow = parts[1];
              var this_dow = tt.dayOfWeek();
              if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {
                return 1;
              }
            }
            return 0;
          },
          check_set_position: function check_set_position(aPos) {
            if (this.has_by_data("BYSETPOS")) {
              var idx = this.by_data.BYSETPOS.indexOf(aPos);
              return idx !== -1;
            }
            return false;
          },
          sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {
            for (var i = 0; i < aRules.length; i++) {
              for (var j = 0; j < i; j++) {
                var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];
                var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];
                if (one > two) {
                  var tmp = aRules[i];
                  aRules[i] = aRules[j];
                  aRules[j] = tmp;
                }
              }
            }
          },
          check_contract_restriction: function check_contract_restriction(aRuleType, v) {
            var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
            var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
            var pass = false;
            if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {
              var ruleType = this.by_data[aRuleType];
              for (var bydatakey in ruleType) {
                if (ruleType.hasOwnProperty(bydatakey)) {
                  if (ruleType[bydatakey] == v) {
                    pass = true;
                    break;
                  }
                }
              }
            } else {
              pass = true;
            }
            return pass;
          },
          check_contracting_rules: function check_contracting_rules() {
            var dow = this.last.dayOfWeek();
            var weekNo = this.last.weekNumber(this.rule.wkst);
            var doy = this.last.dayOfYear();
            return this.check_contract_restriction("BYSECOND", this.last.second) && this.check_contract_restriction("BYMINUTE", this.last.minute) && this.check_contract_restriction("BYHOUR", this.last.hour) && this.check_contract_restriction("BYDAY", ICAL.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction("BYWEEKNO", weekNo) && this.check_contract_restriction("BYMONTHDAY", this.last.day) && this.check_contract_restriction("BYMONTH", this.last.month) && this.check_contract_restriction("BYYEARDAY", doy);
          },
          setup_defaults: function setup_defaults(aRuleType, req, deftime) {
            var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
            var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
            if (ruleMapValue != icalrecur_iterator.CONTRACT) {
              if (!(aRuleType in this.by_data)) {
                this.by_data[aRuleType] = [deftime];
              }
              if (this.rule.freq != req) {
                return this.by_data[aRuleType][0];
              }
            }
            return deftime;
          },
          toJSON: function() {
            var result = Object.create(null);
            result.initialized = this.initialized;
            result.rule = this.rule.toJSON();
            result.dtstart = this.dtstart.toJSON();
            result.by_data = this.by_data;
            result.days = this.days;
            result.last = this.last.toJSON();
            result.by_indices = this.by_indices;
            result.occurrence_number = this.occurrence_number;
            return result;
          }
        };
        icalrecur_iterator._indexMap = {
          "BYSECOND": 0,
          "BYMINUTE": 1,
          "BYHOUR": 2,
          "BYDAY": 3,
          "BYMONTHDAY": 4,
          "BYYEARDAY": 5,
          "BYWEEKNO": 6,
          "BYMONTH": 7,
          "BYSETPOS": 8
        };
        icalrecur_iterator._expandMap = {
          "SECONDLY": [1, 1, 1, 1, 1, 1, 1, 1],
          "MINUTELY": [2, 1, 1, 1, 1, 1, 1, 1],
          "HOURLY": [2, 2, 1, 1, 1, 1, 1, 1],
          "DAILY": [2, 2, 2, 1, 1, 1, 1, 1],
          "WEEKLY": [2, 2, 2, 2, 3, 3, 1, 1],
          "MONTHLY": [2, 2, 2, 2, 2, 3, 3, 1],
          "YEARLY": [2, 2, 2, 2, 2, 2, 2, 2]
        };
        icalrecur_iterator.UNKNOWN = 0;
        icalrecur_iterator.CONTRACT = 1;
        icalrecur_iterator.EXPAND = 2;
        icalrecur_iterator.ILLEGAL = 3;
        return icalrecur_iterator;
      }();
      ICAL.RecurExpansion = function() {
        function formatTime(item) {
          return ICAL.helpers.formatClassType(item, ICAL.Time);
        }
        function compareTime(a, b) {
          return a.compare(b);
        }
        function isRecurringComponent(comp) {
          return comp.hasProperty("rdate") || comp.hasProperty("rrule") || comp.hasProperty("recurrence-id");
        }
        function RecurExpansion(options) {
          this.ruleDates = [];
          this.exDates = [];
          this.fromData(options);
        }
        RecurExpansion.prototype = {
          complete: false,
          ruleIterators: null,
          ruleDates: null,
          exDates: null,
          ruleDateInc: 0,
          exDateInc: 0,
          exDate: null,
          ruleDate: null,
          dtstart: null,
          last: null,
          fromData: function(options) {
            var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);
            if (!start) {
              throw new Error(".dtstart (ICAL.Time) must be given");
            } else {
              this.dtstart = start;
            }
            if (options.component) {
              this._init(options.component);
            } else {
              this.last = formatTime(options.last) || start.clone();
              if (!options.ruleIterators) {
                throw new Error(".ruleIterators or .component must be given");
              }
              this.ruleIterators = options.ruleIterators.map(function(item) {
                return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);
              });
              this.ruleDateInc = options.ruleDateInc;
              this.exDateInc = options.exDateInc;
              if (options.ruleDates) {
                this.ruleDates = options.ruleDates.map(formatTime);
                this.ruleDate = this.ruleDates[this.ruleDateInc];
              }
              if (options.exDates) {
                this.exDates = options.exDates.map(formatTime);
                this.exDate = this.exDates[this.exDateInc];
              }
              if (typeof options.complete !== "undefined") {
                this.complete = options.complete;
              }
            }
          },
          next: function() {
            var iter;
            var ruleOfDay;
            var next;
            var compare;
            var maxTries = 500;
            var currentTry = 0;
            while (true) {
              if (currentTry++ > maxTries) {
                throw new Error("max tries have occured, rule may be impossible to forfill.");
              }
              next = this.ruleDate;
              iter = this._nextRecurrenceIter(this.last);
              if (!next && !iter) {
                this.complete = true;
                break;
              }
              if (!next || iter && next.compare(iter.last) > 0) {
                next = iter.last.clone();
                iter.next();
              }
              if (this.ruleDate === next) {
                this._nextRuleDay();
              }
              this.last = next;
              if (this.exDate) {
                compare = this.exDate.compare(this.last);
                if (compare < 0) {
                  this._nextExDay();
                }
                if (compare === 0) {
                  this._nextExDay();
                  continue;
                }
              }
              return this.last;
            }
          },
          toJSON: function() {
            function toJSON(item) {
              return item.toJSON();
            }
            var result = Object.create(null);
            result.ruleIterators = this.ruleIterators.map(toJSON);
            if (this.ruleDates) {
              result.ruleDates = this.ruleDates.map(toJSON);
            }
            if (this.exDates) {
              result.exDates = this.exDates.map(toJSON);
            }
            result.ruleDateInc = this.ruleDateInc;
            result.exDateInc = this.exDateInc;
            result.last = this.last.toJSON();
            result.dtstart = this.dtstart.toJSON();
            result.complete = this.complete;
            return result;
          },
          _extractDates: function(component, propertyName) {
            function handleProp(prop2) {
              idx = ICAL.helpers.binsearchInsert(result, prop2, compareTime);
              result.splice(idx, 0, prop2);
            }
            var result = [];
            var props = component.getAllProperties(propertyName);
            var len = props.length;
            var i = 0;
            var prop;
            var idx;
            for (; i < len; i++) {
              props[i].getValues().forEach(handleProp);
            }
            return result;
          },
          _init: function(component) {
            this.ruleIterators = [];
            this.last = this.dtstart.clone();
            if (!isRecurringComponent(component)) {
              this.ruleDate = this.last.clone();
              this.complete = true;
              return;
            }
            if (component.hasProperty("rdate")) {
              this.ruleDates = this._extractDates(component, "rdate");
              if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {
                this.ruleDateInc = 0;
                this.last = this.ruleDates[0].clone();
              } else {
                this.ruleDateInc = ICAL.helpers.binsearchInsert(this.ruleDates, this.last, compareTime);
              }
              this.ruleDate = this.ruleDates[this.ruleDateInc];
            }
            if (component.hasProperty("rrule")) {
              var rules = component.getAllProperties("rrule");
              var i = 0;
              var len = rules.length;
              var rule;
              var iter;
              for (; i < len; i++) {
                rule = rules[i].getFirstValue();
                iter = rule.iterator(this.dtstart);
                this.ruleIterators.push(iter);
                iter.next();
              }
            }
            if (component.hasProperty("exdate")) {
              this.exDates = this._extractDates(component, "exdate");
              this.exDateInc = ICAL.helpers.binsearchInsert(this.exDates, this.last, compareTime);
              this.exDate = this.exDates[this.exDateInc];
            }
          },
          _nextExDay: function() {
            this.exDate = this.exDates[++this.exDateInc];
          },
          _nextRuleDay: function() {
            this.ruleDate = this.ruleDates[++this.ruleDateInc];
          },
          _nextRecurrenceIter: function() {
            var iters = this.ruleIterators;
            if (iters.length === 0) {
              return null;
            }
            var len = iters.length;
            var iter;
            var iterTime;
            var iterIdx = 0;
            var chosenIter;
            for (; iterIdx < len; iterIdx++) {
              iter = iters[iterIdx];
              iterTime = iter.last;
              if (iter.completed) {
                len--;
                if (iterIdx !== 0) {
                  iterIdx--;
                }
                iters.splice(iterIdx, 1);
                continue;
              }
              if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {
                chosenIter = iter;
              }
            }
            return chosenIter;
          }
        };
        return RecurExpansion;
      }();
      ICAL.Event = function() {
        function Event(component, options) {
          if (!(component instanceof ICAL.Component)) {
            options = component;
            component = null;
          }
          if (component) {
            this.component = component;
          } else {
            this.component = new ICAL.Component("vevent");
          }
          this._rangeExceptionCache = Object.create(null);
          this.exceptions = Object.create(null);
          this.rangeExceptions = [];
          if (options && options.strictExceptions) {
            this.strictExceptions = options.strictExceptions;
          }
          if (options && options.exceptions) {
            options.exceptions.forEach(this.relateException, this);
          } else if (this.component.parent && !this.isRecurrenceException()) {
            this.component.parent.getAllSubcomponents("vevent").forEach(function(event) {
              if (event.hasProperty("recurrence-id")) {
                this.relateException(event);
              }
            }, this);
          }
        }
        Event.prototype = {
          THISANDFUTURE: "THISANDFUTURE",
          exceptions: null,
          strictExceptions: false,
          relateException: function(obj) {
            if (this.isRecurrenceException()) {
              throw new Error("cannot relate exception to exceptions");
            }
            if (obj instanceof ICAL.Component) {
              obj = new ICAL.Event(obj);
            }
            if (this.strictExceptions && obj.uid !== this.uid) {
              throw new Error("attempted to relate unrelated exception");
            }
            var id = obj.recurrenceId.toString();
            this.exceptions[id] = obj;
            if (obj.modifiesFuture()) {
              var item = [
                obj.recurrenceId.toUnixTime(),
                id
              ];
              var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, item, compareRangeException);
              this.rangeExceptions.splice(idx, 0, item);
            }
          },
          modifiesFuture: function() {
            if (!this.component.hasProperty("recurrence-id")) {
              return false;
            }
            var range = this.component.getFirstProperty("recurrence-id").getParameter("range");
            return range === this.THISANDFUTURE;
          },
          findRangeException: function(time) {
            if (!this.rangeExceptions.length) {
              return null;
            }
            var utc = time.toUnixTime();
            var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, [utc], compareRangeException);
            idx -= 1;
            if (idx < 0) {
              return null;
            }
            var rangeItem = this.rangeExceptions[idx];
            if (utc < rangeItem[0]) {
              return null;
            }
            return rangeItem[1];
          },
          getOccurrenceDetails: function(occurrence) {
            var id = occurrence.toString();
            var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();
            var item;
            var result = {
              recurrenceId: occurrence
            };
            if (id in this.exceptions) {
              item = result.item = this.exceptions[id];
              result.startDate = item.startDate;
              result.endDate = item.endDate;
              result.item = item;
            } else if (utcId in this.exceptions) {
              item = this.exceptions[utcId];
              result.startDate = item.startDate;
              result.endDate = item.endDate;
              result.item = item;
            } else {
              var rangeExceptionId = this.findRangeException(occurrence);
              var end;
              if (rangeExceptionId) {
                var exception = this.exceptions[rangeExceptionId];
                result.item = exception;
                var startDiff = this._rangeExceptionCache[rangeExceptionId];
                if (!startDiff) {
                  var original = exception.recurrenceId.clone();
                  var newStart = exception.startDate.clone();
                  original.zone = newStart.zone;
                  startDiff = newStart.subtractDate(original);
                  this._rangeExceptionCache[rangeExceptionId] = startDiff;
                }
                var start = occurrence.clone();
                start.zone = exception.startDate.zone;
                start.addDuration(startDiff);
                end = start.clone();
                end.addDuration(exception.duration);
                result.startDate = start;
                result.endDate = end;
              } else {
                end = occurrence.clone();
                end.addDuration(this.duration);
                result.endDate = end;
                result.startDate = occurrence;
                result.item = this;
              }
            }
            return result;
          },
          iterator: function(startTime) {
            return new ICAL.RecurExpansion({
              component: this.component,
              dtstart: startTime || this.startDate
            });
          },
          isRecurring: function() {
            var comp = this.component;
            return comp.hasProperty("rrule") || comp.hasProperty("rdate");
          },
          isRecurrenceException: function() {
            return this.component.hasProperty("recurrence-id");
          },
          getRecurrenceTypes: function() {
            var rules = this.component.getAllProperties("rrule");
            var i = 0;
            var len = rules.length;
            var result = Object.create(null);
            for (; i < len; i++) {
              var value = rules[i].getFirstValue();
              result[value.freq] = true;
            }
            return result;
          },
          get uid() {
            return this._firstProp("uid");
          },
          set uid(value) {
            this._setProp("uid", value);
          },
          get startDate() {
            return this._firstProp("dtstart");
          },
          set startDate(value) {
            this._setTime("dtstart", value);
          },
          get endDate() {
            var endDate = this._firstProp("dtend");
            if (!endDate) {
              var duration = this._firstProp("duration");
              endDate = this.startDate.clone();
              if (duration) {
                endDate.addDuration(duration);
              } else if (endDate.isDate) {
                endDate.day += 1;
              }
            }
            return endDate;
          },
          set endDate(value) {
            if (this.component.hasProperty("duration")) {
              this.component.removeProperty("duration");
            }
            this._setTime("dtend", value);
          },
          get duration() {
            var duration = this._firstProp("duration");
            if (!duration) {
              return this.endDate.subtractDateTz(this.startDate);
            }
            return duration;
          },
          set duration(value) {
            if (this.component.hasProperty("dtend")) {
              this.component.removeProperty("dtend");
            }
            this._setProp("duration", value);
          },
          get location() {
            return this._firstProp("location");
          },
          set location(value) {
            return this._setProp("location", value);
          },
          get attendees() {
            return this.component.getAllProperties("attendee");
          },
          get summary() {
            return this._firstProp("summary");
          },
          set summary(value) {
            this._setProp("summary", value);
          },
          get description() {
            return this._firstProp("description");
          },
          set description(value) {
            this._setProp("description", value);
          },
          get organizer() {
            return this._firstProp("organizer");
          },
          set organizer(value) {
            this._setProp("organizer", value);
          },
          get sequence() {
            return this._firstProp("sequence");
          },
          set sequence(value) {
            this._setProp("sequence", value);
          },
          get recurrenceId() {
            return this._firstProp("recurrence-id");
          },
          set recurrenceId(value) {
            this._setTime("recurrence-id", value);
          },
          _setTime: function(propName, time) {
            var prop = this.component.getFirstProperty(propName);
            if (!prop) {
              prop = new ICAL.Property(propName);
              this.component.addProperty(prop);
            }
            if (time.zone === ICAL.Timezone.localTimezone || time.zone === ICAL.Timezone.utcTimezone) {
              prop.removeParameter("tzid");
            } else {
              prop.setParameter("tzid", time.zone.tzid);
            }
            prop.setValue(time);
          },
          _setProp: function(name, value) {
            this.component.updatePropertyWithValue(name, value);
          },
          _firstProp: function(name) {
            return this.component.getFirstPropertyValue(name);
          },
          toString: function() {
            return this.component.toString();
          }
        };
        function compareRangeException(a, b) {
          if (a[0] > b[0])
            return 1;
          if (b[0] > a[0])
            return -1;
          return 0;
        }
        return Event;
      }();
      ICAL.ComponentParser = function() {
        function ComponentParser(options) {
          if (typeof options === "undefined") {
            options = {};
          }
          var key;
          for (key in options) {
            if (options.hasOwnProperty(key)) {
              this[key] = options[key];
            }
          }
        }
        ComponentParser.prototype = {
          parseEvent: true,
          parseTimezone: true,
          oncomplete: function() {
          },
          onerror: function(err) {
          },
          ontimezone: function(component) {
          },
          onevent: function(component) {
          },
          process: function(ical) {
            if (typeof ical === "string") {
              ical = ICAL.parse(ical);
            }
            if (!(ical instanceof ICAL.Component)) {
              ical = new ICAL.Component(ical);
            }
            var components = ical.getAllSubcomponents();
            var i = 0;
            var len = components.length;
            var component;
            for (; i < len; i++) {
              component = components[i];
              switch (component.name) {
                case "vtimezone":
                  if (this.parseTimezone) {
                    var tzid = component.getFirstPropertyValue("tzid");
                    if (tzid) {
                      this.ontimezone(new ICAL.Timezone({
                        tzid,
                        component
                      }));
                    }
                  }
                  break;
                case "vevent":
                  if (this.parseEvent) {
                    this.onevent(new ICAL.Event(component));
                  }
                  break;
                default:
                  continue;
              }
            }
            this.oncomplete();
          }
        };
        return ComponentParser;
      }();
    }
  });

  // src/backend/accounts/ical/validator.js
  var validator_exports3 = {};
  __export(validator_exports3, {
    default: () => validateICal
  });
  async function validateICal({
    userDetails,
    credentials,
    connInfoFields
  }) {
    const calendarUrl = connInfoFields.calendarUrl;
    try {
      const icalReq = new Request(calendarUrl, {});
      const icalResp = await fetch(icalReq);
      if (icalResp.status >= 400) {
        return {
          error: "unknown",
          errorDetails: {
            status: icalResp.status,
            calendarUrl
          }
        };
      }
      const icalText = await icalResp.text();
      const parsed = import_ical.default.parse(icalText);
      const root = new import_ical.default.Component(parsed);
      const calName = root.getFirstPropertyValue("x-wr-calname") || "Unnamed Calendar";
      userDetails.displayName = calName;
      userDetails.emailAddress = calName;
    } catch (ex) {
      return {
        error: "unknown",
        errorDetails: {
          message: ex.toString()
        }
      };
    }
    return {
      engineFields: {
        engine: "ical",
        engineData: {},
        receiveProtoConn: null
      }
    };
  }
  var import_ical;
  var init_validator3 = __esm({
    "src/backend/accounts/ical/validator.js"() {
      import_ical = __toModule(require_ical());
    }
  });

  // src/backend/accountmixins.js
  function getFirstFolderWithType(type) {
    var folders = this.folders;
    if (!folders) {
      try {
        throw new Error();
      } catch (ex) {
        console.log("getFirstFolderWithType explosion!", ex.stack);
        dump("EXPLOSION folders:\n" + ex.stack + "\n");
      }
    }
    for (var iFolder = 0; iFolder < folders.length; iFolder++) {
      if (folders[iFolder].type === type) {
        return folders[iFolder];
      }
    }
    return null;
  }
  function getFolderByPath(folderPath) {
    var folders = this.folders;
    for (var iFolder = 0; iFolder < folders.length; iFolder++) {
      if (folders[iFolder].path === folderPath) {
        return folders[iFolder];
      }
    }
    return null;
  }
  function getFolderById(id) {
    return this.foldersTOC.foldersById.get(id);
  }
  function normalizeFolderHierarchy() {
    var sibling = this.getFirstFolderWithType("drafts") || this.getFirstFolderWithType("sent");
    if (!sibling) {
      return;
    }
    var parent2 = this.getFolderById(sibling.parentId);
    var foldersToMove = [
      this.getFirstFolderWithType("localdrafts"),
      this.getFirstFolderWithType("outbox")
    ];
    foldersToMove.forEach(function(folder) {
      if (!folder || folder.parentId === sibling.parentId) {
        return;
      }
      console.log("Moving folder", folder.name, "underneath", parent2 && parent2.name || "(root)");
      this.universe.__notifyRemovedFolder(this, folder);
      if (parent2) {
        folder.path = parent2.path + (parent2.delim || "/") + folder.name;
        folder.delim = parent2.delim || "/";
        folder.parentId = parent2.id;
        folder.depth = parent2.depth + 1;
      } else {
        folder.path = folder.name;
        folder.delim = "/";
        folder.parentId = null;
        folder.depth = 0;
      }
      this.universe.__notifyAddedFolder(this, folder);
    }, this);
  }
  var init_accountmixins = __esm({
    "src/backend/accountmixins.js"() {
    }
  });

  // src/backend/accounts/activesync/account.js
  var account_exports = {};
  __export(account_exports, {
    default: () => account_default
  });
  function ActiveSyncAccount(universe2, accountDef, foldersTOC, dbConn, receiveProtoConn) {
    this.universe = universe2;
    this.id = accountDef.id;
    this.accountDef = accountDef;
    this._db = dbConn;
    logic.defineScope(this, "Account", {
      accountId: this.id,
      accountType: "activesync"
    });
    if (receiveProtoConn) {
      this.conn = receiveProtoConn;
      this._attachLoggerToConnection(this.conn);
    } else {
      this.conn = null;
    }
    this.enabled = true;
    this.problems = [];
    this._alive = true;
    this.identities = accountDef.identities;
    this.foldersTOC = foldersTOC;
    this.folders = this.foldersTOC.items;
    this.meta = foldersTOC.meta;
    this._syncsInProgress = 0;
    this._lastSyncKey = null;
    this._lastSyncResponseWasEmpty = false;
  }
  var DEFAULT_TIMEOUT_MS, account_default;
  var init_account = __esm({
    "src/backend/accounts/activesync/account.js"() {
      init_logic();
      init_accountmixins();
      init_wbxml();
      init_protocol();
      init_codepages();
      DEFAULT_TIMEOUT_MS = 30 * 1e3;
      ActiveSyncAccount.prototype = {
        type: "activesync",
        supportsServerFolders: true,
        toString: function asa_toString() {
          return "[ActiveSyncAccount: " + this.id + "]";
        },
        __acquire() {
          return Promise.resolve(this);
        },
        __release() {
        },
        withConnection(errback, callback, failString) {
          if (!this.conn) {
            var accountDef = this.accountDef;
            this.conn = new Connection(accountDef.connInfo.deviceId);
            this._attachLoggerToConnection(this.conn);
            this.conn.open(accountDef.connInfo.server, accountDef.credentials.username, accountDef.credentials.password);
            this.conn.timeout = DEFAULT_TIMEOUT_MS;
          }
          if (!this.conn.connected) {
            logic(this, "connecting");
            this.conn.connect(function(error) {
              if (error) {
                this._reportErrorIfNecessary(error);
                if (this._isBadUserOrPassError(error) && !failString) {
                  failString = "bad-user-or-pass";
                }
                errback(failString || "unknown");
                return;
              }
              logic(this, "connected", { connected: this.conn.connected });
              callback();
            }.bind(this));
          } else {
            callback();
          }
        },
        ensureConnection() {
          if (this.conn && this.conn.connected) {
            return Promise.resolve(this.conn);
          }
          return new Promise((resolve, reject) => {
            this.withConnection(reject, () => {
              resolve(this.conn);
            });
          });
        },
        _isBadUserOrPassError(error) {
          return error && error instanceof HttpError && error.status === 401;
        },
        _reportErrorIfNecessary(error) {
          if (!error) {
            return;
          }
          logic(this, "reportErrorIfNecessary", { error });
          if (this._isBadUserOrPassError(error)) {
            this.universe.__reportAccountProblem(this, "bad-user-or-pass", "incoming");
          }
        },
        _attachLoggerToConnection(conn) {
          logic.defineScope(conn, "ActiveSyncConnection", {
            connectionId: logic.uniqueId()
          });
          if (!logic.isCensored) {
            conn.onmessage = this._onmessage_dangerous.bind(this, conn);
          } else {
            conn.onmessage = this._onmessage_safe.bind(this, conn);
          }
        },
        _onmessage_safe: function onmessage(conn, type, special, xhr, params, extraHeaders, sentData, response) {
          if (type === "options") {
            logic(conn, "options", {
              special,
              status: xhr.status,
              response
            });
          } else {
            logic(conn, "command", {
              type,
              special,
              status: xhr.status
            });
          }
        },
        _onmessage_dangerous: function onmessage2(conn, type, special, xhr, params, extraHeaders, sentData, response) {
          if (type === "options") {
            logic(conn, "options", {
              special,
              status: xhr.status,
              response
            });
          } else {
            var sentXML, receivedXML;
            if (sentData) {
              try {
                var sentReader = new Reader(new Uint8Array(sentData), codepages_default);
                sentXML = sentReader.dump();
              } catch (ex) {
                sentXML = "parse problem";
              }
            }
            if (response) {
              try {
                receivedXML = response.dump();
                response.rewind();
              } catch (ex) {
                receivedXML = "parse problem";
              }
            }
            logic(conn, "command", {
              type,
              special,
              status: xhr.status,
              params,
              extraHeaders,
              sentXML,
              receivedXML
            });
          }
        },
        get numActiveConns() {
          return 0;
        },
        checkAccount(callback) {
          if (this.conn != null) {
            if (this.conn.connected) {
              this.conn.disconnect();
            }
            this.conn = null;
          }
          this.withConnection(function(err) {
            callback(err);
          }, function() {
            callback();
          });
        },
        shutdown(callback) {
          if (callback) {
            callback();
          }
        },
        accountDeleted() {
          this._alive = false;
          this.shutdown();
        },
        normalizeFolderHierarchy,
        getFirstFolderWithType,
        getFolderByPath,
        getFolderById,
        getFolderByServerId(serverId) {
          var folders = this.folders;
          for (var iFolder = 0; iFolder < folders.length; iFolder++) {
            if (folders[iFolder].serverId === serverId) {
              return folders[iFolder];
            }
          }
          return null;
        },
        allOperationsCompleted() {
        }
      };
      account_default = ActiveSyncAccount;
    }
  });

  // src/backend/accounts/feed/account.js
  var account_exports2 = {};
  __export(account_exports2, {
    default: () => FeedAccount
  });
  var FeedAccount;
  var init_account2 = __esm({
    "src/backend/accounts/feed/account.js"() {
      FeedAccount = class {
        constructor(universe2, accountDef, foldersTOC, dbConn) {
          this.universe = universe2;
          this.id = accountDef.id;
          this.accountDef = accountDef;
          this._db = dbConn;
          this.enabled = true;
          this.problems = [];
          this.identities = accountDef.identities;
          this.foldersTOC = foldersTOC;
          this.folders = this.foldersTOC.items;
          this.feedUrl = accountDef.feedUrl;
        }
        toString() {
          return `[FeedAccount: ${this.id}]`;
        }
        __acquire() {
          return Promise.resolve(this);
        }
        __release() {
        }
        async checkAccount() {
          return null;
        }
        shutdown() {
        }
      };
      FeedAccount.type = "Feed";
      FeedAccount.supportsServerFolders = false;
    }
  });

  // src/backend/accounts/ical/account.js
  var account_exports3 = {};
  __export(account_exports3, {
    default: () => ICalAccount
  });
  var ICalAccount;
  var init_account3 = __esm({
    "src/backend/accounts/ical/account.js"() {
      ICalAccount = class {
        constructor(universe2, accountDef, foldersTOC, dbConn) {
          this.universe = universe2;
          this.id = accountDef.id;
          this.accountDef = accountDef;
          this._db = dbConn;
          this.enabled = true;
          this.problems = [];
          this.identities = accountDef.identities;
          this.foldersTOC = foldersTOC;
          this.folders = this.foldersTOC.items;
          this.calendarUrl = accountDef.calendarUrl;
        }
        toString() {
          return `[ICalAccount: ${this.id}]`;
        }
        __acquire() {
          return Promise.resolve(this);
        }
        __release() {
        }
        async checkAccount() {
          return null;
        }
        shutdown() {
        }
      };
      ICalAccount.type = "iCal";
      ICalAccount.supportsServerFolders = false;
    }
  });

  // src/shared/util.js
  function bsearchForInsert(list, seekVal, cmpfunc) {
    if (!list.length) {
      return 0;
    }
    var low = 0, high = list.length - 1, mid, cmpval;
    while (low <= high) {
      mid = low + Math.floor((high - low) / 2);
      cmpval = cmpfunc(seekVal, list[mid]);
      if (cmpval < 0) {
        high = mid - 1;
      } else if (cmpval > 0) {
        low = mid + 1;
      } else {
        break;
      }
    }
    if (cmpval < 0) {
      return mid;
    } else if (cmpval > 0) {
      return mid + 1;
    }
    return mid;
  }
  function bsearchMaybeExists(list, seekVal, cmpfunc, aLow, aHigh) {
    var low = aLow === void 0 ? 0 : aLow, high = aHigh === void 0 ? list.length - 1 : aHigh, mid, cmpval;
    while (low <= high) {
      mid = low + Math.floor((high - low) / 2);
      cmpval = cmpfunc(seekVal, list[mid]);
      if (cmpval < 0) {
        high = mid - 1;
      } else if (cmpval > 0) {
        low = mid + 1;
      } else {
        return mid;
      }
    }
    return null;
  }
  function formatAddresses(nameAddrPairs) {
    var addrstrings = [];
    for (var i = 0; i < nameAddrPairs.length; i++) {
      var pair = nameAddrPairs[i];
      if (typeof pair === "string") {
        addrstrings.push(pair);
      } else if (!pair.name) {
        addrstrings.push(pair.address);
      } else {
        addrstrings.push('"' + pair.name.replace(/["']/g, "") + '" <' + pair.address + ">");
      }
    }
    return addrstrings.join(", ");
  }
  function shallowClone2(sourceObj) {
    var destObj = {};
    for (var key in sourceObj) {
      destObj[key] = sourceObj[key];
    }
    return destObj;
  }
  var import_evt4;
  var init_util = __esm({
    "src/shared/util.js"() {
      import_evt4 = __toModule(require_evt());
    }
  });

  // src/backend/task_infra/task_bases/at_most_once.js
  var makeWrappedOverlayFunc, makeWrappedPrefixOverlayFunc, at_most_once_default;
  var init_at_most_once = __esm({
    "src/backend/task_infra/task_bases/at_most_once.js"() {
      init_logic();
      makeWrappedOverlayFunc = function(helpedOverlayFunc) {
        return function(persistentState, memoryState, blockedTaskChecker, id) {
          return helpedOverlayFunc.call(this, id, persistentState.binToMarker.get(id), memoryState.inProgressBins.has(id) || memoryState.remainInProgressBins.has(id), blockedTaskChecker(this.name + ":" + id));
        };
      };
      makeWrappedPrefixOverlayFunc = function([extractor, helpedOverlayFunc]) {
        return function(persistentState, memoryState, blockedTaskChecker, fullId) {
          let binId = extractor(fullId);
          return helpedOverlayFunc.call(this, fullId, binId, persistentState.binToMarker.get(binId), memoryState.inProgressBins.has(binId) || memoryState.remainInProgressBins.has(binId), blockedTaskChecker(this.name + ":" + binId));
        };
      };
      at_most_once_default = {
        isSimple: false,
        isComplex: true,
        __preMix(mixedSource) {
          for (let key of Object.keys(mixedSource)) {
            let overlayMatch = /^helped_overlay_(.+)$/.exec(key);
            if (overlayMatch) {
              let overlayType = overlayMatch[1];
              this["overlay_" + overlayType] = makeWrappedOverlayFunc(mixedSource[key]);
            }
            let prefixedOverlayMatch = /^helped_prefix_overlay_(.+)$/.exec(key);
            if (prefixedOverlayMatch) {
              let overlayType = prefixedOverlayMatch[1];
              this["overlay_" + overlayType] = makeWrappedPrefixOverlayFunc(mixedSource[key]);
            }
          }
        },
        initPersistentState() {
          return {
            binToMarker: new Map()
          };
        },
        deriveMemoryStateFromPersistentState(persistentState, accountId) {
          return {
            memoryState: {
              accountId,
              inProgressBins: new Set(),
              remainInProgressBins: new Set()
            },
            markers: persistentState.binToMarker.values()
          };
        },
        async plan(ctx, persistentState, memoryState, req) {
          let binId = this.binByArg ? req[this.binByArg] : "only";
          if (persistentState.binToMarker.has(binId)) {
            let rval2;
            if (this.helped_already_planned) {
              logic(ctx, "alreadyPlanned");
              rval2 = await this.helped_already_planned(ctx, req);
            } else {
              rval2 = {};
            }
            await ctx.finishTask(rval2);
            return ctx.returnValue(rval2.result);
          }
          let rval = await this.helped_plan(ctx, req);
          if (rval.taskState) {
            let marker = Object.assign({}, rval.taskState, {
              type: this.name,
              id: this.name + ":" + binId,
              accountId: memoryState.accountId
            });
            rval.taskMarkers = new Map([[marker.id, marker]]);
            persistentState.binToMarker.set(binId, marker);
            rval.complexTaskState = persistentState;
            rval.taskState = null;
          }
          if (rval.remainInProgressUntil && this.helped_invalidate_overlays) {
            memoryState.remainInProgressBins.add(binId);
            let dataOverlayManager = ctx.universe.dataOverlayManager;
            rval.remainInProgressUntil.then(() => {
              memoryState.remainInProgressBins.delete(binId);
              this.helped_invalidate_overlays(binId, dataOverlayManager);
            });
          }
          if (this.helped_invalidate_overlays) {
            this.helped_invalidate_overlays(binId, ctx.universe.dataOverlayManager);
          }
          if (rval.announceUpdatedOverlayData) {
            for (let [namespace, id] of rval.announceUpdatedOverlayData) {
              ctx.announceUpdatedOverlayData(namespace, id);
            }
          }
          await ctx.finishTask(rval);
          return ctx.returnValue(rval.result);
        },
        async execute(ctx, persistentState, memoryState, marker) {
          let binId = this.binByArg ? marker[this.binByArg] : "only";
          memoryState.inProgressBins.add(binId);
          if (this.helped_invalidate_overlays) {
            this.helped_invalidate_overlays(binId, ctx.universe.dataOverlayManager);
          }
          let rval = await this.helped_execute(ctx, marker);
          memoryState.inProgressBins.delete(binId);
          persistentState.binToMarker.delete(binId);
          rval.complexTaskState = persistentState;
          if (this.helped_invalidate_overlays) {
            this.helped_invalidate_overlays(binId, ctx.universe.dataOverlayManager);
          }
          if (rval.announceUpdatedOverlayData) {
            for (let [namespace, id] of rval.announceUpdatedOverlayData) {
              ctx.announceUpdatedOverlayData(namespace, id);
            }
          }
          await ctx.finishTask(rval);
          return ctx.returnValue(rval.result);
        }
      };
    }
  });

  // src/backend/task_infra/task_definer.js
  function mixInvokingBaseHooks(baseImpl, mixparts) {
    if (!baseImpl.__preMix && !baseImpl.__postMix) {
      return Object.assign({}, baseImpl, ...mixparts);
    }
    let target = Object.assign({}, baseImpl);
    let coalescedParts = Object.assign({}, ...mixparts);
    if (target.__preMix) {
      target.__preMix(coalescedParts);
    }
    Object.assign(target, coalescedParts);
    if (target.__postMix) {
      target.__postMix();
    }
    return target;
  }
  function TaskDefiner() {
  }
  var SimpleTaskBase, ComplexTaskBase, task_definer_default;
  var init_task_definer = __esm({
    "src/backend/task_infra/task_definer.js"() {
      init_util();
      init_at_most_once();
      SimpleTaskBase = {
        isSimple: true,
        isComplex: false,
        async plan(ctx, rawTask) {
          let decoratedTask = shallowClone2(rawTask);
          if (this.exclusiveResources) {
            decoratedTask.exclusiveResources = this.exclusiveResources(rawTask);
          }
          if (this.priorityTags) {
            decoratedTask.priorityTags = this.priorityTags(rawTask);
          }
          await ctx.finishTask({
            taskState: decoratedTask
          });
        },
        execute: null
      };
      ComplexTaskBase = {
        isSimple: false,
        isComplex: true
      };
      TaskDefiner.prototype = {
        defineSimpleTask(mixparts) {
          return mixInvokingBaseHooks(SimpleTaskBase, mixparts);
        },
        defineAtMostOnceTask(mixparts) {
          return mixInvokingBaseHooks(at_most_once_default, mixparts);
        },
        defineComplexTask(mixparts) {
          return mixInvokingBaseHooks(ComplexTaskBase, mixparts);
        }
      };
      task_definer_default = new TaskDefiner();
    }
  });

  // src/backend/db/folder_info_rep.js
  function makeFolderMeta(raw) {
    return {
      id: raw.id || null,
      serverId: raw.serverId || null,
      name: raw.name || null,
      type: raw.type || null,
      path: raw.path || null,
      serverPath: raw.serverPath || null,
      parentId: raw.parentId || null,
      delim: raw.delim || null,
      depth: raw.depth || 0,
      syncGranularity: raw.syncGranularity || null,
      localMessageCount: 0,
      estimatedUnsyncedMessages: null,
      syncedThrough: null,
      lastSuccessfulSyncAt: raw.lastSuccessfulSyncAt || 0,
      lastAttemptedSyncAt: raw.lastAttemptedSyncAt || 0,
      lastFailedSyncAt: raw.lastFailedSyncAt || 0,
      failedSyncsSinceLastSuccessfulSync: raw.failedSyncsSinceLastSuccessfulSync || 0,
      localUnreadConversations: raw.localUnreadConversations || 0
    };
  }
  var init_folder_info_rep = __esm({
    "src/backend/db/folder_info_rep.js"() {
    }
  });

  // src/backend/accounts/activesync/normalize_folder.js
  function getFirstFolderWithType2(folderIdToFolderInfo, type) {
    for (let folderInfo of folderIdToFolderInfo.values()) {
      if (folderInfo.type === type) {
        return folderInfo;
      }
    }
    return null;
  }
  function normalizeFolder({ idMaker, serverIdToFolderId, folderIdToFolderInfo }, { serverId, parentServerId, displayName, typeNum, forceType }) {
    if (!forceType && !(typeNum in folderTypes)) {
      return true;
    }
    let path = displayName;
    let parentFolderId = null;
    let depth = 0;
    if (parentServerId !== "0") {
      parentFolderId = serverIdToFolderId.get(parentServerId);
      let parentInfo = folderIdToFolderInfo.get(parentFolderId);
      if (!parent) {
        return null;
      }
      path = parentInfo.path + "/" + path;
      depth = parentInfo.depth + 1;
    }
    let useFolderType = folderTypes[typeNum];
    if (depth < 2) {
      var normalizedName = displayName.toLowerCase();
      if (junkFolderNames.includes(normalizedName)) {
        useFolderType = "junk";
      }
    }
    if (forceType) {
      useFolderType = forceType;
    }
    if (typeNum === $FolderTypes.DefaultInbox) {
      let existingInboxMeta = getFirstFolderWithType2(folderIdToFolderInfo, "inbox");
      if (existingInboxMeta) {
        existingInboxMeta.serverId = serverId;
        existingInboxMeta.name = displayName;
        existingInboxMeta.path = path;
        existingInboxMeta.depth = depth;
        return true;
      }
    }
    var folderId = idMaker();
    var folderInfo = makeFolderMeta({
      id: folderId,
      serverId,
      name: displayName,
      type: useFolderType,
      path,
      parentId: parentFolderId,
      depth,
      lastSyncedAt: 0
    });
    return folderInfo;
  }
  var $FolderTypes, folderTypes, junkFolderNames;
  var init_normalize_folder = __esm({
    "src/backend/accounts/activesync/normalize_folder.js"() {
      init_folder_info_rep();
      init_FolderHierarchy();
      $FolderTypes = FolderHierarchy_default.Enums.Type;
      folderTypes = {
        1: "normal",
        2: "inbox",
        3: "drafts",
        4: "trash",
        5: "sent",
        6: "normal",
        12: "normal"
      };
      junkFolderNames = [
        "bulk mail",
        "correo no deseado",
        "courrier ind\xE9sirable",
        "istenmeyen",
        "istenmeyen e-posta",
        "junk",
        "lev\xE9lszem\xE9t",
        "nevy\u017Eiadan\xE1 po\u0161ta",
        "nevy\u017E\xE1dan\xE1 po\u0161ta",
        "no deseado",
        "posta indesiderata",
        "pourriel",
        "roskaposti",
        "skr\xE4ppost",
        "spam",
        "spamowanie",
        "s\xF8ppelpost",
        "th\u01B0 r\xE1c",
        "\u0441\u043F\u0430\u043C",
        "\u05D3\u05D5\u05D0\u05E8 \u05D6\u05D1\u05DC",
        "\u0627\u0644\u0631\u0633\u0627\u0626\u0644 \u0627\u0644\u0639\u0634\u0648\u0627\u0626\u064A\u0629",
        "\u0647\u0631\u0632\u0646\u0627\u0645\u0647",
        "\u0E2A\u0E41\u0E1B\u0E21",
        "\u5783\u573E\u90F5\u4EF6",
        "\u5783\u573E\u90AE\u4EF6",
        "\u5783\u573E\u96FB\u90F5"
      ];
    }
  });

  // src/backend/accounts/activesync/account_sync_state_helper.js
  function AccountSyncStateHelper(ctx, rawSyncState, accountId) {
    if (!rawSyncState) {
      logic(ctx, "creatingDefaultSyncState", {});
      rawSyncState = {
        hierarchySyncKey: "0",
        nextFolderNum: 0,
        serverIdToFolderId: new Map()
      };
    }
    this._ctx = ctx;
    this._accountId = accountId;
    this.rawSyncState = rawSyncState;
    this.serverIdToFolderId = rawSyncState.serverIdToFolderId;
  }
  var init_account_sync_state_helper = __esm({
    "src/backend/accounts/activesync/account_sync_state_helper.js"() {
      init_logic();
      init_a64();
      AccountSyncStateHelper.prototype = {
        get hierarchySyncKey() {
          return this.rawSyncState.hierarchySyncKey;
        },
        set hierarchySyncKey(val) {
          this.rawSyncState.hierarchySyncKey = val;
        },
        issueFolderId() {
          return this._accountId + "." + encodeInt(this.rawSyncState.nextFolderNum++);
        },
        addedFolder(serverId, folderInfo) {
          this.serverIdToFolderId.set(serverId, folderInfo);
        },
        removedFolder(serverId) {
          this.serverIdToFolderId.delete(serverId);
        }
      };
    }
  });

  // src/backend/accounts/activesync/smotocol/enum_hierarchy_changes.js
  async function enumerateHierarchyChanges(conn, { hierarchySyncKey, emitter }) {
    let w = new Writer("1.3", 1, "UTF-8");
    w.stag(FolderHierarchy_default.Tags.FolderSync).tag(FolderHierarchy_default.Tags.SyncKey, hierarchySyncKey).etag();
    let response = await conn.postCommand(w);
    let e = new EventParser();
    let newSyncKey;
    e.addEventListener([FolderHierarchy_default.Tags.FolderSync, FolderHierarchy_default.Tags.SyncKey], function(node) {
      newSyncKey = node.children[0].textContent;
    });
    e.addEventListener([FolderHierarchy_default.Tags.FolderSync, FolderHierarchy_default.Tags.Changes, [FolderHierarchy_default.Tags.Add, FolderHierarchy_default.Tags.Delete]], function(node) {
      let folderArgs = {};
      for (let child of node.children) {
        folderArgs[child.localTagName] = child.children[0].textContent;
      }
      if (node.tag === FolderHierarchy_default.Tags.Add) {
        emitter.emit("add", folderArgs);
      } else {
        emitter.emit("remove", folderArgs.ServerId);
      }
    });
    try {
      e.run(response);
    } catch (ex) {
      console.error("Error parsing FolderSync response:", ex, "\n", ex.stack);
      throw new Error("unknown");
    }
    return { hierarchySyncKey: newSyncKey };
  }
  var init_enum_hierarchy_changes = __esm({
    "src/backend/accounts/activesync/smotocol/enum_hierarchy_changes.js"() {
      init_wbxml();
      init_FolderHierarchy();
    }
  });

  // src/backend/task_mixins/mix_sync_folder_list.js
  var MixinSyncFolderList, mix_sync_folder_list_default;
  var init_mix_sync_folder_list = __esm({
    "src/backend/task_mixins/mix_sync_folder_list.js"() {
      init_folder_info_rep();
      init_util();
      MixinSyncFolderList = {
        name: "sync_folder_list",
        args: ["accountId"],
        essentialOfflineFolders: [
          {
            type: "inbox",
            displayName: "Inbox",
            path: "INBOX",
            serverPath: "INBOX"
          },
          {
            type: "outbox",
            displayName: "outbox"
          },
          {
            type: "localdrafts",
            displayName: "localdrafts"
          }
        ],
        ensureEssentialOfflineFolders(ctx, account) {
          let foldersTOC = account.foldersTOC;
          let newFolders = [];
          for (let desired of this.essentialOfflineFolders) {
            if (foldersTOC.getCanonicalFolderByType(desired.type) === null) {
              newFolders.push(makeFolderMeta({
                id: foldersTOC.issueFolderId(),
                serverId: null,
                name: desired.displayName,
                type: desired.type,
                path: desired.path || desired.displayName,
                serverPath: desired.serverPath || null,
                parentId: null,
                depth: 0,
                lastSyncedAt: 0
              }));
            }
          }
          return Promise.resolve({
            newFolders
          });
        },
        async plan(ctx, rawTask) {
          let decoratedTask = shallowClone2(rawTask);
          decoratedTask.exclusiveResources = [
            `folderInfo:${rawTask.accountId}`
          ];
          decoratedTask.priorityTags = ["view:folders"];
          let account = await ctx.universe.acquireAccount(ctx, rawTask.accountId);
          let {
            newFolders,
            modifiedFolders
          } = await this.ensureEssentialOfflineFolders(ctx, account);
          await ctx.finishTask({
            mutations: {
              folders: modifiedFolders
            },
            newData: {
              folders: newFolders
            },
            taskState: this.execute ? decoratedTask : null
          });
        },
        async execute(ctx, planned) {
          let account = await ctx.universe.acquireAccount(ctx, planned.accountId);
          let {
            modifiedFolders,
            newFolders,
            newTasks,
            modifiedSyncStates
          } = await this.syncFolders(ctx, account);
          await ctx.finishTask({
            mutations: {
              folders: modifiedFolders,
              syncStates: modifiedSyncStates
            },
            newData: {
              folders: newFolders,
              tasks: newTasks
            },
            taskState: null
          });
        }
      };
      mix_sync_folder_list_default = MixinSyncFolderList;
    }
  });

  // src/backend/accounts/activesync/tasks/sync_folder_list.js
  var import_evt5, sync_folder_list_default;
  var init_sync_folder_list = __esm({
    "src/backend/accounts/activesync/tasks/sync_folder_list.js"() {
      import_evt5 = __toModule(require_evt());
      init_task_definer();
      init_normalize_folder();
      init_account_sync_state_helper();
      init_enum_hierarchy_changes();
      init_mix_sync_folder_list();
      sync_folder_list_default = task_definer_default.defineSimpleTask([
        mix_sync_folder_list_default,
        {
          essentialOfflineFolders: [
            {
              type: "inbox",
              displayName: "Inbox"
            },
            {
              type: "outbox",
              displayName: "outbox"
            },
            {
              type: "localdrafts",
              displayName: "localdrafts"
            }
          ],
          async syncFolders(ctx, account) {
            let foldersTOC = account.foldersTOC;
            let conn = await account.ensureConnection();
            let newFolders = [];
            let modifiedFolders = new Map();
            let fromDb = await ctx.beginMutate({
              syncStates: new Map([[account.id, null]])
            });
            let rawSyncState = fromDb.syncStates.get(account.id);
            let syncState = new AccountSyncStateHelper(ctx, rawSyncState, account.id);
            let emitter = new import_evt5.default.Emitter();
            let deferredFolders = [];
            function tryAndAddFolder(folderArgs) {
              let maybeFolderInfo = normalizeFolder({
                idMaker: foldersTOC.issueFolderId.bind(syncState),
                serverIdToFolderId: syncState.serverIdToFolderId,
                folderIdToFolderInfo: foldersTOC.foldersById
              }, {
                serverId: folderArgs.ServerId,
                parentServerId: folderArgs.ParentId,
                displayName: folderArgs.DisplayName,
                typeNum: folderArgs.Type
              });
              if (maybeFolderInfo === null) {
                deferredFolders.push(folderArgs);
              } else if (maybeFolderInfo === true) {
                syncState.addedFolder(maybeFolderInfo);
                modifiedFolders.set(maybeFolderInfo.id, maybeFolderInfo);
              } else {
                syncState.addedFolder(maybeFolderInfo);
                newFolders.push(maybeFolderInfo);
              }
            }
            emitter.on("add", (folderArgs) => {
              tryAndAddFolder(folderArgs);
            });
            emitter.on("remove", (serverId) => {
              syncState.removedFolder(serverId);
              let folderId = syncState.serverIdToFolderId.get(serverId);
              modifiedFolders.set(folderId, null);
            });
            syncState.hierarchySyncKey = (await enumerateHierarchyChanges(conn, {
              hierarchySyncKey: syncState.hierarchySyncKey,
              emitter
            })).hierarchySyncKey;
            while (deferredFolders.length) {
              let processFolders = deferredFolders;
              deferredFolders = [];
              for (let folder of processFolders) {
                tryAndAddFolder(folder);
              }
              if (processFolders.length === deferredFolders.length) {
                throw new Error("got some orphaned folders");
              }
            }
            return {
              newFolders,
              modifiedFolders,
              modifiedSyncStates: new Map([[account.id, syncState.rawSyncState]])
            };
          }
        }
      ]);
    }
  });

  // src/backend/accounts/activesync/folder_sync_state_helper.js
  function FolderSyncStateHelper(ctx, rawSyncState, accountId, folderId) {
    if (!rawSyncState) {
      logic(ctx, "creatingDefaultSyncState", {});
      rawSyncState = {
        nextUmidSuffix: 1,
        syncKey: "0",
        filterType: null,
        serverIdInfo: new Map()
      };
    }
    this._ctx = ctx;
    this._accountId = accountId;
    this._folderId = folderId;
    this.rawSyncState = rawSyncState;
    this._serverIdInfo = this.rawSyncState.serverIdInfo;
    this.umidDeletions = new Set();
    this.umidFlagChanges = new Map();
    this.umidNameReads = new Map();
    this._tasksByConvId = new Map();
    this.tasksToSchedule = [];
    this.umidNameWrites = new Map();
    this.umidLocationWrites = new Map();
  }
  var folder_sync_state_helper_default;
  var init_folder_sync_state_helper = __esm({
    "src/backend/accounts/activesync/folder_sync_state_helper.js"() {
      init_logic();
      init_id_conversions();
      init_util();
      init_a64();
      FolderSyncStateHelper.prototype = {
        get syncKey() {
          return this.rawSyncState.syncKey;
        },
        set syncKey(val) {
          this.rawSyncState.syncKey = val;
        },
        get filterType() {
          return this.rawSyncState.filterType;
        },
        set filterType(val) {
          this.rawSyncState.filterType = val;
        },
        issueUniqueMessageId() {
          return this._folderId + "." + encodeInt(this.rawSyncState.nextUmidSuffix++);
        },
        getUmidForServerId(serverId) {
          return this._serverIdInfo.get(serverId);
        },
        newMessage(serverId, message) {
          let umid = message.umid;
          this.umidNameWrites.set(umid, message.id);
          this.umidLocationWrites.set(umid, [this._folderId, serverId]);
          this._serverIdInfo.set(serverId, umid);
        },
        messageChanged(serverId, changes) {
          let umid = this._serverIdInfo.get(serverId);
          this.umidFlagChanges.set(umid, changes.flagChanges);
          this.umidNameReads.set(umid, null);
        },
        messageDeleted(serverId) {
          let umid = this._serverIdInfo.get(serverId);
          if (!umid) {
            logic.fail("heard about a deletion for an unknown message");
            return;
          }
          this._serverIdInfo.delete(serverId);
          this.umidDeletions.add(umid);
          this.umidNameReads.set(umid, null);
          this.umidLocationWrites.set(umid, null);
        },
        syncKeyInvalidatedSoDeleteAllMessages() {
          this.syncKey = "0";
          for (let serverId of this._serverIdInfo.keys()) {
            this.messageDeleted(serverId);
          }
        },
        generateSyncConvTasks() {
          let umidNameReads = this.umidNameReads;
          for (let [umid, flags] of this.umidFlagChanges) {
            let messageId = umidNameReads.get(umid);
            if (messageId) {
              this._ensureTaskWithUmidFlags(messageId, umid, flags);
            }
          }
          for (let umid of this.umidDeletions) {
            let messageId = umidNameReads.get(umid);
            if (messageId) {
              this._ensureTaskWithRemovedUmid(messageId, umid);
            }
          }
        },
        _ensureTaskWithUmidFlags(messageId, umid, flags) {
          let convId = convIdFromMessageId(messageId);
          let task = this._ensureConvTask(convId);
          if (!task.modifiedUmids) {
            task.modifiedUmids = new Map();
          }
          task.modifiedUmids.set(umid, flags);
        },
        _ensureTaskWithRemovedUmid(messageId, umid) {
          let convId = convIdFromMessageId(messageId);
          let task = this._ensureConvTask(convId);
          if (!task.removedUmids) {
            task.removedUmids = new Set();
          }
          task.removedUmids.add(umid);
        },
        _ensureConvTask(convId) {
          if (this._tasksByConvId.has(convId)) {
            return this._tasksByConvId(convId);
          }
          let task = {
            type: "sync_conv",
            accountId: this._accountId,
            convId,
            modifiedUmids: null,
            removedUmids: null
          };
          this.tasksToSchedule.push(task);
          this._tasksByConvId.set(convId, task);
          return task;
        },
        scheduleAnotherRefreshLikeThisOne(req) {
          let rawTask = shallowClone2(req);
          delete rawTask.exclusiveResources;
          delete rawTask.priorityTags;
          this.tasksToSchedule.push(rawTask);
        }
      };
      folder_sync_state_helper_default = FolderSyncStateHelper;
    }
  });

  // src/backend/accounts/activesync/smotocol/get_folder_sync_key.js
  async function getFolderSyncKey(conn, { folderServerId, filterType }) {
    let w = new Writer("1.3", 1, "UTF-8");
    w.stag(AirSync_default.Tags.Sync).stag(AirSync_default.Tags.Collections).stag(AirSync_default.Tags.Collection);
    if (conn.currentVersion.lt("12.1")) {
      w.tag(AirSync_default.Tags.Cl$ass, "Email");
    }
    w.tag(AirSync_default.Tags.SyncKey, "0").tag(AirSync_default.Tags.CollectionId, folderServerId).stag(AirSync_default.Tags.Options).tag(AirSync_default.Tags.FilterType, filterType).etag().etag().etag().etag();
    let response = await conn.postCommand(w);
    let e = new EventParser();
    let newSyncKey = "0";
    e.addEventListener([
      AirSync_default.Tags.Sync,
      AirSync_default.Tags.Collections,
      AirSync_default.Tags.Collection,
      AirSync_default.Tags.SyncKey
    ], function(node) {
      newSyncKey = node.children[0].textContent;
    });
    try {
      e.run(response);
    } catch (ex) {
      console.error("Error parsing FolderCreate response:", ex, "\n", ex.stack);
      throw new Error("unknown");
    }
    if (newSyncKey === "0") {
      console.error("Unable to get sync key for folder");
      throw new Error("unknown");
    }
    return { syncKey: newSyncKey };
  }
  var init_get_folder_sync_key = __esm({
    "src/backend/accounts/activesync/smotocol/get_folder_sync_key.js"() {
      init_wbxml();
      init_AirSync();
    }
  });

  // src/backend/accounts/activesync/smotocol/get_item_estimate.js
  async function getItemEstimate(conn, { folderSyncKey, folderServerId, filterType }) {
    let w = new Writer("1.3", 1, "UTF-8");
    w.stag(ItemEstimate_default.Tags.GetItemEstimate).stag(ItemEstimate_default.Tags.Collections).stag(ItemEstimate_default.Tags.Collection);
    if (conn.currentVersion.gte("14.0")) {
      w.tag(AirSync_default.Tags.SyncKey, folderSyncKey).tag(ItemEstimate_default.Tags.CollectionId, folderServerId).stag(AirSync_default.Tags.Options).tag(AirSync_default.Tags.FilterType, filterType).etag();
    } else if (conn.currentVersion.gte("12.0")) {
      w.tag(ItemEstimate_default.Tags.CollectionId, folderServerId).tag(AirSync_default.Tags.FilterType, filterType).tag(AirSync_default.Tags.SyncKey, folderSyncKey);
    } else {
      w.tag(ItemEstimate_default.Tags.Class, "Email").tag(AirSync_default.Tags.SyncKey, folderSyncKey).tag(ItemEstimate_default.Tags.CollectionId, folderServerId).tag(AirSync_default.Tags.FilterType, filterType);
    }
    w.etag(ItemEstimate_default.Tags.Collection).etag(ItemEstimate_default.Tags.Collections).etag(ItemEstimate_default.Tags.GetItemEstimate);
    let response = await conn.postCommand(w);
    let e = new EventParser();
    let base = [ItemEstimate_default.Tags.GetItemEstimate, ItemEstimate_default.Tags.Response];
    let status, estimate;
    e.addEventListener(base.concat(ItemEstimate_default.Tags.Status), function(node) {
      status = node.children[0].textContent;
    });
    e.addEventListener(base.concat(ItemEstimate_default.Tags.Collection, ItemEstimate_default.Tags.Estimate), function(node) {
      estimate = parseInt(node.children[0].textContent, 10);
    });
    try {
      e.run(response);
    } catch (ex) {
      console.error("Error parsing FolderCreate response:", ex, "\n", ex.stack);
      throw new Error("unknown");
    }
    if (status !== ItemEstimate_default.Enums.Status.Success) {
      throw new Error("unknown");
    } else {
      return { estimate };
    }
  }
  var init_get_item_estimate = __esm({
    "src/backend/accounts/activesync/smotocol/get_item_estimate.js"() {
      init_wbxml();
      init_AirSync();
      init_ItemEstimate();
    }
  });

  // src/backend/accounts/activesync/smotocol/infer_filter_type.js
  async function inferFilterType(conn, { folderServerId, desiredMessageCount }) {
    const Type = AirSync_default.Enums.FilterType;
    let filterType = Type.TwoWeeksBack;
    let { syncKey } = await getFolderSyncKey(conn, {
      folderServerId,
      filterType
    });
    let { estimate } = await getItemEstimate(conn, {
      folderSyncKey: syncKey,
      folderServerId,
      filterType
    });
    let messagesPerDay = estimate / 14;
    let desiredFilterType;
    if (estimate < 0) {
      desiredFilterType = Type.ThreeDaysBack;
    } else if (messagesPerDay >= desiredMessageCount) {
      desiredFilterType = Type.OneDayBack;
    } else if (messagesPerDay * 3 >= desiredMessageCount) {
      desiredFilterType = Type.ThreeDaysBack;
    } else if (messagesPerDay * 7 >= desiredMessageCount) {
      desiredFilterType = Type.OneWeekBack;
    } else if (messagesPerDay * 14 >= desiredMessageCount) {
      desiredFilterType = Type.TwoWeeksBack;
    } else if (messagesPerDay * 30 >= desiredMessageCount) {
      desiredFilterType = Type.OneMonthBack;
    } else {
      filterType = Type.NoFilter;
      syncKey = (await getFolderSyncKey(conn, { folderServerId, filterType })).syncKey;
      estimate = (await getItemEstimate(conn, {
        folderSyncKey: syncKey,
        folderServerId,
        filterType
      })).estimate;
      if (estimate > desiredMessageCount) {
        desiredFilterType = Type.OneMonthBack;
      } else {
        desiredFilterType = Type.NoFilter;
      }
    }
    if (filterType !== desiredFilterType) {
      filterType = desiredFilterType;
      syncKey = (await getFolderSyncKey(conn, { folderServerId, filterType })).syncKey;
    }
    logic(conn, "inferFilterType", { filterType });
    return { filterType, syncKey };
  }
  var init_infer_filter_type = __esm({
    "src/backend/accounts/activesync/smotocol/infer_filter_type.js"() {
      init_logic();
      init_AirSync();
      init_get_folder_sync_key();
      init_get_item_estimate();
    }
  });

  // src/vendor/mimetypes.js
  var require_mimetypes = __commonJS({
    "src/vendor/mimetypes.js"(exports, module) {
      (function(root, factory) {
        "use strict";
        if (typeof define === "function" && define.amd) {
          define(factory);
        } else if (typeof exports === "object") {
          module.exports = factory();
        } else {
          root.mimetypes = factory();
        }
      })(exports, function() {
        "use strict";
        function detectExtension(mimeType) {
          mimeType = (mimeType || "").toString().toLowerCase().replace(/\s/g, "");
          if (!(mimeType in mimetypesList)) {
            return "bin";
          }
          if (typeof mimetypesList[mimeType] === "string") {
            return mimetypesList[mimeType];
          }
          var mimeParts = mimeType.split("/");
          for (var i = 0, len = mimetypesList[mimeType].length; i < len; i++) {
            if (mimeParts[1] === mimetypesList[mimeType][i]) {
              return mimetypesList[mimeType][i];
            }
          }
          return mimetypesList[mimeType][0];
        }
        function detectMimeType(extension) {
          extension = (extension || "").toString().toLowerCase().replace(/\s/g, "").replace(/^\./g, "");
          if (!(extension in mimetypesExtensions)) {
            return "application/octet-stream";
          }
          if (typeof mimetypesExtensions[extension] === "string") {
            return mimetypesExtensions[extension];
          }
          var mimeParts;
          for (var i = 0, len = mimetypesExtensions[extension].length; i < len; i++) {
            mimeParts = mimetypesExtensions[extension][i].split("/");
            if (mimeParts[1] === extension) {
              return mimetypesExtensions[extension][i];
            }
          }
          return mimetypesExtensions[extension][0];
        }
        var mimetypesList = {
          "application/acad": "dwg",
          "application/andrew-inset": "",
          "application/applixware": "aw",
          "application/arj": "arj",
          "application/atom+xml": "xml",
          "application/atomcat+xml": "atomcat",
          "application/atomsvc+xml": "atomsvc",
          "application/base64": ["mm", "mme"],
          "application/binhex": "hqx",
          "application/binhex4": "hqx",
          "application/book": ["boo", "book"],
          "application/ccxml+xml,": "ccxml",
          "application/cdf": "cdf",
          "application/cdmi-capability": "cdmia",
          "application/cdmi-container": "cdmic",
          "application/cdmi-domain": "cdmid",
          "application/cdmi-object": "cdmio",
          "application/cdmi-queue": "cdmiq",
          "application/clariscad": "ccad",
          "application/commonground": "dp",
          "application/cu-seeme": "cu",
          "application/davmount+xml": "davmount",
          "application/drafting": "drw",
          "application/dsptype": "tsp",
          "application/dssc+der": "dssc",
          "application/dssc+xml": "xdssc",
          "application/dxf": "dxf",
          "application/ecmascript": ["js", "es"],
          "application/emma+xml": "emma",
          "application/envoy": "evy",
          "application/epub+zip": "epub",
          "application/excel": ["xl", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xls", "xlt", "xlv", "xlw"],
          "application/exi": "exi",
          "application/font-tdpfr": "pfr",
          "application/fractals": "fif",
          "application/freeloader": "frl",
          "application/futuresplash": "spl",
          "application/gnutar": "tgz",
          "application/groupwise": "vew",
          "application/hlp": "hlp",
          "application/hta": "hta",
          "application/hyperstudio": "stk",
          "application/i-deas": "unv",
          "application/iges": ["iges", "igs"],
          "application/inf": "inf",
          "application/internet-property-stream": "acx",
          "application/ipfix": "ipfix",
          "application/java": "class",
          "application/java-archive": "jar",
          "application/java-byte-code": "class",
          "application/java-serialized-object": "ser",
          "application/java-vm": "class",
          "application/javascript": "js",
          "application/json": "json",
          "application/lha": "lha",
          "application/lzx": "lzx",
          "application/mac-binary": "bin",
          "application/mac-binhex": "hqx",
          "application/mac-binhex40": "hqx",
          "application/mac-compactpro": "cpt",
          "application/macbinary": "bin",
          "application/mads+xml": "mads",
          "application/marc": "mrc",
          "application/marcxml+xml": "mrcx",
          "application/mathematica": "ma",
          "application/mathml+xml": "mathml",
          "application/mbedlet": "mbd",
          "application/mbox": "mbox",
          "application/mcad": "mcd",
          "application/mediaservercontrol+xml": "mscml",
          "application/metalink4+xml": "meta4",
          "application/mets+xml": "mets",
          "application/mime": "aps",
          "application/mods+xml": "mods",
          "application/mp21": "m21",
          "application/mp4": "mp4",
          "application/mspowerpoint": ["pot", "pps", "ppt", "ppz"],
          "application/msword": ["doc", "dot", "w6w", "wiz", "word"],
          "application/mswrite": "wri",
          "application/mxf": "mxf",
          "application/netmc": "mcp",
          "application/octet-stream": ["*"],
          "application/oda": "oda",
          "application/oebps-package+xml": "opf",
          "application/ogg": "ogx",
          "application/olescript": "axs",
          "application/onenote": "onetoc",
          "application/patch-ops-error+xml": "xer",
          "application/pdf": "pdf",
          "application/pgp-encrypted": "",
          "application/pgp-signature": "pgp",
          "application/pics-rules": "prf",
          "application/pkcs-12": "p12",
          "application/pkcs-crl": "crl",
          "application/pkcs10": "p10",
          "application/pkcs7-mime": ["p7c", "p7m"],
          "application/pkcs7-signature": "p7s",
          "application/pkcs8": "p8",
          "application/pkix-attr-cert": "ac",
          "application/pkix-cert": ["cer", "crt"],
          "application/pkix-crl": "crl",
          "application/pkix-pkipath": "pkipath",
          "application/pkixcmp": "pki",
          "application/plain": "text",
          "application/pls+xml": "pls",
          "application/postscript": ["ai", "eps", "ps"],
          "application/powerpoint": "ppt",
          "application/pro_eng": ["part", "prt"],
          "application/prs.cww": "cww",
          "application/pskc+xml": "pskcxml",
          "application/rdf+xml": "rdf",
          "application/reginfo+xml": "rif",
          "application/relax-ng-compact-syntax": "rnc",
          "application/resource-lists+xml": "rl",
          "application/resource-lists-diff+xml": "rld",
          "application/ringing-tones": "rng",
          "application/rls-services+xml": "rs",
          "application/rsd+xml": "rsd",
          "application/rss+xml": "xml",
          "application/rtf": ["rtf", "rtx"],
          "application/sbml+xml": "sbml",
          "application/scvp-cv-request": "scq",
          "application/scvp-cv-response": "scs",
          "application/scvp-vp-request": "spq",
          "application/scvp-vp-response": "spp",
          "application/sdp": "sdp",
          "application/sea": "sea",
          "application/set": "set",
          "application/set-payment-initiation": "setpay",
          "application/set-registration-initiation": "setreg",
          "application/shf+xml": "shf",
          "application/sla": "stl",
          "application/smil": ["smi", "smil"],
          "application/smil+xml": "smi",
          "application/solids": "sol",
          "application/sounder": "sdr",
          "application/sparql-query": "rq",
          "application/sparql-results+xml": "srx",
          "application/srgs": "gram",
          "application/srgs+xml": "grxml",
          "application/sru+xml": "sru",
          "application/ssml+xml": "ssml",
          "application/step": ["step", "stp"],
          "application/streamingmedia": "ssm",
          "application/tei+xml": "tei",
          "application/thraud+xml": "tfi",
          "application/timestamped-data": "tsd",
          "application/toolbook": "tbk",
          "application/vda": "vda",
          "application/vnd.3gpp.pic-bw-large": "plb",
          "application/vnd.3gpp.pic-bw-small": "psb",
          "application/vnd.3gpp.pic-bw-var": "pvb",
          "application/vnd.3gpp2.tcap": "tcap",
          "application/vnd.3m.post-it-notes": "pwn",
          "application/vnd.accpac.simply.aso": "aso",
          "application/vnd.accpac.simply.imp": "imp",
          "application/vnd.acucobol": "acu",
          "application/vnd.acucorp": "atc",
          "application/vnd.adobe.air-application-installer-package+zip": "air",
          "application/vnd.adobe.fxp": "fxp",
          "application/vnd.adobe.xdp+xml": "xdp",
          "application/vnd.adobe.xfdf": "xfdf",
          "application/vnd.ahead.space": "ahead",
          "application/vnd.airzip.filesecure.azf": "azf",
          "application/vnd.airzip.filesecure.azs": "azs",
          "application/vnd.amazon.ebook": "azw",
          "application/vnd.americandynamics.acc": "acc",
          "application/vnd.amiga.ami": "ami",
          "application/vnd.android.package-archive": "apk",
          "application/vnd.anser-web-certificate-issue-initiation": "cii",
          "application/vnd.anser-web-funds-transfer-initiation": "fti",
          "application/vnd.antix.game-component": "atx",
          "application/vnd.apple.installer+xml": "mpkg",
          "application/vnd.apple.mpegurl": "m3u8",
          "application/vnd.aristanetworks.swi": "swi",
          "application/vnd.audiograph": "aep",
          "application/vnd.blueice.multipass": "mpm",
          "application/vnd.bmi": "bmi",
          "application/vnd.businessobjects": "rep",
          "application/vnd.chemdraw+xml": "cdxml",
          "application/vnd.chipnuts.karaoke-mmd": "mmd",
          "application/vnd.cinderella": "cdy",
          "application/vnd.claymore": "cla",
          "application/vnd.cloanto.rp9": "rp9",
          "application/vnd.clonk.c4group": "c4g",
          "application/vnd.cluetrust.cartomobile-config": "c11amc",
          "application/vnd.cluetrust.cartomobile-config-pkg": "c11amz",
          "application/vnd.commonspace": "csp",
          "application/vnd.contact.cmsg": "cdbcmsg",
          "application/vnd.cosmocaller": "cmc",
          "application/vnd.crick.clicker": "clkx",
          "application/vnd.crick.clicker.keyboard": "clkk",
          "application/vnd.crick.clicker.palette": "clkp",
          "application/vnd.crick.clicker.template": "clkt",
          "application/vnd.crick.clicker.wordbank": "clkw",
          "application/vnd.criticaltools.wbs+xml": "wbs",
          "application/vnd.ctc-posml": "pml",
          "application/vnd.cups-ppd": "ppd",
          "application/vnd.curl.car": "car",
          "application/vnd.curl.pcurl": "pcurl",
          "application/vnd.data-vision.rdz": "rdz",
          "application/vnd.denovo.fcselayout-link": "fe_launch",
          "application/vnd.dna": "dna",
          "application/vnd.dolby.mlp": "mlp",
          "application/vnd.dpgraph": "dpg",
          "application/vnd.dreamfactory": "dfac",
          "application/vnd.dvb.ait": "ait",
          "application/vnd.dvb.service": "svc",
          "application/vnd.dynageo": "geo",
          "application/vnd.ecowin.chart": "mag",
          "application/vnd.enliven": "nml",
          "application/vnd.epson.esf": "esf",
          "application/vnd.epson.msf": "msf",
          "application/vnd.epson.quickanime": "qam",
          "application/vnd.epson.salt": "slt",
          "application/vnd.epson.ssf": "ssf",
          "application/vnd.eszigno3+xml": "es3",
          "application/vnd.ezpix-album": "ez2",
          "application/vnd.ezpix-package": "ez3",
          "application/vnd.fdf": "fdf",
          "application/vnd.fdsn.seed": "seed",
          "application/vnd.flographit": "gph",
          "application/vnd.fluxtime.clip": "ftc",
          "application/vnd.framemaker": "fm",
          "application/vnd.frogans.fnc": "fnc",
          "application/vnd.frogans.ltf": "ltf",
          "application/vnd.fsc.weblaunch": "fsc",
          "application/vnd.fujitsu.oasys": "oas",
          "application/vnd.fujitsu.oasys2": "oa2",
          "application/vnd.fujitsu.oasys3": "oa3",
          "application/vnd.fujitsu.oasysgp": "fg5",
          "application/vnd.fujitsu.oasysprs": "bh2",
          "application/vnd.fujixerox.ddd": "ddd",
          "application/vnd.fujixerox.docuworks": "xdw",
          "application/vnd.fujixerox.docuworks.binder": "xbd",
          "application/vnd.fuzzysheet": "fzs",
          "application/vnd.genomatix.tuxedo": "txd",
          "application/vnd.geogebra.file": "ggb",
          "application/vnd.geogebra.tool": "ggt",
          "application/vnd.geometry-explorer": "gex",
          "application/vnd.geonext": "gxt",
          "application/vnd.geoplan": "g2w",
          "application/vnd.geospace": "g3w",
          "application/vnd.gmx": "gmx",
          "application/vnd.google-earth.kml+xml": "kml",
          "application/vnd.google-earth.kmz": "kmz",
          "application/vnd.grafeq": "gqf",
          "application/vnd.groove-account": "gac",
          "application/vnd.groove-help": "ghf",
          "application/vnd.groove-identity-message": "gim",
          "application/vnd.groove-injector": "grv",
          "application/vnd.groove-tool-message": "gtm",
          "application/vnd.groove-tool-template": "tpl",
          "application/vnd.groove-vcard": "vcg",
          "application/vnd.hal+xml": "hal",
          "application/vnd.handheld-entertainment+xml": "zmm",
          "application/vnd.hbci": "hbci",
          "application/vnd.hhe.lesson-player": "les",
          "application/vnd.hp-hpgl": ["hgl", "hpg", "hpgl"],
          "application/vnd.hp-hpid": "hpid",
          "application/vnd.hp-hps": "hps",
          "application/vnd.hp-jlyt": "jlt",
          "application/vnd.hp-pcl": "pcl",
          "application/vnd.hp-pclxl": "pclxl",
          "application/vnd.hydrostatix.sof-data": "sfd-hdstx",
          "application/vnd.hzn-3d-crossword": "x3d",
          "application/vnd.ibm.minipay": "mpy",
          "application/vnd.ibm.modcap": "afp",
          "application/vnd.ibm.rights-management": "irm",
          "application/vnd.ibm.secure-container": "sc",
          "application/vnd.iccprofile": "icc",
          "application/vnd.igloader": "igl",
          "application/vnd.immervision-ivp": "ivp",
          "application/vnd.immervision-ivu": "ivu",
          "application/vnd.insors.igm": "igm",
          "application/vnd.intercon.formnet": "xpw",
          "application/vnd.intergeo": "i2g",
          "application/vnd.intu.qbo": "qbo",
          "application/vnd.intu.qfx": "qfx",
          "application/vnd.ipunplugged.rcprofile": "rcprofile",
          "application/vnd.irepository.package+xml": "irp",
          "application/vnd.is-xpr": "xpr",
          "application/vnd.isac.fcs": "fcs",
          "application/vnd.jam": "jam",
          "application/vnd.jcp.javame.midlet-rms": "rms",
          "application/vnd.jisp": "jisp",
          "application/vnd.joost.joda-archive": "joda",
          "application/vnd.kahootz": "ktz",
          "application/vnd.kde.karbon": "karbon",
          "application/vnd.kde.kchart": "chrt",
          "application/vnd.kde.kformula": "kfo",
          "application/vnd.kde.kivio": "flw",
          "application/vnd.kde.kontour": "kon",
          "application/vnd.kde.kpresenter": "kpr",
          "application/vnd.kde.kspread": "ksp",
          "application/vnd.kde.kword": "kwd",
          "application/vnd.kenameaapp": "htke",
          "application/vnd.kidspiration": "kia",
          "application/vnd.kinar": "kne",
          "application/vnd.koan": "skp",
          "application/vnd.kodak-descriptor": "sse",
          "application/vnd.las.las+xml": "lasxml",
          "application/vnd.llamagraphics.life-balance.desktop": "lbd",
          "application/vnd.llamagraphics.life-balance.exchange+xml": "lbe",
          "application/vnd.lotus-1-2-3": "123",
          "application/vnd.lotus-approach": "apr",
          "application/vnd.lotus-freelance": "pre",
          "application/vnd.lotus-notes": "nsf",
          "application/vnd.lotus-organizer": "org",
          "application/vnd.lotus-screencam": "scm",
          "application/vnd.lotus-wordpro": "lwp",
          "application/vnd.macports.portpkg": "portpkg",
          "application/vnd.mcd": "mcd",
          "application/vnd.medcalcdata": "mc1",
          "application/vnd.mediastation.cdkey": "cdkey",
          "application/vnd.mfer": "mwf",
          "application/vnd.mfmp": "mfm",
          "application/vnd.micrografx.flo": "flo",
          "application/vnd.micrografx.igx": "igx",
          "application/vnd.mif": "mif",
          "application/vnd.mobius.daf": "daf",
          "application/vnd.mobius.dis": "dis",
          "application/vnd.mobius.mbk": "mbk",
          "application/vnd.mobius.mqy": "mqy",
          "application/vnd.mobius.msl": "msl",
          "application/vnd.mobius.plc": "plc",
          "application/vnd.mobius.txf": "txf",
          "application/vnd.mophun.application": "mpn",
          "application/vnd.mophun.certificate": "mpc",
          "application/vnd.mozilla.xul+xml": "xul",
          "application/vnd.ms-artgalry": "cil",
          "application/vnd.ms-cab-compressed": "cab",
          "application/vnd.ms-excel": ["xla", "xlc", "xlm", "xls", "xlt", "xlw", "xlb", "xll"],
          "application/vnd.ms-excel.addin.macroenabled.12": "xlam",
          "application/vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
          "application/vnd.ms-excel.sheet.macroenabled.12": "xlsm",
          "application/vnd.ms-excel.template.macroenabled.12": "xltm",
          "application/vnd.ms-fontobject": "eot",
          "application/vnd.ms-htmlhelp": "chm",
          "application/vnd.ms-ims": "ims",
          "application/vnd.ms-lrm": "lrm",
          "application/vnd.ms-officetheme": "thmx",
          "application/vnd.ms-outlook": "msg",
          "application/vnd.ms-pki.certstore": "sst",
          "application/vnd.ms-pki.pko": "pko",
          "application/vnd.ms-pki.seccat": "cat",
          "application/vnd.ms-pki.stl": "stl",
          "application/vnd.ms-pkicertstore": "sst",
          "application/vnd.ms-pkiseccat": "cat",
          "application/vnd.ms-pkistl": "stl",
          "application/vnd.ms-powerpoint": ["pot", "pps", "ppt", "ppa", "pwz"],
          "application/vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
          "application/vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
          "application/vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
          "application/vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
          "application/vnd.ms-powerpoint.template.macroenabled.12": "potm",
          "application/vnd.ms-project": "mpp",
          "application/vnd.ms-word.document.macroenabled.12": "docm",
          "application/vnd.ms-word.template.macroenabled.12": "dotm",
          "application/vnd.ms-works": ["wcm", "wdb", "wks", "wps"],
          "application/vnd.ms-wpl": "wpl",
          "application/vnd.ms-xpsdocument": "xps",
          "application/vnd.mseq": "mseq",
          "application/vnd.musician": "mus",
          "application/vnd.muvee.style": "msty",
          "application/vnd.neurolanguage.nlu": "nlu",
          "application/vnd.noblenet-directory": "nnd",
          "application/vnd.noblenet-sealer": "nns",
          "application/vnd.noblenet-web": "nnw",
          "application/vnd.nokia.configuration-message": "ncm",
          "application/vnd.nokia.n-gage.data": "ngdat",
          "application/vnd.nokia.n-gage.symbian.install": "n-gage",
          "application/vnd.nokia.radio-preset": "rpst",
          "application/vnd.nokia.radio-presets": "rpss",
          "application/vnd.nokia.ringing-tone": "rng",
          "application/vnd.novadigm.edm": "edm",
          "application/vnd.novadigm.edx": "edx",
          "application/vnd.novadigm.ext": "ext",
          "application/vnd.oasis.opendocument.chart": "odc",
          "application/vnd.oasis.opendocument.chart-template": "otc",
          "application/vnd.oasis.opendocument.database": "odb",
          "application/vnd.oasis.opendocument.formula": "odf",
          "application/vnd.oasis.opendocument.formula-template": "odft",
          "application/vnd.oasis.opendocument.graphics": "odg",
          "application/vnd.oasis.opendocument.graphics-template": "otg",
          "application/vnd.oasis.opendocument.image": "odi",
          "application/vnd.oasis.opendocument.image-template": "oti",
          "application/vnd.oasis.opendocument.presentation": "odp",
          "application/vnd.oasis.opendocument.presentation-template": "otp",
          "application/vnd.oasis.opendocument.spreadsheet": "ods",
          "application/vnd.oasis.opendocument.spreadsheet-template": "ots",
          "application/vnd.oasis.opendocument.text": "odt",
          "application/vnd.oasis.opendocument.text-master": "odm",
          "application/vnd.oasis.opendocument.text-template": "ott",
          "application/vnd.oasis.opendocument.text-web": "oth",
          "application/vnd.olpc-sugar": "xo",
          "application/vnd.oma.dd2+xml": "dd2",
          "application/vnd.openofficeorg.extension": "oxt",
          "application/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
          "application/vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
          "application/vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
          "application/vnd.openxmlformats-officedocument.presentationml.template": "potx",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
          "application/vnd.osgeo.mapguide.package": "mgp",
          "application/vnd.osgi.dp": "dp",
          "application/vnd.palm": "pdb",
          "application/vnd.pawaafile": "paw",
          "application/vnd.pg.format": "str",
          "application/vnd.pg.osasli": "ei6",
          "application/vnd.picsel": "efif",
          "application/vnd.pmi.widget": "wg",
          "application/vnd.pocketlearn": "plf",
          "application/vnd.powerbuilder6": "pbd",
          "application/vnd.previewsystems.box": "box",
          "application/vnd.proteus.magazine": "mgz",
          "application/vnd.publishare-delta-tree": "qps",
          "application/vnd.pvi.ptid1": "ptid",
          "application/vnd.quark.quarkxpress": "qxd",
          "application/vnd.realvnc.bed": "bed",
          "application/vnd.recordare.musicxml": "mxl",
          "application/vnd.recordare.musicxml+xml": "musicxml",
          "application/vnd.rig.cryptonote": "cryptonote",
          "application/vnd.rim.cod": "cod",
          "application/vnd.rn-realmedia": "rm",
          "application/vnd.rn-realplayer": "rnx",
          "application/vnd.route66.link66+xml": "link66",
          "application/vnd.sailingtracker.track": "st",
          "application/vnd.seemail": "see",
          "application/vnd.sema": "sema",
          "application/vnd.semd": "semd",
          "application/vnd.semf": "semf",
          "application/vnd.shana.informed.formdata": "ifm",
          "application/vnd.shana.informed.formtemplate": "itp",
          "application/vnd.shana.informed.interchange": "iif",
          "application/vnd.shana.informed.package": "ipk",
          "application/vnd.simtech-mindmapper": "twd",
          "application/vnd.smaf": "mmf",
          "application/vnd.smart.teacher": "teacher",
          "application/vnd.solent.sdkm+xml": "sdkm",
          "application/vnd.spotfire.dxp": "dxp",
          "application/vnd.spotfire.sfs": "sfs",
          "application/vnd.stardivision.calc": "sdc",
          "application/vnd.stardivision.draw": "sda",
          "application/vnd.stardivision.impress": "sdd",
          "application/vnd.stardivision.math": "smf",
          "application/vnd.stardivision.writer": "sdw",
          "application/vnd.stardivision.writer-global": "sgl",
          "application/vnd.stepmania.stepchart": "sm",
          "application/vnd.sun.xml.calc": "sxc",
          "application/vnd.sun.xml.calc.template": "stc",
          "application/vnd.sun.xml.draw": "sxd",
          "application/vnd.sun.xml.draw.template": "std",
          "application/vnd.sun.xml.impress": "sxi",
          "application/vnd.sun.xml.impress.template": "sti",
          "application/vnd.sun.xml.math": "sxm",
          "application/vnd.sun.xml.writer": "sxw",
          "application/vnd.sun.xml.writer.global": "sxg",
          "application/vnd.sun.xml.writer.template": "stw",
          "application/vnd.sus-calendar": "sus",
          "application/vnd.svd": "svd",
          "application/vnd.symbian.install": "sis",
          "application/vnd.syncml+xml": "xsm",
          "application/vnd.syncml.dm+wbxml": "bdm",
          "application/vnd.syncml.dm+xml": "xdm",
          "application/vnd.tao.intent-module-archive": "tao",
          "application/vnd.tmobile-livetv": "tmo",
          "application/vnd.trid.tpt": "tpt",
          "application/vnd.triscape.mxs": "mxs",
          "application/vnd.trueapp": "tra",
          "application/vnd.ufdl": "ufd",
          "application/vnd.uiq.theme": "utz",
          "application/vnd.umajin": "umj",
          "application/vnd.unity": "unityweb",
          "application/vnd.uoml+xml": "uoml",
          "application/vnd.vcx": "vcx",
          "application/vnd.visio": "vsd",
          "application/vnd.visionary": "vis",
          "application/vnd.vsf": "vsf",
          "application/vnd.wap.wbxml": "wbxml",
          "application/vnd.wap.wmlc": "wmlc",
          "application/vnd.wap.wmlscriptc": "wmlsc",
          "application/vnd.webturbo": "wtb",
          "application/vnd.wolfram.player": "nbp",
          "application/vnd.wordperfect": "wpd",
          "application/vnd.wqd": "wqd",
          "application/vnd.wt.stf": "stf",
          "application/vnd.xara": ["web", "xar"],
          "application/vnd.xfdl": "xfdl",
          "application/vnd.yamaha.hv-dic": "hvd",
          "application/vnd.yamaha.hv-script": "hvs",
          "application/vnd.yamaha.hv-voice": "hvp",
          "application/vnd.yamaha.openscoreformat": "osf",
          "application/vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
          "application/vnd.yamaha.smaf-audio": "saf",
          "application/vnd.yamaha.smaf-phrase": "spf",
          "application/vnd.yellowriver-custom-menu": "cmp",
          "application/vnd.zul": "zir",
          "application/vnd.zzazz.deck+xml": "zaz",
          "application/vocaltec-media-desc": "vmd",
          "application/vocaltec-media-file": "vmf",
          "application/voicexml+xml": "vxml",
          "application/widget": "wgt",
          "application/winhlp": "hlp",
          "application/wordperfect": ["wp", "wp5", "wp6", "wpd"],
          "application/wordperfect6.0": ["w60", "wp5"],
          "application/wordperfect6.1": "w61",
          "application/wsdl+xml": "wsdl",
          "application/wspolicy+xml": "wspolicy",
          "application/x-123": "wk1",
          "application/x-7z-compressed": "7z",
          "application/x-abiword": "abw",
          "application/x-ace-compressed": "ace",
          "application/x-aim": "aim",
          "application/x-authorware-bin": "aab",
          "application/x-authorware-map": "aam",
          "application/x-authorware-seg": "aas",
          "application/x-bcpio": "bcpio",
          "application/x-binary": "bin",
          "application/x-binhex40": "hqx",
          "application/x-bittorrent": "torrent",
          "application/x-bsh": ["bsh", "sh", "shar"],
          "application/x-bytecode.elisp": "elc",
          "applicaiton/x-bytecode.python": "pyc",
          "application/x-bzip": "bz",
          "application/x-bzip2": ["boz", "bz2"],
          "application/x-cdf": "cdf",
          "application/x-cdlink": "vcd",
          "application/x-chat": ["cha", "chat"],
          "application/x-chess-pgn": "pgn",
          "application/x-cmu-raster": "ras",
          "application/x-cocoa": "cco",
          "application/x-compactpro": "cpt",
          "application/x-compress": "z",
          "application/x-compressed": ["tgz", "gz", "z", "zip"],
          "application/x-conference": "nsc",
          "application/x-cpio": "cpio",
          "application/x-cpt": "cpt",
          "application/x-csh": "csh",
          "application/x-debian-package": "deb",
          "application/x-deepv": "deepv",
          "application/x-director": ["dcr", "dir", "dxr"],
          "application/x-doom": "wad",
          "application/x-dtbncx+xml": "ncx",
          "application/x-dtbook+xml": "dtb",
          "application/x-dtbresource+xml": "res",
          "application/x-dvi": "dvi",
          "application/x-elc": "elc",
          "application/x-envoy": ["env", "evy"],
          "application/x-esrehber": "es",
          "application/x-excel": ["xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xls", "xlt", "xlv", "xlw"],
          "application/x-font-bdf": "bdf",
          "application/x-font-ghostscript": "gsf",
          "application/x-font-linux-psf": "psf",
          "application/x-font-otf": "otf",
          "application/x-font-pcf": "pcf",
          "application/x-font-snf": "snf",
          "application/x-font-ttf": "ttf",
          "application/x-font-type1": "pfa",
          "application/x-font-woff": "woff",
          "application/x-frame": "mif",
          "application/x-freelance": "pre",
          "application/x-futuresplash": "spl",
          "application/x-gnumeric": "gnumeric",
          "application/x-gsp": "gsp",
          "application/x-gss": "gss",
          "application/x-gtar": "gtar",
          "application/x-gzip": ["gz", "gzip"],
          "application/x-hdf": "hdf",
          "application/x-helpfile": ["help", "hlp"],
          "application/x-httpd-imap": "imap",
          "application/x-ima": "ima",
          "application/x-internet-signup": ["ins", "isp"],
          "application/x-internett-signup": "ins",
          "application/x-inventor": "iv",
          "application/x-ip2": "ip",
          "application/x-iphone": "iii",
          "application/x-java-class": "class",
          "application/x-java-commerce": "jcm",
          "application/x-java-jnlp-file": "jnlp",
          "application/x-javascript": "js",
          "application/x-koan": ["skd", "skm", "skp", "skt"],
          "application/x-ksh": "ksh",
          "application/x-latex": ["latex", "ltx"],
          "application/x-lha": "lha",
          "application/x-lisp": "lsp",
          "application/x-livescreen": "ivy",
          "application/x-lotus": "wq1",
          "application/x-lotusscreencam": "scm",
          "application/x-lzh": "lzh",
          "application/x-lzx": "lzx",
          "application/x-mac-binhex40": "hqx",
          "application/x-macbinary": "bin",
          "application/x-magic-cap-package-1.0": "mc$",
          "application/x-mathcad": "mcd",
          "application/x-meme": "mm",
          "application/x-midi": ["mid", "midi"],
          "application/x-mif": "mif",
          "application/x-mix-transfer": "nix",
          "application/x-mobipocket-ebook": "prc",
          "application/x-mplayer2": "asx",
          "application/x-ms-application": "application",
          "application/x-ms-wmd": "wmd",
          "application/x-ms-wmz": "wmz",
          "application/x-ms-xbap": "xbap",
          "application/x-msaccess": "mdb",
          "application/x-msbinder": "obd",
          "application/x-mscardfile": "crd",
          "application/x-msclip": "clp",
          "application/x-msdownload": ["dll", "exe"],
          "application/x-msexcel": ["xla", "xls", "xlw"],
          "application/x-msmediaview": ["m13", "m14", "mvb"],
          "application/x-msmetafile": "wmf",
          "application/x-msmoney": "mny",
          "application/x-mspowerpoint": "ppt",
          "application/x-mspublisher": "pub",
          "application/x-msschedule": "scd",
          "application/x-msterminal": "trm",
          "application/x-mswrite": "wri",
          "application/x-navi-animation": "ani",
          "application/x-navidoc": "nvd",
          "application/x-navimap": "map",
          "application/x-navistyle": "stl",
          "application/x-netcdf": ["cdf", "nc"],
          "application/x-newton-compatible-pkg": "pkg",
          "application/x-nokia-9000-communicator-add-on-software": "aos",
          "application/x-omc": "omc",
          "application/x-omcdatamaker": "omcd",
          "application/x-omcregerator": "omcr",
          "application/x-pagemaker": ["pm4", "pm5"],
          "application/x-pcl": "pcl",
          "application/x-perfmon": ["pma", "pmc", "pml", "pmr", "pmw"],
          "application/x-pixclscript": "plx",
          "application/x-pkcs10": "p10",
          "application/x-pkcs12": ["p12", "pfx"],
          "application/x-pkcs7-certificates": ["p7b", "spc"],
          "application/x-pkcs7-certreqresp": "p7r",
          "application/x-pkcs7-mime": ["p7c", "p7m"],
          "application/x-pkcs7-signature": ["p7s", "p7a"],
          "application/x-pointplus": "css",
          "application/x-portable-anymap": "pnm",
          "application/x-project": ["mpc", "mpt", "mpv", "mpx"],
          "application/x-qpro": "wb1",
          "application/x-rar-compressed": "rar",
          "application/x-rtf": "rtf",
          "application/x-sdp": "sdp",
          "application/x-sea": "sea",
          "application/x-seelogo": "sl",
          "application/x-sh": "sh",
          "application/x-shar": ["shar", "sh"],
          "application/x-shockwave-flash": "swf",
          "application/x-silverlight-app": "xap",
          "application/x-sit": "sit",
          "application/x-sprite": ["spr", "sprite"],
          "application/x-stuffit": "sit",
          "application/x-stuffitx": "sitx",
          "application/x-sv4cpio": "sv4cpio",
          "application/x-sv4crc": "sv4crc",
          "application/x-tar": "tar",
          "application/x-tbook": ["sbk", "tbk"],
          "application/x-tcl": "tcl",
          "application/x-tex": "tex",
          "application/x-tex-tfm": "tfm",
          "application/x-texinfo": ["texi", "texinfo"],
          "application/x-troff": ["roff", "t", "tr"],
          "application/x-troff-man": "man",
          "application/x-troff-me": "me",
          "application/x-troff-ms": "ms",
          "application/x-troff-msvideo": "avi",
          "application/x-ustar": "ustar",
          "application/x-visio": ["vsd", "vst", "vsw"],
          "application/x-vnd.audioexplosion.mzz": "mzz",
          "application/x-vnd.ls-xpix": "xpix",
          "application/x-vrml": "vrml",
          "application/x-wais-source": ["src", "wsrc"],
          "application/x-winhelp": "hlp",
          "application/x-wintalk": "wtk",
          "application/x-world": ["svr", "wrl"],
          "application/x-wpwin": "wpd",
          "application/x-wri": "wri",
          "application/x-x509-ca-cert": ["cer", "crt", "der"],
          "application/x-x509-user-cert": "crt",
          "application/x-xfig": "fig",
          "application/x-xpinstall": "xpi",
          "application/x-zip-compressed": "zip",
          "application/xcap-diff+xml": "xdf",
          "application/xenc+xml": "xenc",
          "application/xhtml+xml": "xhtml",
          "application/xml": "xml",
          "application/xml-dtd": "dtd",
          "application/xop+xml": "xop",
          "application/xslt+xml": "xslt",
          "application/xspf+xml": "xspf",
          "application/xv+xml": "mxml",
          "application/yang": "yang",
          "application/yin+xml": "yin",
          "application/ynd.ms-pkipko": "pko",
          "application/zip": "zip",
          "audio/adpcm": "adp",
          "audio/aiff": ["aif", "aifc", "aiff"],
          "audio/basic": ["au", "snd"],
          "audio/it": "it",
          "audio/make": ["funk", "my", "pfunk"],
          "audio/make.my.funk": "pfunk",
          "audio/mid": ["mid", "rmi"],
          "audio/midi": ["kar", "mid", "midi"],
          "audio/mod": "mod",
          "audio/mp4": "mp4a",
          "audio/mpeg": ["mp3", "m2a", "mp2", "mpa", "mpg", "mpga"],
          "audio/mpeg3": "mp3",
          "audio/nspaudio": ["la", "lma"],
          "audio/ogg": "oga",
          "audio/s3m": "s3m",
          "audio/tsp-audio": "tsi",
          "audio/tsplayer": "tsp",
          "audio/vnd.dece.audio": "uva",
          "audio/vnd.digital-winds": "eol",
          "audio/vnd.dra": "dra",
          "audio/vnd.dts": "dts",
          "audio/vnd.dts.hd": "dtshd",
          "audio/vnd.lucent.voice": "lvp",
          "audio/vnd.ms-playready.media.pya": "pya",
          "audio/vnd.nuera.ecelp4800": "ecelp4800",
          "audio/vnd.nuera.ecelp7470": "ecelp7470",
          "audio/vnd.nuera.ecelp9600": "ecelp9600",
          "audio/vnd.qcelp": "qcp",
          "audio/vnd.rip": "rip",
          "audio/voc": "voc",
          "audio/voxware": "vox",
          "audio/wav": "wav",
          "audio/webm": "weba",
          "audio/x-aac": "aac",
          "audio/x-adpcm": "snd",
          "audio/x-aiff": ["aif", "aifc", "aiff"],
          "audio/x-au": "au",
          "audio/x-gsm": ["gsd", "gsm"],
          "audio/x-jam": "jam",
          "audio/x-liveaudio": "lam",
          "audio/x-mid": ["mid", "midi"],
          "audio/x-midi": ["mid", "midi"],
          "audio/x-mod": "mod",
          "audio/x-mpeg": "mp2",
          "audio/x-mpeg-3": "mp3",
          "audio/x-mpegurl": "m3u",
          "audio/x-mpequrl": "m3u",
          "audio/x-ms-wax": "wax",
          "audio/x-ms-wma": "wma",
          "audio/x-nspaudio": ["la", "lma"],
          "audio/x-pn-realaudio": ["ra", "ram", "rm", "rmm", "rmp"],
          "audio/x-pn-realaudio-plugin": ["ra", "rmp", "rpm"],
          "audio/x-psid": "sid",
          "audio/x-realaudio": "ra",
          "audio/x-twinvq": "vqf",
          "audio/x-twinvq-plugin": ["vqe", "vql"],
          "audio/x-vnd.audioexplosion.mjuicemediafile": "mjf",
          "audio/x-voc": "voc",
          "audio/x-wav": "wav",
          "audio/xm": "xm",
          "chemical/x-cdx": "cdx",
          "chemical/x-cif": "cif",
          "chemical/x-cmdf": "cmdf",
          "chemical/x-cml": "cml",
          "chemical/x-csml": "csml",
          "chemical/x-pdb": ["pdb", "xyz"],
          "chemical/x-xyz": "xyz",
          "drawing/x-dwf": "dwf",
          "i-world/i-vrml": "ivr",
          "image/bmp": ["bmp", "bm"],
          "image/cgm": "cgm",
          "image/cis-cod": "cod",
          "image/cmu-raster": ["ras", "rast"],
          "image/fif": "fif",
          "image/florian": ["flo", "turbot"],
          "image/g3fax": "g3",
          "image/gif": "gif",
          "image/ief": ["ief", "iefs"],
          "image/jpeg": ["jpe", "jpeg", "jpg", "jfif", "jfif-tbnl"],
          "image/jutvision": "jut",
          "image/ktx": "ktx",
          "image/naplps": ["nap", "naplps"],
          "image/pict": ["pic", "pict"],
          "image/pipeg": "jfif",
          "image/pjpeg": ["jfif", "jpe", "jpeg", "jpg"],
          "image/png": ["png", "x-png"],
          "image/prs.btif": "btif",
          "image/svg+xml": "svg",
          "image/tiff": ["tif", "tiff"],
          "image/vasa": "mcf",
          "image/vnd.adobe.photoshop": "psd",
          "image/vnd.dece.graphic": "uvi",
          "image/vnd.djvu": "djvu",
          "image/vnd.dvb.subtitle": "sub",
          "image/vnd.dwg": ["dwg", "dxf", "svf"],
          "image/vnd.dxf": "dxf",
          "image/vnd.fastbidsheet": "fbs",
          "image/vnd.fpx": "fpx",
          "image/vnd.fst": "fst",
          "image/vnd.fujixerox.edmics-mmr": "mmr",
          "image/vnd.fujixerox.edmics-rlc": "rlc",
          "image/vnd.ms-modi": "mdi",
          "image/vnd.net-fpx": ["fpx", "npx"],
          "image/vnd.rn-realflash": "rf",
          "image/vnd.rn-realpix": "rp",
          "image/vnd.wap.wbmp": "wbmp",
          "image/vnd.xiff": "xif",
          "image/webp": "webp",
          "image/x-cmu-raster": "ras",
          "image/x-cmx": "cmx",
          "image/x-dwg": ["dwg", "dxf", "svf"],
          "image/x-freehand": "fh",
          "image/x-icon": "ico",
          "image/x-jg": "art",
          "image/x-jps": "jps",
          "image/x-niff": ["nif", "niff"],
          "image/x-pcx": "pcx",
          "image/x-pict": ["pct", "pic"],
          "image/x-portable-anymap": "pnm",
          "image/x-portable-bitmap": "pbm",
          "image/x-portable-graymap": "pgm",
          "image/x-portable-greymap": "pgm",
          "image/x-portable-pixmap": "ppm",
          "image/x-quicktime": ["qif", "qti", "qtif"],
          "image/x-rgb": "rgb",
          "image/x-tiff": ["tif", "tiff"],
          "image/x-windows-bmp": "bmp",
          "image/x-xbitmap": "xbm",
          "image/x-xbm": "xbm",
          "image/x-xpixmap": ["xpm", "pm"],
          "image/x-xwd": "xwd",
          "image/x-xwindowdump": "xwd",
          "image/xbm": "xbm",
          "image/xpm": "xpm",
          "message/rfc822": ["mht", "mhtml", "nws", "mime", "eml"],
          "model/iges": ["iges", "igs"],
          "model/mesh": "msh",
          "model/vnd.collada+xml": "dae",
          "model/vnd.dwf": "dwf",
          "model/vnd.gdl": "gdl",
          "model/vnd.gtw": "gtw",
          "model/vnd.mts": "mts",
          "model/vnd.vtu": "vtu",
          "model/vrml": ["vrml", "wrl", "wrz"],
          "model/x-pov": "pov",
          "multipart/x-gzip": "gzip",
          "multipart/x-ustar": "ustar",
          "multipart/x-zip": "zip",
          "music/crescendo": ["mid", "midi"],
          "music/x-karaoke": "kar",
          "paleovu/x-pv": "pvu",
          "text/asp": "asp",
          "text/calendar": "ics",
          "text/css": "css",
          "text/csv": "csv",
          "text/ecmascript": "js",
          "text/h323": "323",
          "text/html": ["htm", "html", "stm", "acgi", "htmls", "htx", "shtml"],
          "text/iuls": "uls",
          "text/javascript": "js",
          "text/mcf": "mcf",
          "text/n3": "n3",
          "text/pascal": "pas",
          "text/plain": ["bas", "c", "h", "txt", "c++", "cc", "com", "conf", "cxx", "def", "f", "f90", "for", "g", "hh", "idc", "jav", "java", "list", "log", "lst", "m", "mar", "pl", "sdml", "text"],
          "text/plain-bas": "par",
          "text/prs.lines.tag": "dsc",
          "text/richtext": ["rtx", "rt", "rtf"],
          "text/scriplet": "wsc",
          "text/scriptlet": "sct",
          "text/sgml": ["sgm", "sgml"],
          "text/tab-separated-values": "tsv",
          "text/troff": "t",
          "text/turtle": "ttl",
          "text/uri-list": ["uni", "unis", "uri", "uris"],
          "text/vnd.abc": "abc",
          "text/vnd.curl": "curl",
          "text/vnd.curl.dcurl": "dcurl",
          "text/vnd.curl.mcurl": "mcurl",
          "text/vnd.curl.scurl": "scurl",
          "text/vnd.fly": "fly",
          "text/vnd.fmi.flexstor": "flx",
          "text/vnd.graphviz": "gv",
          "text/vnd.in3d.3dml": "3dml",
          "text/vnd.in3d.spot": "spot",
          "text/vnd.rn-realtext": "rt",
          "text/vnd.sun.j2me.app-descriptor": "jad",
          "text/vnd.wap.wml": "wml",
          "text/vnd.wap.wmlscript": "wmls",
          "text/webviewhtml": "htt",
          "text/x-asm": ["asm", "s"],
          "text/x-audiosoft-intra": "aip",
          "text/x-c": ["c", "cc", "cpp"],
          "text/x-component": "htc",
          "text/x-fortran": ["f", "f77", "f90", "for"],
          "text/x-h": ["h", "hh"],
          "text/x-java-source": ["jav", "java"],
          "text/x-java-source,java": "java",
          "text/x-la-asf": "lsx",
          "text/x-m": "m",
          "text/x-pascal": "p",
          "text/x-script": "hlb",
          "text/x-script.csh": "csh",
          "text/x-script.elisp": "el",
          "text/x-script.guile": "scm",
          "text/x-script.ksh": "ksh",
          "text/x-script.lisp": "lsp",
          "text/x-script.perl": "pl",
          "text/x-script.perl-module": "pm",
          "text/x-script.phyton": "py",
          "text/x-script.rexx": "rexx",
          "text/x-script.scheme": "scm",
          "text/x-script.sh": "sh",
          "text/x-script.tcl": "tcl",
          "text/x-script.tcsh": "tcsh",
          "text/x-script.zsh": "zsh",
          "text/x-server-parsed-html": ["shtml", "ssi"],
          "text/x-setext": "etx",
          "text/x-sgml": ["sgm", "sgml"],
          "text/x-speech": ["spc", "talk"],
          "text/x-uil": "uil",
          "text/x-uuencode": ["uu", "uue"],
          "text/x-vcalendar": "vcs",
          "text/x-vcard": "vcf",
          "text/xml": "xml",
          "video/3gpp": "3gp",
          "video/3gpp2": "3g2",
          "video/animaflex": "afl",
          "video/avi": "avi",
          "video/avs-video": "avs",
          "video/dl": "dl",
          "video/fli": "fli",
          "video/gl": "gl",
          "video/h261": "h261",
          "video/h263": "h263",
          "video/h264": "h264",
          "video/jpeg": "jpgv",
          "video/jpm": "jpm",
          "video/mj2": "mj2",
          "video/mp4": "mp4",
          "video/mpeg": ["mp2", "mpa", "mpe", "mpeg", "mpg", "mpv2", "m1v", "m2v", "mp3"],
          "video/msvideo": "avi",
          "video/ogg": "ogv",
          "video/quicktime": ["mov", "qt", "moov"],
          "video/vdo": "vdo",
          "video/vivo": ["viv", "vivo"],
          "video/vnd.dece.hd": "uvh",
          "video/vnd.dece.mobile": "uvm",
          "video/vnd.dece.pd": "uvp",
          "video/vnd.dece.sd": "uvs",
          "video/vnd.dece.video": "uvv",
          "video/vnd.fvt": "fvt",
          "video/vnd.mpegurl": "mxu",
          "video/vnd.ms-playready.media.pyv": "pyv",
          "video/vnd.rn-realvideo": "rv",
          "video/vnd.uvvu.mp4": "uvu",
          "video/vnd.vivo": ["viv", "vivo"],
          "video/vosaic": "vos",
          "video/webm": "webm",
          "video/x-amt-demorun": "xdr",
          "video/x-amt-showrun": "xsr",
          "video/x-atomic3d-feature": "fmf",
          "video/x-dl": "dl",
          "video/x-dv": ["dif", "dv"],
          "video/x-f4v": "f4v",
          "video/x-fli": "fli",
          "video/x-flv": "flv",
          "video/x-gl": "gl",
          "video/x-isvideo": "isu",
          "video/x-la-asf": ["lsf", "lsx"],
          "video/x-m4v": "m4v",
          "video/x-motion-jpeg": "mjpg",
          "video/x-mpeg": ["mp2", "mp3"],
          "video/x-mpeq2a": "mp2",
          "video/x-ms-asf": ["asf", "asr", "asx"],
          "video/x-ms-asf-plugin": "asx",
          "video/x-ms-wm": "wm",
          "video/x-ms-wmv": "wmv",
          "video/x-ms-wmx": "wmx",
          "video/x-ms-wvx": "wvx",
          "video/x-msvideo": "avi",
          "video/x-qtc": "qtc",
          "video/x-scm": "scm",
          "video/x-sgi-movie": ["movie", "mv"],
          "windows/metafile": "wmf",
          "www/mime": "mime",
          "x-conference/x-cooltalk": "ice",
          "x-music/x-midi": ["mid", "midi"],
          "x-world/x-3dmf": ["3dm", "3dmf", "qd3", "qd3d"],
          "x-world/x-svr": "svr",
          "x-world/x-vrml": ["flr", "vrml", "wrl", "wrz", "xaf", "xof"],
          "x-world/x-vrt": "vrt",
          "xgl/drawing": "xgz",
          "xgl/movie": "xmz"
        };
        var mimetypesExtensions = {
          "": ["application/andrew-inset", "application/pgp-encrypted"],
          "*": "application/octet-stream",
          "123": "application/vnd.lotus-1-2-3",
          "323": "text/h323",
          "3dm": "x-world/x-3dmf",
          "3dmf": "x-world/x-3dmf",
          "3dml": "text/vnd.in3d.3dml",
          "3g2": "video/3gpp2",
          "3gp": "video/3gpp",
          "7z": "application/x-7z-compressed",
          "a": "application/octet-stream",
          "aab": "application/x-authorware-bin",
          "aac": "audio/x-aac",
          "aam": "application/x-authorware-map",
          "aas": "application/x-authorware-seg",
          "abc": "text/vnd.abc",
          "abw": "application/x-abiword",
          "ac": "application/pkix-attr-cert",
          "acc": "application/vnd.americandynamics.acc",
          "ace": "application/x-ace-compressed",
          "acgi": "text/html",
          "acu": "application/vnd.acucobol",
          "acx": "application/internet-property-stream",
          "adp": "audio/adpcm",
          "aep": "application/vnd.audiograph",
          "afl": "video/animaflex",
          "afp": "application/vnd.ibm.modcap",
          "ahead": "application/vnd.ahead.space",
          "ai": "application/postscript",
          "aif": ["audio/aiff", "audio/x-aiff"],
          "aifc": ["audio/aiff", "audio/x-aiff"],
          "aiff": ["audio/aiff", "audio/x-aiff"],
          "aim": "application/x-aim",
          "aip": "text/x-audiosoft-intra",
          "air": "application/vnd.adobe.air-application-installer-package+zip",
          "ait": "application/vnd.dvb.ait",
          "ami": "application/vnd.amiga.ami",
          "ani": "application/x-navi-animation",
          "aos": "application/x-nokia-9000-communicator-add-on-software",
          "apk": "application/vnd.android.package-archive",
          "application": "application/x-ms-application",
          "apr": "application/vnd.lotus-approach",
          "aps": "application/mime",
          "arc": "application/octet-stream",
          "arj": ["application/arj", "application/octet-stream"],
          "art": "image/x-jg",
          "asf": "video/x-ms-asf",
          "asm": "text/x-asm",
          "aso": "application/vnd.accpac.simply.aso",
          "asp": "text/asp",
          "asr": "video/x-ms-asf",
          "asx": ["video/x-ms-asf", "application/x-mplayer2", "video/x-ms-asf-plugin"],
          "atc": "application/vnd.acucorp",
          "atomcat": "application/atomcat+xml",
          "atomsvc": "application/atomsvc+xml",
          "atx": "application/vnd.antix.game-component",
          "au": ["audio/basic", "audio/x-au"],
          "avi": ["video/avi", "video/msvideo", "application/x-troff-msvideo", "video/x-msvideo"],
          "avs": "video/avs-video",
          "aw": "application/applixware",
          "axs": "application/olescript",
          "azf": "application/vnd.airzip.filesecure.azf",
          "azs": "application/vnd.airzip.filesecure.azs",
          "azw": "application/vnd.amazon.ebook",
          "bas": "text/plain",
          "bcpio": "application/x-bcpio",
          "bdf": "application/x-font-bdf",
          "bdm": "application/vnd.syncml.dm+wbxml",
          "bed": "application/vnd.realvnc.bed",
          "bh2": "application/vnd.fujitsu.oasysprs",
          "bin": ["application/octet-stream", "application/mac-binary", "application/macbinary", "application/x-macbinary", "application/x-binary"],
          "bm": "image/bmp",
          "bmi": "application/vnd.bmi",
          "bmp": ["image/bmp", "image/x-windows-bmp"],
          "boo": "application/book",
          "book": "application/book",
          "box": "application/vnd.previewsystems.box",
          "boz": "application/x-bzip2",
          "bsh": "application/x-bsh",
          "btif": "image/prs.btif",
          "bz": "application/x-bzip",
          "bz2": "application/x-bzip2",
          "c": ["text/plain", "text/x-c"],
          "c++": "text/plain",
          "c11amc": "application/vnd.cluetrust.cartomobile-config",
          "c11amz": "application/vnd.cluetrust.cartomobile-config-pkg",
          "c4g": "application/vnd.clonk.c4group",
          "cab": "application/vnd.ms-cab-compressed",
          "car": "application/vnd.curl.car",
          "cat": ["application/vnd.ms-pkiseccat", "application/vnd.ms-pki.seccat"],
          "cc": ["text/plain", "text/x-c"],
          "ccad": "application/clariscad",
          "cco": "application/x-cocoa",
          "ccxml": "application/ccxml+xml,",
          "cdbcmsg": "application/vnd.contact.cmsg",
          "cdf": ["application/cdf", "application/x-cdf", "application/x-netcdf"],
          "cdkey": "application/vnd.mediastation.cdkey",
          "cdmia": "application/cdmi-capability",
          "cdmic": "application/cdmi-container",
          "cdmid": "application/cdmi-domain",
          "cdmio": "application/cdmi-object",
          "cdmiq": "application/cdmi-queue",
          "cdx": "chemical/x-cdx",
          "cdxml": "application/vnd.chemdraw+xml",
          "cdy": "application/vnd.cinderella",
          "cer": ["application/pkix-cert", "application/x-x509-ca-cert"],
          "cgm": "image/cgm",
          "cha": "application/x-chat",
          "chat": "application/x-chat",
          "chm": "application/vnd.ms-htmlhelp",
          "chrt": "application/vnd.kde.kchart",
          "cif": "chemical/x-cif",
          "cii": "application/vnd.anser-web-certificate-issue-initiation",
          "cil": "application/vnd.ms-artgalry",
          "cla": "application/vnd.claymore",
          "class": ["application/octet-stream", "application/java", "application/java-byte-code", "application/java-vm", "application/x-java-class"],
          "clkk": "application/vnd.crick.clicker.keyboard",
          "clkp": "application/vnd.crick.clicker.palette",
          "clkt": "application/vnd.crick.clicker.template",
          "clkw": "application/vnd.crick.clicker.wordbank",
          "clkx": "application/vnd.crick.clicker",
          "clp": "application/x-msclip",
          "cmc": "application/vnd.cosmocaller",
          "cmdf": "chemical/x-cmdf",
          "cml": "chemical/x-cml",
          "cmp": "application/vnd.yellowriver-custom-menu",
          "cmx": "image/x-cmx",
          "cod": ["image/cis-cod", "application/vnd.rim.cod"],
          "com": ["application/octet-stream", "text/plain"],
          "conf": "text/plain",
          "cpio": "application/x-cpio",
          "cpp": "text/x-c",
          "cpt": ["application/mac-compactpro", "application/x-compactpro", "application/x-cpt"],
          "crd": "application/x-mscardfile",
          "crl": ["application/pkix-crl", "application/pkcs-crl"],
          "crt": ["application/pkix-cert", "application/x-x509-user-cert", "application/x-x509-ca-cert"],
          "cryptonote": "application/vnd.rig.cryptonote",
          "csh": ["text/x-script.csh", "application/x-csh"],
          "csml": "chemical/x-csml",
          "csp": "application/vnd.commonspace",
          "css": ["text/css", "application/x-pointplus"],
          "csv": "text/csv",
          "cu": "application/cu-seeme",
          "curl": "text/vnd.curl",
          "cww": "application/prs.cww",
          "cxx": "text/plain",
          "dae": "model/vnd.collada+xml",
          "daf": "application/vnd.mobius.daf",
          "davmount": "application/davmount+xml",
          "dcr": "application/x-director",
          "dcurl": "text/vnd.curl.dcurl",
          "dd2": "application/vnd.oma.dd2+xml",
          "ddd": "application/vnd.fujixerox.ddd",
          "deb": "application/x-debian-package",
          "deepv": "application/x-deepv",
          "def": "text/plain",
          "der": "application/x-x509-ca-cert",
          "dfac": "application/vnd.dreamfactory",
          "dif": "video/x-dv",
          "dir": "application/x-director",
          "dis": "application/vnd.mobius.dis",
          "djvu": "image/vnd.djvu",
          "dl": ["video/dl", "video/x-dl"],
          "dll": "application/x-msdownload",
          "dms": "application/octet-stream",
          "dna": "application/vnd.dna",
          "doc": "application/msword",
          "docm": "application/vnd.ms-word.document.macroenabled.12",
          "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          "dot": "application/msword",
          "dotm": "application/vnd.ms-word.template.macroenabled.12",
          "dotx": "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
          "dp": ["application/commonground", "application/vnd.osgi.dp"],
          "dpg": "application/vnd.dpgraph",
          "dra": "audio/vnd.dra",
          "drw": "application/drafting",
          "dsc": "text/prs.lines.tag",
          "dssc": "application/dssc+der",
          "dtb": "application/x-dtbook+xml",
          "dtd": "application/xml-dtd",
          "dts": "audio/vnd.dts",
          "dtshd": "audio/vnd.dts.hd",
          "dump": "application/octet-stream",
          "dv": "video/x-dv",
          "dvi": "application/x-dvi",
          "dwf": ["model/vnd.dwf", "drawing/x-dwf"],
          "dwg": ["application/acad", "image/vnd.dwg", "image/x-dwg"],
          "dxf": ["application/dxf", "image/vnd.dwg", "image/vnd.dxf", "image/x-dwg"],
          "dxp": "application/vnd.spotfire.dxp",
          "dxr": "application/x-director",
          "ecelp4800": "audio/vnd.nuera.ecelp4800",
          "ecelp7470": "audio/vnd.nuera.ecelp7470",
          "ecelp9600": "audio/vnd.nuera.ecelp9600",
          "edm": "application/vnd.novadigm.edm",
          "edx": "application/vnd.novadigm.edx",
          "efif": "application/vnd.picsel",
          "ei6": "application/vnd.pg.osasli",
          "el": "text/x-script.elisp",
          "elc": ["application/x-elc", "application/x-bytecode.elisp"],
          "eml": "message/rfc822",
          "emma": "application/emma+xml",
          "env": "application/x-envoy",
          "eol": "audio/vnd.digital-winds",
          "eot": "application/vnd.ms-fontobject",
          "eps": "application/postscript",
          "epub": "application/epub+zip",
          "es": ["application/ecmascript", "application/x-esrehber"],
          "es3": "application/vnd.eszigno3+xml",
          "esf": "application/vnd.epson.esf",
          "etx": "text/x-setext",
          "evy": ["application/envoy", "application/x-envoy"],
          "exe": ["application/octet-stream", "application/x-msdownload"],
          "exi": "application/exi",
          "ext": "application/vnd.novadigm.ext",
          "ez2": "application/vnd.ezpix-album",
          "ez3": "application/vnd.ezpix-package",
          "f": ["text/plain", "text/x-fortran"],
          "f4v": "video/x-f4v",
          "f77": "text/x-fortran",
          "f90": ["text/plain", "text/x-fortran"],
          "fbs": "image/vnd.fastbidsheet",
          "fcs": "application/vnd.isac.fcs",
          "fdf": "application/vnd.fdf",
          "fe_launch": "application/vnd.denovo.fcselayout-link",
          "fg5": "application/vnd.fujitsu.oasysgp",
          "fh": "image/x-freehand",
          "fif": ["application/fractals", "image/fif"],
          "fig": "application/x-xfig",
          "fli": ["video/fli", "video/x-fli"],
          "flo": ["image/florian", "application/vnd.micrografx.flo"],
          "flr": "x-world/x-vrml",
          "flv": "video/x-flv",
          "flw": "application/vnd.kde.kivio",
          "flx": "text/vnd.fmi.flexstor",
          "fly": "text/vnd.fly",
          "fm": "application/vnd.framemaker",
          "fmf": "video/x-atomic3d-feature",
          "fnc": "application/vnd.frogans.fnc",
          "for": ["text/plain", "text/x-fortran"],
          "fpx": ["image/vnd.fpx", "image/vnd.net-fpx"],
          "frl": "application/freeloader",
          "fsc": "application/vnd.fsc.weblaunch",
          "fst": "image/vnd.fst",
          "ftc": "application/vnd.fluxtime.clip",
          "fti": "application/vnd.anser-web-funds-transfer-initiation",
          "funk": "audio/make",
          "fvt": "video/vnd.fvt",
          "fxp": "application/vnd.adobe.fxp",
          "fzs": "application/vnd.fuzzysheet",
          "g": "text/plain",
          "g2w": "application/vnd.geoplan",
          "g3": "image/g3fax",
          "g3w": "application/vnd.geospace",
          "gac": "application/vnd.groove-account",
          "gdl": "model/vnd.gdl",
          "geo": "application/vnd.dynageo",
          "gex": "application/vnd.geometry-explorer",
          "ggb": "application/vnd.geogebra.file",
          "ggt": "application/vnd.geogebra.tool",
          "ghf": "application/vnd.groove-help",
          "gif": "image/gif",
          "gim": "application/vnd.groove-identity-message",
          "gl": ["video/gl", "video/x-gl"],
          "gmx": "application/vnd.gmx",
          "gnumeric": "application/x-gnumeric",
          "gph": "application/vnd.flographit",
          "gqf": "application/vnd.grafeq",
          "gram": "application/srgs",
          "grv": "application/vnd.groove-injector",
          "grxml": "application/srgs+xml",
          "gsd": "audio/x-gsm",
          "gsf": "application/x-font-ghostscript",
          "gsm": "audio/x-gsm",
          "gsp": "application/x-gsp",
          "gss": "application/x-gss",
          "gtar": "application/x-gtar",
          "gtm": "application/vnd.groove-tool-message",
          "gtw": "model/vnd.gtw",
          "gv": "text/vnd.graphviz",
          "gxt": "application/vnd.geonext",
          "gz": ["application/x-gzip", "application/x-compressed"],
          "gzip": ["multipart/x-gzip", "application/x-gzip"],
          "h": ["text/plain", "text/x-h"],
          "h261": "video/h261",
          "h263": "video/h263",
          "h264": "video/h264",
          "hal": "application/vnd.hal+xml",
          "hbci": "application/vnd.hbci",
          "hdf": "application/x-hdf",
          "help": "application/x-helpfile",
          "hgl": "application/vnd.hp-hpgl",
          "hh": ["text/plain", "text/x-h"],
          "hlb": "text/x-script",
          "hlp": ["application/winhlp", "application/hlp", "application/x-helpfile", "application/x-winhelp"],
          "hpg": "application/vnd.hp-hpgl",
          "hpgl": "application/vnd.hp-hpgl",
          "hpid": "application/vnd.hp-hpid",
          "hps": "application/vnd.hp-hps",
          "hqx": ["application/mac-binhex40", "application/binhex", "application/binhex4", "application/mac-binhex", "application/x-binhex40", "application/x-mac-binhex40"],
          "hta": "application/hta",
          "htc": "text/x-component",
          "htke": "application/vnd.kenameaapp",
          "htm": "text/html",
          "html": "text/html",
          "htmls": "text/html",
          "htt": "text/webviewhtml",
          "htx": "text/html",
          "hvd": "application/vnd.yamaha.hv-dic",
          "hvp": "application/vnd.yamaha.hv-voice",
          "hvs": "application/vnd.yamaha.hv-script",
          "i2g": "application/vnd.intergeo",
          "icc": "application/vnd.iccprofile",
          "ice": "x-conference/x-cooltalk",
          "ico": "image/x-icon",
          "ics": "text/calendar",
          "idc": "text/plain",
          "ief": "image/ief",
          "iefs": "image/ief",
          "ifm": "application/vnd.shana.informed.formdata",
          "iges": ["application/iges", "model/iges"],
          "igl": "application/vnd.igloader",
          "igm": "application/vnd.insors.igm",
          "igs": ["application/iges", "model/iges"],
          "igx": "application/vnd.micrografx.igx",
          "iif": "application/vnd.shana.informed.interchange",
          "iii": "application/x-iphone",
          "ima": "application/x-ima",
          "imap": "application/x-httpd-imap",
          "imp": "application/vnd.accpac.simply.imp",
          "ims": "application/vnd.ms-ims",
          "inf": "application/inf",
          "ins": ["application/x-internet-signup", "application/x-internett-signup"],
          "ip": "application/x-ip2",
          "ipfix": "application/ipfix",
          "ipk": "application/vnd.shana.informed.package",
          "irm": "application/vnd.ibm.rights-management",
          "irp": "application/vnd.irepository.package+xml",
          "isp": "application/x-internet-signup",
          "isu": "video/x-isvideo",
          "it": "audio/it",
          "itp": "application/vnd.shana.informed.formtemplate",
          "iv": "application/x-inventor",
          "ivp": "application/vnd.immervision-ivp",
          "ivr": "i-world/i-vrml",
          "ivu": "application/vnd.immervision-ivu",
          "ivy": "application/x-livescreen",
          "jad": "text/vnd.sun.j2me.app-descriptor",
          "jam": ["application/vnd.jam", "audio/x-jam"],
          "jar": "application/java-archive",
          "jav": ["text/plain", "text/x-java-source"],
          "java": ["text/plain", "text/x-java-source,java", "text/x-java-source"],
          "jcm": "application/x-java-commerce",
          "jfif": ["image/pipeg", "image/jpeg", "image/pjpeg"],
          "jfif-tbnl": "image/jpeg",
          "jisp": "application/vnd.jisp",
          "jlt": "application/vnd.hp-jlyt",
          "jnlp": "application/x-java-jnlp-file",
          "joda": "application/vnd.joost.joda-archive",
          "jpe": ["image/jpeg", "image/pjpeg"],
          "jpeg": ["image/jpeg", "image/pjpeg"],
          "jpg": ["image/jpeg", "image/pjpeg"],
          "jpgv": "video/jpeg",
          "jpm": "video/jpm",
          "jps": "image/x-jps",
          "js": ["application/javascript", "application/ecmascript", "text/javascript", "text/ecmascript", "application/x-javascript"],
          "json": "application/json",
          "jut": "image/jutvision",
          "kar": ["audio/midi", "music/x-karaoke"],
          "karbon": "application/vnd.kde.karbon",
          "kfo": "application/vnd.kde.kformula",
          "kia": "application/vnd.kidspiration",
          "kml": "application/vnd.google-earth.kml+xml",
          "kmz": "application/vnd.google-earth.kmz",
          "kne": "application/vnd.kinar",
          "kon": "application/vnd.kde.kontour",
          "kpr": "application/vnd.kde.kpresenter",
          "ksh": ["application/x-ksh", "text/x-script.ksh"],
          "ksp": "application/vnd.kde.kspread",
          "ktx": "image/ktx",
          "ktz": "application/vnd.kahootz",
          "kwd": "application/vnd.kde.kword",
          "la": ["audio/nspaudio", "audio/x-nspaudio"],
          "lam": "audio/x-liveaudio",
          "lasxml": "application/vnd.las.las+xml",
          "latex": "application/x-latex",
          "lbd": "application/vnd.llamagraphics.life-balance.desktop",
          "lbe": "application/vnd.llamagraphics.life-balance.exchange+xml",
          "les": "application/vnd.hhe.lesson-player",
          "lha": ["application/octet-stream", "application/lha", "application/x-lha"],
          "lhx": "application/octet-stream",
          "link66": "application/vnd.route66.link66+xml",
          "list": "text/plain",
          "lma": ["audio/nspaudio", "audio/x-nspaudio"],
          "log": "text/plain",
          "lrm": "application/vnd.ms-lrm",
          "lsf": "video/x-la-asf",
          "lsp": ["application/x-lisp", "text/x-script.lisp"],
          "lst": "text/plain",
          "lsx": ["video/x-la-asf", "text/x-la-asf"],
          "ltf": "application/vnd.frogans.ltf",
          "ltx": "application/x-latex",
          "lvp": "audio/vnd.lucent.voice",
          "lwp": "application/vnd.lotus-wordpro",
          "lzh": ["application/octet-stream", "application/x-lzh"],
          "lzx": ["application/lzx", "application/octet-stream", "application/x-lzx"],
          "m": ["text/plain", "text/x-m"],
          "m13": "application/x-msmediaview",
          "m14": "application/x-msmediaview",
          "m1v": "video/mpeg",
          "m21": "application/mp21",
          "m2a": "audio/mpeg",
          "m2v": "video/mpeg",
          "m3u": ["audio/x-mpegurl", "audio/x-mpequrl"],
          "m3u8": "application/vnd.apple.mpegurl",
          "m4v": "video/x-m4v",
          "ma": "application/mathematica",
          "mads": "application/mads+xml",
          "mag": "application/vnd.ecowin.chart",
          "man": "application/x-troff-man",
          "map": "application/x-navimap",
          "mar": "text/plain",
          "mathml": "application/mathml+xml",
          "mbd": "application/mbedlet",
          "mbk": "application/vnd.mobius.mbk",
          "mbox": "application/mbox",
          "mc$": "application/x-magic-cap-package-1.0",
          "mc1": "application/vnd.medcalcdata",
          "mcd": ["application/mcad", "application/vnd.mcd", "application/x-mathcad"],
          "mcf": ["image/vasa", "text/mcf"],
          "mcp": "application/netmc",
          "mcurl": "text/vnd.curl.mcurl",
          "mdb": "application/x-msaccess",
          "mdi": "image/vnd.ms-modi",
          "me": "application/x-troff-me",
          "meta4": "application/metalink4+xml",
          "mets": "application/mets+xml",
          "mfm": "application/vnd.mfmp",
          "mgp": "application/vnd.osgeo.mapguide.package",
          "mgz": "application/vnd.proteus.magazine",
          "mht": "message/rfc822",
          "mhtml": "message/rfc822",
          "mid": ["audio/mid", "audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"],
          "midi": ["audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"],
          "mif": ["application/vnd.mif", "application/x-mif", "application/x-frame"],
          "mime": ["message/rfc822", "www/mime"],
          "mj2": "video/mj2",
          "mjf": "audio/x-vnd.audioexplosion.mjuicemediafile",
          "mjpg": "video/x-motion-jpeg",
          "mlp": "application/vnd.dolby.mlp",
          "mm": ["application/base64", "application/x-meme"],
          "mmd": "application/vnd.chipnuts.karaoke-mmd",
          "mme": "application/base64",
          "mmf": "application/vnd.smaf",
          "mmr": "image/vnd.fujixerox.edmics-mmr",
          "mny": "application/x-msmoney",
          "mod": ["audio/mod", "audio/x-mod"],
          "mods": "application/mods+xml",
          "moov": "video/quicktime",
          "mov": "video/quicktime",
          "movie": "video/x-sgi-movie",
          "mp2": ["video/mpeg", "audio/mpeg", "video/x-mpeg", "audio/x-mpeg", "video/x-mpeq2a"],
          "mp3": ["audio/mpeg", "audio/mpeg3", "video/mpeg", "audio/x-mpeg-3", "video/x-mpeg"],
          "mp4": ["video/mp4", "application/mp4"],
          "mp4a": "audio/mp4",
          "mpa": ["video/mpeg", "audio/mpeg"],
          "mpc": ["application/vnd.mophun.certificate", "application/x-project"],
          "mpe": "video/mpeg",
          "mpeg": "video/mpeg",
          "mpg": ["video/mpeg", "audio/mpeg"],
          "mpga": "audio/mpeg",
          "mpkg": "application/vnd.apple.installer+xml",
          "mpm": "application/vnd.blueice.multipass",
          "mpn": "application/vnd.mophun.application",
          "mpp": "application/vnd.ms-project",
          "mpt": "application/x-project",
          "mpv": "application/x-project",
          "mpv2": "video/mpeg",
          "mpx": "application/x-project",
          "mpy": "application/vnd.ibm.minipay",
          "mqy": "application/vnd.mobius.mqy",
          "mrc": "application/marc",
          "mrcx": "application/marcxml+xml",
          "ms": "application/x-troff-ms",
          "mscml": "application/mediaservercontrol+xml",
          "mseq": "application/vnd.mseq",
          "msf": "application/vnd.epson.msf",
          "msg": "application/vnd.ms-outlook",
          "msh": "model/mesh",
          "msl": "application/vnd.mobius.msl",
          "msty": "application/vnd.muvee.style",
          "mts": "model/vnd.mts",
          "mus": "application/vnd.musician",
          "musicxml": "application/vnd.recordare.musicxml+xml",
          "mv": "video/x-sgi-movie",
          "mvb": "application/x-msmediaview",
          "mwf": "application/vnd.mfer",
          "mxf": "application/mxf",
          "mxl": "application/vnd.recordare.musicxml",
          "mxml": "application/xv+xml",
          "mxs": "application/vnd.triscape.mxs",
          "mxu": "video/vnd.mpegurl",
          "my": "audio/make",
          "mzz": "application/x-vnd.audioexplosion.mzz",
          "n-gage": "application/vnd.nokia.n-gage.symbian.install",
          "n3": "text/n3",
          "nap": "image/naplps",
          "naplps": "image/naplps",
          "nbp": "application/vnd.wolfram.player",
          "nc": "application/x-netcdf",
          "ncm": "application/vnd.nokia.configuration-message",
          "ncx": "application/x-dtbncx+xml",
          "ngdat": "application/vnd.nokia.n-gage.data",
          "nif": "image/x-niff",
          "niff": "image/x-niff",
          "nix": "application/x-mix-transfer",
          "nlu": "application/vnd.neurolanguage.nlu",
          "nml": "application/vnd.enliven",
          "nnd": "application/vnd.noblenet-directory",
          "nns": "application/vnd.noblenet-sealer",
          "nnw": "application/vnd.noblenet-web",
          "npx": "image/vnd.net-fpx",
          "nsc": "application/x-conference",
          "nsf": "application/vnd.lotus-notes",
          "nvd": "application/x-navidoc",
          "nws": "message/rfc822",
          "o": "application/octet-stream",
          "oa2": "application/vnd.fujitsu.oasys2",
          "oa3": "application/vnd.fujitsu.oasys3",
          "oas": "application/vnd.fujitsu.oasys",
          "obd": "application/x-msbinder",
          "oda": "application/oda",
          "odb": "application/vnd.oasis.opendocument.database",
          "odc": "application/vnd.oasis.opendocument.chart",
          "odf": "application/vnd.oasis.opendocument.formula",
          "odft": "application/vnd.oasis.opendocument.formula-template",
          "odg": "application/vnd.oasis.opendocument.graphics",
          "odi": "application/vnd.oasis.opendocument.image",
          "odm": "application/vnd.oasis.opendocument.text-master",
          "odp": "application/vnd.oasis.opendocument.presentation",
          "ods": "application/vnd.oasis.opendocument.spreadsheet",
          "odt": "application/vnd.oasis.opendocument.text",
          "oga": "audio/ogg",
          "ogv": "video/ogg",
          "ogx": "application/ogg",
          "omc": "application/x-omc",
          "omcd": "application/x-omcdatamaker",
          "omcr": "application/x-omcregerator",
          "onetoc": "application/onenote",
          "opf": "application/oebps-package+xml",
          "org": "application/vnd.lotus-organizer",
          "osf": "application/vnd.yamaha.openscoreformat",
          "osfpvg": "application/vnd.yamaha.openscoreformat.osfpvg+xml",
          "otc": "application/vnd.oasis.opendocument.chart-template",
          "otf": "application/x-font-otf",
          "otg": "application/vnd.oasis.opendocument.graphics-template",
          "oth": "application/vnd.oasis.opendocument.text-web",
          "oti": "application/vnd.oasis.opendocument.image-template",
          "otp": "application/vnd.oasis.opendocument.presentation-template",
          "ots": "application/vnd.oasis.opendocument.spreadsheet-template",
          "ott": "application/vnd.oasis.opendocument.text-template",
          "oxt": "application/vnd.openofficeorg.extension",
          "p": "text/x-pascal",
          "p10": ["application/pkcs10", "application/x-pkcs10"],
          "p12": ["application/pkcs-12", "application/x-pkcs12"],
          "p7a": "application/x-pkcs7-signature",
          "p7b": "application/x-pkcs7-certificates",
          "p7c": ["application/pkcs7-mime", "application/x-pkcs7-mime"],
          "p7m": ["application/pkcs7-mime", "application/x-pkcs7-mime"],
          "p7r": "application/x-pkcs7-certreqresp",
          "p7s": ["application/pkcs7-signature", "application/x-pkcs7-signature"],
          "p8": "application/pkcs8",
          "par": "text/plain-bas",
          "part": "application/pro_eng",
          "pas": "text/pascal",
          "paw": "application/vnd.pawaafile",
          "pbd": "application/vnd.powerbuilder6",
          "pbm": "image/x-portable-bitmap",
          "pcf": "application/x-font-pcf",
          "pcl": ["application/vnd.hp-pcl", "application/x-pcl"],
          "pclxl": "application/vnd.hp-pclxl",
          "pct": "image/x-pict",
          "pcurl": "application/vnd.curl.pcurl",
          "pcx": "image/x-pcx",
          "pdb": ["application/vnd.palm", "chemical/x-pdb"],
          "pdf": "application/pdf",
          "pfa": "application/x-font-type1",
          "pfr": "application/font-tdpfr",
          "pfunk": ["audio/make", "audio/make.my.funk"],
          "pfx": "application/x-pkcs12",
          "pgm": ["image/x-portable-graymap", "image/x-portable-greymap"],
          "pgn": "application/x-chess-pgn",
          "pgp": "application/pgp-signature",
          "pic": ["image/pict", "image/x-pict"],
          "pict": "image/pict",
          "pkg": "application/x-newton-compatible-pkg",
          "pki": "application/pkixcmp",
          "pkipath": "application/pkix-pkipath",
          "pko": ["application/ynd.ms-pkipko", "application/vnd.ms-pki.pko"],
          "pl": ["text/plain", "text/x-script.perl"],
          "plb": "application/vnd.3gpp.pic-bw-large",
          "plc": "application/vnd.mobius.plc",
          "plf": "application/vnd.pocketlearn",
          "pls": "application/pls+xml",
          "plx": "application/x-pixclscript",
          "pm": ["text/x-script.perl-module", "image/x-xpixmap"],
          "pm4": "application/x-pagemaker",
          "pm5": "application/x-pagemaker",
          "pma": "application/x-perfmon",
          "pmc": "application/x-perfmon",
          "pml": ["application/vnd.ctc-posml", "application/x-perfmon"],
          "pmr": "application/x-perfmon",
          "pmw": "application/x-perfmon",
          "png": "image/png",
          "pnm": ["application/x-portable-anymap", "image/x-portable-anymap"],
          "portpkg": "application/vnd.macports.portpkg",
          "pot": ["application/vnd.ms-powerpoint", "application/mspowerpoint"],
          "potm": "application/vnd.ms-powerpoint.template.macroenabled.12",
          "potx": "application/vnd.openxmlformats-officedocument.presentationml.template",
          "pov": "model/x-pov",
          "ppa": "application/vnd.ms-powerpoint",
          "ppam": "application/vnd.ms-powerpoint.addin.macroenabled.12",
          "ppd": "application/vnd.cups-ppd",
          "ppm": "image/x-portable-pixmap",
          "pps": ["application/vnd.ms-powerpoint", "application/mspowerpoint"],
          "ppsm": "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
          "ppsx": "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
          "ppt": ["application/vnd.ms-powerpoint", "application/mspowerpoint", "application/powerpoint", "application/x-mspowerpoint"],
          "pptm": "application/vnd.ms-powerpoint.presentation.macroenabled.12",
          "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
          "ppz": "application/mspowerpoint",
          "prc": "application/x-mobipocket-ebook",
          "pre": ["application/vnd.lotus-freelance", "application/x-freelance"],
          "prf": "application/pics-rules",
          "prt": "application/pro_eng",
          "ps": "application/postscript",
          "psb": "application/vnd.3gpp.pic-bw-small",
          "psd": ["application/octet-stream", "image/vnd.adobe.photoshop"],
          "psf": "application/x-font-linux-psf",
          "pskcxml": "application/pskc+xml",
          "ptid": "application/vnd.pvi.ptid1",
          "pub": "application/x-mspublisher",
          "pvb": "application/vnd.3gpp.pic-bw-var",
          "pvu": "paleovu/x-pv",
          "pwn": "application/vnd.3m.post-it-notes",
          "pwz": "application/vnd.ms-powerpoint",
          "py": "text/x-script.phyton",
          "pya": "audio/vnd.ms-playready.media.pya",
          "pyc": "applicaiton/x-bytecode.python",
          "pyv": "video/vnd.ms-playready.media.pyv",
          "qam": "application/vnd.epson.quickanime",
          "qbo": "application/vnd.intu.qbo",
          "qcp": "audio/vnd.qcelp",
          "qd3": "x-world/x-3dmf",
          "qd3d": "x-world/x-3dmf",
          "qfx": "application/vnd.intu.qfx",
          "qif": "image/x-quicktime",
          "qps": "application/vnd.publishare-delta-tree",
          "qt": "video/quicktime",
          "qtc": "video/x-qtc",
          "qti": "image/x-quicktime",
          "qtif": "image/x-quicktime",
          "qxd": "application/vnd.quark.quarkxpress",
          "ra": ["audio/x-realaudio", "audio/x-pn-realaudio", "audio/x-pn-realaudio-plugin"],
          "ram": "audio/x-pn-realaudio",
          "rar": "application/x-rar-compressed",
          "ras": ["image/cmu-raster", "application/x-cmu-raster", "image/x-cmu-raster"],
          "rast": "image/cmu-raster",
          "rcprofile": "application/vnd.ipunplugged.rcprofile",
          "rdf": "application/rdf+xml",
          "rdz": "application/vnd.data-vision.rdz",
          "rep": "application/vnd.businessobjects",
          "res": "application/x-dtbresource+xml",
          "rexx": "text/x-script.rexx",
          "rf": "image/vnd.rn-realflash",
          "rgb": "image/x-rgb",
          "rif": "application/reginfo+xml",
          "rip": "audio/vnd.rip",
          "rl": "application/resource-lists+xml",
          "rlc": "image/vnd.fujixerox.edmics-rlc",
          "rld": "application/resource-lists-diff+xml",
          "rm": ["application/vnd.rn-realmedia", "audio/x-pn-realaudio"],
          "rmi": "audio/mid",
          "rmm": "audio/x-pn-realaudio",
          "rmp": ["audio/x-pn-realaudio-plugin", "audio/x-pn-realaudio"],
          "rms": "application/vnd.jcp.javame.midlet-rms",
          "rnc": "application/relax-ng-compact-syntax",
          "rng": ["application/ringing-tones", "application/vnd.nokia.ringing-tone"],
          "rnx": "application/vnd.rn-realplayer",
          "roff": "application/x-troff",
          "rp": "image/vnd.rn-realpix",
          "rp9": "application/vnd.cloanto.rp9",
          "rpm": "audio/x-pn-realaudio-plugin",
          "rpss": "application/vnd.nokia.radio-presets",
          "rpst": "application/vnd.nokia.radio-preset",
          "rq": "application/sparql-query",
          "rs": "application/rls-services+xml",
          "rsd": "application/rsd+xml",
          "rt": ["text/richtext", "text/vnd.rn-realtext"],
          "rtf": ["application/rtf", "text/richtext", "application/x-rtf"],
          "rtx": ["text/richtext", "application/rtf"],
          "rv": "video/vnd.rn-realvideo",
          "s": "text/x-asm",
          "s3m": "audio/s3m",
          "saf": "application/vnd.yamaha.smaf-audio",
          "saveme": "application/octet-stream",
          "sbk": "application/x-tbook",
          "sbml": "application/sbml+xml",
          "sc": "application/vnd.ibm.secure-container",
          "scd": "application/x-msschedule",
          "scm": ["application/vnd.lotus-screencam", "video/x-scm", "text/x-script.guile", "application/x-lotusscreencam", "text/x-script.scheme"],
          "scq": "application/scvp-cv-request",
          "scs": "application/scvp-cv-response",
          "sct": "text/scriptlet",
          "scurl": "text/vnd.curl.scurl",
          "sda": "application/vnd.stardivision.draw",
          "sdc": "application/vnd.stardivision.calc",
          "sdd": "application/vnd.stardivision.impress",
          "sdkm": "application/vnd.solent.sdkm+xml",
          "sdml": "text/plain",
          "sdp": ["application/sdp", "application/x-sdp"],
          "sdr": "application/sounder",
          "sdw": "application/vnd.stardivision.writer",
          "sea": ["application/sea", "application/x-sea"],
          "see": "application/vnd.seemail",
          "seed": "application/vnd.fdsn.seed",
          "sema": "application/vnd.sema",
          "semd": "application/vnd.semd",
          "semf": "application/vnd.semf",
          "ser": "application/java-serialized-object",
          "set": "application/set",
          "setpay": "application/set-payment-initiation",
          "setreg": "application/set-registration-initiation",
          "sfd-hdstx": "application/vnd.hydrostatix.sof-data",
          "sfs": "application/vnd.spotfire.sfs",
          "sgl": "application/vnd.stardivision.writer-global",
          "sgm": ["text/sgml", "text/x-sgml"],
          "sgml": ["text/sgml", "text/x-sgml"],
          "sh": ["application/x-shar", "application/x-bsh", "application/x-sh", "text/x-script.sh"],
          "shar": ["application/x-bsh", "application/x-shar"],
          "shf": "application/shf+xml",
          "shtml": ["text/html", "text/x-server-parsed-html"],
          "sid": "audio/x-psid",
          "sis": "application/vnd.symbian.install",
          "sit": ["application/x-stuffit", "application/x-sit"],
          "sitx": "application/x-stuffitx",
          "skd": "application/x-koan",
          "skm": "application/x-koan",
          "skp": ["application/vnd.koan", "application/x-koan"],
          "skt": "application/x-koan",
          "sl": "application/x-seelogo",
          "sldm": "application/vnd.ms-powerpoint.slide.macroenabled.12",
          "sldx": "application/vnd.openxmlformats-officedocument.presentationml.slide",
          "slt": "application/vnd.epson.salt",
          "sm": "application/vnd.stepmania.stepchart",
          "smf": "application/vnd.stardivision.math",
          "smi": ["application/smil", "application/smil+xml"],
          "smil": "application/smil",
          "snd": ["audio/basic", "audio/x-adpcm"],
          "snf": "application/x-font-snf",
          "sol": "application/solids",
          "spc": ["text/x-speech", "application/x-pkcs7-certificates"],
          "spf": "application/vnd.yamaha.smaf-phrase",
          "spl": ["application/futuresplash", "application/x-futuresplash"],
          "spot": "text/vnd.in3d.spot",
          "spp": "application/scvp-vp-response",
          "spq": "application/scvp-vp-request",
          "spr": "application/x-sprite",
          "sprite": "application/x-sprite",
          "src": "application/x-wais-source",
          "sru": "application/sru+xml",
          "srx": "application/sparql-results+xml",
          "sse": "application/vnd.kodak-descriptor",
          "ssf": "application/vnd.epson.ssf",
          "ssi": "text/x-server-parsed-html",
          "ssm": "application/streamingmedia",
          "ssml": "application/ssml+xml",
          "sst": ["application/vnd.ms-pkicertstore", "application/vnd.ms-pki.certstore"],
          "st": "application/vnd.sailingtracker.track",
          "stc": "application/vnd.sun.xml.calc.template",
          "std": "application/vnd.sun.xml.draw.template",
          "step": "application/step",
          "stf": "application/vnd.wt.stf",
          "sti": "application/vnd.sun.xml.impress.template",
          "stk": "application/hyperstudio",
          "stl": ["application/vnd.ms-pkistl", "application/sla", "application/vnd.ms-pki.stl", "application/x-navistyle"],
          "stm": "text/html",
          "stp": "application/step",
          "str": "application/vnd.pg.format",
          "stw": "application/vnd.sun.xml.writer.template",
          "sub": "image/vnd.dvb.subtitle",
          "sus": "application/vnd.sus-calendar",
          "sv4cpio": "application/x-sv4cpio",
          "sv4crc": "application/x-sv4crc",
          "svc": "application/vnd.dvb.service",
          "svd": "application/vnd.svd",
          "svf": ["image/vnd.dwg", "image/x-dwg"],
          "svg": "image/svg+xml",
          "svr": ["x-world/x-svr", "application/x-world"],
          "swf": "application/x-shockwave-flash",
          "swi": "application/vnd.aristanetworks.swi",
          "sxc": "application/vnd.sun.xml.calc",
          "sxd": "application/vnd.sun.xml.draw",
          "sxg": "application/vnd.sun.xml.writer.global",
          "sxi": "application/vnd.sun.xml.impress",
          "sxm": "application/vnd.sun.xml.math",
          "sxw": "application/vnd.sun.xml.writer",
          "t": ["text/troff", "application/x-troff"],
          "talk": "text/x-speech",
          "tao": "application/vnd.tao.intent-module-archive",
          "tar": "application/x-tar",
          "tbk": ["application/toolbook", "application/x-tbook"],
          "tcap": "application/vnd.3gpp2.tcap",
          "tcl": ["text/x-script.tcl", "application/x-tcl"],
          "tcsh": "text/x-script.tcsh",
          "teacher": "application/vnd.smart.teacher",
          "tei": "application/tei+xml",
          "tex": "application/x-tex",
          "texi": "application/x-texinfo",
          "texinfo": "application/x-texinfo",
          "text": ["application/plain", "text/plain"],
          "tfi": "application/thraud+xml",
          "tfm": "application/x-tex-tfm",
          "tgz": ["application/gnutar", "application/x-compressed"],
          "thmx": "application/vnd.ms-officetheme",
          "tif": ["image/tiff", "image/x-tiff"],
          "tiff": ["image/tiff", "image/x-tiff"],
          "tmo": "application/vnd.tmobile-livetv",
          "torrent": "application/x-bittorrent",
          "tpl": "application/vnd.groove-tool-template",
          "tpt": "application/vnd.trid.tpt",
          "tr": "application/x-troff",
          "tra": "application/vnd.trueapp",
          "trm": "application/x-msterminal",
          "tsd": "application/timestamped-data",
          "tsi": "audio/tsp-audio",
          "tsp": ["application/dsptype", "audio/tsplayer"],
          "tsv": "text/tab-separated-values",
          "ttf": "application/x-font-ttf",
          "ttl": "text/turtle",
          "turbot": "image/florian",
          "twd": "application/vnd.simtech-mindmapper",
          "txd": "application/vnd.genomatix.tuxedo",
          "txf": "application/vnd.mobius.txf",
          "txt": "text/plain",
          "ufd": "application/vnd.ufdl",
          "uil": "text/x-uil",
          "uls": "text/iuls",
          "umj": "application/vnd.umajin",
          "uni": "text/uri-list",
          "unis": "text/uri-list",
          "unityweb": "application/vnd.unity",
          "unv": "application/i-deas",
          "uoml": "application/vnd.uoml+xml",
          "uri": "text/uri-list",
          "uris": "text/uri-list",
          "ustar": ["application/x-ustar", "multipart/x-ustar"],
          "utz": "application/vnd.uiq.theme",
          "uu": ["application/octet-stream", "text/x-uuencode"],
          "uue": "text/x-uuencode",
          "uva": "audio/vnd.dece.audio",
          "uvh": "video/vnd.dece.hd",
          "uvi": "image/vnd.dece.graphic",
          "uvm": "video/vnd.dece.mobile",
          "uvp": "video/vnd.dece.pd",
          "uvs": "video/vnd.dece.sd",
          "uvu": "video/vnd.uvvu.mp4",
          "uvv": "video/vnd.dece.video",
          "vcd": "application/x-cdlink",
          "vcf": "text/x-vcard",
          "vcg": "application/vnd.groove-vcard",
          "vcs": "text/x-vcalendar",
          "vcx": "application/vnd.vcx",
          "vda": "application/vda",
          "vdo": "video/vdo",
          "vew": "application/groupwise",
          "vis": "application/vnd.visionary",
          "viv": ["video/vivo", "video/vnd.vivo"],
          "vivo": ["video/vivo", "video/vnd.vivo"],
          "vmd": "application/vocaltec-media-desc",
          "vmf": "application/vocaltec-media-file",
          "voc": ["audio/voc", "audio/x-voc"],
          "vos": "video/vosaic",
          "vox": "audio/voxware",
          "vqe": "audio/x-twinvq-plugin",
          "vqf": "audio/x-twinvq",
          "vql": "audio/x-twinvq-plugin",
          "vrml": ["model/vrml", "x-world/x-vrml", "application/x-vrml"],
          "vrt": "x-world/x-vrt",
          "vsd": ["application/vnd.visio", "application/x-visio"],
          "vsf": "application/vnd.vsf",
          "vst": "application/x-visio",
          "vsw": "application/x-visio",
          "vtu": "model/vnd.vtu",
          "vxml": "application/voicexml+xml",
          "w60": "application/wordperfect6.0",
          "w61": "application/wordperfect6.1",
          "w6w": "application/msword",
          "wad": "application/x-doom",
          "wav": ["audio/wav", "audio/x-wav"],
          "wax": "audio/x-ms-wax",
          "wb1": "application/x-qpro",
          "wbmp": "image/vnd.wap.wbmp",
          "wbs": "application/vnd.criticaltools.wbs+xml",
          "wbxml": "application/vnd.wap.wbxml",
          "wcm": "application/vnd.ms-works",
          "wdb": "application/vnd.ms-works",
          "web": "application/vnd.xara",
          "weba": "audio/webm",
          "webm": "video/webm",
          "webp": "image/webp",
          "wg": "application/vnd.pmi.widget",
          "wgt": "application/widget",
          "wiz": "application/msword",
          "wk1": "application/x-123",
          "wks": "application/vnd.ms-works",
          "wm": "video/x-ms-wm",
          "wma": "audio/x-ms-wma",
          "wmd": "application/x-ms-wmd",
          "wmf": ["windows/metafile", "application/x-msmetafile"],
          "wml": "text/vnd.wap.wml",
          "wmlc": "application/vnd.wap.wmlc",
          "wmls": "text/vnd.wap.wmlscript",
          "wmlsc": "application/vnd.wap.wmlscriptc",
          "wmv": "video/x-ms-wmv",
          "wmx": "video/x-ms-wmx",
          "wmz": "application/x-ms-wmz",
          "woff": "application/x-font-woff",
          "word": "application/msword",
          "wp": "application/wordperfect",
          "wp5": ["application/wordperfect", "application/wordperfect6.0"],
          "wp6": "application/wordperfect",
          "wpd": ["application/wordperfect", "application/vnd.wordperfect", "application/x-wpwin"],
          "wpl": "application/vnd.ms-wpl",
          "wps": "application/vnd.ms-works",
          "wq1": "application/x-lotus",
          "wqd": "application/vnd.wqd",
          "wri": ["application/mswrite", "application/x-wri", "application/x-mswrite"],
          "wrl": ["model/vrml", "x-world/x-vrml", "application/x-world"],
          "wrz": ["model/vrml", "x-world/x-vrml"],
          "wsc": "text/scriplet",
          "wsdl": "application/wsdl+xml",
          "wspolicy": "application/wspolicy+xml",
          "wsrc": "application/x-wais-source",
          "wtb": "application/vnd.webturbo",
          "wtk": "application/x-wintalk",
          "wvx": "video/x-ms-wvx",
          "x-png": "image/png",
          "x3d": "application/vnd.hzn-3d-crossword",
          "xaf": "x-world/x-vrml",
          "xap": "application/x-silverlight-app",
          "xar": "application/vnd.xara",
          "xbap": "application/x-ms-xbap",
          "xbd": "application/vnd.fujixerox.docuworks.binder",
          "xbm": ["image/xbm", "image/x-xbm", "image/x-xbitmap"],
          "xdf": "application/xcap-diff+xml",
          "xdm": "application/vnd.syncml.dm+xml",
          "xdp": "application/vnd.adobe.xdp+xml",
          "xdr": "video/x-amt-demorun",
          "xdssc": "application/dssc+xml",
          "xdw": "application/vnd.fujixerox.docuworks",
          "xenc": "application/xenc+xml",
          "xer": "application/patch-ops-error+xml",
          "xfdf": "application/vnd.adobe.xfdf",
          "xfdl": "application/vnd.xfdl",
          "xgz": "xgl/drawing",
          "xhtml": "application/xhtml+xml",
          "xif": "image/vnd.xiff",
          "xl": "application/excel",
          "xla": ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"],
          "xlam": "application/vnd.ms-excel.addin.macroenabled.12",
          "xlb": ["application/excel", "application/vnd.ms-excel", "application/x-excel"],
          "xlc": ["application/vnd.ms-excel", "application/excel", "application/x-excel"],
          "xld": ["application/excel", "application/x-excel"],
          "xlk": ["application/excel", "application/x-excel"],
          "xll": ["application/excel", "application/vnd.ms-excel", "application/x-excel"],
          "xlm": ["application/vnd.ms-excel", "application/excel", "application/x-excel"],
          "xls": ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"],
          "xlsb": "application/vnd.ms-excel.sheet.binary.macroenabled.12",
          "xlsm": "application/vnd.ms-excel.sheet.macroenabled.12",
          "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          "xlt": ["application/vnd.ms-excel", "application/excel", "application/x-excel"],
          "xltm": "application/vnd.ms-excel.template.macroenabled.12",
          "xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
          "xlv": ["application/excel", "application/x-excel"],
          "xlw": ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"],
          "xm": "audio/xm",
          "xml": ["application/xml", "text/xml", "application/atom+xml", "application/rss+xml"],
          "xmz": "xgl/movie",
          "xo": "application/vnd.olpc-sugar",
          "xof": "x-world/x-vrml",
          "xop": "application/xop+xml",
          "xpi": "application/x-xpinstall",
          "xpix": "application/x-vnd.ls-xpix",
          "xpm": ["image/xpm", "image/x-xpixmap"],
          "xpr": "application/vnd.is-xpr",
          "xps": "application/vnd.ms-xpsdocument",
          "xpw": "application/vnd.intercon.formnet",
          "xslt": "application/xslt+xml",
          "xsm": "application/vnd.syncml+xml",
          "xspf": "application/xspf+xml",
          "xsr": "video/x-amt-showrun",
          "xul": "application/vnd.mozilla.xul+xml",
          "xwd": ["image/x-xwd", "image/x-xwindowdump"],
          "xyz": ["chemical/x-xyz", "chemical/x-pdb"],
          "yang": "application/yang",
          "yin": "application/yin+xml",
          "z": ["application/x-compressed", "application/x-compress"],
          "zaz": "application/vnd.zzazz.deck+xml",
          "zip": ["application/zip", "multipart/x-zip", "application/x-zip-compressed", "application/x-compressed"],
          "zir": "application/vnd.zul",
          "zmm": "application/vnd.handheld-entertainment+xml",
          "zoo": "application/octet-stream",
          "zsh": "text/x-script.zsh"
        };
        return {
          detectExtension,
          detectMimeType
        };
      });
    }
  });

  // src/vendor/addressparser.js
  var require_addressparser = __commonJS({
    "src/vendor/addressparser.js"(exports, module) {
      (function(root, factory) {
        "use strict";
        if (typeof define === "function" && define.amd) {
          define(factory);
        } else if (typeof exports === "object") {
          module.exports = factory();
        } else {
          root.addressparser = factory();
        }
      })(exports, function() {
        "use strict";
        var addressparser2 = {};
        addressparser2.parse = function(str) {
          var tokenizer2 = new addressparser2.Tokenizer(str), tokens = tokenizer2.tokenize();
          var addresses = [], address = [], parsedAddresses = [];
          tokens.forEach(function(token) {
            if (token.type === "operator" && (token.value === "," || token.value === ";")) {
              if (address.length) {
                addresses.push(address);
              }
              address = [];
            } else {
              address.push(token);
            }
          });
          if (address.length) {
            addresses.push(address);
          }
          addresses.forEach(function(address2) {
            address2 = addressparser2._handleAddress(address2);
            if (address2.length) {
              parsedAddresses = parsedAddresses.concat(address2);
            }
          });
          return parsedAddresses;
        };
        addressparser2._handleAddress = function(tokens) {
          var token, isGroup = false, state = "text", address, addresses = [], data = {
            address: [],
            comment: [],
            group: [],
            text: []
          }, i, len;
          for (i = 0, len = tokens.length; i < len; i++) {
            token = tokens[i];
            if (token.type === "operator") {
              switch (token.value) {
                case "<":
                  state = "address";
                  break;
                case "(":
                  state = "comment";
                  break;
                case ":":
                  state = "group";
                  isGroup = true;
                  break;
                default:
                  state = "text";
              }
            } else {
              if (token.value) {
                data[state].push(token.value);
              }
            }
          }
          if (!data.text.length && data.comment.length) {
            data.text = data.comment;
            data.comment = [];
          }
          if (isGroup) {
            data.text = data.text.join(" ");
            addresses.push({
              name: data.text || address && address.name,
              group: data.group.length ? addressparser2.parse(data.group.join(",")) : []
            });
          } else {
            if (!data.address.length && data.text.length) {
              for (i = data.text.length - 1; i >= 0; i--) {
                if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                  data.address = data.text.splice(i, 1);
                  break;
                }
              }
              var _regexHandler = function(address2) {
                if (!data.address.length) {
                  data.address = [address2.trim()];
                  return " ";
                } else {
                  return address2;
                }
              };
              if (!data.address.length) {
                for (i = data.text.length - 1; i >= 0; i--) {
                  data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^@\s]+\b\s*/, _regexHandler).trim();
                  if (data.address.length) {
                    break;
                  }
                }
              }
            }
            if (!data.text.length && data.comment.length) {
              data.text = data.comment;
              data.comment = [];
            }
            if (data.address.length > 1) {
              data.text = data.text.concat(data.address.splice(1));
            }
            data.text = data.text.join(" ");
            data.address = data.address.join(" ");
            if (!data.address && isGroup) {
              return [];
            } else {
              address = {
                address: data.address || data.text || "",
                name: data.text || data.address || ""
              };
              if (address.address === address.name) {
                if ((address.address || "").match(/@/)) {
                  address.name = "";
                } else {
                  address.address = "";
                }
              }
              addresses.push(address);
            }
          }
          return addresses;
        };
        addressparser2.Tokenizer = function(str) {
          this.str = (str || "").toString();
          this.operatorCurrent = "";
          this.operatorExpecting = "";
          this.node = null;
          this.escaped = false;
          this.list = [];
        };
        addressparser2.Tokenizer.prototype.operators = {
          '"': '"',
          "(": ")",
          "<": ">",
          ",": "",
          ":": ";",
          ";": ""
        };
        addressparser2.Tokenizer.prototype.tokenize = function() {
          var chr, list = [];
          for (var i = 0, len = this.str.length; i < len; i++) {
            chr = this.str.charAt(i);
            this.checkChar(chr);
          }
          this.list.forEach(function(node) {
            node.value = (node.value || "").toString().trim();
            if (node.value) {
              list.push(node);
            }
          });
          return list;
        };
        addressparser2.Tokenizer.prototype.checkChar = function(chr) {
          if ((chr in this.operators || chr === "\\") && this.escaped) {
            this.escaped = false;
          } else if (this.operatorExpecting && chr === this.operatorExpecting) {
            this.node = {
              type: "operator",
              value: chr
            };
            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = "";
            this.escaped = false;
            return;
          } else if (!this.operatorExpecting && chr in this.operators) {
            this.node = {
              type: "operator",
              value: chr
            };
            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = this.operators[chr];
            this.escaped = false;
            return;
          }
          if (!this.escaped && chr === "\\") {
            this.escaped = true;
            return;
          }
          if (!this.node) {
            this.node = {
              type: "text",
              value: ""
            };
            this.list.push(this.node);
          }
          if (this.escaped && chr !== "\\") {
            this.node.value += "\\";
          }
          this.node.value += chr;
          this.escaped = false;
        };
        return addressparser2;
      });
    }
  });

  // src/backend/db/mail_rep.js
  function makeMessageInfo(raw) {
    if (!raw.author) {
      throw new Error("No author?!");
    }
    if (!raw.date) {
      throw new Error("No date?!");
    }
    if (!raw.attachments || !raw.bodyReps) {
      throw new Error("No attachments / bodyReps?!");
    }
    if (Array.isArray(raw.folderIds)) {
      throw new Error("raw.folderIds must be a Set, not an Array");
    }
    return {
      id: raw.id,
      umid: raw.umid || null,
      guid: raw.guid || null,
      date: raw.date,
      dateModified: raw.dateModified || raw.date,
      author: raw.author,
      to: raw.to || null,
      cc: raw.cc || null,
      bcc: raw.bcc || null,
      replyTo: raw.replyTo || null,
      flags: raw.flags || [],
      folderIds: raw.folderIds || new Set(),
      hasAttachments: raw.hasAttachments || false,
      subject: raw.subject != null ? raw.subject : null,
      snippet: raw.snippet != null ? raw.snippet : null,
      attachments: raw.attachments,
      relatedParts: raw.relatedParts || null,
      references: raw.references || null,
      bodyReps: raw.bodyReps,
      authoredBodySize: raw.authoredBodySize || 0,
      draftInfo: raw.draftInfo || null
    };
  }
  function makeDraftInfo(raw) {
    return {
      draftType: raw.draftType,
      mode: raw.mode || null,
      refMessageId: raw.refMessageId || null,
      refMessageDate: raw.refMessageDate || null,
      sendProblems: raw.sendProblems || null
    };
  }
  function makeBodyPart(raw) {
    if (raw.type !== "plain" && raw.type !== "html" && raw.type !== "attr") {
      throw new Error("Bad body type: " + raw.type);
    }
    if (raw.sizeEstimate === void 0) {
      throw new Error("Need size estimate!");
    }
    return {
      type: raw.type,
      part: raw.part || null,
      sizeEstimate: raw.sizeEstimate,
      amountDownloaded: raw.amountDownloaded || 0,
      isDownloaded: raw.isDownloaded || false,
      _partInfo: raw._partInfo || null,
      contentBlob: raw.contentBlob || null,
      authoredBodySize: raw.authoredBodySize || 0
    };
  }
  function makeAttachmentPart(raw) {
    if (raw.sizeEstimate === void 0) {
      throw new Error("Need size estimate!");
    }
    if (raw.relId === void 0) {
      throw new Error("attachments need relIds");
    }
    return {
      relId: raw.relId,
      name: raw.name != null ? raw.name : null,
      contentId: raw.contentId || null,
      type: raw.type || "application/octet-stream",
      part: raw.part || null,
      encoding: raw.encoding || null,
      sizeEstimate: raw.sizeEstimate,
      downloadState: raw.downloadState || null,
      file: raw.file || null,
      charset: raw.charset || null,
      textFormat: raw.textFormat || null
    };
  }
  var init_mail_rep = __esm({
    "src/backend/db/mail_rep.js"() {
    }
  });

  // src/backend/accounts/activesync/smotocol/parse_full_message.js
  function parseFullMessage(node, { messageId, umid, folderId }) {
    let scratchMsg = {
      id: messageId,
      umid,
      guid: "",
      author: null,
      to: null,
      cc: null,
      bcc: null,
      replyTo: null,
      date: null,
      flags: [],
      folderIds: new Set([folderId]),
      hasAttachments: false,
      subject: null,
      snippet: null,
      attachments: [],
      relatedParts: [],
      references: [],
      bodyReps: null
    };
    let bodyType, bodySize;
    for (let child of node.children) {
      let childText = child.children.length ? child.children[0].textContent : null;
      switch (child.tag) {
        case Email_default.Tags.Subject:
          scratchMsg.subject = childText;
          break;
        case Email_default.Tags.From:
          scratchMsg.author = (0, import_addressparser.parse)(childText)[0] || null;
          break;
        case Email_default.Tags.To:
          scratchMsg.to = (0, import_addressparser.parse)(childText);
          break;
        case Email_default.Tags.Cc:
          scratchMsg.cc = (0, import_addressparser.parse)(childText);
          break;
        case Email_default.Tags.ReplyTo:
          scratchMsg.replyTo = (0, import_addressparser.parse)(childText);
          break;
        case Email_default.Tags.DateReceived:
          scratchMsg.date = new Date(childText).valueOf();
          break;
        case Email_default.Tags.Read:
          if (childText === "1") {
            scratchMsg.flags.push("\\Seen");
          }
          break;
        case Email_default.Tags.Flag:
          for (let grandchild of child.children) {
            if (grandchild.tag === Email_default.Tags.Status && grandchild.children[0].textContent !== "0") {
              scratchMsg.flags.push("\\Flagged");
            }
          }
          break;
        case AirSyncBase_default.Tags.Body:
          for (let grandchild of child.children) {
            switch (grandchild.tag) {
              case AirSyncBase_default.Tags.Type:
                var type = grandchild.children[0].textContent;
                if (type === AirSyncBase_default.Enums.Type.HTML) {
                  bodyType = "html";
                } else {
                  if (type !== AirSyncBase_default.Enums.Type.PlainText) {
                    console.warn("A message had a strange body type:", type);
                  }
                  bodyType = "plain";
                }
                break;
              case AirSyncBase_default.Tags.EstimatedDataSize:
                bodySize = grandchild.children[0].textContent;
                break;
              default:
                break;
            }
          }
          break;
        case Email_default.Tags.BodySize:
          bodyType = "plain";
          bodySize = childText;
          break;
        case AirSyncBase_default.Tags.Attachments:
        case Email_default.Tags.Attachments:
          for (let attachmentNode of child.children) {
            if (attachmentNode.tag !== AirSyncBase_default.Tags.Attachment && attachmentNode.tag !== Email_default.Tags.Attachment) {
              continue;
            }
            let attachment = {
              relId: encodeInt(scratchMsg.attachments.length),
              name: null,
              contentId: null,
              type: null,
              part: null,
              encoding: null,
              sizeEstimate: null,
              downloadState: null,
              file: null
            };
            let isInline = false;
            for (let attachData of attachmentNode.children) {
              let dot, ext;
              let attachDataText = attachData.children.length ? attachData.children[0].textContent : null;
              switch (attachData.tag) {
                case AirSyncBase_default.Tags.DisplayName:
                case Email_default.Tags.DisplayName:
                  attachment.name = attachDataText;
                  dot = attachment.name.lastIndexOf(".");
                  ext = dot > 0 ? attachment.name.substring(dot + 1).toLowerCase() : "";
                  attachment.type = import_mimetypes.default.detectMimeType(ext);
                  break;
                case AirSyncBase_default.Tags.FileReference:
                case Email_default.Tags.AttName:
                case Email_default.Tags.Att0Id:
                  attachment.part = attachDataText;
                  break;
                case AirSyncBase_default.Tags.EstimatedDataSize:
                case Email_default.Tags.AttSize:
                  attachment.sizeEstimate = parseInt(attachDataText, 10);
                  break;
                case AirSyncBase_default.Tags.ContentId:
                  attachment.contentId = attachDataText;
                  break;
                case AirSyncBase_default.Tags.IsInline:
                  isInline = attachDataText === "1";
                  break;
                default:
                  break;
              }
            }
            if (isInline) {
              scratchMsg.relatedParts.push(makeAttachmentPart(attachment));
            } else {
              scratchMsg.attachments.push(makeAttachmentPart(attachment));
            }
          }
          scratchMsg.hasAttachments = !!scratchMsg.attachments.length;
          break;
        default:
          break;
      }
    }
    scratchMsg.bodyReps = [
      makeBodyPart({
        type: bodyType,
        sizeEstimate: bodySize,
        amountDownloaded: 0,
        isDownloaded: false
      })
    ];
    return makeMessageInfo(scratchMsg);
  }
  var import_mimetypes, import_addressparser;
  var init_parse_full_message = __esm({
    "src/backend/accounts/activesync/smotocol/parse_full_message.js"() {
      import_mimetypes = __toModule(require_mimetypes());
      import_addressparser = __toModule(require_addressparser());
      init_a64();
      init_mail_rep();
      init_AirSyncBase();
      init_Email();
    }
  });

  // src/backend/accounts/activesync/smotocol/parse_changed_message.js
  function parseChangedMessage(node) {
    let flagChanges = {
      add: null,
      remove: null
    };
    function setFlagState(flag, beSet) {
      if (beSet) {
        if (!flagChanges.add) {
          flagChanges.add = [];
        }
        flagChanges.add.push(flag);
      } else {
        if (!flagChanges.remove) {
          flagChanges.remove = [];
        }
        flagChanges.remove.push(flag);
      }
    }
    for (let child of node.children) {
      let childText = child.children.length ? child.children[0].textContent : null;
      switch (child.tag) {
        case Email_default.Tags.Read:
          setFlagState("\\Seen", childText === "1");
          break;
        case Email_default.Tags.Flag:
          for (let grandchild of child.children) {
            if (grandchild.tag === Email_default.Tags.Status) {
              setFlagState("\\Flagged", grandchild.children[0].textContent !== "0");
            }
          }
          break;
        default:
          break;
      }
    }
    return { flagChanges };
  }
  var init_parse_changed_message = __esm({
    "src/backend/accounts/activesync/smotocol/parse_changed_message.js"() {
      init_Email();
    }
  });

  // src/backend/accounts/activesync/smotocol/enum_folder_changes.js
  async function enumerateFolderChanges(conn, { folderSyncKey, folderServerId, filterType, issueIds, emitter }) {
    let w = new Writer("1.3", 1, "UTF-8");
    w.stag(AirSync_default.Tags.Sync).stag(AirSync_default.Tags.Collections).stag(AirSync_default.Tags.Collection);
    if (conn.currentVersion.lt("12.1")) {
      w.tag(AirSync_default.Tags.Class, "Email");
    }
    w.tag(AirSync_default.Tags.SyncKey, folderSyncKey).tag(AirSync_default.Tags.CollectionId, folderServerId).tag(AirSync_default.Tags.GetChanges).stag(AirSync_default.Tags.Options).tag(AirSync_default.Tags.FilterType, filterType);
    if (conn.currentVersion.lte("12.0")) {
      w.tag(AirSync_default.Tags.MIMESupport, AirSync_default.Enums.MIMESupport.Never).tag(AirSync_default.Tags.Truncation, AirSync_default.Enums.MIMETruncation.TruncateAll);
    }
    w.etag().etag().etag().etag();
    let response = await conn.postCommand(w);
    if (!response) {
      logic(conn, "syncComplete", { emptyResponse: true });
      return {
        invalidSyncKey: false,
        syncKey: folderSyncKey,
        moreAvailable: false,
        noChanges: true
      };
    }
    let e = new EventParser();
    let base = [AirSync_default.Tags.Sync, AirSync_default.Tags.Collections, AirSync_default.Tags.Collection];
    let status;
    let newSyncKey;
    let moreAvailable = false;
    let addCount = 0, changeCount = 0, removeCount = 0;
    e.addEventListener(base.concat(AirSync_default.Tags.SyncKey), function(node) {
      newSyncKey = node.children[0].textContent;
    });
    e.addEventListener(base.concat(AirSync_default.Tags.Status), function(node) {
      status = node.children[0].textContent;
    });
    e.addEventListener(base.concat(AirSync_default.Tags.MoreAvailable), function(node) {
      moreAvailable = true;
    });
    e.addEventListener(base.concat(AirSync_default.Tags.Commands, AirSync_default.Tags.Add), function(node) {
      let messageServerId, nodeToParse;
      for (let child of node.children) {
        switch (child.tag) {
          case AirSync_default.Tags.ServerId:
            messageServerId = child.children[0].textContent;
            break;
          case AirSync_default.Tags.ApplicationData:
            nodeToParse = child;
            break;
          default:
            break;
        }
      }
      if (nodeToParse && messageServerId) {
        try {
          let message = parseFullMessage(nodeToParse, issueIds());
          addCount++;
          emitter.emit("add", messageServerId, message);
        } catch (ex) {
          console.error("Failed to parse a full message:", ex, "\n", ex.stack);
        }
      }
    });
    e.addEventListener(base.concat(AirSync_default.Tags.Commands, AirSync_default.Tags.Change), function(node) {
      let messageServerId, changes;
      for (let child of node.children) {
        switch (child.tag) {
          case AirSync_default.Tags.ServerId:
            messageServerId = child.children[0].textContent;
            break;
          case AirSync_default.Tags.ApplicationData:
            try {
              changes = parseChangedMessage(child);
            } catch (ex) {
              console.error("Failed to parse a change:", ex, "\n", ex.stack);
              return;
            }
            break;
          default:
            break;
        }
      }
      if (messageServerId && changes) {
        changeCount++;
        emitter.emit("change", messageServerId, changes);
      }
    });
    e.addEventListener(base.concat(AirSync_default.Tags.Commands, [[AirSync_default.Tags.Delete, AirSync_default.Tags.SoftDelete]]), function(node) {
      let messageServerId;
      for (let child of node.children) {
        switch (child.tag) {
          case AirSync_default.Tags.ServerId:
            messageServerId = child.children[0].textContent;
            break;
          default:
            break;
        }
      }
      if (messageServerId) {
        removeCount++;
        emitter.emit("remove", messageServerId);
      }
    });
    try {
      e.run(response);
    } catch (ex) {
      console.error("Error parsing Sync response:", ex, "\n", ex.stack);
      throw new Error("unknown");
    }
    if (status === AirSync_default.Enums.Status.Success) {
      logic(conn, "syncComplete", {
        added: addCount,
        changed: changeCount,
        removed: removeCount
      });
      return { invalidSyncKey: false, syncKey: newSyncKey, moreAvailable };
    } else if (status === AirSync_default.Enums.Status.InvalidSyncKey) {
      return { invalidSyncKey: true, syncKey: "0", moreAvailable };
    }
    logic(conn, "syncError", { status });
    throw new Error("unknown");
  }
  var init_enum_folder_changes = __esm({
    "src/backend/accounts/activesync/smotocol/enum_folder_changes.js"() {
      init_logic();
      init_wbxml();
      init_AirSync();
      init_parse_full_message();
      init_parse_changed_message();
    }
  });

  // src/backend/db/comparators.js
  function folderConversationComparator(a, b) {
    let dateDelta = b.date - a.date;
    if (dateDelta) {
      return dateDelta;
    }
    let aId = a.id;
    let bId = b.id;
    if (bId > aId) {
      return 1;
    } else if (aId > bId) {
      return -1;
    }
    return 0;
  }
  function conversationMessageComparator(a, b) {
    let dateDelta = b.date - a.date;
    if (dateDelta) {
      return dateDelta;
    }
    let aId = a.id;
    let bId = b.id;
    if (bId > aId) {
      return 1;
    } else if (aId > bId) {
      return -1;
    }
    return 0;
  }
  function oldToNewConversationMessageComparator(a, b) {
    let dateDelta = a.date - b.date;
    if (dateDelta) {
      return dateDelta;
    }
    let aId = a.id;
    let bId = b.id;
    if (bId > aId) {
      return 1;
    } else if (aId > bId) {
      return -1;
    }
    return 0;
  }
  var init_comparators = __esm({
    "src/backend/db/comparators.js"() {
    }
  });

  // src/app_logic/conv_churn.js
  function churnConversation(convInfo, messages, oldConvInfo, convType, convMeta) {
    messages = messages.concat();
    messages.sort(oldToNewConversationMessageComparator);
    let tidbits = convInfo.app.tidbits = [];
    let midToIndex = new Map();
    let findClosestAncestor = (references) => {
      if (!references) {
        return 0;
      }
      for (let i = references.length; i >= 0; i--) {
        let ref = references[i];
        if (midToIndex.has(ref)) {
          return midToIndex.get(ref);
        }
      }
      return 0;
    };
    for (let message of messages) {
      let isRead = message.flags.includes("\\Seen");
      let isStarred = message.flags.includes("\\Flagged");
      tidbits.push({
        id: message.id,
        date: message.date,
        isRead,
        isStarred,
        author: message.author,
        parent: findClosestAncestor(message.references)
      });
      midToIndex.set(message.guid, tidbits.length - 1);
    }
    if (tidbits.length === 1) {
      convInfo.height = 1;
    } else {
      convInfo.height = 2;
    }
    if (convType === "phab-drev") {
      convInfo.app.drevInfo = convMeta.drevInfo;
      const patchInfo = convInfo.app.patchInfo = convMeta.patchInfo;
      for (const folderId of patchInfo.virtFolderIds) {
        convInfo.folderIds.add(folderId);
      }
    }
  }
  var init_conv_churn = __esm({
    "src/app_logic/conv_churn.js"() {
      init_comparators();
    }
  });

  // src/backend/churn_drivers/conv_churn_driver.js
  function churnConversationDriver(convId, oldConvInfo, messages, convType = "mail", convMeta) {
    let userCanonicalField = "address";
    if (convType === "phab-drev") {
      userCanonicalField = "nick";
    }
    let authorsById = new Map();
    let snippetCount = 0;
    let tidbits = [];
    let convHasUnread = false;
    let convHasStarred = false;
    let convHasDrafts = false;
    let convHasAttachments = false;
    let convFolderIds = new Set();
    let effectiveDate = 0;
    let fallbackDate = 0;
    for (let message of messages) {
      let isRead = message.flags.includes("\\Seen");
      let isStarred = message.flags.includes("\\Flagged");
      let isDraft = message.draftInfo !== null;
      fallbackDate = Math.max(fallbackDate, message.date);
      if (isDraft) {
        convHasDrafts = true;
      } else {
        effectiveDate = Math.max(effectiveDate, message.date);
      }
      if (!isRead) {
        convHasUnread = true;
      }
      if (isStarred) {
        convHasStarred = true;
      }
      if (message.hasAttachments) {
        convHasAttachments = true;
      }
      if (!authorsById.has(message.author[userCanonicalField])) {
        authorsById.set(message.author[userCanonicalField], message.author);
      }
      for (let folderId of message.folderIds) {
        convFolderIds.add(folderId);
      }
      if (message.snippet !== null) {
        snippetCount++;
      }
    }
    if (!effectiveDate) {
      effectiveDate = fallbackDate;
    }
    let convInfo = {
      id: convId,
      convType,
      date: effectiveDate,
      folderIds: convFolderIds,
      height: 1,
      subject: messages[0].subject,
      messageCount: messages.length,
      snippetCount,
      authors: Array.from(authorsById.values()),
      tidbits,
      hasUnread: convHasUnread,
      hasStarred: convHasStarred,
      hasDrafts: convHasDrafts,
      hasAttachments: convHasAttachments,
      app: {}
    };
    try {
      churnConversation(convInfo, messages, oldConvInfo, convType, convMeta);
    } catch (ex) {
      logic(scope2, "appChurnEx", { ex });
    }
    return convInfo;
  }
  var scope2;
  var init_conv_churn_driver = __esm({
    "src/backend/churn_drivers/conv_churn_driver.js"() {
      init_logic();
      init_conv_churn();
      scope2 = {};
      logic.defineScope(scope2, "churnConversationDriver");
    }
  });

  // src/backend/task_helpers/sync_overlay_helpers.js
  function syncNormalOverlay(id, marker, inProgress, blockedBy) {
    let status;
    if (inProgress) {
      status = "active";
    } else if (marker) {
      status = "pending";
    } else {
      return null;
    }
    let blocked = null;
    if (blockedBy) {
      switch (blockedBy[blockedBy.length - 1][0]) {
        case "o":
          blocked = "offline";
          break;
        case "c":
          blocked = "bad-auth";
          break;
        case "h":
          blocked = "unknown";
          break;
        default:
          break;
      }
    }
    return { status, blocked };
  }
  function syncPrefixOverlay(fullId, binId, marker, inProgress, blockedBy) {
    return syncNormalOverlay(binId, marker, inProgress, blockedBy);
  }
  var init_sync_overlay_helpers = __esm({
    "src/backend/task_helpers/sync_overlay_helpers.js"() {
    }
  });

  // src/backend/accounts/activesync/tasks/sync_refresh.js
  var import_evt6, sync_refresh_default;
  var init_sync_refresh = __esm({
    "src/backend/accounts/activesync/tasks/sync_refresh.js"() {
      import_evt6 = __toModule(require_evt());
      init_logic();
      init_util();
      init_date();
      init_task_definer();
      init_folder_sync_state_helper();
      init_get_folder_sync_key();
      init_infer_filter_type();
      init_enum_folder_changes();
      init_id_conversions();
      init_conv_churn_driver();
      init_syncbase();
      init_sync_overlay_helpers();
      sync_refresh_default = task_definer_default.defineAtMostOnceTask([
        {
          name: "sync_refresh",
          binByArg: "folderId",
          helped_overlay_folders: syncNormalOverlay,
          helped_invalidate_overlays(folderId, dataOverlayManager) {
            dataOverlayManager.announceUpdatedOverlayData("folders", folderId);
          },
          helped_already_planned(ctx, rawTask) {
            return Promise.resolve({
              result: ctx.trackMeInTaskGroup("sync_refresh:" + rawTask.folderId)
            });
          },
          async helped_plan(ctx, rawTask) {
            let foldersTOC = await ctx.universe.acquireAccountFoldersTOC(ctx, ctx.accountId);
            let folderInfo = foldersTOC.foldersById.get(rawTask.folderId);
            let plannedTask;
            if (!folderInfo.serverId) {
              plannedTask = null;
            } else {
              plannedTask = shallowClone2(rawTask);
              plannedTask.resources = [
                "online",
                `credentials!${rawTask.accountId}`,
                `happy!${rawTask.accountId}`
              ];
              plannedTask.priorityTags = [`view:folder:${rawTask.folderId}`];
            }
            let groupPromise = ctx.trackMeInTaskGroup("sync_refresh:" + rawTask.folderId);
            return {
              taskState: plannedTask,
              remainInProgressUntil: groupPromise,
              result: groupPromise
            };
          },
          async helped_execute(ctx, req) {
            let fromDb = await ctx.beginMutate({
              syncStates: new Map([[req.folderId, null]])
            });
            let rawSyncState = fromDb.syncStates.get(req.folderId);
            let syncState = new folder_sync_state_helper_default(ctx, rawSyncState, req.accountId, req.folderId, "refresh");
            let account = await ctx.universe.acquireAccount(ctx, req.accountId);
            let conn = await account.ensureConnection();
            let folderInfo = account.getFolderById(req.folderId);
            let emitter = new import_evt6.default.Emitter();
            let newConversations = [];
            let newMessages = [];
            let issueIds = () => {
              let umid = syncState.issueUniqueMessageId();
              let convId = req.accountId + "." + messageIdComponentFromUmid(umid);
              let messageId = convId + "." + messageIdComponentFromUmid(umid);
              return { messageId, umid, folderId: req.folderId };
            };
            emitter.on("add", (serverMessageId, message) => {
              syncState.newMessage(serverMessageId, message);
              let convId = convIdFromMessageId(message.id);
              newMessages.push(message);
              let convInfo = churnConversationDriver(convId, null, [message]);
              newConversations.push(convInfo);
            });
            emitter.on("change", (serverMessageId, changes) => {
              syncState.messageChanged(serverMessageId, changes);
            });
            emitter.on("remove", (serverMessageId) => {
              syncState.messageDeleted(serverMessageId);
            });
            let syncKeyTriesAllowed = 1;
            let syncDate;
            while (syncKeyTriesAllowed--) {
              if (!syncState.filterType) {
                logic(ctx, "inferringFilterType");
                let results = await inferFilterType(conn, {
                  folderServerId: folderInfo.serverId,
                  desiredMessageCount: SYNC_WHOLE_FOLDER_AT_N_MESSAGES
                });
                syncState.syncKey = results.syncKey;
                syncState.filterType = results.filterType;
              }
              if (!syncState.syncKey || syncState.syncKey === "0") {
                syncState.syncKey = (await getFolderSyncKey(conn, {
                  folderServerId: folderInfo.serverId,
                  filterType: syncState.filterType
                })).syncKey;
              }
              syncDate = NOW();
              let {
                invalidSyncKey,
                syncKey,
                moreToSync
              } = await enumerateFolderChanges(conn, {
                folderSyncKey: syncState.syncKey,
                folderServerId: folderInfo.serverId,
                filterType: syncState.filterType,
                issueIds,
                emitter
              });
              if (invalidSyncKey) {
                syncKeyTriesAllowed++;
                syncState.syncKey = "0";
                continue;
              }
              syncState.syncKey = syncKey;
              if (moreToSync) {
                syncState.scheduleAnotherRefreshLikeThisOne(req);
              }
            }
            if (syncState.umidNameReads.size) {
              await ctx.read({
                umidNames: syncState.umidNameReads
              });
              syncState.generateSyncConvTasks();
            }
            return {
              mutations: {
                syncStates: new Map([[req.folderId, syncState.rawSyncState]]),
                umidNames: syncState.umidNameWrites,
                umidLocations: syncState.umidLocationWrites
              },
              newData: {
                conversations: newConversations,
                messages: newMessages,
                tasks: syncState.tasksToSchedule
              },
              atomicClobbers: {
                folders: new Map([
                  [
                    req.folderId,
                    {
                      lastSuccessfulSyncAt: syncDate,
                      lastAttemptedSyncAt: syncDate,
                      failedSyncsSinceLastSuccessfulSync: 0
                    }
                  ]
                ])
              }
            };
          }
        }
      ]);
    }
  });

  // src/backend/delta_algebra.js
  function normalizeAndApplyChanges(values, toAdd, toRemove) {
    if (!Array.isArray(values)) {
      return normalizeAndApplyChangesToSet(values, toAdd, toRemove);
    }
    let actuallyAdded = null;
    let actuallyRemoved = null;
    if (toAdd) {
      for (let addend of toAdd) {
        if (values.indexOf(addend === -1)) {
          if (!actuallyAdded) {
            actuallyAdded = [];
          }
          values.push(addend);
          actuallyAdded.push(addend);
        }
      }
    }
    if (toRemove) {
      for (let subtrahend of toRemove) {
        let index = values.indexOf(subtrahend);
        if (index !== -1) {
          if (!actuallyRemoved) {
            actuallyRemoved = [];
          }
          values.splice(index, 1);
          actuallyRemoved.push(subtrahend);
        }
      }
    }
    return { add: actuallyAdded, remove: actuallyRemoved };
  }
  function normalizeAndApplyChangesToSet(values, toAdd, toRemove) {
    let actuallyAdded = null;
    let actuallyRemoved = null;
    if (toAdd) {
      for (let addend of toAdd) {
        if (!values.has(addend)) {
          if (!actuallyAdded) {
            actuallyAdded = [];
          }
          values.add(addend);
          actuallyAdded.push(addend);
        }
      }
    }
    if (toRemove) {
      for (let subtrahend of toRemove) {
        if (values.has(subtrahend)) {
          if (!actuallyRemoved) {
            actuallyRemoved = [];
          }
          values.delete(subtrahend);
          actuallyRemoved.push(subtrahend);
        }
      }
    }
    return { add: actuallyAdded, remove: actuallyRemoved };
  }
  function applyChanges(value, changes) {
    if (!Array.isArray(value)) {
      applyChangesToSet(value, changes);
      return;
    }
    if (changes.add) {
      for (let addend of changes.add) {
        if (!value.includes(addend)) {
          value.push(addend);
        }
      }
    }
    if (changes.remove) {
      for (let subtrahend of changes.remove) {
        let index = value.indexOf(subtrahend);
        if (index !== -1) {
          value.splice(subtrahend, 1);
        }
      }
    }
  }
  function applyChangesToSet(value, changes) {
    if (changes.add) {
      for (let addend of changes.add) {
        if (!value.has(addend)) {
          value.push(addend);
        }
      }
    }
    if (changes.remove) {
      for (let subtrahend of changes.remove) {
        if (value.has(subtrahend)) {
          value.delete(subtrahend);
        }
      }
    }
  }
  function concatLists(a, b) {
    if (a && b) {
      return a.concat(b);
    } else if (a) {
      return a;
    }
    return b;
  }
  function mergeChanges(existingChanges, newChanges) {
    let derivedAdd;
    let derivedRemove;
    if (existingChanges.add && newChanges.remove || existingChanges.remove && newChanges.add) {
      derivedAdd = [];
      let pendingRemove = new Set(newChanges.remove);
      if (existingChanges.add) {
        for (let item of existingChanges.add) {
          if (pendingRemove.has(item)) {
            pendingRemove.delete(item);
          } else {
            derivedAdd.push(item);
          }
        }
      }
      derivedRemove = [];
      let pendingAdd = new Set(newChanges.add);
      if (existingChanges.remove) {
        for (let item of existingChanges.remove) {
          if (pendingAdd.has(item)) {
            pendingAdd.delete(item);
          } else {
            derivedRemove.push(item);
          }
        }
      }
      derivedAdd = concatLists(derivedAdd, Array.from(pendingAdd));
      derivedRemove = concatLists(derivedRemove, Array.from(pendingRemove));
    } else {
      derivedAdd = concatLists(existingChanges.add, newChanges.add);
      derivedRemove = concatLists(existingChanges.remove, newChanges.remove);
    }
    if (derivedAdd && !derivedAdd.length) {
      derivedAdd = null;
    }
    if (derivedRemove && !derivedRemove.length) {
      derivedRemove = null;
    }
    return {
      add: derivedAdd,
      remove: derivedRemove
    };
  }
  var init_delta_algebra = __esm({
    "src/backend/delta_algebra.js"() {
    }
  });

  // src/backend/task_mixins/mix_sync_conv.js
  var mix_sync_conv_default;
  var init_mix_sync_conv = __esm({
    "src/backend/task_mixins/mix_sync_conv.js"() {
      init_conv_churn_driver();
      mix_sync_conv_default = {
        async plan(ctx, req) {
          let fromDb = await ctx.beginMutate({
            conversations: new Map([[req.convId, null]]),
            messagesByConversation: new Map([[req.convId, null]])
          });
          let loadedMessages = fromDb.messagesByConversation.get(req.convId);
          let modifiedMessagesMap = new Map();
          let umidNameWrites = new Map();
          let keptMessages = [];
          for (let message of loadedMessages) {
            if (req.removedUmids && req.removedUmids.has(message.umid)) {
              modifiedMessagesMap.set(message.id, null);
              umidNameWrites.set(message.umid, null);
            } else {
              keptMessages.push(message);
              if (req.modifiedUmids && req.modifiedUmids.has(message.umid)) {
                this.applyChanges(message, req.modifiedUmids.get(message.umid));
                modifiedMessagesMap.set(message.id, message);
              }
            }
          }
          let convInfo;
          if (keptMessages.length) {
            let oldConvInfo = fromDb.conversations.get(req.convId);
            convInfo = churnConversationDriver(req.convId, oldConvInfo, keptMessages);
          } else {
            convInfo = null;
          }
          await ctx.finishTask({
            mutations: {
              conversations: new Map([[req.convId, convInfo]]),
              messages: modifiedMessagesMap,
              umidNames: umidNameWrites
            }
          });
        },
        execute: null
      };
    }
  });

  // src/backend/accounts/activesync/tasks/sync_conv.js
  var sync_conv_default;
  var init_sync_conv = __esm({
    "src/backend/accounts/activesync/tasks/sync_conv.js"() {
      init_task_definer();
      init_delta_algebra();
      init_mix_sync_conv();
      sync_conv_default = task_definer_default.defineSimpleTask([
        mix_sync_conv_default,
        {
          name: "sync_conv",
          applyChanges(message, flagChanges) {
            applyChanges(message.flags, flagChanges);
          }
        }
      ]);
    }
  });

  // src/backend/bodies/quotechew.js
  function indexOfDefault(string, search, startIndex, defVal) {
    var idx = string.indexOf(search, startIndex);
    if (idx === -1) {
      return defVal;
    }
    return idx;
  }
  function countNewlinesInRegion(string, startIndex, endIndex) {
    var idx = startIndex - 1, count = 0;
    for (; ; ) {
      idx = string.indexOf(NEWLINE, idx + 1);
      if (idx === -1 || idx >= endIndex) {
        return count;
      }
      count++;
    }
  }
  function quoteProcessTextBody(fullBodyText) {
    var contentRep = [];
    var line;
    function countQuoteDepthAndNormalize() {
      var count = 1;
      var lastStartOffset = 1, spaceOk = true;
      for (var i = 1; i < line.length; i++) {
        var c = line.charCodeAt(i);
        if (c === CHARCODE_GT) {
          count++;
          lastStartOffset++;
          spaceOk = true;
        } else if (c === CHARCODE_SPACE) {
          if (!spaceOk) {
            break;
          }
          lastStartOffset++;
          spaceOk = false;
        } else {
          break;
        }
      }
      if (lastStartOffset) {
        line = line.substring(lastStartOffset);
      }
      return count;
    }
    function lookBackwardsForBoilerplate(chunk) {
      var idxLineStart2, idxLineEnd2, chunkLine, idxRegionEnd = chunk.length, scanLinesLeft = MAX_BOILERPLATE_LINES, sawNonWhitespaceLine = false, lastContentLine = null, lastBoilerplateStart = null, sawProduct = false, insertAt = contentRep.length;
      function pushBoilerplate(contentType, merge) {
        var boilerChunk = chunk.substring(idxLineStart2, idxRegionEnd);
        var idxChunkEnd = idxLineStart2 - 1;
        while (chunk.charCodeAt(idxChunkEnd - 1) === CHARCODE_NEWLINE) {
          idxChunkEnd--;
        }
        var newChunk = chunk.substring(0, idxChunkEnd);
        var ate = countNewlinesInRegion(chunk, newChunk.length, idxLineStart2 - 1);
        chunk = newChunk;
        idxRegionEnd = chunk.length;
        if (!merge) {
          contentRep.splice(insertAt, 0, (ate & 255) << 8 | contentType, boilerChunk);
        } else {
          contentRep[insertAt] = (ate & 255) << 8 | contentRep[insertAt] & 255;
          contentRep[insertAt + 1] = boilerChunk + "\n" + contentRep[insertAt + 1];
        }
        sawNonWhitespaceLine = false;
        scanLinesLeft = MAX_BOILERPLATE_LINES;
        lastContentLine = null;
        lastBoilerplateStart = idxLineStart2;
      }
      for (idxLineStart2 = chunk.lastIndexOf("\n") + 1, idxLineEnd2 = chunk.length; idxLineEnd2 > 0 && scanLinesLeft; idxLineEnd2 = idxLineStart2 - 1, idxLineStart2 = chunk.lastIndexOf("\n", idxLineEnd2 - 1) + 1, scanLinesLeft--) {
        chunkLine = chunk.substring(idxLineStart2, idxLineEnd2);
        if (!chunkLine.length || chunkLine.length === 1 && chunkLine.charCodeAt(0) === CHARCODE_NBSP) {
          continue;
        }
        if (RE_SIGNATURE_LINE.test(chunkLine)) {
          if (idxLineEnd2 + 1 === lastBoilerplateStart) {
            pushBoilerplate(null, true);
          } else {
            pushBoilerplate(CT_SIGNATURE);
          }
          continue;
        }
        if (RE_SECTION_DELIM.test(chunkLine)) {
          if (lastContentLine) {
            if (RE_LEGAL_BOILER_START.test(lastContentLine)) {
              pushBoilerplate(CT_BOILERPLATE_DISCLAIMER);
              continue;
            }
            if (RE_LIST_BOILER.test(lastContentLine)) {
              pushBoilerplate(CT_BOILERPLATE_LIST_INFO);
              continue;
            }
          }
          return chunk;
        }
        if (!sawNonWhitespaceLine) {
          if (!sawProduct && RE_PRODUCT_BOILER.test(chunkLine)) {
            pushBoilerplate(CT_BOILERPLATE_PRODUCT);
            sawProduct = true;
            continue;
          }
          sawNonWhitespaceLine = true;
        }
        lastContentLine = chunkLine;
      }
      return chunk;
    }
    function pushContent(considerForBoilerplate, upToPoint2, forcePostLine) {
      if (idxRegionStart === null) {
        if (atePreLines) {
          if (contentRep.length) {
            atePreLines--;
          }
          contentRep.push((atePreLines & 255) << 8 | CT_AUTHORED_CONTENT);
          contentRep.push("");
        }
      } else {
        if (upToPoint2 === void 0) {
          upToPoint2 = idxLineStart;
        }
        var chunk = fullBodyText.substring(idxRegionStart, idxLastNonWhitespaceLineEnd);
        var atePostLines = forcePostLine ? 1 : 0;
        if (idxLastNonWhitespaceLineEnd + 1 !== upToPoint2) {
          atePostLines += countNewlinesInRegion(fullBodyText, idxLastNonWhitespaceLineEnd + 1, upToPoint2);
        }
        contentRep.push((atePreLines & 255) << 8 | (atePostLines & 255) << 16 | CT_AUTHORED_CONTENT);
        var iChunk = contentRep.push(chunk) - 1;
        if (considerForBoilerplate) {
          var newChunk = lookBackwardsForBoilerplate(chunk);
          if (chunk.length !== newChunk.length) {
            if (atePostLines) {
              var iLastMeta = contentRep.length - 2;
              contentRep[iLastMeta] = (atePostLines & 255) << 16 | contentRep[iLastMeta];
              contentRep[iChunk - 1] = (atePreLines & 255) << 8 | CT_AUTHORED_CONTENT;
            }
            if (!newChunk.length) {
              if (atePreLines) {
                var bpAte = contentRep[iChunk + 1] >> 8 & 255;
                bpAte += atePreLines;
                contentRep[iChunk + 1] = (bpAte & 255) << 8 | contentRep[iChunk + 1] & 4294902015;
              }
              contentRep.splice(iChunk - 1, 2);
            } else {
              contentRep[iChunk] = newChunk;
            }
          }
        }
      }
      atePreLines = 0;
      idxRegionStart = null;
      lastNonWhitespaceLine = null;
      idxLastNonWhitespaceLineEnd = null;
      idxPrevLastNonWhitespaceLineEnd = null;
    }
    function pushQuote(newQuoteDepth) {
      var atePostLines = 0;
      while (quoteRunLines.length && !quoteRunLines[quoteRunLines.length - 1]) {
        quoteRunLines.pop();
        atePostLines++;
      }
      contentRep.push((atePostLines & 255) << 24 | (ateQuoteLines & 255) << 16 | inQuoteDepth - 1 << 8 | CT_QUOTED_REPLY);
      contentRep.push(quoteRunLines.join("\n"));
      inQuoteDepth = newQuoteDepth;
      if (inQuoteDepth) {
        quoteRunLines = [];
      } else {
        quoteRunLines = null;
      }
      ateQuoteLines = 0;
      generatedQuoteBlock = true;
    }
    var idxLineStart, idxLineEnd, bodyLength = fullBodyText.length, idxRegionStart = null, lastNonWhitespaceLine = null, idxLastNonWhitespaceLineEnd = null, idxPrevLastNonWhitespaceLineEnd = null, inQuoteDepth = 0, quoteRunLines = null, generatedQuoteBlock = false, atePreLines = 0, ateQuoteLines = 0;
    for (idxLineStart = 0, idxLineEnd = indexOfDefault(fullBodyText, "\n", idxLineStart, fullBodyText.length); idxLineStart < bodyLength; idxLineStart = idxLineEnd + 1, idxLineEnd = indexOfDefault(fullBodyText, "\n", idxLineStart, fullBodyText.length)) {
      line = fullBodyText.substring(idxLineStart, idxLineEnd);
      if (!line.length || line.length === 1 && line.charCodeAt(0) === CHARCODE_NBSP) {
        if (inQuoteDepth) {
          pushQuote(0);
        }
        if (idxRegionStart === null) {
          atePreLines++;
        }
        continue;
      }
      if (line.charCodeAt(0) === CHARCODE_GT) {
        var lineDepth = countQuoteDepthAndNormalize();
        if (!inQuoteDepth) {
          if (lastNonWhitespaceLine && RE_WROTE_LINE.test(lastNonWhitespaceLine)) {
            var upToPoint = idxLastNonWhitespaceLineEnd;
            if (idxPrevLastNonWhitespaceLineEnd !== null) {
              var considerIndex = idxPrevLastNonWhitespaceLineEnd + 1;
              while (considerIndex < idxLastNonWhitespaceLineEnd) {
                if (fullBodyText[considerIndex++] === "\n") {
                  break;
                }
              }
              if (considerIndex === idxLastNonWhitespaceLineEnd) {
                upToPoint = fullBodyText.lastIndexOf("\n", idxPrevLastNonWhitespaceLineEnd - 1);
                lastNonWhitespaceLine = fullBodyText.substring(upToPoint + 1, idxLastNonWhitespaceLineEnd).replace(/\s*\n\s*/, " ");
                idxPrevLastNonWhitespaceLineEnd = upToPoint - 1;
                if (idxPrevLastNonWhitespaceLineEnd <= idxRegionStart) {
                  idxRegionStart = null;
                }
              }
            }
            idxLastNonWhitespaceLineEnd = idxPrevLastNonWhitespaceLineEnd;
            if (idxLastNonWhitespaceLineEnd === null) {
              idxRegionStart = null;
            }
            var leadin = lastNonWhitespaceLine;
            pushContent(!generatedQuoteBlock, upToPoint);
            var leadinNewlines = 0;
            if (upToPoint + 1 !== idxLineStart) {
              leadinNewlines = countNewlinesInRegion(fullBodyText, upToPoint + 1, idxLineStart);
            }
            contentRep.push(leadinNewlines << 8 | CT_LEADIN_TO_QUOTE);
            contentRep.push(leadin);
          } else {
            pushContent(!generatedQuoteBlock);
          }
          quoteRunLines = [];
          inQuoteDepth = lineDepth;
        } else if (lineDepth !== inQuoteDepth) {
          pushQuote(lineDepth);
        }
        if (quoteRunLines.length || line.length) {
          quoteRunLines.push(line);
        } else {
          ateQuoteLines++;
        }
      } else {
        if (inQuoteDepth) {
          pushQuote(0);
          idxLastNonWhitespaceLineEnd = null;
        }
        if (idxRegionStart === null) {
          idxRegionStart = idxLineStart;
        }
        lastNonWhitespaceLine = line;
        idxPrevLastNonWhitespaceLineEnd = idxLastNonWhitespaceLineEnd;
        idxLastNonWhitespaceLineEnd = idxLineEnd;
      }
    }
    if (inQuoteDepth) {
      pushQuote(0);
    } else {
      pushContent(true, fullBodyText.length, fullBodyText.charCodeAt(fullBodyText.length - 1) === CHARCODE_NEWLINE);
    }
    return contentRep;
  }
  function generateSnippet(rep, desiredLength) {
    for (var i = 0; i < rep.length; i += 2) {
      var etype = rep[i] & 15, block = rep[i + 1];
      switch (etype) {
        case CT_AUTHORED_CONTENT:
          if (!block.length) {
            break;
          }
          if (block.length < desiredLength) {
            return block.trim().replace(RE_NORMALIZE_WHITESPACE, " ");
          }
          var idxPrevSpace = block.lastIndexOf(" ", desiredLength);
          if (desiredLength - idxPrevSpace < MAX_WORD_SHRINK) {
            return block.substring(0, idxPrevSpace).trim().replace(RE_NORMALIZE_WHITESPACE, " ");
          }
          return block.substring(0, desiredLength).trim().replace(RE_NORMALIZE_WHITESPACE, " ");
        default:
          break;
      }
    }
    return "";
  }
  function expandQuotedPrefix(s, depth) {
    if (s.charCodeAt(0) === CHARCODE_NEWLINE) {
      return replyQuotePrefixStringsNoSpace[depth];
    }
    return replyQuotePrefixStrings[depth];
  }
  function expandQuoted(s, depth) {
    var ws = replyQuoteNewlineReplaceStrings[depth], nows = replyQuoteNewlineReplaceStringsNoSpace[depth];
    return s.replace(RE_NEWLINE, function(m, idx) {
      if (s.charCodeAt(idx + 1) === CHARCODE_NEWLINE) {
        return nows;
      }
      return ws;
    });
  }
  function generateReplyText(rep) {
    var strBits = [];
    var lastContentDepth = null;
    var suppressWhitespaceBlankLine = false;
    for (var i = 0; i < rep.length; i += 2) {
      var etype = rep[i] & 15, block = rep[i + 1];
      switch (etype) {
        default:
        case CT_AUTHORED_CONTENT:
        case CT_SIGNATURE:
        case CT_LEADIN_TO_QUOTE:
          if (block.length) {
            if (lastContentDepth !== null) {
              strBits.push(NEWLINE);
              if (!suppressWhitespaceBlankLine) {
                strBits.push(replyQuoteBlankLine[lastContentDepth]);
              }
            }
            strBits.push(expandQuotedPrefix(block, 0));
            strBits.push(expandQuoted(block, 0));
            lastContentDepth = 1;
            suppressWhitespaceBlankLine = etype === CT_LEADIN_TO_QUOTE;
          }
          break;
        case CT_QUOTED_TYPE:
          if (i) {
            strBits.push(NEWLINE);
          }
          var depth = (rep[i] >> 8 & 255) + 1;
          if (depth < MAX_QUOTE_REPEAT_DEPTH) {
            if (lastContentDepth !== null) {
              strBits.push(NEWLINE);
              if (!suppressWhitespaceBlankLine) {
                strBits.push(replyQuoteBlankLine[lastContentDepth]);
              }
            }
            strBits.push(expandQuotedPrefix(block, depth));
            strBits.push(expandQuoted(block, depth));
            lastContentDepth = depth;
            suppressWhitespaceBlankLine = RE_REPLY_LAST_LINE_IN_BLOCK_CONTAINS_WROTE.test(block);
          }
          break;
        case CT_BOILERPLATE_DISCLAIMER:
        case CT_BOILERPLATE_LIST_INFO:
        case CT_BOILERPLATE_PRODUCT:
        case CT_BOILERPLATE_ADS:
          break;
      }
    }
    return strBits.join("");
  }
  function generateForwardBodyText(rep) {
    var strBits = [], nl;
    for (var i = 0; i < rep.length; i += 2) {
      if (i) {
        strBits.push(NEWLINE);
      }
      var etype = rep[i] & 15, block = rep[i + 1];
      switch (etype) {
        default:
        case CT_AUTHORED_CONTENT:
          for (nl = rep[i] >> 8 & 255; nl; nl--) {
            strBits.push(NEWLINE);
          }
          strBits.push(block);
          for (nl = rep[i] >> 16 & 255; nl; nl--) {
            strBits.push(NEWLINE);
          }
          break;
        case CT_LEADIN_TO_QUOTE:
          strBits.push(block);
          for (nl = rep[i] >> 8 & 255; nl; nl--) {
            strBits.push(NEWLINE);
          }
          break;
        case CT_SIGNATURE:
        case CT_BOILERPLATE_DISCLAIMER:
        case CT_BOILERPLATE_LIST_INFO:
        case CT_BOILERPLATE_PRODUCT:
        case CT_BOILERPLATE_ADS:
          for (nl = rep[i] >> 8 & 255; nl; nl--) {
            strBits.push(NEWLINE);
          }
          strBits.push(block);
          for (nl = rep[i] >> 16 & 255; nl; nl--) {
            strBits.push(NEWLINE);
          }
          break;
        case CT_QUOTED_TYPE:
          var depth = Math.min(rep[i] >> 8 & 255, 8);
          for (nl = rep[i] >> 16 & 255; nl; nl--) {
            strBits.push(replyQuotePrefixStringsNoSpace[depth]);
            strBits.push(NEWLINE);
          }
          strBits.push(expandQuotedPrefix(block, depth));
          strBits.push(expandQuoted(block, depth));
          for (nl = rep[i] >> 24 & 255; nl; nl--) {
            strBits.push(NEWLINE);
            strBits.push(replyQuotePrefixStringsNoSpace[depth]);
          }
          break;
      }
    }
    return strBits.join("");
  }
  function estimateAuthoredBodySize(bodyRep) {
    let authoredBodySize = 0;
    for (var iRep = 0; iRep < bodyRep.length; iRep += 2) {
      var etype = bodyRep[iRep] & 15, block = bodyRep[iRep + 1];
      if (etype !== CT_AUTHORED_CONTENT) {
        continue;
      }
      authoredBodySize += block.length;
    }
    return authoredBodySize;
  }
  var CT_AUTHORED_CONTENT, CT_SIGNATURE, CT_LEADIN_TO_QUOTE, CT_QUOTED_TYPE, CT_QUOTED_REPLY, CT_BOILERPLATE_DISCLAIMER, CT_BOILERPLATE_LIST_INFO, CT_BOILERPLATE_PRODUCT, CT_BOILERPLATE_ADS, CHARCODE_GT, CHARCODE_SPACE, CHARCODE_NBSP, CHARCODE_NEWLINE, RE_SECTION_DELIM, RE_LIST_BOILER, RE_WROTE_LINE, RE_REPLY_LAST_LINE_IN_BLOCK_CONTAINS_WROTE, RE_SIGNATURE_LINE, MAX_BOILERPLATE_LINES, RE_PRODUCT_BOILER, RE_LEGAL_BOILER_START, NEWLINE, RE_NEWLINE, MAX_WORD_SHRINK, RE_NORMALIZE_WHITESPACE, MAX_QUOTE_REPEAT_DEPTH, replyQuotePrefixStrings, replyQuotePrefixStringsNoSpace, replyQuoteNewlineReplaceStrings, replyQuoteNewlineReplaceStringsNoSpace, replyQuoteBlankLine;
  var init_quotechew = __esm({
    "src/backend/bodies/quotechew.js"() {
      CT_AUTHORED_CONTENT = 1;
      CT_SIGNATURE = 2;
      CT_LEADIN_TO_QUOTE = 3;
      CT_QUOTED_TYPE = 4;
      CT_QUOTED_REPLY = 20;
      CT_BOILERPLATE_DISCLAIMER = 5;
      CT_BOILERPLATE_LIST_INFO = 6;
      CT_BOILERPLATE_PRODUCT = 7;
      CT_BOILERPLATE_ADS = 8;
      CHARCODE_GT = ">".charCodeAt(0);
      CHARCODE_SPACE = " ".charCodeAt(0);
      CHARCODE_NBSP = "\xA0".charCodeAt(0);
      CHARCODE_NEWLINE = "\n".charCodeAt(0);
      RE_SECTION_DELIM = /^[_-]{6,}$/;
      RE_LIST_BOILER = /mailing list$/;
      RE_WROTE_LINE = /wrote/;
      RE_REPLY_LAST_LINE_IN_BLOCK_CONTAINS_WROTE = /wrote[^\n]+$/;
      RE_SIGNATURE_LINE = /^-- $/;
      MAX_BOILERPLATE_LINES = 20;
      RE_PRODUCT_BOILER = /^(?:Sent from (?:Mobile|my .+))$/;
      RE_LEGAL_BOILER_START = /^(?:This message|Este mensaje)/;
      NEWLINE = "\n";
      RE_NEWLINE = /\n/g;
      MAX_WORD_SHRINK = 8;
      RE_NORMALIZE_WHITESPACE = /\s+/g;
      MAX_QUOTE_REPEAT_DEPTH = 5;
      replyQuotePrefixStrings = [
        "> ",
        ">> ",
        ">>> ",
        ">>>> ",
        ">>>>> ",
        ">>>>>> ",
        ">>>>>>> ",
        ">>>>>>>> ",
        ">>>>>>>>> "
      ];
      replyQuotePrefixStringsNoSpace = [
        ">",
        ">>",
        ">>>",
        ">>>>",
        ">>>>>",
        ">>>>>>",
        ">>>>>>>",
        ">>>>>>>>",
        ">>>>>>>>>"
      ];
      replyQuoteNewlineReplaceStrings = [
        "\n> ",
        "\n>> ",
        "\n>>> ",
        "\n>>>> ",
        "\n>>>>> ",
        "\n>>>>>> ",
        "\n>>>>>>> ",
        "\n>>>>>>>> "
      ];
      replyQuoteNewlineReplaceStringsNoSpace = [
        "\n>",
        "\n>>",
        "\n>>>",
        "\n>>>>",
        "\n>>>>>",
        "\n>>>>>>",
        "\n>>>>>>>",
        "\n>>>>>>>>"
      ];
      replyQuoteBlankLine = [
        "\n",
        ">\n",
        ">>\n",
        ">>>\n",
        ">>>>\n",
        ">>>>>\n",
        ">>>>>>\n",
        ">>>>>>>\n",
        ">>>>>>>>\n"
      ];
    }
  });

  // src/vendor/bleach/bleach/css-parser/tokenizer.js
  var require_tokenizer = __commonJS({
    "src/vendor/bleach/bleach/css-parser/tokenizer.js"(exports) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define(["exports"], factory);
        } else if (typeof exports !== "undefined") {
          factory(exports);
        } else {
          factory(root);
        }
      })(exports, function(exports2) {
        var between = function(num, first, last) {
          return num >= first && num <= last;
        };
        function digit(code) {
          return between(code, 48, 57);
        }
        function hexdigit(code) {
          return digit(code) || between(code, 65, 70) || between(code, 97, 102);
        }
        function uppercaseletter(code) {
          return between(code, 65, 90);
        }
        function lowercaseletter(code) {
          return between(code, 97, 122);
        }
        function letter(code) {
          return uppercaseletter(code) || lowercaseletter(code);
        }
        function nonascii(code) {
          return code >= 160;
        }
        function namestartchar(code) {
          return letter(code) || nonascii(code) || code == 95;
        }
        function namechar(code) {
          return namestartchar(code) || digit(code) || code == 45;
        }
        function nonprintable(code) {
          return between(code, 0, 8) || between(code, 14, 31) || between(code, 127, 159);
        }
        function newline(code) {
          return code == 10 || code == 12;
        }
        function whitespace(code) {
          return newline(code) || code == 9 || code == 32;
        }
        function badescape(code) {
          return newline(code) || isNaN(code);
        }
        var maximumallowedcodepoint = 1114111;
        function tokenize(str, options) {
          if (options == void 0)
            options = { transformFunctionWhitespace: false, scientificNotation: false };
          var i = -1;
          var tokens = [];
          var state = "data";
          var code;
          var currtoken;
          var line = 0;
          var column = 0;
          var lastLineLength = 0;
          var incrLineno = function() {
            line += 1;
            lastLineLength = column;
            column = 0;
          };
          var locStart = { line, column };
          var next = function(num) {
            if (num === void 0)
              num = 1;
            return str.charCodeAt(i + num);
          };
          var consume = function(num) {
            if (num === void 0)
              num = 1;
            i += num;
            code = str.charCodeAt(i);
            if (newline(code))
              incrLineno();
            else
              column += num;
            return true;
          };
          var reconsume = function() {
            i -= 1;
            if (newline(code)) {
              line -= 1;
              column = lastLineLength;
            } else {
              column -= 1;
            }
            locStart.line = line;
            locStart.column = column;
            return true;
          };
          var eof = function() {
            return i >= str.length;
          };
          var donothing = function() {
          };
          var emit = function(token) {
            if (token) {
              token.finish();
            } else {
              token = currtoken.finish();
            }
            if (options.loc === true) {
              token.loc = {};
              token.loc.start = { line: locStart.line, column: locStart.column, idx: locStart.idx };
              locStart = { line, column, idx: i };
              token.loc.end = locStart;
            }
            tokens.push(token);
            currtoken = void 0;
            return true;
          };
          var create = function(token) {
            currtoken = token;
            return true;
          };
          var parseerror = function() {
            return true;
          };
          var catchfire = function(msg) {
            return true;
          };
          var switchto = function(newstate) {
            state = newstate;
            return true;
          };
          var consumeEscape = function() {
            consume();
            if (hexdigit(code)) {
              var digits = [];
              for (var total2 = 0; total2 < 6; total2++) {
                if (hexdigit(code)) {
                  digits.push(code);
                  consume();
                } else {
                  break;
                }
              }
              var value = parseInt(digits.map(String.fromCharCode).join(""), 16);
              if (value > maximumallowedcodepoint)
                value = 65533;
              if (!whitespace(code))
                reconsume();
              return value;
            } else {
              return code;
            }
          };
          for (; ; ) {
            if (i > str.length * 2)
              return "I'm infinite-looping!";
            consume();
            switch (state) {
              case "data":
                if (whitespace(code)) {
                  emit(new WhitespaceToken());
                  while (whitespace(next()))
                    consume();
                } else if (code == 34)
                  switchto("double-quote-string");
                else if (code == 35)
                  switchto("hash");
                else if (code == 39)
                  switchto("single-quote-string");
                else if (code == 40)
                  emit(new OpenParenToken());
                else if (code == 41)
                  emit(new CloseParenToken());
                else if (code == 43) {
                  if (digit(next()) || next() == 46 && digit(next(2)))
                    switchto("number") && reconsume();
                  else
                    emit(new DelimToken(code));
                } else if (code == 45) {
                  if (next(1) == 45 && next(2) == 62)
                    consume(2) && emit(new CDCToken());
                  else if (digit(next()) || next(1) == 46 && digit(next(2)))
                    switchto("number") && reconsume();
                  else
                    switchto("ident") && reconsume();
                } else if (code == 46) {
                  if (digit(next()))
                    switchto("number") && reconsume();
                  else
                    emit(new DelimToken(code));
                } else if (code == 47) {
                  if (next() == 42)
                    consume() && switchto("comment");
                  else
                    emit(new DelimToken(code));
                } else if (code == 58)
                  emit(new ColonToken());
                else if (code == 59)
                  emit(new SemicolonToken());
                else if (code == 60) {
                  if (next(1) == 33 && next(2) == 45 && next(3) == 45)
                    consume(3) && emit(new CDOToken());
                  else
                    emit(new DelimToken(code));
                } else if (code == 64)
                  switchto("at-keyword");
                else if (code == 91)
                  emit(new OpenSquareToken());
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && emit(new DelimToken(code));
                  else
                    switchto("ident") && reconsume();
                } else if (code == 93)
                  emit(new CloseSquareToken());
                else if (code == 123)
                  emit(new OpenCurlyToken());
                else if (code == 125)
                  emit(new CloseCurlyToken());
                else if (digit(code))
                  switchto("number") && reconsume();
                else if (code == 85 || code == 117) {
                  if (next(1) == 43 && hexdigit(next(2)))
                    consume() && switchto("unicode-range");
                  else
                    switchto("ident") && reconsume();
                } else if (namestartchar(code))
                  switchto("ident") && reconsume();
                else if (eof()) {
                  emit(new EOFToken2());
                  return tokens;
                } else
                  emit(new DelimToken(code));
                break;
              case "double-quote-string":
                if (currtoken == void 0)
                  create(new StringToken());
                if (code == 34)
                  emit() && switchto("data");
                else if (eof())
                  parseerror() && emit() && switchto("data") && reconsume();
                else if (newline(code))
                  parseerror() && emit(new BadStringToken()) && switchto("data") && reconsume();
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && emit(new BadStringToken()) && switchto("data");
                  else if (newline(next()))
                    consume();
                  else
                    currtoken.append(consumeEscape());
                } else
                  currtoken.append(code);
                break;
              case "single-quote-string":
                if (currtoken == void 0)
                  create(new StringToken());
                if (code == 39)
                  emit() && switchto("data");
                else if (eof())
                  parseerror() && emit() && switchto("data");
                else if (newline(code))
                  parseerror() && emit(new BadStringToken()) && switchto("data") && reconsume();
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && emit(new BadStringToken()) && switchto("data");
                  else if (newline(next()))
                    consume();
                  else
                    currtoken.append(consumeEscape());
                } else
                  currtoken.append(code);
                break;
              case "hash":
                if (namechar(code))
                  create(new HashToken(code)) && switchto("hash-rest");
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && emit(new DelimToken(35)) && switchto("data") && reconsume();
                  else
                    create(new HashToken(consumeEscape())) && switchto("hash-rest");
                } else
                  emit(new DelimToken(35)) && switchto("data") && reconsume();
                break;
              case "hash-rest":
                if (namechar(code))
                  currtoken.append(code);
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && emit() && switchto("data") && reconsume();
                  else
                    currtoken.append(consumeEscape());
                } else
                  emit() && switchto("data") && reconsume();
                break;
              case "comment":
                if (code == 42) {
                  if (next() == 47)
                    consume() && switchto("data");
                  else
                    donothing();
                } else if (eof())
                  parseerror() && switchto("data") && reconsume();
                else
                  donothing();
                break;
              case "at-keyword":
                if (code == 45) {
                  if (namestartchar(next()))
                    create(new AtKeywordToken(45)) && switchto("at-keyword-rest");
                  else if (next(1) == 92 && !badescape(next(2)))
                    create(new AtKeywordtoken(45)) && switchto("at-keyword-rest");
                  else
                    parseerror() && emit(new DelimToken(64)) && switchto("data") && reconsume();
                } else if (namestartchar(code))
                  create(new AtKeywordToken(code)) && switchto("at-keyword-rest");
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && emit(new DelimToken(35)) && switchto("data") && reconsume();
                  else
                    create(new AtKeywordToken(consumeEscape())) && switchto("at-keyword-rest");
                } else
                  emit(new DelimToken(64)) && switchto("data") && reconsume();
                break;
              case "at-keyword-rest":
                if (namechar(code))
                  currtoken.append(code);
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && emit() && switchto("data") && reconsume();
                  else
                    currtoken.append(consumeEscape());
                } else
                  emit() && switchto("data") && reconsume();
                break;
              case "ident":
                if (code == 45) {
                  if (namestartchar(next()))
                    create(new IdentifierToken(code)) && switchto("ident-rest");
                  else if (next(1) == 92 && !badescape(next(2)))
                    create(new IdentifierToken(code)) && switchto("ident-rest");
                  else
                    emit(new DelimToken(45)) && switchto("data");
                } else if (namestartchar(code))
                  create(new IdentifierToken(code)) && switchto("ident-rest");
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && switchto("data") && reconsume();
                  else
                    create(new IdentifierToken(consumeEscape())) && switchto("ident-rest");
                } else
                  catchfire("Hit the generic 'else' clause in ident state.") && switchto("data") && reconsume();
                break;
              case "ident-rest":
                if (namechar(code))
                  currtoken.append(code);
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && emit() && switchto("data") && reconsume();
                  else
                    currtoken.append(consumeEscape());
                } else if (code == 40) {
                  if (currtoken.ASCIImatch("url"))
                    switchto("url");
                  else
                    emit(new FunctionToken(currtoken)) && switchto("data");
                } else if (whitespace(code) && options.transformFunctionWhitespace)
                  switchto("transform-function-whitespace") && reconsume();
                else
                  emit() && switchto("data") && reconsume();
                break;
              case "transform-function-whitespace":
                if (whitespace(next()))
                  donothing();
                else if (code == 40)
                  emit(new FunctionToken(currtoken)) && switchto("data");
                else
                  emit() && switchto("data") && reconsume();
                break;
              case "number":
                create(new NumberToken());
                if (code == 45) {
                  if (digit(next()))
                    consume() && currtoken.append([45, code]) && switchto("number-rest");
                  else if (next(1) == 46 && digit(next(2)))
                    consume(2) && currtoken.append([45, 46, code]) && switchto("number-fraction");
                  else
                    switchto("data") && reconsume();
                } else if (code == 43) {
                  if (digit(next()))
                    consume() && currtoken.append([43, code]) && switchto("number-rest");
                  else if (next(1) == 46 && digit(next(2)))
                    consume(2) && currtoken.append([43, 46, code]) && switchto("number-fraction");
                  else
                    switchto("data") && reconsume();
                } else if (digit(code))
                  currtoken.append(code) && switchto("number-rest");
                else if (code == 46) {
                  if (digit(next()))
                    consume() && currtoken.append([46, code]) && switchto("number-fraction");
                  else
                    switchto("data") && reconsume();
                } else
                  switchto("data") && reconsume();
                break;
              case "number-rest":
                if (digit(code))
                  currtoken.append(code);
                else if (code == 46) {
                  if (digit(next()))
                    consume() && currtoken.append([46, code]) && switchto("number-fraction");
                  else
                    emit() && switchto("data") && reconsume();
                } else if (code == 37)
                  emit(new PercentageToken(currtoken)) && switchto("data");
                else if (code == 69 || code == 101) {
                  if (digit(next()))
                    consume() && currtoken.append([37, code]) && switchto("sci-notation");
                  else if ((next(1) == 43 || next(1) == 45) && digit(next(2)))
                    currtoken.append([37, next(1), next(2)]) && consume(2) && switchto("sci-notation");
                  else
                    create(new DimensionToken(currtoken, code)) && switchto("dimension");
                } else if (code == 45) {
                  if (namestartchar(next()))
                    consume() && create(new DimensionToken(currtoken, [45, code])) && switchto("dimension");
                  else if (next(1) == 92 && badescape(next(2)))
                    parseerror() && emit() && switchto("data") && reconsume();
                  else if (next(1) == 92)
                    consume() && create(new DimensionToken(currtoken, [45, consumeEscape()])) && switchto("dimension");
                  else
                    emit() && switchto("data") && reconsume();
                } else if (namestartchar(code))
                  create(new DimensionToken(currtoken, code)) && switchto("dimension");
                else if (code == 92) {
                  if (badescape(next))
                    parseerror() && emit() && switchto("data") && reconsume();
                  else
                    create(new DimensionToken(currtoken, consumeEscape)) && switchto("dimension");
                } else
                  emit() && switchto("data") && reconsume();
                break;
              case "number-fraction":
                currtoken.type = "number";
                if (digit(code))
                  currtoken.append(code);
                else if (code == 37)
                  emit(new PercentageToken(currtoken)) && switchto("data");
                else if (code == 69 || code == 101) {
                  if (digit(next()))
                    consume() && currtoken.append([101, code]) && switchto("sci-notation");
                  else if ((next(1) == 43 || next(1) == 45) && digit(next(2)))
                    currtoken.append([101, next(1), next(2)]) && consume(2) && switchto("sci-notation");
                  else
                    create(new DimensionToken(currtoken, code)) && switchto("dimension");
                } else if (code == 45) {
                  if (namestartchar(next()))
                    consume() && create(new DimensionToken(currtoken, [45, code])) && switchto("dimension");
                  else if (next(1) == 92 && badescape(next(2)))
                    parseerror() && emit() && switchto("data") && reconsume();
                  else if (next(1) == 92)
                    consume() && create(new DimensionToken(currtoken, [45, consumeEscape()])) && switchto("dimension");
                  else
                    emit() && switchto("data") && reconsume();
                } else if (namestartchar(code))
                  create(new DimensionToken(currtoken, code)) && switchto("dimension");
                else if (code == 92) {
                  if (badescape(next))
                    parseerror() && emit() && switchto("data") && reconsume();
                  else
                    create(new DimensionToken(currtoken, consumeEscape())) && switchto("dimension");
                } else
                  emit() && switchto("data") && reconsume();
                break;
              case "dimension":
                if (namechar(code))
                  currtoken.append(code);
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && emit() && switchto("data") && reconsume();
                  else
                    currtoken.append(consumeEscape());
                } else
                  emit() && switchto("data") && reconsume();
                break;
              case "sci-notation":
                currtoken.type = "number";
                if (digit(code))
                  currtoken.append(code);
                else
                  emit() && switchto("data") && reconsume();
                break;
              case "url":
                if (eof())
                  parseerror() && emit(new BadURLToken()) && switchto("data");
                else if (code == 34)
                  switchto("url-double-quote");
                else if (code == 39)
                  switchto("url-single-quote");
                else if (code == 41)
                  emit(new URLToken()) && switchto("data");
                else if (whitespace(code))
                  donothing();
                else
                  switchto("url-unquoted") && reconsume();
                break;
              case "url-double-quote":
                if (!(currtoken instanceof URLToken))
                  create(new URLToken());
                if (eof())
                  parseerror() && emit(new BadURLToken()) && switchto("data");
                else if (code == 34)
                  switchto("url-end");
                else if (newline(code))
                  parseerror() && switchto("bad-url");
                else if (code == 92) {
                  if (newline(next()))
                    consume();
                  else if (badescape(next()))
                    parseerror() && emit(new BadURLToken()) && switchto("data") && reconsume();
                  else
                    currtoken.append(consumeEscape());
                } else
                  currtoken.append(code);
                break;
              case "url-single-quote":
                if (!(currtoken instanceof URLToken))
                  create(new URLToken());
                if (eof())
                  parseerror() && emit(new BadURLToken()) && switchto("data");
                else if (code == 39)
                  switchto("url-end");
                else if (newline(code))
                  parseerror() && switchto("bad-url");
                else if (code == 92) {
                  if (newline(next()))
                    consume();
                  else if (badescape(next()))
                    parseerror() && emit(new BadURLToken()) && switchto("data") && reconsume();
                  else
                    currtoken.append(consumeEscape());
                } else
                  currtoken.append(code);
                break;
              case "url-end":
                if (eof())
                  parseerror() && emit(new BadURLToken()) && switchto("data");
                else if (whitespace(code))
                  donothing();
                else if (code == 41)
                  emit() && switchto("data");
                else
                  parseerror() && switchto("bad-url") && reconsume();
                break;
              case "url-unquoted":
                if (!(currtoken instanceof URLToken))
                  create(new URLToken());
                if (eof())
                  parseerror() && emit(new BadURLToken()) && switchto("data");
                else if (whitespace(code))
                  switchto("url-end");
                else if (code == 41)
                  emit() && switchto("data");
                else if (code == 34 || code == 39 || code == 40 || nonprintable(code))
                  parseerror() && switchto("bad-url");
                else if (code == 92) {
                  if (badescape(next()))
                    parseerror() && switchto("bad-url");
                  else
                    currtoken.append(consumeEscape());
                } else
                  currtoken.append(code);
                break;
              case "bad-url":
                if (eof())
                  parseerror() && emit(new BadURLToken()) && switchto("data");
                else if (code == 41)
                  emit(new BadURLToken()) && switchto("data");
                else if (code == 92) {
                  if (badescape(next()))
                    donothing();
                  else
                    consumeEscape();
                } else
                  donothing();
                break;
              case "unicode-range":
                var start = [code], end = [code];
                for (var total = 1; total < 6; total++) {
                  if (hexdigit(next())) {
                    consume();
                    start.push(code);
                    end.push(code);
                  } else
                    break;
                }
                if (next() == 63) {
                  for (; total < 6; total++) {
                    if (next() == 63) {
                      consume();
                      start.push("0".charCodeAt(0));
                      end.push("f".charCodeAt(0));
                    } else
                      break;
                  }
                  emit(new UnicodeRangeToken(start, end)) && switchto("data");
                } else if (next(1) == 45 && hexdigit(next(2))) {
                  consume();
                  consume();
                  end = [code];
                  for (var total = 1; total < 6; total++) {
                    if (hexdigit(next())) {
                      consume();
                      end.push(code);
                    } else
                      break;
                  }
                  emit(new UnicodeRangeToken(start, end)) && switchto("data");
                } else
                  emit(new UnicodeRangeToken(start)) && switchto("data");
                break;
              default:
                catchfire("Unknown state '" + state + "'");
            }
          }
        }
        function stringFromCodeArray(arr) {
          return String.fromCharCode.apply(null, arr.filter(function(e) {
            return e;
          }));
        }
        function CSSParserToken(options) {
          return this;
        }
        CSSParserToken.prototype.finish = function() {
          return this;
        };
        CSSParserToken.prototype.toString = function() {
          return this.tokenType;
        };
        CSSParserToken.prototype.toJSON = function() {
          return this.toString();
        };
        function BadStringToken() {
          return this;
        }
        BadStringToken.prototype = new CSSParserToken();
        BadStringToken.prototype.tokenType = "BADSTRING";
        function BadURLToken() {
          return this;
        }
        BadURLToken.prototype = new CSSParserToken();
        BadURLToken.prototype.tokenType = "BADURL";
        function WhitespaceToken() {
          return this;
        }
        WhitespaceToken.prototype = new CSSParserToken();
        WhitespaceToken.prototype.tokenType = "WHITESPACE";
        WhitespaceToken.prototype.toString = function() {
          return "WS";
        };
        function CDOToken() {
          return this;
        }
        CDOToken.prototype = new CSSParserToken();
        CDOToken.prototype.tokenType = "CDO";
        function CDCToken() {
          return this;
        }
        CDCToken.prototype = new CSSParserToken();
        CDCToken.prototype.tokenType = "CDC";
        function ColonToken() {
          return this;
        }
        ColonToken.prototype = new CSSParserToken();
        ColonToken.prototype.tokenType = ":";
        function SemicolonToken() {
          return this;
        }
        SemicolonToken.prototype = new CSSParserToken();
        SemicolonToken.prototype.tokenType = ";";
        function OpenCurlyToken() {
          return this;
        }
        OpenCurlyToken.prototype = new CSSParserToken();
        OpenCurlyToken.prototype.tokenType = "{";
        function CloseCurlyToken() {
          return this;
        }
        CloseCurlyToken.prototype = new CSSParserToken();
        CloseCurlyToken.prototype.tokenType = "}";
        function OpenSquareToken() {
          return this;
        }
        OpenSquareToken.prototype = new CSSParserToken();
        OpenSquareToken.prototype.tokenType = "[";
        function CloseSquareToken() {
          return this;
        }
        CloseSquareToken.prototype = new CSSParserToken();
        CloseSquareToken.prototype.tokenType = "]";
        function OpenParenToken() {
          return this;
        }
        OpenParenToken.prototype = new CSSParserToken();
        OpenParenToken.prototype.tokenType = "(";
        function CloseParenToken() {
          return this;
        }
        CloseParenToken.prototype = new CSSParserToken();
        CloseParenToken.prototype.tokenType = ")";
        function EOFToken2() {
          return this;
        }
        EOFToken2.prototype = new CSSParserToken();
        EOFToken2.prototype.tokenType = "EOF";
        function DelimToken(code) {
          this.value = String.fromCharCode(code);
          return this;
        }
        DelimToken.prototype = new CSSParserToken();
        DelimToken.prototype.tokenType = "DELIM";
        DelimToken.prototype.toString = function() {
          return "DELIM(" + this.value + ")";
        };
        function StringValuedToken() {
          return this;
        }
        StringValuedToken.prototype = new CSSParserToken();
        StringValuedToken.prototype.append = function(val) {
          if (val instanceof Array) {
            for (var i = 0; i < val.length; i++) {
              this.value.push(val[i]);
            }
          } else {
            this.value.push(val);
          }
          return true;
        };
        StringValuedToken.prototype.finish = function() {
          this.value = this.valueAsString();
          return this;
        };
        StringValuedToken.prototype.ASCIImatch = function(str) {
          return this.valueAsString().toLowerCase() == str.toLowerCase();
        };
        StringValuedToken.prototype.valueAsString = function() {
          if (typeof this.value == "string")
            return this.value;
          return stringFromCodeArray(this.value);
        };
        StringValuedToken.prototype.valueAsCodes = function() {
          if (typeof this.value == "string") {
            var ret = [];
            for (var i = 0; i < this.value.length; i++)
              ret.push(this.value.charCodeAt(i));
            return ret;
          }
          return this.value.filter(function(e) {
            return e;
          });
        };
        function IdentifierToken(val) {
          this.value = [];
          this.append(val);
        }
        IdentifierToken.prototype = new StringValuedToken();
        IdentifierToken.prototype.tokenType = "IDENT";
        IdentifierToken.prototype.toString = function() {
          return "IDENT(" + this.value + ")";
        };
        function FunctionToken(val) {
          this.value = val.finish().value;
        }
        FunctionToken.prototype = new StringValuedToken();
        FunctionToken.prototype.tokenType = "FUNCTION";
        FunctionToken.prototype.toString = function() {
          return "FUNCTION(" + this.value + ")";
        };
        function AtKeywordToken(val) {
          this.value = [];
          this.append(val);
        }
        AtKeywordToken.prototype = new StringValuedToken();
        AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
        AtKeywordToken.prototype.toString = function() {
          return "AT(" + this.value + ")";
        };
        function HashToken(val) {
          this.value = [];
          this.append(val);
        }
        HashToken.prototype = new StringValuedToken();
        HashToken.prototype.tokenType = "HASH";
        HashToken.prototype.toString = function() {
          return "HASH(" + this.value + ")";
        };
        function StringToken(val) {
          this.value = [];
          this.append(val);
        }
        StringToken.prototype = new StringValuedToken();
        StringToken.prototype.tokenType = "STRING";
        StringToken.prototype.toString = function() {
          return '"' + this.value + '"';
        };
        function URLToken(val) {
          this.value = [];
          this.append(val);
        }
        URLToken.prototype = new StringValuedToken();
        URLToken.prototype.tokenType = "URL";
        URLToken.prototype.toString = function() {
          return "URL(" + this.value + ")";
        };
        function NumberToken(val) {
          this.value = [];
          this.append(val);
          this.type = "integer";
        }
        NumberToken.prototype = new StringValuedToken();
        NumberToken.prototype.tokenType = "NUMBER";
        NumberToken.prototype.toString = function() {
          if (this.type == "integer")
            return "INT(" + this.value + ")";
          return "NUMBER(" + this.value + ")";
        };
        NumberToken.prototype.finish = function() {
          this.repr = this.valueAsString();
          this.value = this.repr * 1;
          if (Math.abs(this.value) % 1 != 0)
            this.type = "number";
          return this;
        };
        function PercentageToken(val) {
          val.finish();
          this.value = val.value;
          this.repr = val.repr;
        }
        PercentageToken.prototype = new CSSParserToken();
        PercentageToken.prototype.tokenType = "PERCENTAGE";
        PercentageToken.prototype.toString = function() {
          return "PERCENTAGE(" + this.value + ")";
        };
        function DimensionToken(val, unit) {
          val.finish();
          this.num = val.value;
          this.unit = [];
          this.repr = val.repr;
          this.append(unit);
        }
        DimensionToken.prototype = new CSSParserToken();
        DimensionToken.prototype.tokenType = "DIMENSION";
        DimensionToken.prototype.toString = function() {
          return "DIM(" + this.num + "," + this.unit + ")";
        };
        DimensionToken.prototype.append = function(val) {
          if (val instanceof Array) {
            for (var i = 0; i < val.length; i++) {
              this.unit.push(val[i]);
            }
          } else {
            this.unit.push(val);
          }
          return true;
        };
        DimensionToken.prototype.finish = function() {
          this.unit = stringFromCodeArray(this.unit);
          this.repr += this.unit;
          return this;
        };
        function UnicodeRangeToken(start, end) {
          start = parseInt(stringFromCodeArray(start), 16);
          if (end === void 0)
            end = start + 1;
          else
            end = parseInt(stringFromCodeArray(end), 16);
          if (start > maximumallowedcodepoint)
            end = start;
          if (end < start)
            end = start;
          if (end > maximumallowedcodepoint)
            end = maximumallowedcodepoint;
          this.start = start;
          this.end = end;
          return this;
        }
        UnicodeRangeToken.prototype = new CSSParserToken();
        UnicodeRangeToken.prototype.tokenType = "UNICODE-RANGE";
        UnicodeRangeToken.prototype.toString = function() {
          if (this.start + 1 == this.end)
            return "UNICODE-RANGE(" + this.start.toString(16).toUpperCase() + ")";
          if (this.start < this.end)
            return "UNICODE-RANGE(" + this.start.toString(16).toUpperCase() + "-" + this.end.toString(16).toUpperCase() + ")";
          return "UNICODE-RANGE()";
        };
        UnicodeRangeToken.prototype.contains = function(code) {
          return code >= this.start && code < this.end;
        };
        exports2.tokenize = tokenize;
        exports2.EOFToken = EOFToken2;
      });
    }
  });

  // src/vendor/bleach/bleach/css-parser/parser.js
  var require_parser = __commonJS({
    "src/vendor/bleach/bleach/css-parser/parser.js"(exports) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define(["exports", "./tokenizer"], factory);
        } else if (typeof exports !== "undefined") {
          factory(exports, require_tokenizer());
        } else {
          factory(root, root);
        }
      })(exports, function(exports2, tokenizer2) {
        function parse(tokens, initialMode) {
          var mode = initialMode || "top-level";
          var i = -1;
          var token;
          var stylesheet;
          switch (mode) {
            case "top-level":
              stylesheet = new Stylesheet();
              break;
            case "declaration":
              stylesheet = new StyleRule();
              break;
          }
          stylesheet.startTok = tokens[0];
          var stack = [stylesheet];
          var rule = stack[0];
          var consume = function(advance) {
            if (advance === void 0)
              advance = 1;
            i += advance;
            if (i < tokens.length)
              token = tokens[i];
            else
              token = new EOFToken();
            return true;
          };
          var reprocess = function() {
            i--;
            return true;
          };
          var next = function() {
            return tokens[i + 1];
          };
          var switchto = function(newmode) {
            if (newmode === void 0) {
              if (rule.fillType !== "")
                mode = rule.fillType;
              else if (rule.type == "STYLESHEET")
                mode = "top-level";
              else {
              }
            } else {
              mode = newmode;
            }
            return true;
          };
          var push = function(newRule) {
            rule = newRule;
            rule.startTok = token;
            stack.push(rule);
            return true;
          };
          var parseerror = function(msg) {
            return true;
          };
          var pop = function() {
            var oldrule = stack.pop();
            oldrule.endTok = token;
            rule = stack[stack.length - 1];
            rule.append(oldrule);
            return true;
          };
          var discard = function() {
            stack.pop();
            rule = stack[stack.length - 1];
            return true;
          };
          var finish = function() {
            while (stack.length > 1) {
              pop();
            }
            rule.endTok = token;
          };
          for (; ; ) {
            consume();
            switch (mode) {
              case "top-level":
                switch (token.tokenType) {
                  case "CDO":
                  case "CDC":
                  case "WHITESPACE":
                    break;
                  case "AT-KEYWORD":
                    push(new AtRule(token.value)) && switchto("at-rule");
                    break;
                  case "{":
                    parseerror("Attempt to open a curly-block at top-level.") && consumeAPrimitive();
                    break;
                  case "EOF":
                    finish();
                    return stylesheet;
                  default:
                    push(new StyleRule()) && switchto("selector") && reprocess();
                }
                break;
              case "at-rule":
                switch (token.tokenType) {
                  case ";":
                    pop() && switchto();
                    break;
                  case "{":
                    if (rule.fillType !== "")
                      switchto(rule.fillType);
                    else
                      parseerror("Attempt to open a curly-block in a statement-type at-rule.") && discard() && switchto("next-block") && reprocess();
                    break;
                  case "EOF":
                    finish();
                    return stylesheet;
                  default:
                    rule.appendPrelude(consumeAPrimitive());
                }
                break;
              case "rule":
                switch (token.tokenType) {
                  case "WHITESPACE":
                    break;
                  case "}":
                    pop() && switchto();
                    break;
                  case "AT-KEYWORD":
                    push(new AtRule(token.value)) && switchto("at-rule");
                    break;
                  case "EOF":
                    finish();
                    return stylesheet;
                  default:
                    push(new StyleRule()) && switchto("selector") && reprocess();
                }
                break;
              case "selector":
                switch (token.tokenType) {
                  case "{":
                    switchto("declaration");
                    break;
                  case "EOF":
                    discard() && finish();
                    return stylesheet;
                  default:
                    rule.appendSelector(consumeAPrimitive());
                }
                break;
              case "declaration":
                switch (token.tokenType) {
                  case "WHITESPACE":
                  case ";":
                    break;
                  case "}":
                    pop() && switchto();
                    break;
                  case "AT-RULE":
                    push(new AtRule(token.value)) && switchto("at-rule");
                    break;
                  case "IDENT":
                    push(new Declaration(token.value)) && switchto("after-declaration-name");
                    break;
                  case "EOF":
                    finish();
                    return stylesheet;
                  default:
                    parseerror() && discard() && switchto("next-declaration");
                }
                break;
              case "after-declaration-name":
                switch (token.tokenType) {
                  case "WHITESPACE":
                    break;
                  case ":":
                    switchto("declaration-value");
                    break;
                  case ";":
                    parseerror("Incomplete declaration - semicolon after property name.") && discard() && switchto();
                    break;
                  case "EOF":
                    discard() && finish();
                    return stylesheet;
                  default:
                    parseerror("Invalid declaration - additional token after property name") && discard() && switchto("next-declaration");
                }
                break;
              case "declaration-value":
                switch (token.tokenType) {
                  case "DELIM":
                    if (token.value == "!" && next().tokenType == "IDENTIFIER" && next().value.toLowerCase() == "important") {
                      consume();
                      rule.important = true;
                      switchto("declaration-end");
                    } else {
                      rule.append(token);
                    }
                    break;
                  case ";":
                    pop() && switchto();
                    break;
                  case "}":
                    pop() && pop() && switchto();
                    break;
                  case "EOF":
                    finish();
                    return stylesheet;
                  default:
                    rule.append(consumeAPrimitive());
                }
                break;
              case "declaration-end":
                switch (token.tokenType) {
                  case "WHITESPACE":
                    break;
                  case ";":
                    pop() && switchto();
                    break;
                  case "}":
                    pop() && pop() && switchto();
                    break;
                  case "EOF":
                    finish();
                    return stylesheet;
                  default:
                    parseerror("Invalid declaration - additional token after !important.") && discard() && switchto("next-declaration");
                }
                break;
              case "next-block":
                switch (token.tokenType) {
                  case "{":
                    consumeAPrimitive() && switchto();
                    break;
                  case "EOF":
                    finish();
                    return stylesheet;
                  default:
                    consumeAPrimitive();
                    break;
                }
                break;
              case "next-declaration":
                switch (token.tokenType) {
                  case ";":
                    switchto("declaration");
                    break;
                  case "}":
                    switchto("declaration") && reprocess();
                    break;
                  case "EOF":
                    finish();
                    return stylesheet;
                  default:
                    consumeAPrimitive();
                    break;
                }
                break;
              default:
                return;
            }
          }
          function consumeAPrimitive() {
            switch (token.tokenType) {
              case "(":
              case "[":
              case "{":
                return consumeASimpleBlock();
              case "FUNCTION":
                return consumeAFunc();
              default:
                return token;
            }
          }
          function consumeASimpleBlock() {
            var endingTokenType = { "(": ")", "[": "]", "{": "}" }[token.tokenType];
            var block = new SimpleBlock(token.tokenType);
            for (; ; ) {
              consume();
              switch (token.tokenType) {
                case "EOF":
                case endingTokenType:
                  return block;
                default:
                  block.append(consumeAPrimitive());
              }
            }
          }
          function consumeAFunc() {
            var func = new Func(token.value);
            var arg = new FuncArg();
            for (; ; ) {
              consume();
              switch (token.tokenType) {
                case "EOF":
                case ")":
                  func.append(arg);
                  return func;
                case "DELIM":
                  if (token.value == ",") {
                    func.append(arg);
                    arg = new FuncArg();
                  } else {
                    arg.append(token);
                  }
                  break;
                default:
                  arg.append(consumeAPrimitive());
              }
            }
          }
        }
        function CSSParserRule() {
          return this;
        }
        CSSParserRule.prototype.fillType = "";
        CSSParserRule.prototype.toString = function(indent) {
          return JSON.stringify(this.toJSON(), null, indent);
        };
        CSSParserRule.prototype.append = function(val) {
          this.value.push(val);
          return this;
        };
        function Stylesheet() {
          this.value = [];
          return this;
        }
        Stylesheet.prototype = new CSSParserRule();
        Stylesheet.prototype.type = "STYLESHEET";
        Stylesheet.prototype.toJSON = function() {
          return { type: "stylesheet", value: this.value.map(function(e) {
            return e.toJSON();
          }) };
        };
        function AtRule(name) {
          this.name = name;
          this.prelude = [];
          this.value = [];
          if (name in AtRule.registry)
            this.fillType = AtRule.registry[name];
          return this;
        }
        AtRule.prototype = new CSSParserRule();
        AtRule.prototype.type = "AT-RULE";
        AtRule.prototype.appendPrelude = function(val) {
          this.prelude.push(val);
          return this;
        };
        AtRule.prototype.toJSON = function() {
          return { type: "at", name: this.name, prelude: this.prelude.map(function(e) {
            return e.toJSON();
          }), value: this.value.map(function(e) {
            return e.toJSON();
          }) };
        };
        AtRule.registry = {
          "import": "",
          "media": "rule",
          "font-face": "declaration",
          "page": "declaration",
          "keyframes": "rule",
          "namespace": "",
          "counter-style": "declaration",
          "supports": "rule",
          "document": "rule",
          "font-feature-values": "declaration",
          "viewport": "",
          "region-style": "rule"
        };
        function StyleRule() {
          this.selector = [];
          this.value = [];
          return this;
        }
        StyleRule.prototype = new CSSParserRule();
        StyleRule.prototype.type = "STYLE-RULE";
        StyleRule.prototype.fillType = "declaration";
        StyleRule.prototype.appendSelector = function(val) {
          this.selector.push(val);
          return this;
        };
        StyleRule.prototype.toJSON = function() {
          return { type: "selector", selector: this.selector.map(function(e) {
            return e.toJSON();
          }), value: this.value.map(function(e) {
            return e.toJSON();
          }) };
        };
        function Declaration(name) {
          this.name = name;
          this.value = [];
          return this;
        }
        Declaration.prototype = new CSSParserRule();
        Declaration.prototype.type = "DECLARATION";
        Declaration.prototype.toJSON = function() {
          return { type: "declaration", name: this.name, value: this.value.map(function(e) {
            return e.toJSON();
          }) };
        };
        function SimpleBlock(type) {
          this.name = type;
          this.value = [];
          return this;
        }
        SimpleBlock.prototype = new CSSParserRule();
        SimpleBlock.prototype.type = "BLOCK";
        SimpleBlock.prototype.toJSON = function() {
          return { type: "block", name: this.name, value: this.value.map(function(e) {
            return e.toJSON();
          }) };
        };
        function Func(name) {
          this.name = name;
          this.value = [];
          return this;
        }
        Func.prototype = new CSSParserRule();
        Func.prototype.type = "FUNCTION";
        Func.prototype.toJSON = function() {
          return { type: "func", name: this.name, value: this.value.map(function(e) {
            return e.toJSON();
          }) };
        };
        function FuncArg() {
          this.value = [];
          return this;
        }
        FuncArg.prototype = new CSSParserRule();
        FuncArg.prototype.type = "FUNCTION-ARG";
        FuncArg.prototype.toJSON = function() {
          return this.value.map(function(e) {
            return e.toJSON();
          });
        };
        exports2.parse = parse;
      });
    }
  });

  // src/vendor/bleach/bleach.js
  function clean(html, opts) {
    if (!html)
      return "";
    html = html.replace(/<!DOCTYPE\s+[^>]*>/gi, "");
    return cleanNode(html, opts);
  }
  function cleanNode(html, opts) {
    try {
      let debug = function(str) {
        console.log("Bleach: " + str + "\n");
      };
      opts = opts || DEFAULTS;
      var attrsByTag = opts.hasOwnProperty("attributes") ? opts.attributes : DEFAULTS.attributes;
      var wildAttrs;
      if (Array.isArray(attrsByTag)) {
        wildAttrs = attrsByTag;
        attrsByTag = {};
      } else if (attrsByTag.hasOwnProperty("*")) {
        wildAttrs = attrsByTag["*"];
      } else {
        wildAttrs = [];
      }
      var sanitizeOptions = {
        ignoreComment: "stripComments" in opts ? opts.stripComments : DEFAULTS.stripComments,
        allowedStyles: opts.styles || DEFAULTS.styles,
        allowedTags: opts.tags || DEFAULTS.tags,
        stripMode: "strip" in opts ? opts.strip : DEFAULTS.strip,
        pruneTags: opts.prune || DEFAULTS.prune,
        allowedAttributesByTag: attrsByTag,
        wildAttributes: wildAttrs,
        callbackRegexp: opts.callbackRegexp || null,
        callback: opts.callbackRegexp && opts.callback || null,
        maxLength: opts.maxLength || 0
      };
      var sanitizer = new HTMLSanitizer(sanitizeOptions);
      HTMLParser.HTMLParser(html, sanitizer);
      return sanitizer.output;
    } catch (e) {
      console.error(e, "\n", e.stack);
      throw e;
    }
  }
  function makeReverseEntities() {
    reverseEntities = {};
    Object.keys(entities).forEach(function(key) {
      reverseEntities[entities[key]] = key;
    });
  }
  function escapeHTMLTextKeepingExistingEntities(text) {
    return text.replace(/[<>"']|&(?![#a-zA-Z0-9]+;)/g, function(c) {
      return "&#" + c.charCodeAt(0) + ";";
    });
  }
  function unescapeHTMLEntities(text) {
    return text.replace(entityRegExp, function(match, ref) {
      var converted = "";
      if (ref.charAt(0) === "#") {
        var secondChar = ref.charAt(1);
        if (secondChar === "x" || secondChar === "X") {
          converted = String.fromCharCode(parseInt(ref.substring(2), 16));
        } else {
          converted = String.fromCharCode(parseInt(ref.substring(1), 10));
        }
      } else {
        if (!reverseEntities)
          makeReverseEntities();
        if (reverseEntities.hasOwnProperty(ref))
          converted = String.fromCharCode(reverseEntities[ref]);
      }
      return converted;
    });
  }
  function escapePlaintextIntoElementContext(text) {
    return text.replace(/[&<>"'\/]/g, function(c) {
      var code = c.charCodeAt(0);
      return "&" + (entities[code] || "#" + code) + ";";
    });
  }
  function escapePlaintextIntoAttribute(text) {
    return text.replace(/[\u0000-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u0100]/g, function(c) {
      var code = c.charCodeAt(0);
      return "&" + (entities[code] || "#" + code) + ";";
    });
  }
  var import_tokenizer, import_parser, ALLOWED_TAGS, ALLOWED_ATTRIBUTES, ALLOWED_STYLES, DEFAULTS, RE_NORMALIZE_WHITESPACE2, HTMLSanitizer, HTMLParser, CSSParser, entities, reverseEntities, entityRegExp;
  var init_bleach = __esm({
    "src/vendor/bleach/bleach.js"() {
      import_tokenizer = __toModule(require_tokenizer());
      import_parser = __toModule(require_parser());
      ALLOWED_TAGS = [
        "a",
        "abbr",
        "acronym",
        "b",
        "blockquote",
        "code",
        "em",
        "i",
        "li",
        "ol",
        "strong",
        "ul"
      ];
      ALLOWED_ATTRIBUTES = {
        "a": ["href", "title"],
        "abbr": ["title"],
        "acronym": ["title"]
      };
      ALLOWED_STYLES = [];
      DEFAULTS = {
        tags: ALLOWED_TAGS,
        prune: [],
        attributes: ALLOWED_ATTRIBUTES,
        styles: ALLOWED_STYLES,
        strip: false,
        stripComments: true
      };
      RE_NORMALIZE_WHITESPACE2 = /\s+/g;
      HTMLSanitizer = function(options) {
        this.output = "";
        this.ignoreComment = options.ignoreComment;
        this.allowedStyles = options.allowedStyles;
        this.allowedTags = options.allowedTags;
        this.stripMode = options.stripMode;
        this.pruneTags = options.pruneTags;
        this.allowedAttributesByTag = options.allowedAttributesByTag;
        this.wildAttributes = options.wildAttributes;
        this.callbackRegexp = options.callbackRegexp;
        this.callback = options.callback;
        this.isInsideStyleTag = false;
        this.isInsidePrunedTag = 0;
        this.isInsideStrippedTag = 0;
        this.maxLength = options.maxLength || 0;
        this.complete = false;
        this.ignoreFragments = this.maxLength > 0;
      };
      HTMLSanitizer.prototype = {
        start: function(tag, attrs, unary) {
          if (this.pruneTags.indexOf(tag) !== -1) {
            if (!unary)
              this.isInsidePrunedTag++;
            return;
          } else if (this.isInsidePrunedTag) {
            return;
          }
          if (this.allowedTags.indexOf(tag) === -1) {
            if (this.stripMode) {
              if (!unary) {
                this.isInsideStrippedTag++;
              }
              return;
            }
            this.output += "&lt;" + (unary ? "/" : "") + tag + "&gt;";
            return;
          }
          this.isInsideStyleTag = tag == "style" && !unary;
          var callbackRegexp = this.callbackRegexp;
          if (callbackRegexp && callbackRegexp.test(tag)) {
            attrs = this.callback(tag, attrs);
          }
          var whitelist = this.allowedAttributesByTag[tag];
          var wildAttrs = this.wildAttributes;
          var result = "<" + tag;
          for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i];
            var attrName = attr.name.toLowerCase();
            if (attr.safe || wildAttrs.indexOf(attrName) !== -1 || whitelist && whitelist.indexOf(attrName) !== -1) {
              if (attrName == "style") {
                var attrValue = "";
                try {
                  attrValue = CSSParser.parseAttribute(attr.escaped, this.allowedStyles);
                } catch (e) {
                  console.log('CSSParser.parseAttribute failed for: "' + attr.escaped + '", skipping. Error: ' + e);
                }
                result += " " + attrName + '="' + attrValue + '"';
              } else {
                result += " " + attrName + '="' + attr.escaped + '"';
              }
            }
          }
          result += (unary ? "/" : "") + ">";
          this.output += result;
        },
        end: function(tag) {
          if (this.pruneTags.indexOf(tag) !== -1) {
            this.isInsidePrunedTag--;
            return;
          } else if (this.isInsidePrunedTag) {
            return;
          }
          if (this.allowedTags.indexOf(tag) === -1) {
            if (this.isInsideStrippedTag) {
              this.isInsideStrippedTag--;
              return;
            }
            this.output += "&lt;/" + tag + "&gt;";
            return;
          }
          if (this.isInsideStyleTag) {
            this.isInsideStyleTag = false;
          }
          this.output += "</" + tag + ">";
        },
        chars: function(text) {
          if (this.isInsidePrunedTag || this.complete)
            return;
          if (this.isInsideStyleTag) {
            this.output += CSSParser.parseBody(text, this.allowedStyles);
            return;
          }
          if (this.maxLength) {
            if (this.insideTagForSnippet) {
              if (text.indexOf(">") !== -1) {
                this.insideTagForSnippet = false;
              }
              return;
            } else {
              if (text.charAt(0) === "<") {
                this.insideTagForSnippet = true;
                return;
              }
            }
            var normalizedText = text.replace(RE_NORMALIZE_WHITESPACE2, " ");
            var length = this.output.length;
            if (length && normalizedText[0] === " " && this.output[length - 1] === " ") {
              normalizedText = normalizedText.substring(1);
            }
            this.output += normalizedText;
            if (this.output.length >= this.maxLength) {
              this.output = this.output.substring(0, this.maxLength);
              this.complete = true;
            }
          } else {
            this.output += escapeHTMLTextKeepingExistingEntities(text);
          }
        },
        comment: function(comment) {
          if (this.isInsidePrunedTag)
            return;
          if (this.ignoreComment)
            return;
          this.output += "<!--" + comment + "-->";
        }
      };
      HTMLParser = function() {
        var startTag = /^<(?:[-A-Za-z0-9_]+:)?([-A-Za-z0-9_]+)([^>]*)>/, endTag = /^<\/(?:[-A-Za-z0-9_]+:)?([-A-Za-z0-9_]+)[^>]*>/, attr = /(?:[-A-Za-z0-9_]+:)?([-A-Za-z0-9_]+)(?:\s*=\s*(?:(?:"([^"]*)")|(?:'([^']*)')|([^>\s]+)))?/g;
        var empty = makeMap("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed");
        var block = makeMap("address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul");
        var inline = makeMap("abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var");
        var closeSelf = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");
        var fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");
        var special = makeMap("script,style");
        var HTMLParser2 = this.HTMLParser = function(html, handler) {
          var index, chars, match, stack = [], last = html;
          stack.last = function() {
            return this[this.length - 1];
          };
          while (html) {
            chars = true;
            if (!stack.last() || !special[stack.last()]) {
              if (html.lastIndexOf("<!--", 0) == 0) {
                index = html.indexOf("-->");
                if (index >= 4) {
                  if (handler.comment)
                    handler.comment(html.substring(4, index));
                  html = html.substring(index + 3);
                  chars = false;
                } else {
                  if (handler.comment)
                    handler.comment(html.substring(4, -1));
                  html = "";
                  chars = false;
                }
              } else if (html.lastIndexOf("</", 0) == 0) {
                match = html.match(endTag);
                if (match) {
                  html = html.substring(match[0].length);
                  match[0].replace(endTag, parseEndTag);
                  chars = false;
                }
              } else if (html.lastIndexOf("<", 0) == 0) {
                match = html.match(startTag);
                if (match) {
                  html = html.substring(match[0].length);
                  match[0].replace(startTag, parseStartTag);
                  chars = false;
                }
              }
              if (chars) {
                index = html.indexOf("<");
                if (index === 0) {
                  var text = html.substring(0, 1);
                  html = html.substring(1);
                } else {
                  var text = index < 0 ? html : html.substring(0, index);
                  html = index < 0 ? "" : html.substring(index);
                }
                if (handler.chars) {
                  handler.chars(text);
                  if (handler.complete)
                    return this;
                }
              }
            } else {
              var skipWork = false;
              html = html.replace(new RegExp("^([^]*?)</" + stack.last() + "[^>]*>", "i"), function(all, text2) {
                if (!skipWork) {
                  text2 = text2.replace(/<!--([^]*?)-->/g, "$1").replace(/<!\[CDATA\[([^]*?)]]>/g, "$1");
                  if (handler.chars) {
                    handler.chars(text2);
                    skipWork = handler.complete;
                  }
                }
                return "";
              });
              if (handler.complete)
                return this;
              parseEndTag("", stack.last());
            }
            if (html == last) {
              if (handler.ignoreFragments) {
                return;
              } else {
                console.log(html);
                console.log(last);
                throw "Parse Error: " + html;
              }
            }
            last = html;
          }
          parseEndTag();
          function parseStartTag(tag, tagName, rest) {
            tagName = tagName.toLowerCase();
            if (block[tagName]) {
              while (stack.last() && inline[stack.last()]) {
                parseEndTag("", stack.last());
              }
            }
            if (closeSelf[tagName] && stack.last() == tagName) {
              parseEndTag("", tagName);
            }
            var unary = empty[tagName];
            if (rest.length && rest[rest.length - 1] === "/") {
              unary = true;
              rest = rest.slice(0, -1);
            }
            if (!unary)
              stack.push(tagName);
            if (handler.start) {
              var attrs = [];
              rest.replace(attr, function(match2, name) {
                var value = arguments[2] ? arguments[2] : arguments[3] ? arguments[3] : arguments[4] ? arguments[4] : fillAttrs[name] ? name : "";
                attrs.push({
                  name,
                  value,
                  escaped: value.replace(/"/g, "&quot;"),
                  safe: false
                });
              });
              if (handler.start)
                handler.start(tagName, attrs, unary);
            }
          }
          function parseEndTag(tag, tagName) {
            if (!tagName)
              var pos = 0;
            else {
              tagName = tagName.toLowerCase();
              for (var pos = stack.length - 1; pos >= 0; pos--)
                if (stack[pos] == tagName)
                  break;
            }
            if (pos >= 0) {
              for (var i = stack.length - 1; i >= pos; i--)
                if (handler.end)
                  handler.end(stack[i]);
              stack.length = pos;
            }
          }
        };
        function makeMap(str) {
          var obj = {}, items = str.split(",");
          for (var i = 0; i < items.length; i++)
            obj[items[i]] = true;
          return obj;
        }
        return this;
      }();
      CSSParser = {
        parseAttribute: function(data, allowedStyles) {
          var tokens = import_tokenizer.default.tokenize(data, { loc: true });
          var rule = import_parser.default.parse(tokens, "declaration");
          var keepText = [];
          this._filterDeclarations(null, rule.value, allowedStyles, data, keepText);
          var oot = keepText.join("");
          return oot;
        },
        _filterDeclarations: function(parent2, decls, allowedStyles, fullText, textOut) {
          for (var i = 0; i < decls.length; i++) {
            var decl = decls[i];
            if (decl.type !== "DECLARATION") {
              continue;
            }
            if (allowedStyles.indexOf(decl.name) !== -1) {
              textOut.push(fullText.substring(decl.startTok.loc.start.idx, parent2 && parent2.endTok === decl.endTok ? decl.endTok.loc.start.idx : decl.endTok.loc.end.idx + 1));
            }
          }
        },
        parseBody: function(data, allowedStyles) {
          var body = "";
          var oot = "";
          try {
            var tokens = import_tokenizer.default.tokenize(data, { loc: true });
            var stylesheet = import_parser.default.parse(tokens);
            var keepText = [];
            for (var i = 0; i < stylesheet.value.length; i++) {
              var sub = stylesheet.value[i];
              if (sub.type === "STYLE-RULE") {
                keepText.push(data.substring(sub.startTok.loc.start.idx, sub.value.length ? sub.value[0].startTok.loc.start.idx : sub.endTok.loc.start.idx));
                this._filterDeclarations(sub, sub.value, allowedStyles, data, keepText);
                keepText.push(data.substring(sub.endTok.loc.start.idx, sub.endTok.loc.end.idx + 1));
              }
            }
            oot = keepText.join("");
          } catch (e) {
            console.log("bleach CSS parsing failed, skipping. Error: " + e);
            oot = "";
          }
          return oot;
        }
      };
      entities = {
        34: "quot",
        38: "amp",
        39: "apos",
        60: "lt",
        62: "gt",
        160: "nbsp",
        161: "iexcl",
        162: "cent",
        163: "pound",
        164: "curren",
        165: "yen",
        166: "brvbar",
        167: "sect",
        168: "uml",
        169: "copy",
        170: "ordf",
        171: "laquo",
        172: "not",
        173: "shy",
        174: "reg",
        175: "macr",
        176: "deg",
        177: "plusmn",
        178: "sup2",
        179: "sup3",
        180: "acute",
        181: "micro",
        182: "para",
        183: "middot",
        184: "cedil",
        185: "sup1",
        186: "ordm",
        187: "raquo",
        188: "frac14",
        189: "frac12",
        190: "frac34",
        191: "iquest",
        192: "Agrave",
        193: "Aacute",
        194: "Acirc",
        195: "Atilde",
        196: "Auml",
        197: "Aring",
        198: "AElig",
        199: "Ccedil",
        200: "Egrave",
        201: "Eacute",
        202: "Ecirc",
        203: "Euml",
        204: "Igrave",
        205: "Iacute",
        206: "Icirc",
        207: "Iuml",
        208: "ETH",
        209: "Ntilde",
        210: "Ograve",
        211: "Oacute",
        212: "Ocirc",
        213: "Otilde",
        214: "Ouml",
        215: "times",
        216: "Oslash",
        217: "Ugrave",
        218: "Uacute",
        219: "Ucirc",
        220: "Uuml",
        221: "Yacute",
        222: "THORN",
        223: "szlig",
        224: "agrave",
        225: "aacute",
        226: "acirc",
        227: "atilde",
        228: "auml",
        229: "aring",
        230: "aelig",
        231: "ccedil",
        232: "egrave",
        233: "eacute",
        234: "ecirc",
        235: "euml",
        236: "igrave",
        237: "iacute",
        238: "icirc",
        239: "iuml",
        240: "eth",
        241: "ntilde",
        242: "ograve",
        243: "oacute",
        244: "ocirc",
        245: "otilde",
        246: "ouml",
        247: "divide",
        248: "oslash",
        249: "ugrave",
        250: "uacute",
        251: "ucirc",
        252: "uuml",
        253: "yacute",
        254: "thorn",
        255: "yuml",
        402: "fnof",
        913: "Alpha",
        914: "Beta",
        915: "Gamma",
        916: "Delta",
        917: "Epsilon",
        918: "Zeta",
        919: "Eta",
        920: "Theta",
        921: "Iota",
        922: "Kappa",
        923: "Lambda",
        924: "Mu",
        925: "Nu",
        926: "Xi",
        927: "Omicron",
        928: "Pi",
        929: "Rho",
        931: "Sigma",
        932: "Tau",
        933: "Upsilon",
        934: "Phi",
        935: "Chi",
        936: "Psi",
        937: "Omega",
        945: "alpha",
        946: "beta",
        947: "gamma",
        948: "delta",
        949: "epsilon",
        950: "zeta",
        951: "eta",
        952: "theta",
        953: "iota",
        954: "kappa",
        955: "lambda",
        956: "mu",
        957: "nu",
        958: "xi",
        959: "omicron",
        960: "pi",
        961: "rho",
        962: "sigmaf",
        963: "sigma",
        964: "tau",
        965: "upsilon",
        966: "phi",
        967: "chi",
        968: "psi",
        969: "omega",
        977: "thetasym",
        978: "upsih",
        982: "piv",
        8226: "bull",
        8230: "hellip",
        8242: "prime",
        8243: "Prime",
        8254: "oline",
        8260: "frasl",
        8472: "weierp",
        8465: "image",
        8476: "real",
        8482: "trade",
        8501: "alefsym",
        8592: "larr",
        8593: "uarr",
        8594: "rarr",
        8595: "darr",
        8596: "harr",
        8629: "crarr",
        8656: "lArr",
        8657: "uArr",
        8658: "rArr",
        8659: "dArr",
        8660: "hArr",
        8704: "forall",
        8706: "part",
        8707: "exist",
        8709: "empty",
        8711: "nabla",
        8712: "isin",
        8713: "notin",
        8715: "ni",
        8719: "prod",
        8721: "sum",
        8722: "minus",
        8727: "lowast",
        8730: "radic",
        8733: "prop",
        8734: "infin",
        8736: "ang",
        8743: "and",
        8744: "or",
        8745: "cap",
        8746: "cup",
        8747: "int",
        8756: "there4",
        8764: "sim",
        8773: "cong",
        8776: "asymp",
        8800: "ne",
        8801: "equiv",
        8804: "le",
        8805: "ge",
        8834: "sub",
        8835: "sup",
        8836: "nsub",
        8838: "sube",
        8839: "supe",
        8853: "oplus",
        8855: "otimes",
        8869: "perp",
        8901: "sdot",
        8968: "lceil",
        8969: "rceil",
        8970: "lfloor",
        8971: "rfloor",
        9001: "lang",
        9002: "rang",
        9674: "loz",
        9824: "spades",
        9827: "clubs",
        9829: "hearts",
        9830: "diams",
        338: "OElig",
        339: "oelig",
        352: "Scaron",
        353: "scaron",
        376: "Yuml",
        710: "circ",
        732: "tilde",
        8194: "ensp",
        8195: "emsp",
        8201: "thinsp",
        8204: "zwnj",
        8205: "zwj",
        8206: "lrm",
        8207: "rlm",
        8211: "ndash",
        8212: "mdash",
        8216: "lsquo",
        8217: "rsquo",
        8218: "sbquo",
        8220: "ldquo",
        8221: "rdquo",
        8222: "bdquo",
        8224: "dagger",
        8225: "Dagger",
        8240: "permil",
        8249: "lsaquo",
        8250: "rsaquo",
        8364: "euro"
      };
      entityRegExp = /\&([#a-zA-Z0-9]+);/g;
    }
  });

  // src/backend/bodies/htmlchew.js
  function getAttributeFromList(attrs, name) {
    var len = attrs.length;
    for (var i = 0; i < len; i++) {
      var attr = attrs[i];
      if (attr.name.toLowerCase() === name) {
        return attr;
      }
    }
    return null;
  }
  function stashLinks(lowerTag, attrs) {
    var classAttr;
    if (RE_IMG_TAG.test(lowerTag)) {
      attrs = attrs.filter(function(attr) {
        switch (attr.name.toLowerCase()) {
          case "cid-src":
          case "ext-src":
            return false;
          case "class":
            classAttr = attr;
          default:
            return true;
        }
      });
      var srcAttr = getAttributeFromList(attrs, "src");
      if (srcAttr) {
        if (RE_CID_URL.test(srcAttr.escaped)) {
          srcAttr.name = "cid-src";
          if (classAttr) {
            classAttr.escaped += " moz-embedded-image";
          } else {
            attrs.push({ name: "class", escaped: "moz-embedded-image" });
          }
          srcAttr.escaped = srcAttr.escaped.substring(4);
        } else if (RE_HTTP_URL.test(srcAttr.escaped)) {
          srcAttr.name = "ext-src";
          if (classAttr) {
            classAttr.escaped += " moz-external-image";
          } else {
            attrs.push({ name: "class", escaped: "moz-external-image" });
          }
        }
      }
    } else {
      attrs = attrs.filter(function(attr) {
        switch (attr.name.toLowerCase()) {
          case "cid-src":
          case "ext-src":
            return false;
          case "class":
            classAttr = attr;
          default:
            return true;
        }
      });
      var linkAttr = getAttributeFromList(attrs, "href");
      if (linkAttr) {
        var link = linkAttr.escaped;
        if (RE_HTTP_URL.test(link) || RE_MAILTO_URL.test(link)) {
          linkAttr.name = "ext-href";
          if (classAttr) {
            classAttr.escaped += " moz-external-link";
          } else {
            attrs.push({ name: "class", escaped: "moz-external-link" });
          }
        } else {
          attrs.splice(attrs.indexOf(linkAttr), 1);
        }
      }
    }
    return attrs;
  }
  function sanitizeAndNormalizeHtml(htmlString) {
    return clean(htmlString, BLEACH_SETTINGS);
  }
  function generateSnippet2(htmlString) {
    return unescapeHTMLEntities(clean(htmlString, BLEACH_SNIPPET_SETTINGS));
  }
  function generateSearchableTextVersion(htmlString, includeQuotes) {
    var settings;
    if (includeQuotes) {
      settings = BLEACH_SEARCHABLE_TEXT_WITH_QUOTES_SETTINGS;
    } else {
      settings = BLEACH_SEARCHABLE_TEXT_WITHOUT_QUOTES_SETTINGS;
    }
    var cleaned = clean(htmlString, settings);
    return unescapeHTMLEntities(cleaned);
  }
  function wrapTextIntoSafeHTMLString(text, wrapTag, transformNewlines, attrs) {
    if (transformNewlines === void 0) {
      transformNewlines = true;
    }
    wrapTag = wrapTag || "div";
    text = escapePlaintextIntoElementContext(text);
    text = transformNewlines ? text.replace(/\n/g, "<br/>") : text;
    var attributes = "";
    if (attrs) {
      var len = attrs.length;
      for (var i = 0; i < len; i += 2) {
        attributes += " " + attrs[i] + '="' + escapePlaintextIntoAttribute(attrs[i + 1]) + '"';
      }
    }
    return "<" + wrapTag + attributes + ">" + text + "</" + wrapTag + ">";
  }
  function escapeAttrValue(s) {
    return s.replace(RE_QUOTE_CHAR, "&quot;");
  }
  var LEGAL_TAGS, PRUNE_TAGS, LEGAL_ATTR_MAP, LEGAL_STYLES, RE_NODE_NEEDS_TRANSFORM, RE_CID_URL, RE_HTTP_URL, RE_MAILTO_URL, RE_IMG_TAG, BLEACH_SETTINGS, BLEACH_SNIPPET_SETTINGS, MAX_SEARCHABLE_TEXT_LENGTH, BLEACH_SEARCHABLE_TEXT_WITH_QUOTES_SETTINGS, BLEACH_SEARCHABLE_TEXT_WITHOUT_QUOTES_SETTINGS, RE_QUOTE_CHAR;
  var init_htmlchew = __esm({
    "src/backend/bodies/htmlchew.js"() {
      init_bleach();
      init_syncbase();
      LEGAL_TAGS = [
        "a",
        "abbr",
        "acronym",
        "area",
        "article",
        "aside",
        "b",
        "bdi",
        "bdo",
        "big",
        "blockquote",
        "br",
        "caption",
        "center",
        "cite",
        "code",
        "col",
        "colgroup",
        "dd",
        "del",
        "details",
        "dfn",
        "dir",
        "div",
        "dl",
        "dt",
        "em",
        "figcaption",
        "figure",
        "font",
        "footer",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "i",
        "img",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "listing",
        "map",
        "mark",
        "nav",
        "nobr",
        "noscript",
        "ol",
        "output",
        "p",
        "pre",
        "q",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "section",
        "small",
        "span",
        "strike",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "time",
        "title",
        "tr",
        "tt",
        "u",
        "ul",
        "var",
        "wbr"
      ];
      PRUNE_TAGS = [
        "button",
        "datalist",
        "script",
        "select",
        "svg",
        "title"
      ];
      LEGAL_ATTR_MAP = {
        "*": [
          "abbr",
          "align",
          "alt",
          "axis",
          "bgcolor",
          "border",
          "cellpadding",
          "cellspacing",
          "charoff",
          "class",
          "clear",
          "color",
          "cols",
          "colspan",
          "compact",
          "coords",
          "datetime",
          "dir",
          "face",
          "frame",
          "headers",
          "height",
          "hspace",
          "id",
          "lang",
          "media",
          "nohref",
          "noshade",
          "nowrap",
          "open",
          "pointsize",
          "pubdate",
          "reversed",
          "rows",
          "rowspan",
          "rules",
          "size",
          "scope",
          "scoped",
          "shape",
          "span",
          "start",
          "summary",
          "style",
          "title",
          "valign",
          "value",
          "vspace",
          "width"
        ],
        a: ["ext-href", "hreflang"],
        area: ["ext-href", "hreflang"],
        blockquote: ["cite", "type"],
        img: ["cid-src", "ext-src", "ismap", "usemap"],
        meta: ["charset"],
        ol: ["type"],
        style: ["type"]
      };
      LEGAL_STYLES = [
        "background-color",
        "border",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-color",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "clear",
        "color",
        "display",
        "float",
        "font-family",
        "font-size",
        "font-style",
        "font-weight",
        "height",
        "line-height",
        "list-style-position",
        "list-style-type",
        "margin",
        "margin-bottom",
        "margin-left",
        "margin-right",
        "margin-top",
        "padding",
        "padding-bottom",
        "padding-left",
        "padding-right",
        "padding-top",
        "text-align",
        "text-align-last",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-style",
        "text-indent",
        "vertical-align",
        "white-space",
        "width",
        "word-break",
        "word-spacing",
        "word-wrap"
      ];
      RE_NODE_NEEDS_TRANSFORM = /^(?:a|area|img)$/;
      RE_CID_URL = /^cid:/i;
      RE_HTTP_URL = /^http(?:s)?/i;
      RE_MAILTO_URL = /^mailto:/i;
      RE_IMG_TAG = /^img$/;
      BLEACH_SETTINGS = {
        tags: LEGAL_TAGS,
        strip: true,
        stripComments: true,
        prune: PRUNE_TAGS,
        attributes: LEGAL_ATTR_MAP,
        styles: LEGAL_STYLES,
        asNode: true,
        callbackRegexp: RE_NODE_NEEDS_TRANSFORM,
        callback: stashLinks
      };
      BLEACH_SNIPPET_SETTINGS = {
        tags: [],
        strip: true,
        stripComments: true,
        prune: [
          "style",
          "button",
          "datalist",
          "script",
          "select",
          "svg",
          "title"
        ],
        asNode: true,
        maxLength: DESIRED_SNIPPET_LENGTH
      };
      MAX_SEARCHABLE_TEXT_LENGTH = 256 * 1024;
      BLEACH_SEARCHABLE_TEXT_WITH_QUOTES_SETTINGS = {
        tags: [],
        strip: true,
        stripComments: true,
        prune: [
          "style",
          "button",
          "datalist",
          "script",
          "select",
          "svg",
          "title"
        ],
        asNode: true,
        maxLength: MAX_SEARCHABLE_TEXT_LENGTH
      };
      BLEACH_SEARCHABLE_TEXT_WITHOUT_QUOTES_SETTINGS = {
        tags: [],
        strip: true,
        stripComments: true,
        prune: [
          "style",
          "button",
          "datalist",
          "script",
          "select",
          "svg",
          "title",
          "blockquote"
        ],
        asNode: true,
        maxLength: MAX_SEARCHABLE_TEXT_LENGTH
      };
      RE_QUOTE_CHAR = /"/g;
    }
  });

  // src/backend/bodies/mailchew.js
  function generateBaseComposeParts(identity) {
    let textMsg;
    if (identity.signatureEnabled && identity.signature && identity.signature.length) {
      textMsg = "\n\n--\n" + identity.signature;
    } else {
      textMsg = "";
    }
    return makeBodyPartsFromTextAndHTML(textMsg, null);
  }
  function generateReplySubject(origSubject) {
    var re = "Re: ";
    if (origSubject) {
      if (RE_RE.test(origSubject)) {
        return origSubject;
      }
      return re + origSubject;
    }
    return re;
  }
  function generateForwardSubject(origSubject) {
    var fwd = "Fwd: ";
    if (origSubject) {
      if (RE_FWD.test(origSubject)) {
        return origSubject;
      }
      return fwd + origSubject;
    }
    return fwd;
  }
  function generateMessageIdHeaderValue() {
    return Math.random().toString(16).substr(2) + Math.random().toString(16).substr(1) + "@mozgaia";
  }
  function setLocalizedStrings(strings2) {
    l10n_wroteString = strings2.wrote;
    l10n_originalMessageString = strings2.originalMessage;
    l10n_forward_header_labels = strings2.forwardHeaderLabels;
  }
  function makeBodyPartsFromTextAndHTML(textMsg, htmlMsg) {
    let bodyReps = [];
    bodyReps.push(makeBodyPart({
      type: "plain",
      part: null,
      sizeEstimate: textMsg.length,
      amountDownloaded: textMsg.length,
      isDownloaded: true,
      _partInfo: {},
      contentBlob: new Blob([JSON.stringify([1, textMsg])], {
        type: "application/json"
      })
    }));
    if (htmlMsg) {
      bodyReps.push(makeBodyPart({
        type: "html",
        part: null,
        sizeEstimate: htmlMsg.length,
        amountDownloaded: htmlMsg.length,
        isDownloaded: true,
        _partInfo: {},
        contentBlob: new Blob([htmlMsg], { type: "text/html" })
      }));
    }
    return bodyReps;
  }
  async function generateReplyParts(reps, authorPair, msgDate, identity, refGuid) {
    var useName = authorPair.name ? authorPair.name.trim() : authorPair.address;
    var textMsg = "\n\n" + l10n_wroteString.replace("{name}", useName) + ":\n", htmlMsg = null;
    for (let i = 0; i < reps.length; i++) {
      let repType = reps[i].type;
      let repBlob = reps[i].contentBlob;
      let rep;
      if (repType === "plain") {
        rep = JSON.parse(await repBlob.text());
        var replyText = generateReplyText(rep);
        if (htmlMsg) {
          htmlMsg += wrapTextIntoSafeHTMLString(replyText) + "\n";
        } else {
          textMsg += replyText;
        }
      } else if (repType === "html") {
        rep = await repBlob.text();
        if (!htmlMsg) {
          htmlMsg = "";
          if (textMsg.slice(-1) === "\n") {
            textMsg = textMsg.slice(0, -1);
          }
        }
        htmlMsg += "<blockquote ";
        if (refGuid) {
          htmlMsg += 'cite="mid:' + escapeAttrValue(refGuid) + '" ';
        }
        htmlMsg += 'type="cite">' + rep + "</blockquote>";
      }
    }
    if (identity.signature && identity.signatureEnabled) {
      if (htmlMsg) {
        htmlMsg += wrapTextIntoSafeHTMLString(identity.signature, "pre", false, ["class", "moz-signature", "cols", "72"]);
      } else {
        textMsg += "\n\n-- \n" + identity.signature;
      }
    }
    return makeBodyPartsFromTextAndHTML(textMsg, htmlMsg);
  }
  async function generateForwardParts(sourceMessage, identity) {
    var textMsg = "\n\n", htmlMsg = null;
    if (identity.signature && identity.signatureEnabled) {
      textMsg += "-- \n" + identity.signature + "\n\n";
    }
    textMsg += "-------- " + l10n_originalMessageString + " --------\n";
    textMsg += l10n_forward_header_labels.subject + ": " + sourceMessage.subject + "\n";
    textMsg += l10n_forward_header_labels.date + ": " + new Date(sourceMessage.date) + "\n";
    textMsg += l10n_forward_header_labels.from + ": " + formatAddresses([sourceMessage.author]) + "\n";
    if (sourceMessage.replyTo) {
      textMsg += l10n_forward_header_labels.replyTo + ": " + formatAddresses([sourceMessage.replyTo]) + "\n";
    }
    if (sourceMessage.to && sourceMessage.to.length) {
      textMsg += l10n_forward_header_labels.to + ": " + formatAddresses(sourceMessage.to) + "\n";
    }
    if (sourceMessage.cc && sourceMessage.cc.length) {
      textMsg += l10n_forward_header_labels.cc + ": " + formatAddresses(sourceMessage.cc) + "\n";
    }
    textMsg += "\n";
    let reps = sourceMessage.bodyReps;
    for (let i = 0; i < reps.length; i++) {
      let repType = reps[i].type;
      let repBlob = reps[i].contentBlob;
      let rep;
      if (repType === "plain") {
        rep = JSON.parse(await repBlob.text());
        let forwardText = generateForwardBodyText(rep);
        if (htmlMsg) {
          htmlMsg += wrapTextIntoSafeHTMLString(forwardText) + "\n";
        } else {
          textMsg += forwardText;
        }
      } else if (repType === "html") {
        rep = await repBlob.text();
        if (!htmlMsg) {
          htmlMsg = "";
          if (textMsg.slice(-1) === "\n") {
            textMsg = textMsg.slice(0, -1);
          }
        }
        htmlMsg += rep;
      }
    }
    return makeBodyPartsFromTextAndHTML(textMsg, htmlMsg);
  }
  function mergeUserTextWithHTML(text, html) {
    return HTML_WRAP_TOP + wrapTextIntoSafeHTMLString(text, "div") + html + HTML_WRAP_BOTTOM;
  }
  function processMessageContent(content, type, isDownloaded, generateSnippet3) {
    if (content.slice(-1) === "\n") {
      content = content.slice(0, -1);
    }
    let parsedContent, contentBlob, snippet;
    let authoredBodySize = 0;
    switch (type) {
      case "plain":
        try {
          parsedContent = quoteProcessTextBody(content);
          authoredBodySize = estimateAuthoredBodySize(parsedContent);
        } catch (ex) {
          logic(scope3, "textChewError", { ex });
          parsedContent = [];
        }
        if (generateSnippet3) {
          try {
            snippet = generateSnippet(parsedContent, DESIRED_SNIPPET_LENGTH);
          } catch (ex) {
            logic(scope3, "textSnippetError", { ex });
            snippet = "";
          }
        }
        contentBlob = new Blob([JSON.stringify(parsedContent)], {
          type: "application/json"
        });
        break;
      case "html":
        if (generateSnippet3) {
          try {
            snippet = generateSnippet2(content);
          } catch (ex) {
            logic(scope3, "htmlSnippetError", { ex });
            snippet = "";
          }
        }
        if (isDownloaded) {
          try {
            parsedContent = sanitizeAndNormalizeHtml(content);
            contentBlob = new Blob([parsedContent], { type: "text/html" });
            authoredBodySize = generateSearchableTextVersion(parsedContent, false).length;
          } catch (ex) {
            logic(scope3, "htmlParseError", { ex });
            parsedContent = "";
          }
        }
        break;
      default: {
        throw new Error("unpossible!");
      }
    }
    return { contentBlob, snippet, authoredBodySize };
  }
  function processAttributeContent(attrData) {
    const contentBlob = new Blob([JSON.stringify(attrData)], {
      type: "application/json"
    });
    return {
      contentBlob,
      snippet: "",
      authoredBodySize: contentBlob.size
    };
  }
  var scope3, RE_RE, RE_FWD, l10n_wroteString, l10n_originalMessageString, l10n_forward_header_labels, HTML_WRAP_TOP, HTML_WRAP_BOTTOM;
  var init_mailchew = __esm({
    "src/backend/bodies/mailchew.js"() {
      init_logic();
      init_util();
      init_mailchew_strings();
      init_quotechew();
      init_htmlchew();
      init_syncbase();
      init_mail_rep();
      scope3 = logic.scope("MailChew");
      RE_RE = /^[Rr][Ee]:/;
      RE_FWD = /^[Ff][Ww][Dd]:/;
      l10n_wroteString = "{name} wrote";
      l10n_originalMessageString = "Original Message";
      l10n_forward_header_labels = {
        subject: "Subject",
        date: "Date",
        from: "From",
        replyTo: "Reply-To",
        to: "To",
        cc: "CC"
      };
      if (strings) {
        setLocalizedStrings(strings);
      }
      events.on("strings", function(strings2) {
        setLocalizedStrings(strings2);
      });
      HTML_WRAP_TOP = '<html><body><body bgcolor="#FFFFFF" text="#000000">';
      HTML_WRAP_BOTTOM = "</body></html>";
    }
  });

  // src/backend/accounts/activesync/smotocol/download_body.js
  async function downloadBody(conn, { folderServerId, messageServerId, bodyType, truncationSize }) {
    let w = new Writer("1.3", 1, "UTF-8");
    w.stag(ItemOperations_default.Tags.Tags.ItemOperations).stag(ItemOperations_default.Tags.Fetch).tag(ItemOperations_default.Tags.Store, "Mailbox").tag(AirSync_default.Tags.CollectionId, folderServerId).tag(AirSync_default.Tags.ServerId, messageServerId).stag(ItemOperations_default.Tags.Options).stag(ItemOperations_default.Tags.Schema).tag(AirSyncBase_default.Tags.Body).etag().stag(AirSyncBase_default.Tags.BodyPreference).tag(AirSyncBase_default.Tags.Type, bodyType);
    if (truncationSize) {
      w.tag(AirSyncBase_default.Tags.TruncationSize, truncationSize);
    }
    w.etag().etag().etag().etag();
    let response = await conn.postCommand(w);
    let e = new EventParser();
    let status, bodyContent;
    e.addEventListener([ItemOperations_default.Tags.ItemOperations, ItemOperations_default.Tags.Status], function(node) {
      status = node.children[0].textContent;
    });
    e.addEventListener([
      ItemOperations_default.Tags.ItemOperations,
      ItemOperations_default.Tags.Response,
      ItemOperations_default.Tags.Fetch,
      ItemOperations_default.Tags.Properties,
      AirSyncBase_default.Tags.Body,
      AirSyncBase_default.Tags.Data
    ], function(node) {
      bodyContent = node.children[0].textContent;
    });
    try {
      e.run(response);
    } catch (ex) {
      console.error("Error parsing FolderSync response:", ex, "\n", ex.stack);
      throw new Error("unknown");
    }
    if (status !== ItemOperations_default.Enums.Status.Success) {
      throw new Error("unknown");
    }
    return { bodyContent };
  }
  var init_download_body = __esm({
    "src/backend/accounts/activesync/smotocol/download_body.js"() {
      init_wbxml();
      init_ItemOperations();
      init_AirSync();
      init_AirSyncBase();
    }
  });

  // src/backend/accounts/activesync/smotocol/download_body_25.js
  async function downloadBody2(conn, { folderSyncKey, folderServerId, messageServerId, bodyType }) {
    let w = new Writer("1.3", 1, "UTF-8");
    w.stag(AirSync_default.Tags.Sync).stag(AirSync_default.Tags.Collections).stag(AirSync_default.Tags.Collection).tag(AirSync_default.Tags.Class, "Email").tag(AirSync_default.Tags.SyncKey, folderSyncKey).tag(AirSync_default.Tags.CollectionId, folderServerId).stag(AirSync_default.Tags.Options).tag(AirSync_default.Tags.MIMESupport, AirSync_default.Tags.Enums.MIMESupport.Never).etag().stag(AirSync_default.Tags.Commands).stag(AirSync_default.Tags.Fetch).tag(AirSync_default.Tags.ServerId, messageServerId).etag().etag().etag().etag().etag();
    let response = await conn.postCommand(w);
    let e = new EventParser();
    let base = [AirSync_default.Tags.Sync, AirSync_default.Tags.Collections, AirSync_default.Tags.Collection];
    let newSyncKey, status, bodyContent;
    e.addEventListener(base.concat(AirSync_default.Tags.SyncKey), function(node) {
      newSyncKey = node.children[0].textContent;
    });
    e.addEventListener(base.concat(AirSync_default.Tags.Status), function(node) {
      status = node.children[0].textContent;
    });
    e.addEventListener(base.concat(AirSync_default.Tags.Responses, AirSync_default.Tags.Fetch, AirSync_default.Tags.ApplicationData, Email_default.Tags.Body), function(node) {
      bodyContent = node.children[0].textContent;
    });
    try {
      e.run(response);
    } catch (ex) {
      console.error("Error parsing FolderSync response:", ex, "\n", ex.stack);
      throw new Error("unknown");
    }
    if (status !== ItemOperations_default.Enums.Status.Success) {
      throw new Error("unknown");
    }
    return { syncKey: newSyncKey, bodyContent };
  }
  var init_download_body_25 = __esm({
    "src/backend/accounts/activesync/smotocol/download_body_25.js"() {
      init_wbxml();
      init_ItemOperations();
      init_AirSync();
      init_Email();
    }
  });

  // src/backend/task_mixins/mix_sync_body.js
  var mix_sync_body_default;
  var init_mix_sync_body = __esm({
    "src/backend/task_mixins/mix_sync_body.js"() {
      mix_sync_body_default = {
        name: "sync_body",
        initPersistentState() {
          return null;
        },
        deriveMemoryStateFromPersistentState() {
          return {
            memoryState: new Map(),
            markers: []
          };
        },
        async plan(ctx, persistentState, memoryState, rawTask) {
          let planned = memoryState.get(rawTask.convId);
          if (planned) {
            if (rawTask.amount && (!planned.amount || planned.amount === "snippet")) {
              planned.amount = rawTask.amount;
            }
            if (rawTask.fullBodyMessageIds) {
              if (planned.fullBodyMessageIds) {
                planned.fullBodyMessageIds = new Set(planned.fullBodyMessageIds);
                for (let messageId of rawTask.fullBodyMessageIds) {
                  planned.fullBodyMessageIds.add(messageId);
                }
              } else {
                planned.fullBodyMessageIds = rawTask.fullBodyMessageIds;
              }
            }
          } else {
            planned = {
              markerId: "sync_body:" + rawTask.convId,
              convId: rawTask.convId,
              amount: rawTask.amount,
              fullBodyMessageIds: rawTask.fullBodyMessageIds
            };
            memoryState.set(planned.convId, planned);
          }
          let priorityTags = [`view:conv:${planned.convId}`];
          if (planned.fullBodyMessageIds) {
            for (let messageId of planned.fullBodyMessageIds) {
              priorityTags.push(`view:body:${messageId}`);
            }
          }
          let modifyTaskMarkers = new Map([
            [
              planned.markerId,
              {
                type: this.name,
                id: planned.markerId,
                accountId: rawTask.accountId,
                convId: planned.convId,
                priorityTags,
                exclusiveResources: [`conv:${planned.convId}`]
              }
            ]
          ]);
          await ctx.finishTask({
            taskState: null,
            taskMarkers: modifyTaskMarkers
          });
        }
      };
    }
  });

  // src/backend/accounts/activesync/tasks/sync_body.js
  var DESIRED_TEXT_SNIPPET_BYTES, sync_body_default;
  var init_sync_body = __esm({
    "src/backend/accounts/activesync/tasks/sync_body.js"() {
      init_task_definer();
      init_folder_sync_state_helper();
      init_conv_churn_driver();
      init_mailchew();
      init_download_body();
      init_download_body_25();
      init_AirSyncBase();
      init_syncbase();
      init_mix_sync_body();
      DESIRED_TEXT_SNIPPET_BYTES = 512;
      sync_body_default = task_definer_default.defineComplexTask([
        mix_sync_body_default,
        {
          async execute(ctx, persistentState, memoryState, marker) {
            let req = memoryState.get(marker.convId);
            let account = await ctx.universe.acquireAccount(ctx, marker.accountId);
            let conn = await account.ensureConnection();
            let use25 = conn.currentVersion.lt("12.0");
            let fromDb = await ctx.beginMutate({
              conversations: new Map([[req.convId, null]]),
              messagesByConversation: new Map([[req.convId, null]])
            });
            let oldConvInfo = fromDb.conversations.get(req.convId);
            let loadedMessages = fromDb.messagesByConversation.get(req.convId);
            let modifiedMessagesMap = new Map();
            let umidLocations = new Map();
            for (let message of loadedMessages) {
              umidLocations.set(message.umid, null);
            }
            await ctx.read({
              umidLocations
            });
            let rawSyncStateReads = new Map();
            for (let [folderId] of umidLocations.values()) {
              rawSyncStateReads.set(folderId, null);
            }
            await ctx.mutateMore({
              syncStates: rawSyncStateReads
            });
            let syncStates = new Map();
            for (let [folderId, rawSyncState] of rawSyncStateReads) {
              syncStates.set(folderId, new folder_sync_state_helper_default(ctx, rawSyncState, marker.accountId, folderId));
            }
            let truncationSize = 0;
            if (req.amount === "snippet") {
              truncationSize = DESIRED_SNIPPET_LENGTH;
            } else if (req.amount) {
              truncationSize = req.amount;
            }
            for (let message of loadedMessages) {
              let [folderId, messageServerId] = umidLocations.get(message.umid);
              let folderInfo = account.getFolderById(folderId);
              let folderServerId = folderInfo.serverId;
              let syncState = syncStates.get(folderId);
              let bodyRep = message.bodyReps[0];
              let bodyType = bodyRep.type;
              let snippetOnly = false;
              if (truncationSize && truncationSize < bodyRep.sizeEstimate) {
                snippetOnly = true;
                if (!use25) {
                  bodyType = "plain";
                  truncationSize = DESIRED_TEXT_SNIPPET_BYTES;
                }
              }
              let asBodyType = bodyType === "html" ? AirSyncBase_default.Enums.Type.HTML : AirSyncBase_default.Enums.Type.PlainText;
              let bodyContent;
              if (use25) {
                let result = await downloadBody2(conn, {
                  folderSyncKey: syncState.syncKey,
                  folderServerId,
                  messageServerId,
                  bodyType: asBodyType
                });
                bodyContent = result.bodyContent;
                syncState.syncKey = result.syncKey;
              } else {
                bodyContent = (await downloadBody(conn, {
                  folderServerId,
                  messageServerId,
                  bodyType: asBodyType,
                  truncationSize
                })).bodyContent;
              }
              bodyContent = bodyContent.replace(/\r/g, "");
              let { contentBlob, snippet } = processMessageContent(bodyContent, bodyType, !snippetOnly, true);
              message.snippet = snippet;
              if (!snippetOnly) {
                bodyRep.contentBlob = contentBlob;
                bodyRep.isDownloaded = true;
              }
              modifiedMessagesMap.set(message.id, message);
            }
            let convInfo = churnConversationDriver(req.convId, oldConvInfo, loadedMessages);
            memoryState.delete(req.convId);
            await ctx.finishTask({
              mutations: {
                conversations: new Map([[req.convId, convInfo]]),
                messages: modifiedMessagesMap,
                syncStates: rawSyncStateReads
              }
            });
          }
        }
      ]);
    }
  });

  // src/backend/accounts/activesync/smotocol/modify_folder_messages.js
  async function modifyFolderMessages(conn, args) {
    let { folderServerId, folderSyncKey, permanentDeletion } = args;
    let readMap = args.read || new Map();
    let flagMap = args.flag || new Map();
    let deleteSet = args.delete || new Set();
    let w = new Writer("1.3", 1, "UTF-8");
    w.stag(AirSync_default.Tags.Sync).stag(AirSync_default.Tags.Collections).stag(AirSync_default.Tags.Collection);
    if (conn.currentVersion.lt("12.1")) {
      w.tag(AirSync_default.Tags.Class, "Email");
    }
    w.tag(AirSync_default.Tags.SyncKey, folderSyncKey).tag(AirSync_default.Tags.CollectionId, folderServerId).tag(AirSync_default.Tags.DeletesAsMoves, permanentDeletion ? "0" : 1).tag(AirSync_default.Tags.GetChanges, "0").stag(AirSync_default.Tags.Commands);
    for (let [serverId, beRead] of readMap) {
      w.stag(AirSync_default.Tags.Change).tag(AirSync_default.Tags.ServerId, serverId).stag(AirSync_default.Tags.ApplicationData).tag(Email_default.Tags.Read, beRead ? "1" : "0").etag(AirSync_default.Tags.ApplicationData).etag(AirSync_default.Tags.Change);
    }
    for (let [serverId, beFlagged] of flagMap) {
      w.stag(AirSync_default.Tags.Change).tag(AirSync_default.Tags.ServerId, serverId).stag(AirSync_default.Tags.ApplicationData).stag(Email_default.Tags.Flag).tag(Email_default.Tags.Status, beFlagged ? "2" : "0").etag().etag(AirSync_default.Tags.ApplicationData).etag(AirSync_default.Tags.Change);
    }
    for (let serverId of deleteSet) {
      w.stag(AirSync_default.Tags.Delete).tag(AirSync_default.Tags.ServerId, serverId).etag(AirSync_default.Tags.Delete);
    }
    w.etag(AirSync_default.Tags.Commands).etag(AirSync_default.Tags.Collection).etag(AirSync_default.Tags.Collections).etag(AirSync_default.Tags.Sync);
    let response = await conn.postCommand(w);
    let e = new EventParser();
    let newSyncKey, status;
    let base = [AirSync_default.Tags.Sync, AirSync_default.Tags.Collections, AirSync_default.Tags.Collection];
    e.addEventListener(base.concat(AirSync_default.Tags.SyncKey), function(node) {
      newSyncKey = node.children[0].textContent;
    });
    e.addEventListener(base.concat(AirSync_default.Tags.Status), function(node) {
      status = node.children[0].textContent;
    });
    try {
      e.run(response);
    } catch (ex) {
      console.error("Error parsing Sync mutation response:", ex, "\n", ex.stack);
      throw new Error("unknown");
    }
    if (status === AirSync_default.Enums.Status.Success) {
      return { syncKey: newSyncKey };
    }
    console.error("Something went wrong during ActiveSync syncing and we got a status of " + status);
    throw new Error("unknown");
  }
  var init_modify_folder_messages = __esm({
    "src/backend/accounts/activesync/smotocol/modify_folder_messages.js"() {
      init_wbxml();
      init_AirSync();
      init_Email();
    }
  });

  // src/backend/message_selector.js
  function selectMessages(messages, onlyMessages, selector) {
    let filtered = messages;
    if (onlyMessages) {
      filtered = filtered.filter((message) => {
        return onlyMessages.includes(message.id);
      });
    }
    if (selector) {
      switch (selector) {
        case "last":
          filtered = filtered.slice(-1);
          break;
        default:
          throw new Error("unsupported message selector:" + selector);
      }
    }
    return filtered;
  }
  var init_message_selector = __esm({
    "src/backend/message_selector.js"() {
    }
  });

  // src/backend/task_mixins/mix_store_flags.js
  var MixStoreFlagsMixin, mix_store_flags_default;
  var init_mix_store_flags = __esm({
    "src/backend/task_mixins/mix_store_flags.js"() {
      init_delta_algebra();
      init_message_selector();
      init_conv_churn_driver();
      MixStoreFlagsMixin = {
        initPersistentState() {
          return {
            umidChanges: new Map()
          };
        },
        deriveMemoryStateFromPersistentState(persistentState, accountId) {
          let markers = [];
          for (let umid of persistentState.umidChanges.keys()) {
            markers.push({
              type: this.name,
              id: this.name + ":" + umid,
              accountId,
              umid,
              priorityTags: [],
              exclusiveResources: []
            });
          }
          return {
            memoryState: {},
            markers
          };
        },
        async plan(ctx, persistentState, memoryState, req) {
          let { umidChanges } = persistentState;
          let fromDb = await ctx.beginMutate({
            conversations: new Map([[req.convId, null]]),
            messagesByConversation: new Map([[req.convId, null]])
          });
          let loadedMessages = fromDb.messagesByConversation.get(req.convId);
          let modifiedMessagesMap = new Map();
          let modifyTaskMarkers = new Map();
          let anyMessageChanged = false;
          let filteredMessages = selectMessages(loadedMessages, req.onlyMessages, req.messageSelector);
          let undoTasks = [];
          for (let message of filteredMessages) {
            let actualChanges = normalizeAndApplyChanges(message.flags, req.add, req.remove);
            let { add: actuallyAdded, remove: actuallyRemoved } = actualChanges;
            if (actuallyAdded || actuallyRemoved) {
              undoTasks.push({
                type: this.name,
                accountId: req.accountId,
                convId: req.convId,
                onlyMessages: [message.id],
                messageSelector: null,
                add: actuallyRemoved && actuallyRemoved.concat(),
                remove: actuallyAdded && actuallyAdded.concat()
              });
              modifiedMessagesMap.set(message.id, message);
              anyMessageChanged = true;
              let umid = message.umid;
              let markerId = this.name + ":" + umid;
              if (umidChanges.has(umid)) {
                let mergedChanges = mergeChanges(umidChanges.get(umid), actualChanges);
                if (mergedChanges.add || mergedChanges.remove) {
                  umidChanges.set(umid, mergedChanges);
                  continue;
                } else {
                  umidChanges.delete(umid);
                  modifyTaskMarkers.set(markerId, null);
                  continue;
                }
              }
              if (this.execute) {
                umidChanges.set(umid, actualChanges);
                modifyTaskMarkers.set(markerId, {
                  type: this.name,
                  id: markerId,
                  accountId: req.accountId,
                  umid,
                  priorityTags: [],
                  exclusiveResources: []
                });
              }
            }
          }
          let conversationsMap = null;
          if (anyMessageChanged) {
            let oldConvInfo = fromDb.conversations.get(req.convId);
            let convInfo = churnConversationDriver(req.convId, oldConvInfo, loadedMessages);
            conversationsMap = new Map([[convInfo.id, convInfo]]);
          }
          await ctx.finishTask({
            mutations: {
              conversations: conversationsMap,
              messages: modifiedMessagesMap
            },
            taskMarkers: modifyTaskMarkers,
            complexTaskState: persistentState,
            undoTasks
          });
        },
        consult(askingCtx, persistentState, memoryState, argDict) {
          let { umid, value } = argDict;
          let { umidChanges } = persistentState;
          if (umidChanges.has(umid)) {
            let changes = umidChanges.get(umid);
            applyChanges(value, changes);
          }
        },
        execute: null
      };
      mix_store_flags_default = MixStoreFlagsMixin;
    }
  });

  // src/backend/accounts/activesync/tasks/store_flags.js
  var store_flags_default;
  var init_store_flags = __esm({
    "src/backend/accounts/activesync/tasks/store_flags.js"() {
      init_task_definer();
      init_folder_sync_state_helper();
      init_modify_folder_messages();
      init_mix_store_flags();
      store_flags_default = task_definer_default.defineComplexTask([
        mix_store_flags_default,
        {
          name: "store_flags",
          async execute(ctx, persistentState, memoryState, marker) {
            let { umidChanges } = persistentState;
            let changes = umidChanges.get(marker.umid);
            let account = await ctx.universe.acquireAccount(ctx, marker.accountId);
            let fromDb = await ctx.read({
              umidLocations: new Map([[marker.umid, null]])
            });
            let [folderId, messageServerId] = fromDb.umidLocations.get(marker.umid);
            fromDb = await ctx.beginMutate({
              syncStates: new Map([[folderId, null]])
            });
            let rawSyncState = fromDb.syncStates.get(folderId);
            let syncState = new folder_sync_state_helper_default(ctx, rawSyncState, marker.accountId, folderId);
            let folderInfo = account.getFolderById(folderId);
            let conn = await account.ensureConnection();
            let readMap = new Map();
            let flagMap = new Map();
            if (changes.add) {
              if (changes.add.includes("\\Seen")) {
                readMap.set(messageServerId, true);
              }
              if (changes.add.includes("\\Flagged")) {
                flagMap.set(messageServerId, true);
              }
            }
            if (changes.remove) {
              if (changes.remove.includes("\\Seen")) {
                readMap.set(messageServerId, false);
              }
              if (changes.remove.includes("\\Flagged")) {
                flagMap.set(messageServerId, false);
              }
            }
            syncState.syncKey = (await modifyFolderMessages(conn, {
              folderServerId: folderInfo.serverId,
              folderSyncKey: syncState.syncKey,
              read: readMap,
              flag: flagMap
            })).syncKey;
            umidChanges.delete(marker.umid);
            await ctx.finishTask({
              syncStates: new Map([[folderId, syncState.rawSyncState]]),
              complexTaskState: persistentState
            });
          }
        }
      ]);
    }
  });

  // src/backend/tasks/draft_save.js
  var draft_save_default;
  var init_draft_save = __esm({
    "src/backend/tasks/draft_save.js"() {
      init_logic();
      init_task_definer();
      init_conv_churn_driver();
      init_id_conversions();
      init_syncbase();
      init_quotechew();
      draft_save_default = task_definer_default.defineSimpleTask([
        {
          name: "draft_save",
          async plan(ctx, req) {
            let { messageId } = req;
            let convId = convIdFromMessageId(messageId);
            let fromDb = await ctx.beginMutate({
              conversations: new Map([[convId, null]]),
              messagesByConversation: new Map([[convId, null]])
            });
            let messages = fromDb.messagesByConversation.get(convId);
            let modifiedMessagesMap = new Map();
            let messageInfo = messages.find((msg) => msg.id === messageId);
            if (messageInfo === null) {
              throw new Error("moot");
            }
            let draftFields = req.draftFields;
            messageInfo.date = draftFields.date;
            messageInfo.to = draftFields.to;
            messageInfo.cc = draftFields.cc;
            messageInfo.bcc = draftFields.bcc;
            messageInfo.subject = draftFields.subject;
            let textRep = messageInfo.bodyReps.find((rep) => {
              return rep.type === "plain";
            });
            textRep.contentBlob = new Blob([JSON.stringify([1, draftFields.textBody])], { type: "application/json" });
            try {
              let parsedContent = quoteProcessTextBody(draftFields.textBody);
              messageInfo.snippet = generateSnippet(parsedContent, DESIRED_SNIPPET_LENGTH);
            } catch (ex) {
              logic.fail(ex);
            }
            modifiedMessagesMap.set(messageId, messageInfo);
            let oldConvInfo = fromDb.conversations.get(req.convId);
            let convInfo = churnConversationDriver(convId, oldConvInfo, messages);
            await ctx.finishTask({
              mutations: {
                conversations: new Map([[convId, convInfo]]),
                messages: modifiedMessagesMap
              }
            });
          },
          execute: null
        }
      ]);
    }
  });

  // src/vendor/safe-base64.js
  function mimeStyleBase64Encode(data) {
    var wholeLines = Math.floor(data.length / 57);
    var partialBytes = data.length - wholeLines * 57;
    var encodedLength = wholeLines * 78;
    if (partialBytes) {
      encodedLength += Math.ceil(partialBytes / 3) * 4 + 2;
    }
    var encoded = new Uint8Array(encodedLength);
    function encode6Bits(nibbly) {
      if (nibbly <= 25) {
        encoded[iWrite++] = 65 + nibbly;
      } else if (nibbly <= 51) {
        encoded[iWrite++] = 97 - 26 + nibbly;
      } else if (nibbly <= 61) {
        encoded[iWrite++] = 48 - 52 + nibbly;
      } else if (nibbly === 62) {
        encoded[iWrite++] = 43;
      } else {
        encoded[iWrite++] = 47;
      }
    }
    var iRead = 0, iWrite = 0, bytesToRead;
    for (bytesToRead = data.length; bytesToRead >= 3; bytesToRead -= 3) {
      var b1 = data[iRead++], b2 = data[iRead++], b3 = data[iRead++];
      encode6Bits(b1 >> 2);
      encode6Bits((b1 & 3) << 4 | b2 >> 4);
      encode6Bits((b2 & 15) << 2 | b3 >> 6);
      encode6Bits(b3 & 63);
      if (iRead % 57 === 0 || bytesToRead === 3) {
        encoded[iWrite++] = 13;
        encoded[iWrite++] = 10;
      }
    }
    switch (bytesToRead) {
      case 2:
        b1 = data[iRead++];
        b2 = data[iRead++];
        encode6Bits(b1 >> 2);
        encode6Bits((b1 & 3) << 4 | b2 >> 4);
        encode6Bits((b2 & 15) << 2 | 0);
        encoded[iWrite++] = 61;
        encoded[iWrite++] = 13;
        encoded[iWrite++] = 10;
        break;
      case 1:
        b1 = data[iRead++];
        encode6Bits(b1 >> 2);
        encode6Bits((b1 & 3) << 4 | 0);
        encoded[iWrite++] = 61;
        encoded[iWrite++] = 61;
        encoded[iWrite++] = 13;
        encoded[iWrite++] = 10;
        break;
    }
    return encoded;
  }
  var init_safe_base64 = __esm({
    "src/vendor/safe-base64.js"() {
    }
  });

  // src/backend/tasks/draft_attach.js
  var draft_attach_default;
  var init_draft_attach = __esm({
    "src/backend/tasks/draft_attach.js"() {
      init_syncbase();
      init_task_definer();
      init_conv_churn_driver();
      init_mail_rep();
      init_safe_base64();
      init_id_conversions();
      draft_attach_default = task_definer_default.defineSimpleTask([
        {
          name: "draft_attach",
          async plan(ctx, req) {
            let { messageId } = req;
            let convId = convIdFromMessageId(messageId);
            let fromDb = await ctx.beginMutate({
              conversations: new Map([[convId, null]]),
              messagesByConversation: new Map([[convId, null]])
            });
            let messages = fromDb.messagesByConversation.get(convId);
            let modifiedMessagesMap = new Map();
            let messageInfo = messages.find((msg) => msg.id === messageId);
            if (messageInfo === null) {
              throw new Error("moot");
            }
            let messageKey = [messageInfo.id, messageInfo.date];
            const attachmentDef = req.attachmentDef;
            const wholeBlob = attachmentDef.blob;
            messageInfo.attaching = makeAttachmentPart({
              relId: attachmentDef.relId,
              name: attachmentDef.name,
              type: wholeBlob.type,
              sizeEstimate: wholeBlob.size,
              downloadState: "draft",
              file: []
            });
            let blobOffset = 0;
            while (blobOffset < wholeBlob.size) {
              let nextOffset = Math.min(wholeBlob.size, blobOffset + BLOB_BASE64_BATCH_CONVERT_SIZE);
              console.log("attachBlobToDraft: fetching", blobOffset, "to", nextOffset, "of", wholeBlob.size);
              let slicedBlob = wholeBlob.slice(blobOffset, nextOffset);
              blobOffset = nextOffset;
              let arraybuffer = await slicedBlob.arrayBuffer();
              let binaryDataU8 = new Uint8Array(arraybuffer);
              let encodedU8 = mimeStyleBase64Encode(binaryDataU8);
              messageInfo.attaching.file.push(new Blob([encodedU8], { type: wholeBlob.type }));
              await ctx.dangerousIncrementalWrite({
                messages: new Map([[messageId, messageInfo]])
              });
              let flushedReads = await ctx.mutateMore({
                flushedMessageReads: true,
                messages: new Map([[messageKey, null]])
              });
              messageInfo = flushedReads.messages.get(messageId);
            }
            messageInfo.hasAttachments = true;
            messageInfo.attachments.push(messageInfo.attaching);
            delete messageInfo.attaching;
            modifiedMessagesMap.set(messageId, messageInfo);
            let oldConvInfo = fromDb.conversations.get(req.convId);
            let convInfo = churnConversationDriver(convId, oldConvInfo, messages);
            await ctx.finishTask({
              mutations: {
                conversations: new Map([[convId, convInfo]]),
                messages: modifiedMessagesMap
              }
            });
          },
          execute: null
        }
      ]);
    }
  });

  // src/backend/tasks/draft_detach.js
  var draft_detach_default;
  var init_draft_detach = __esm({
    "src/backend/tasks/draft_detach.js"() {
      init_task_definer();
      init_conv_churn_driver();
      init_id_conversions();
      draft_detach_default = task_definer_default.defineSimpleTask([
        {
          name: "draft_detach",
          async plan(ctx, req) {
            let { messageId } = req;
            let convId = convIdFromMessageId(messageId);
            let fromDb = await ctx.beginMutate({
              conversations: new Map([[convId, null]]),
              messagesByConversation: new Map([[convId, null]])
            });
            let messages = fromDb.messagesByConversation.get(convId);
            let modifiedMessagesMap = new Map();
            let messageInfo = messages.find((msg) => msg.id === messageId);
            if (messageInfo === null) {
              throw new Error("moot");
            }
            let attachmentIndex = messageInfo.attachments.findIndex((att) => att.relId === req.attachmentRelId);
            if (attachmentIndex === -1) {
              throw new Error("moot");
            }
            messageInfo.attachments.splice(attachmentIndex, 1);
            messageInfo.hasAttachments = !!messageInfo.attachments.length;
            modifiedMessagesMap.set(messageId, messageInfo);
            let oldConvInfo = fromDb.conversations.get(req.convId);
            let convInfo = churnConversationDriver(convId, oldConvInfo, messages);
            await ctx.finishTask({
              mutations: {
                conversations: new Map([[convId, convInfo]]),
                messages: modifiedMessagesMap
              }
            });
          },
          execute: null
        }
      ]);
    }
  });

  // src/backend/tasks/draft_delete.js
  var draft_delete_default;
  var init_draft_delete = __esm({
    "src/backend/tasks/draft_delete.js"() {
      init_task_definer();
      init_conv_churn_driver();
      init_id_conversions();
      draft_delete_default = task_definer_default.defineSimpleTask([
        {
          name: "draft_delete",
          async plan(ctx, req) {
            let { messageId } = req;
            let convId = convIdFromMessageId(messageId);
            let fromDb = await ctx.beginMutate({
              conversations: new Map([[convId, null]]),
              messagesByConversation: new Map([[convId, null]])
            });
            let messages = fromDb.messagesByConversation.get(convId);
            let modifiedMessagesMap = new Map();
            let draftIndex = messages.findIndex((msg) => msg.id === messageId);
            if (draftIndex === -1) {
              throw new Error("moot");
            }
            messages.splice(draftIndex, 1);
            modifiedMessagesMap.set(messageId, null);
            let modifiedConversations = new Map();
            if (messages.length) {
              let oldConvInfo = fromDb.conversations.get(req.convId);
              let convInfo = churnConversationDriver(convId, oldConvInfo, messages);
              modifiedConversations.set(convId, convInfo);
            } else {
              modifiedConversations.set(convId, null);
            }
            await ctx.finishTask({
              mutations: {
                conversations: modifiedConversations,
                messages: modifiedMessagesMap
              }
            });
          },
          execute: null
        }
      ]);
    }
  });

  // src/backend/accounts/activesync/smotocol/send_mail.js
  async function sendMail(conn, { mimeBlob, progress }) {
    let w = new Writer("1.3", 1, "UTF-8", null, "blob");
    w.stag(ComposeMail_default.Tags.SendMail).tag(ComposeMail_default.Tags.ClientId, Date.now().toString() + "@mozgaia").tag(ComposeMail_default.Tags.SaveInSentItems).stag(ComposeMail_default.Tags.Mime).opaque(mimeBlob).etag().etag();
    let response = await conn.postCommand(w, {
      uploadProgress: progress
    });
    if (response === null) {
      return;
    }
    throw new Error("unknown");
  }
  var init_send_mail = __esm({
    "src/backend/accounts/activesync/smotocol/send_mail.js"() {
      init_wbxml();
      init_ComposeMail();
    }
  });

  // src/backend/accounts/activesync/smotocol/send_mail_12x.js
  async function sendMail2(conn, { mimeBlob, progress }) {
    await conn.postData("SendMail", "message/rfc822", mimeBlob, {
      extraParams: {
        SaveInSent: "T"
      },
      uploadProgress: progress
    });
  }
  var init_send_mail_12x = __esm({
    "src/backend/accounts/activesync/smotocol/send_mail_12x.js"() {
    }
  });

  // src/vendor/stringencoding.js
  var require_stringencoding = __commonJS({
    "src/vendor/stringencoding.js"() {
      "use strict";
      define(function(require2) {
        var utf7 = require2("utf7");
        return {
          TextEncoder: function(encoding) {
            var encoder = new globalThis.TextEncoder(encoding);
            this.encode = encoder.encode.bind(encoder);
          },
          TextDecoder: function(encoding) {
            encoding = encoding && encoding.toLowerCase();
            if (encoding === "utf-7" || encoding === "utf7") {
              this.decode = function(buf) {
                var mimefuncs2 = require2("mimefuncs");
                return utf7.decode(mimefuncs2.fromTypedArray(buf));
              };
            } else {
              var decoder = new globalThis.TextDecoder(encoding);
              this.decode = decoder.decode.bind(decoder);
            }
          }
        };
      });
    }
  });

  // src/vendor/mimefuncs.js
  var require_mimefuncs = __commonJS({
    "src/vendor/mimefuncs.js"(exports, module) {
      (function(root, factory) {
        "use strict";
        var encoding;
        if (typeof define === "function" && define.amd) {
          define(["stringencoding"], function(encoding2) {
            return factory(encoding2.TextEncoder, encoding2.TextDecoder, root.btoa);
          });
        } else if (typeof exports === "object") {
          encoding = require_stringencoding();
          module.exports = factory(encoding.TextEncoder, encoding.TextDecoder, root.btoa);
        } else {
          root.mimefuncs = factory(root.TextEncoder, root.TextDecoder, root.btoa);
        }
      })(exports, function(TextEncoder2, TextDecoder2, btoa2) {
        "use strict";
        btoa2 = btoa2 || base64Encode;
        var mimefuncs2 = {
          mimeEncode: function(data, fromCharset) {
            fromCharset = fromCharset || "UTF-8";
            var buffer = mimefuncs2.charset.convert(data || "", fromCharset), ranges = [
              [9],
              [10],
              [13],
              [32],
              [33],
              [35, 60],
              [62],
              [64, 94],
              [96, 126]
            ], result = "", ord;
            for (var i = 0, len = buffer.length; i < len; i++) {
              ord = buffer[i];
              if (mimefuncs2._checkRanges(ord, ranges) && !((ord === 32 || ord === 9) && (i === len - 1 || buffer[i + 1] === 10 || buffer[i + 1] === 13))) {
                result += String.fromCharCode(ord);
                continue;
              }
              result += "=" + (ord < 16 ? "0" : "") + ord.toString(16).toUpperCase();
            }
            return result;
          },
          mimeDecode: function(str, fromCharset) {
            str = (str || "").toString();
            fromCharset = fromCharset || "UTF-8";
            var encodedBytesCount = (str.match(/\=[\da-fA-F]{2}/g) || []).length, bufferLength = str.length - encodedBytesCount * 2, chr, hex, buffer = new Uint8Array(bufferLength), bufferPos = 0;
            for (var i = 0, len = str.length; i < len; i++) {
              chr = str.charAt(i);
              if (chr === "=" && (hex = str.substr(i + 1, 2)) && /[\da-fA-F]{2}/.test(hex)) {
                buffer[bufferPos++] = parseInt(hex, 16);
                i += 2;
                continue;
              }
              buffer[bufferPos++] = chr.charCodeAt(0);
            }
            return mimefuncs2.charset.decode(buffer, fromCharset);
          },
          base64Encode: function(data, fromCharset) {
            var buf, b64;
            if (fromCharset !== "binary" && typeof data !== "string") {
              buf = mimefuncs2.charset.convert(data || "", fromCharset);
            } else {
              buf = data;
            }
            b64 = mimefuncs2.base64.encode(buf);
            return mimefuncs2._addSoftLinebreaks(b64, "base64");
          },
          base64Decode: function(str, fromCharset) {
            var buf = mimefuncs2.base64.decode(str || "", "buffer");
            return mimefuncs2.charset.decode(buf, fromCharset);
          },
          quotedPrintableEncode: function(data, fromCharset) {
            var mimeEncodedStr = mimefuncs2.mimeEncode(data, fromCharset);
            mimeEncodedStr = mimeEncodedStr.replace(/\r?\n|\r/g, "\r\n").replace(/[\t ]+$/gm, function(spaces) {
              return spaces.replace(/ /g, "=20").replace(/\t/g, "=09");
            });
            return mimefuncs2._addSoftLinebreaks(mimeEncodedStr, "qp");
          },
          quotedPrintableDecode: function(str, fromCharset) {
            str = (str || "").toString();
            str = str.replace(/[\t ]+$/gm, "").replace(/\=(?:\r?\n|$)/g, "");
            return mimefuncs2.mimeDecode(str, fromCharset);
          },
          mimeWordEncode: function(data, mimeWordEncoding, maxLength, fromCharset) {
            mimeWordEncoding = (mimeWordEncoding || "Q").toString().toUpperCase().trim().charAt(0);
            if (!fromCharset && typeof maxLength === "string" && !maxLength.match(/^[0-9]+$/)) {
              fromCharset = maxLength;
              maxLength = void 0;
            }
            maxLength = maxLength || 0;
            var encodedStr, toCharset = "UTF-8", i, len, parts;
            if (maxLength && maxLength > 7 + toCharset.length) {
              maxLength -= 7 + toCharset.length;
            }
            if (mimeWordEncoding === "Q") {
              encodedStr = mimefuncs2.mimeEncode(data, fromCharset);
              encodedStr = encodedStr.replace(/[\r\n\t_]/g, function(chr) {
                var code = chr.charCodeAt(0);
                return "=" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
              }).replace(/\s/g, "_");
            } else if (mimeWordEncoding === "B") {
              encodedStr = typeof data === "string" ? data : mimefuncs2.decode(data, fromCharset);
              maxLength = Math.max(3, (maxLength - maxLength % 4) / 4 * 3);
            }
            if (maxLength && encodedStr.length > maxLength) {
              if (mimeWordEncoding === "Q") {
                encodedStr = mimefuncs2._splitMimeEncodedString(encodedStr, maxLength).join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
              } else {
                parts = [];
                for (i = 0, len = encodedStr.length; i < len; i += maxLength) {
                  parts.push(mimefuncs2.base64.encode(encodedStr.substr(i, maxLength)));
                }
                if (parts.length > 1) {
                  return "=?" + toCharset + "?" + mimeWordEncoding + "?" + parts.join("?= =?" + toCharset + "?" + mimeWordEncoding + "?") + "?=";
                } else {
                  encodedStr = parts.join("");
                }
              }
            } else if (mimeWordEncoding === "B") {
              encodedStr = mimefuncs2.base64.encode(encodedStr);
            }
            return "=?" + toCharset + "?" + mimeWordEncoding + "?" + encodedStr + (encodedStr.substr(-2) === "?=" ? "" : "?=");
          },
          mimeWordsEncode: function(data, mimeWordEncoding, maxLength, fromCharset) {
            if (!fromCharset && typeof maxLength === "string" && !maxLength.match(/^[0-9]+$/)) {
              fromCharset = maxLength;
              maxLength = void 0;
            }
            maxLength = maxLength || 0;
            var decodedValue = mimefuncs2.charset.decode(mimefuncs2.charset.convert(data || "", fromCharset)), encodedValue;
            encodedValue = decodedValue.replace(/([^\s\u0080-\uFFFF]*[\u0080-\uFFFF]+[^\s\u0080-\uFFFF]*(?:\s+[^\s\u0080-\uFFFF]*[\u0080-\uFFFF]+[^\s\u0080-\uFFFF]*\s*)?)+/g, function(match) {
              return match.length ? mimefuncs2.mimeWordEncode(match, mimeWordEncoding || "Q", maxLength) : "";
            });
            return encodedValue;
          },
          mimeWordDecode: function(str) {
            str = (str || "").toString().trim();
            var fromCharset, encoding, match;
            match = str.match(/^\=\?([\w_\-\*]+)\?([QqBb])\?([^\?]+)\?\=$/i);
            if (!match) {
              return str;
            }
            fromCharset = match[1].split("*").shift();
            encoding = (match[2] || "Q").toString().toUpperCase();
            str = (match[3] || "").replace(/_/g, " ");
            if (encoding === "B") {
              return mimefuncs2.base64Decode(str, fromCharset);
            } else if (encoding === "Q") {
              return mimefuncs2.mimeDecode(str, fromCharset);
            } else {
              return str;
            }
          },
          mimeWordsDecode: function(str) {
            str = (str || "").toString();
            str = str.replace(/(=\?[^?]+\?[QqBb]\?[^?]+\?=)\s+(?==\?[^?]+\?[QqBb]\?[^?]+\?=)/g, "$1").replace(/\=\?([\w_\-\*]+)\?([QqBb])\?[^\?]+\?\=/g, function(mimeWord) {
              return mimefuncs2.mimeWordDecode(mimeWord);
            });
            return str;
          },
          foldLines: function(str, lineLengthMax, afterSpace) {
            str = (str || "").toString();
            lineLengthMax = lineLengthMax || 76;
            var pos = 0, len = str.length, result = "", line, match;
            while (pos < len) {
              line = str.substr(pos, lineLengthMax);
              if (line.length < lineLengthMax) {
                result += line;
                break;
              }
              if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
                line = match[0];
                result += line;
                pos += line.length;
                continue;
              } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
              } else if (match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/)) {
                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
              }
              result += line;
              pos += line.length;
              if (pos < len) {
                result += "\r\n";
              }
            }
            return result;
          },
          headerLineEncode: function(key, value, fromCharset) {
            var encodedValue = mimefuncs2.mimeWordsEncode(value, "Q", 52, fromCharset);
            return mimefuncs2.foldLines(key + ": " + encodedValue, 76);
          },
          headerLineDecode: function(headerLine) {
            var line = (headerLine || "").toString().replace(/(?:\r?\n|\r)[ \t]*/g, " ").trim(), match = line.match(/^\s*([^:]+):(.*)$/), key = (match && match[1] || "").trim(), value = (match && match[2] || "").trim();
            return {
              key,
              value
            };
          },
          headerLinesDecode: function(headers) {
            var lines = headers.split(/\r?\n|\r/), headersObj = {}, key, value, header, i, len;
            for (i = lines.length - 1; i >= 0; i--) {
              if (i && lines[i].match(/^\s/)) {
                lines[i - 1] += "\r\n" + lines[i];
                lines.splice(i, 1);
              }
            }
            for (i = 0, len = lines.length; i < len; i++) {
              header = mimefuncs2.headerLineDecode(lines[i]);
              key = (header.key || "").toString().toLowerCase().trim();
              value = header.value || "";
              if (!headersObj[key]) {
                headersObj[key] = value;
              } else {
                headersObj[key] = [].concat(headersObj[key], value);
              }
            }
            return headersObj;
          },
          toTypedArray: function(binaryString) {
            var buf = new Uint8Array(binaryString.length);
            for (var i = 0, len = binaryString.length; i < len; i++) {
              buf[i] = binaryString.charCodeAt(i);
            }
            return buf;
          },
          fromTypedArray: function(buf) {
            var i, l;
            if (!buf.buffer) {
              buf = new Uint8Array(buf);
            }
            var sbits = new Array(buf.length);
            for (i = 0, l = buf.length; i < l; i++) {
              sbits[i] = String.fromCharCode(buf[i]);
            }
            return sbits.join("");
          },
          parseHeaderValue: function(str) {
            var response = {
              value: false,
              params: {}
            }, key = false, value = "", type = "value", quote = false, escaped = false, chr;
            for (var i = 0, len = str.length; i < len; i++) {
              chr = str.charAt(i);
              if (type === "key") {
                if (chr === "=") {
                  key = value.trim().toLowerCase();
                  type = "value";
                  value = "";
                  continue;
                }
                value += chr;
              } else {
                if (escaped) {
                  value += chr;
                } else if (chr === "\\") {
                  escaped = true;
                  continue;
                } else if (quote && chr === quote) {
                  quote = false;
                } else if (!quote && chr === '"') {
                  quote = chr;
                } else if (!quote && chr === ";") {
                  if (key === false) {
                    response.value = value.trim();
                  } else {
                    response.params[key] = value.trim();
                  }
                  type = "key";
                  value = "";
                } else {
                  value += chr;
                }
                escaped = false;
              }
            }
            if (type === "value") {
              if (key === false) {
                response.value = value.trim();
              } else {
                response.params[key] = value.trim();
              }
            } else if (value.trim()) {
              response.params[value.trim().toLowerCase()] = "";
            }
            Object.keys(response.params).forEach(function(key2) {
              var actualKey, nr, match, value2;
              if (match = key2.match(/(\*(\d+)|\*(\d+)\*|\*)$/)) {
                actualKey = key2.substr(0, match.index);
                nr = Number(match[2] || match[3]) || 0;
                if (!response.params[actualKey] || typeof response.params[actualKey] !== "object") {
                  response.params[actualKey] = {
                    charset: false,
                    values: []
                  };
                }
                value2 = response.params[key2];
                if (nr === 0 && match[0].substr(-1) === "*" && (match = value2.match(/^([^']*)'[^']*'(.*)$/))) {
                  response.params[actualKey].charset = match[1] || "iso-8859-1";
                  value2 = match[2];
                }
                response.params[actualKey].values[nr] = value2;
                delete response.params[key2];
              }
            });
            Object.keys(response.params).forEach(function(key2) {
              var value2;
              if (response.params[key2] && Array.isArray(response.params[key2].values)) {
                value2 = response.params[key2].values.map(function(val) {
                  return val || "";
                }).join("");
                if (response.params[key2].charset) {
                  response.params[key2] = "=?" + response.params[key2].charset + "?Q?" + value2.replace(/[=\?_\s]/g, function(s) {
                    var c = s.charCodeAt(0).toString(16);
                    if (s === " ") {
                      return "_";
                    } else {
                      return "%" + (c.length < 2 ? "0" : "") + c;
                    }
                  }).replace(/%/g, "=") + "?=";
                } else {
                  response.params[key2] = value2;
                }
              }
            }.bind(this));
            return response;
          },
          continuationEncode: function(key, data, maxLength, fromCharset) {
            var list = [];
            var encodedStr = typeof data === "string" ? data : mimefuncs2.decode(data, fromCharset);
            var chr;
            var line;
            var startPos = 0;
            var isEncoded = false;
            maxLength = maxLength || 50;
            if (/^[\w.\- ]*$/.test(data)) {
              if (encodedStr.length <= maxLength) {
                return [{
                  key,
                  value: /[\s";=]/.test(encodedStr) ? '"' + encodedStr + '"' : encodedStr
                }];
              }
              encodedStr = encodedStr.replace(new RegExp(".{" + maxLength + "}", "g"), function(str) {
                list.push({
                  line: str
                });
                return "";
              });
              if (encodedStr) {
                list.push({
                  line: encodedStr
                });
              }
            } else {
              line = "utf-8''";
              isEncoded = true;
              startPos = 0;
              for (var i = 0, len = encodedStr.length; i < len; i++) {
                chr = encodedStr[i];
                if (isEncoded) {
                  chr = encodeURIComponent(chr);
                } else {
                  chr = chr === " " ? chr : encodeURIComponent(chr);
                  if (chr !== encodedStr[i]) {
                    if ((encodeURIComponent(line) + chr).length >= maxLength) {
                      list.push({
                        line,
                        encoded: isEncoded
                      });
                      line = "";
                      startPos = i - 1;
                    } else {
                      isEncoded = true;
                      i = startPos;
                      line = "";
                      continue;
                    }
                  }
                }
                if ((line + chr).length >= maxLength) {
                  list.push({
                    line,
                    encoded: isEncoded
                  });
                  line = chr = encodedStr[i] === " " ? " " : encodeURIComponent(encodedStr[i]);
                  if (chr === encodedStr[i]) {
                    isEncoded = false;
                    startPos = i - 1;
                  } else {
                    isEncoded = true;
                  }
                } else {
                  line += chr;
                }
              }
              if (line) {
                list.push({
                  line,
                  encoded: isEncoded
                });
              }
            }
            return list.map(function(item, i2) {
              return {
                key: key + "*" + i2 + (item.encoded ? "*" : ""),
                value: /[\s";=]/.test(item.line) ? '"' + item.line + '"' : item.line
              };
            });
          },
          _splitMimeEncodedString: function(str, maxlen) {
            var curLine, match, chr, done, lines = [];
            maxlen = Math.max(maxlen || 0, 12);
            while (str.length) {
              curLine = str.substr(0, maxlen);
              if (match = curLine.match(/\=[0-9A-F]?$/i)) {
                curLine = curLine.substr(0, match.index);
              }
              done = false;
              while (!done) {
                done = true;
                if (match = str.substr(curLine.length).match(/^\=([0-9A-F]{2})/i)) {
                  chr = parseInt(match[1], 16);
                  if (chr < 194 && chr > 127) {
                    curLine = curLine.substr(0, curLine.length - 3);
                    done = false;
                  }
                }
              }
              if (curLine.length) {
                lines.push(curLine);
              }
              str = str.substr(curLine.length);
            }
            return lines;
          },
          _addSoftLinebreaks: function(str, encoding) {
            var lineLengthMax = 76;
            encoding = (encoding || "base64").toString().toLowerCase().trim();
            if (encoding === "qp") {
              return mimefuncs2._addQPSoftLinebreaks(str, lineLengthMax);
            } else {
              return mimefuncs2._addBase64SoftLinebreaks(str, lineLengthMax);
            }
          },
          _addBase64SoftLinebreaks: function(base64EncodedStr, lineLengthMax) {
            base64EncodedStr = (base64EncodedStr || "").toString().trim();
            return base64EncodedStr.replace(new RegExp(".{" + lineLengthMax + "}", "g"), "$&\r\n").trim();
          },
          _addQPSoftLinebreaks: function(qpEncodedStr, lineLengthMax) {
            qpEncodedStr = (qpEncodedStr || "").toString();
            lineLengthMax = lineLengthMax || 76;
            var pos = 0, len = qpEncodedStr.length, match, code, line, lineMargin = Math.floor(lineLengthMax / 3), result = "";
            while (pos < len) {
              line = qpEncodedStr.substr(pos, lineLengthMax);
              if (match = line.match(/\r\n/)) {
                line = line.substr(0, match.index + match[0].length);
                result += line;
                pos += line.length;
                continue;
              }
              if (line.substr(-1) === "\n") {
                result += line;
                pos += line.length;
                continue;
              } else if (match = line.substr(-lineMargin).match(/\n.*?$/)) {
                line = line.substr(0, line.length - (match[0].length - 1));
                result += line;
                pos += line.length;
                continue;
              } else if (line.length > lineLengthMax - lineMargin && (match = line.substr(-lineMargin).match(/[ \t\.,!\?][^ \t\.,!\?]*$/))) {
                line = line.substr(0, line.length - (match[0].length - 1));
              } else if (line.substr(-1) === "\r") {
                line = line.substr(0, line.length - 1);
              } else {
                if (line.match(/\=[\da-f]{0,2}$/i)) {
                  if (match = line.match(/\=[\da-f]{0,1}$/i)) {
                    line = line.substr(0, line.length - match[0].length);
                  }
                  while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/\=[\da-f]{2}$/ig))) {
                    code = parseInt(match[0].substr(1, 2), 16);
                    if (code < 128) {
                      break;
                    }
                    line = line.substr(0, line.length - 3);
                    if (code >= 192) {
                      break;
                    }
                  }
                }
              }
              if (pos + line.length < len && line.substr(-1) !== "\n") {
                if (line.length === lineLengthMax && line.match(/\=[\da-f]{2}$/i)) {
                  line = line.substr(0, line.length - 3);
                } else if (line.length === lineLengthMax) {
                  line = line.substr(0, line.length - 1);
                }
                pos += line.length;
                line += "=\r\n";
              } else {
                pos += line.length;
              }
              result += line;
            }
            return result;
          },
          _checkRanges: function(nr, ranges) {
            for (var i = ranges.length - 1; i >= 0; i--) {
              if (!ranges[i].length) {
                continue;
              }
              if (ranges[i].length === 1 && nr === ranges[i][0]) {
                return true;
              }
              if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
                return true;
              }
            }
            return false;
          }
        };
        mimefuncs2.charset = {
          encode: function(str) {
            return new TextEncoder2("UTF-8").encode(str);
          },
          decode: function(buf, fromCharset) {
            fromCharset = mimefuncs2.charset.normalizeCharset(fromCharset || "UTF-8");
            if (!buf) {
              console.error(new Error().stack);
            }
            if (!buf.buffer) {
              buf = new Uint8Array(buf);
            }
            try {
              return new TextDecoder2(fromCharset).decode(buf);
            } catch (E) {
              try {
                return new TextDecoder2("utf-8", {
                  fatal: true
                }).decode(buf);
              } catch (E2) {
                try {
                  return new TextDecoder2("iso-8859-15").decode(buf);
                } catch (E3) {
                  return mimefuncs2.fromTypedArray(buf);
                }
              }
            }
          },
          convert: function(data, fromCharset) {
            fromCharset = mimefuncs2.charset.normalizeCharset(fromCharset || "UTF-8");
            var bufString;
            if (typeof data !== "string") {
              if (fromCharset.match(/^utf[\-_]?8$/)) {
                return data;
              }
              bufString = mimefuncs2.charset.decode(data, fromCharset);
              return mimefuncs2.charset.encode(bufString);
            }
            return mimefuncs2.charset.encode(data);
          },
          normalizeCharset: function(charset) {
            var match;
            if (match = charset.match(/^utf[\-_]?(\d+)$/i)) {
              return "UTF-" + match[1];
            }
            if (match = charset.match(/^win[\-_]?(\d+)$/i)) {
              return "WINDOWS-" + match[1];
            }
            if (match = charset.match(/^latin[\-_]?(\d+)$/i)) {
              return "ISO-8859-" + match[1];
            }
            return charset;
          }
        };
        mimefuncs2.base64 = {
          encode: function(data) {
            if (!data) {
              return "";
            }
            if (typeof data === "string") {
              return btoa2(unescape(encodeURIComponent(data)));
            }
            var len = data.byteLength, binStr = "";
            if (!data.buffer) {
              data.buffer = new Uint8Array(data);
            }
            for (var i = 0; i < len; i++) {
              binStr += String.fromCharCode(data[i]);
            }
            return btoa2(binStr);
          },
          decode: function(data, outputEncoding) {
            outputEncoding = (outputEncoding || "buffer").toLowerCase().trim();
            var buf = mimefuncs2.base64.toTypedArray(data);
            if (outputEncoding === "string") {
              return mimefuncs2.charset.decode(buf);
            } else {
              return buf;
            }
          },
          toTypedArray: function(base64Str) {
            var bitsSoFar = 0;
            var validBits = 0;
            var iOut = 0;
            var arr = new Uint8Array(Math.ceil(base64Str.length * 3 / 4));
            var c;
            var bits;
            for (var i = 0, len = base64Str.length; i < len; i++) {
              c = base64Str.charCodeAt(i);
              if (c >= 65 && c <= 90) {
                bits = c - 65;
              } else if (c >= 97 && c <= 122) {
                bits = c - 97 + 26;
              } else if (c >= 48 && c <= 57) {
                bits = c - 48 + 52;
              } else if (c === 43) {
                bits = 62;
              } else if (c === 47) {
                bits = 63;
              } else if (c === 61) {
                validBits = 0;
                continue;
              } else {
                continue;
              }
              bitsSoFar = bitsSoFar << 6 | bits;
              validBits += 6;
              if (validBits >= 8) {
                validBits -= 8;
                arr[iOut++] = bitsSoFar >> validBits;
                if (validBits === 2) {
                  bitsSoFar &= 3;
                } else if (validBits === 4) {
                  bitsSoFar &= 15;
                }
              }
            }
            if (iOut < arr.length) {
              return arr.subarray(0, iOut);
            }
            return arr;
          }
        };
        function base64Encode(input) {
          var str = String(input);
          var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          for (var block, charCode, idx = 0, map = chars, output = ""; str.charAt(idx | 0) || (map = "=", idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
            charCode = str.charCodeAt(idx += 3 / 4);
            if (charCode > 255) {
              throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
            }
            block = block << 8 | charCode;
          }
          return output;
        }
        return mimefuncs2;
      });
    }
  });

  // src/vendor/punycode.js
  var require_punycode = __commonJS({
    "src/vendor/punycode.js"(exports, module) {
      (function(root) {
        var freeExports = typeof exports == "object" && exports;
        var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
        var freeGlobal = typeof global == "object" && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
          root = freeGlobal;
        }
        var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^ -~]/, regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error(type) {
          throw RangeError(errors[type]);
        }
        function map(array, fn) {
          var length = array.length;
          while (length--) {
            array[length] = fn(array[length]);
          }
          return array;
        }
        function mapDomain(string, fn) {
          return map(string.split(regexSeparators), fn).join(".");
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          return map(array, function(value) {
            var output = "";
            if (value > 65535) {
              value -= 65536;
              output += stringFromCharCode(value >>> 10 & 1023 | 55296);
              value = 56320 | value & 1023;
            }
            output += stringFromCharCode(value);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode(input) {
          var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            for (oldi = i, w = 1, k = base; ; k += base) {
              if (index >= inputLength) {
                error("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error("overflow");
              }
              i += digit * w;
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (digit < t) {
                break;
              }
              baseMinusT = base - t;
              if (w > floor(maxInt / baseMinusT)) {
                error("overflow");
              }
              w *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            if (floor(i / out) > maxInt - n) {
              error("overflow");
            }
            n += floor(i / out);
            i %= out;
            output.splice(i++, 0, n);
          }
          return ucs2encode(output);
        }
        function encode(input) {
          var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n = initialN;
          delta = 0;
          bias = initialBias;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error("overflow");
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue < n && ++delta > maxInt) {
                error("overflow");
              }
              if (currentValue == n) {
                for (q = delta, k = base; ; k += base) {
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  qMinusT = q - t;
                  baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n;
          }
          return output.join("");
        }
        function toUnicode(domain) {
          return mapDomain(domain, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(domain) {
          return mapDomain(domain, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
          });
        }
        punycode2 = {
          "version": "1.2.4",
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode,
          "encode": encode,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          define("punycode", function() {
            return punycode2;
          });
        } else if (freeExports && !freeExports.nodeType) {
          if (freeModule) {
            freeModule.exports = punycode2;
          } else {
            for (key in punycode2) {
              punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
            }
          }
        } else {
          root.punycode = punycode2;
        }
      })(exports);
    }
  });

  // src/vendor/mailbuild.js
  var require_mailbuild = __commonJS({
    "src/vendor/mailbuild.js"(exports, module) {
      (function(root, factory) {
        "use strict";
        if (typeof define === "function" && define.amd) {
          define(["mimefuncs", "mimetypes", "punycode", "addressparser"], factory);
        } else if (typeof exports === "object") {
          module.exports = factory(require_mimefuncs(), require_mimetypes(), require_punycode(), require_addressparser());
        } else {
          root.mailbuild = factory(mimefuncs, mimetypes, punycode, addressparser);
        }
      })(exports, function(mimefuncs2, mimetypes3, punycode2, addressparser2) {
        "use strict";
        function MimeNode2(contentType, options) {
          this.nodeCounter = 0;
          options = options || {};
          this.baseBoundary = options.baseBoundary || Date.now().toString() + Math.random();
          this.date = new Date();
          this.rootNode = options.rootNode || this;
          if (options.filename) {
            this.filename = options.filename;
            if (!contentType) {
              contentType = mimetypes3.detectMimeType(this.filename.split(".").pop());
            }
          }
          this.parentNode = options.parentNode;
          this._nodeId = ++this.rootNode.nodeCounter;
          this._childNodes = [];
          this._headers = [];
          if (contentType) {
            this.setHeader("content-type", contentType);
          }
        }
        MimeNode2.prototype.createChild = function(contentType, options) {
          if (!options && typeof contentType === "object") {
            options = contentType;
            contentType = void 0;
          }
          var node = new MimeNode2(contentType, options);
          this.appendChild(node);
          return node;
        };
        MimeNode2.prototype.appendChild = function(childNode) {
          if (childNode.rootNode !== this.rootNode) {
            childNode.rootNode = this.rootNode;
            childNode._nodeId = ++this.rootNode.nodeCounter;
          }
          childNode.parentNode = this;
          this._childNodes.push(childNode);
          return childNode;
        };
        MimeNode2.prototype.replace = function(node) {
          if (node === this) {
            return this;
          }
          this.parentNode._childNodes.forEach(function(childNode, i) {
            if (childNode === this) {
              node.rootNode = this.rootNode;
              node.parentNode = this.parentNode;
              node._nodeId = this._nodeId;
              this.rootNode = this;
              this.parentNode = void 0;
              node.parentNode._childNodes[i] = node;
            }
          }.bind(this));
          return node;
        };
        MimeNode2.prototype.remove = function() {
          if (!this.parentNode) {
            return this;
          }
          for (var i = this.parentNode._childNodes.length - 1; i >= 0; i--) {
            if (this.parentNode._childNodes[i] === this) {
              this.parentNode._childNodes.splice(i, 1);
              this.parentNode = void 0;
              this.rootNode = this;
              return this;
            }
          }
        };
        MimeNode2.prototype.setHeader = function(key, value) {
          var added = false, headerValue;
          if (!value && key && typeof key === "object") {
            if (key.key && key.value) {
              this.setHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
              key.forEach(function(i2) {
                this.setHeader(i2.key, i2.value);
              }.bind(this));
            } else {
              Object.keys(key).forEach(function(i2) {
                this.setHeader(i2, key[i2]);
              }.bind(this));
            }
            return this;
          }
          key = this._normalizeHeaderKey(key);
          headerValue = {
            key,
            value
          };
          for (var i = 0, len = this._headers.length; i < len; i++) {
            if (this._headers[i].key === key) {
              if (!added) {
                this._headers[i] = headerValue;
                added = true;
              } else {
                this._headers.splice(i, 1);
                i--;
                len--;
              }
            }
          }
          if (!added) {
            this._headers.push(headerValue);
          }
          return this;
        };
        MimeNode2.prototype.addHeader = function(key, value) {
          if (!value && key && typeof key === "object") {
            if (key.key && key.value) {
              this.addHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
              key.forEach(function(i) {
                this.addHeader(i.key, i.value);
              }.bind(this));
            } else {
              Object.keys(key).forEach(function(i) {
                this.addHeader(i, key[i]);
              }.bind(this));
            }
            return this;
          }
          this._headers.push({
            key: this._normalizeHeaderKey(key),
            value
          });
          return this;
        };
        MimeNode2.prototype.getHeader = function(key) {
          key = this._normalizeHeaderKey(key);
          for (var i = 0, len = this._headers.length; i < len; i++) {
            if (this._headers[i].key === key) {
              return this._headers[i].value;
            }
          }
        };
        MimeNode2.prototype.setContent = function(content) {
          this.content = content;
          return this;
        };
        MimeNode2.prototype.build = function() {
          var lines = [], contentType = (this.getHeader("Content-Type") || "").toString().toLowerCase().trim(), transferEncoding, flowed;
          if (this.content) {
            transferEncoding = (this.getHeader("Content-Transfer-Encoding") || "").toString().toLowerCase().trim();
            if (!transferEncoding || ["base64", "quoted-printable"].indexOf(transferEncoding) < 0) {
              if (/^text\//i.test(contentType)) {
                if (this._isPlainText(this.content)) {
                  if (/^.{77,}/m.test(this.content)) {
                    flowed = true;
                  }
                  transferEncoding = "7bit";
                } else {
                  transferEncoding = "quoted-printable";
                }
              } else if (!/^multipart\//i.test(contentType)) {
                transferEncoding = transferEncoding || "base64";
              }
            }
            if (transferEncoding) {
              this.setHeader("Content-Transfer-Encoding", transferEncoding);
            }
          }
          if (this.filename && !this.getHeader("Content-Disposition")) {
            this.setHeader("Content-Disposition", "attachment");
          }
          this._headers.forEach(function(header) {
            var key = header.key, value = header.value, structured;
            switch (header.key) {
              case "Content-Disposition":
                structured = mimefuncs2.parseHeaderValue(value);
                if (this.filename) {
                  structured.params.filename = this.filename;
                }
                value = this._buildHeaderValue(structured);
                break;
              case "Content-Type":
                structured = mimefuncs2.parseHeaderValue(value);
                this._handleContentType(structured);
                if (flowed) {
                  structured.params.format = "flowed";
                }
                if (String(structured.params.format).toLowerCase().trim() === "flowed") {
                  flowed = true;
                }
                if (structured.value.match(/^text\//) && typeof this.content === "string" && /[\u0080-\uFFFF]/.test(this.content)) {
                  structured.params.charset = "utf-8";
                }
                value = this._buildHeaderValue(structured);
                break;
              case "Bcc":
                return;
            }
            value = this._encodeHeaderValue(key, value);
            if (!(value || "").toString().trim()) {
              return;
            }
            lines.push(mimefuncs2.foldLines(key + ": " + value, 76));
          }.bind(this));
          if (this.rootNode === this) {
            if (!this.getHeader("Date")) {
              lines.push("Date: " + this.date.toUTCString().replace(/GMT/, "+0000"));
            }
            if (!this.getHeader("Message-Id")) {
              lines.push("Message-Id: <" + [0, 0, 0].reduce(function(prev) {
                return prev + "-" + Math.floor((1 + Math.random()) * 4294967296).toString(16).substring(1);
              }, Date.now()) + "@" + (this.getEnvelope().from || "localhost").split("@").pop() + ">");
            }
            if (!this.getHeader("MIME-Version")) {
              lines.push("MIME-Version: 1.0");
            }
          }
          lines.push("");
          if (this.content) {
            switch (transferEncoding) {
              case "quoted-printable":
                lines.push(mimefuncs2.quotedPrintableEncode(this.content));
                break;
              case "base64":
                lines.push(mimefuncs2.base64Encode(this.content, typeof this.content === "object" && "binary" || false));
                break;
              default:
                if (flowed) {
                  lines.push(mimefuncs2.foldLines(this.content.replace(/\r?\n/g, "\r\n").replace(/^( |From|>)/igm, " $1"), 76, true));
                } else {
                  lines.push(this.content.replace(/\r?\n/g, "\r\n"));
                }
            }
            if (this.multipart) {
              lines.push("");
            }
          }
          if (this.multipart) {
            this._childNodes.forEach(function(node) {
              lines.push("--" + this.boundary);
              lines.push(node.build());
            }.bind(this));
            lines.push("--" + this.boundary + "--");
            lines.push("");
          }
          return lines.join("\r\n");
        };
        MimeNode2.prototype.getEnvelope = function() {
          var envelope = {
            from: false,
            to: []
          };
          this._headers.forEach(function(header) {
            var list = [];
            if (header.key === "From" || !envelope.from && ["Reply-To", "Sender"].indexOf(header.key) >= 0) {
              this._convertAddresses(this._parseAddresses(header.value), list);
              if (list.length && list[0]) {
                envelope.from = list[0];
              }
            } else if (["To", "Cc", "Bcc"].indexOf(header.key) >= 0) {
              this._convertAddresses(this._parseAddresses(header.value), envelope.to);
            }
          }.bind(this));
          return envelope;
        };
        MimeNode2.prototype._parseAddresses = function(addresses) {
          return [].concat.apply([], [].concat(addresses).map(function(address) {
            if (address && address.address) {
              address = this._convertAddresses(address);
            }
            return addressparser2.parse(address);
          }.bind(this)));
        };
        MimeNode2.prototype._normalizeHeaderKey = function(key) {
          return (key || "").toString().replace(/\r?\n|\r/g, " ").trim().toLowerCase().replace(/^MIME\b|^[a-z]|\-[a-z]/ig, function(c) {
            return c.toUpperCase();
          });
        };
        MimeNode2.prototype._buildHeaderValue = function(structured) {
          var paramsArray = [];
          Object.keys(structured.params || {}).forEach(function(param) {
            if (param === "filename") {
              mimefuncs2.continuationEncode(param, structured.params[param], 50).forEach(function(encodedParam) {
                paramsArray.push(encodedParam.key + "=" + encodedParam.value);
              });
            } else {
              paramsArray.push(param + "=" + this._escapeHeaderArgument(structured.params[param]));
            }
          }.bind(this));
          return structured.value + (paramsArray.length ? "; " + paramsArray.join("; ") : "");
        };
        MimeNode2.prototype._escapeHeaderArgument = function(value) {
          if (value.match(/[\s'"\\;\/=]|^\-/g)) {
            return '"' + value.replace(/(["\\])/g, "\\$1") + '"';
          } else {
            return value;
          }
        };
        MimeNode2.prototype._handleContentType = function(structured) {
          this.contentType = structured.value.trim().toLowerCase();
          this.multipart = this.contentType.split("/").reduce(function(prev, value) {
            return prev === "multipart" ? value : false;
          });
          if (this.multipart) {
            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
          } else {
            this.boundary = false;
          }
        };
        MimeNode2.prototype._generateBoundary = function() {
          return "----sinikael-?=_" + this._nodeId + "-" + this.rootNode.baseBoundary;
        };
        MimeNode2.prototype._encodeHeaderValue = function(key, value) {
          key = this._normalizeHeaderKey(key);
          switch (key) {
            case "From":
            case "Sender":
            case "To":
            case "Cc":
            case "Bcc":
            case "Reply-To":
              return this._convertAddresses(this._parseAddresses(value));
            case "Message-Id":
            case "In-Reply-To":
            case "Content-Id":
              value = (value || "").toString().replace(/\r?\n|\r/g, " ");
              if (value.charAt(0) !== "<") {
                value = "<" + value;
              }
              if (value.charAt(value.length - 1) !== ">") {
                value = value + ">";
              }
              return value;
            case "References":
              value = [].concat.apply([], [].concat(value || "").map(function(elm) {
                elm = (elm || "").toString().replace(/\r?\n|\r/g, " ").trim();
                return elm.replace(/<[^>]*>/g, function(str) {
                  return str.replace(/\s/g, "");
                }).split(/\s+/);
              })).map(function(elm) {
                if (elm.charAt(0) !== "<") {
                  elm = "<" + elm;
                }
                if (elm.charAt(elm.length - 1) !== ">") {
                  elm = elm + ">";
                }
                return elm;
              });
              return value.join(" ").trim();
            default:
              value = (value || "").toString().replace(/\r?\n|\r/g, " ");
              return mimefuncs2.mimeWordsEncode(value, "Q", 52);
          }
        };
        MimeNode2.prototype._convertAddresses = function(addresses, uniqueList) {
          var values = [];
          uniqueList = uniqueList || [];
          [].concat(addresses || []).forEach(function(address) {
            if (address.address) {
              address.address = address.address.replace(/^.*?(?=\@)/, function(user) {
                return mimefuncs2.mimeWordsEncode(user, "Q", 52);
              }).replace(/@.+$/, function(domain) {
                return "@" + punycode2.toASCII(domain.substr(1));
              });
              if (!address.name) {
                values.push(address.address);
              } else if (address.name) {
                values.push(this._encodeAddressName(address.name) + " <" + address.address + ">");
              }
              if (uniqueList.indexOf(address.address) < 0) {
                uniqueList.push(address.address);
              }
            } else if (address.group) {
              values.push(this._encodeAddressName(address.name) + ":" + (address.group.length ? this._convertAddresses(address.group, uniqueList) : "").trim() + ";");
            }
          }.bind(this));
          return values.join(", ");
        };
        MimeNode2.prototype._encodeAddressName = function(name) {
          if (!/^[\w ']*$/.test(name)) {
            if (/^[\x20-\x7e]*$/.test(name)) {
              return '"' + name.replace(/([\\"])/g, "\\$1") + '"';
            } else {
              return mimefuncs2.mimeWordEncode(name, "Q", 52);
            }
          }
          return name;
        };
        MimeNode2.prototype._isPlainText = function(value) {
          if (typeof value !== "string" || /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/.test(value)) {
            return false;
          } else {
            return true;
          }
        };
        return MimeNode2;
      });
    }
  });

  // src/backend/drafts/composer.js
  function normalizeNewlines(body) {
    return body.replace(/\r?\n|\r/g, "\r\n");
  }
  function Composer(messageInfo, account, reportHeartbeat) {
    this.messageInfo = messageInfo;
    this.account = account;
    this.sentDate = new Date(messageInfo.date);
    this._heartbeat = reportHeartbeat;
    this.superBlob = null;
  }
  var import_mailbuild;
  var init_composer = __esm({
    "src/backend/drafts/composer.js"() {
      import_mailbuild = __toModule(require_mailbuild());
      init_mailchew();
      init_util();
      import_mailbuild.default.prototype.removeHeader = function(key) {
        for (var i = 0, len = this._headers.length; i < len; i++) {
          if (this._headers[i].key === key) {
            this._headers.splice(i, 1);
            break;
          }
        }
      };
      Composer.prototype = {
        getEnvelope() {
          return this._rootNode.getEnvelope();
        },
        async buildMessage(opts) {
          let messageInfo = this.messageInfo;
          let messageNode;
          let quoteChewedRep = JSON.parse(await messageInfo.bodyReps[0].contentBlob.text());
          let textContent = quoteChewedRep[1];
          if (messageInfo.bodyReps.length === 2) {
            let htmlContent = await messageInfo.bodyReps[1].contentBlob.text();
            messageNode = new import_mailbuild.default("text/html");
            messageNode.setContent(normalizeNewlines(mergeUserTextWithHTML(textContent, htmlContent)));
          } else {
            messageNode = new import_mailbuild.default("text/plain");
            messageNode.setContent(normalizeNewlines(textContent));
          }
          var root;
          if (messageInfo.attachments.length) {
            root = this._rootNode = new import_mailbuild.default("multipart/mixed");
            root.appendChild(messageNode);
          } else {
            root = this._rootNode = messageNode;
          }
          root.setHeader("From", formatAddresses([messageInfo.author]));
          root.setHeader("Subject", messageInfo.subject);
          if (messageInfo.replyTo) {
            root.setHeader("Reply-To", formatAddresses[messageInfo.replyTo]);
          }
          if (messageInfo.to && messageInfo.to.length) {
            root.setHeader("To", formatAddresses(messageInfo.to));
          }
          if (messageInfo.cc && messageInfo.cc.length) {
            root.setHeader("Cc", formatAddresses(messageInfo.cc));
          }
          if (messageInfo.bcc && messageInfo.bcc.length) {
            root.setHeader("Bcc", formatAddresses(messageInfo.bcc));
          }
          root.setHeader("User-Agent", "GaiaMail/0.2");
          root.setHeader("Date", this.sentDate.toUTCString());
          root.setHeader("Message-Id", messageInfo.guid);
          if (messageInfo.references && messageInfo.references.length) {
            root.setHeader("References", messageInfo.references);
          }
          root.setHeader("Content-Transfer-Encoding", "quoted-printable");
          this._blobReplacements = [];
          this._uniqueBlobBoundary = "{{blob!" + Math.random() + Date.now() + "}}";
          messageInfo.attachments.forEach((attachment) => {
            try {
              var attachmentNode = new import_mailbuild.default(attachment.type, {
                filename: attachment.name
              });
              attachmentNode.setHeader("Content-Transfer-Encoding", "base64");
              attachmentNode.setContent(this._uniqueBlobBoundary);
              root.appendChild(attachmentNode);
              this._blobReplacements.push(new Blob(attachment.file));
            } catch (ex) {
              console.error("Problem attaching attachment:", ex, "\n", ex.stack);
            }
          });
          var TEMP_BCC = "Bcc-Temp";
          var TEMP_BCC_REGEX = /^Bcc-Temp: /m;
          var hasBcc = opts.includeBcc && this.messageInfo.bcc && this.messageInfo.bcc.length;
          if (hasBcc) {
            this._rootNode.setHeader(TEMP_BCC, formatAddresses(this.messageInfo.bcc));
          } else {
            this._rootNode.removeHeader(TEMP_BCC);
          }
          var str = this._rootNode.build();
          if (opts.smtp) {
            str = str.replace(/\n\./g, "\n..");
          }
          if (hasBcc) {
            str = str.replace(TEMP_BCC_REGEX, "Bcc: ");
          }
          if (str.slice(-2) !== "\r\n") {
            str += "\r\n";
          }
          var splits = str.split(btoa(this._uniqueBlobBoundary) + "\r\n");
          this._blobReplacements.forEach(function(blob, i) {
            splits.splice(i * 2 + 1, 0, blob);
          });
          this.superBlob = new Blob(splits, {
            type: this._rootNode.getHeader("content-type")
          });
        },
        heartbeat(reason) {
          if (this._heartbeat) {
            this._heartbeat(reason);
          }
        }
      };
    }
  });

  // src/backend/task_mixins/mix_outbox_send.js
  var mix_outbox_send_default;
  var init_mix_outbox_send = __esm({
    "src/backend/task_mixins/mix_outbox_send.js"() {
      init_conv_churn_driver();
      init_composer();
      init_id_conversions();
      mix_outbox_send_default = {
        name: "outbox_send",
        initPersistentState() {
          return {
            messageIdsToSend: new Map(),
            sendOrderingCounter: 0
          };
        },
        _markerIdForMessage(accountId, messageId) {
          return this.name + ":" + messageId;
        },
        _makeMarkerForMessage(accountId, messageId, order) {
          return {
            type: this.name,
            id: this._markerIdForMessage(accountId, messageId),
            accountId,
            onlineOnly: true,
            priorityTags: [],
            resources: [],
            exclusiveResources: [],
            relPriority: -order,
            messageId
          };
        },
        deriveMemoryStateFromPersistentState(persistentState, accountId) {
          let markers = [];
          for (let [messageId, { order }] of persistentState.messageIdsToSend) {
            markers.push(this._makeMarkerForMessage(accountId, messageId, order));
          }
          return {
            memoryState: {
              paused: false,
              activelySending: new Map()
            },
            markers
          };
        },
        async _planSend(ctx, persistentState, memoryState, rawTask) {
          const { messageId } = rawTask;
          let convId = convIdFromMessageId(messageId);
          let fromDb = await ctx.beginMutate({
            conversations: new Map([[convId, null]]),
            messagesByConversation: new Map([[convId, null]])
          });
          let oldConvInfo = fromDb.conversations.get(convId);
          let messages = fromDb.messagesByConversation.get(convId);
          let messageInfo = messages.find((msg) => msg.id === messageId);
          let foldersToc = await ctx.universe.acquireAccountFoldersTOC(ctx, ctx.accountId);
          let outboxFolder = foldersToc.getCanonicalFolderByType("outbox");
          messageInfo.folderIds = new Set([outboxFolder.id]);
          messageInfo.draftInfo.sendProblems = {
            error: null,
            badAddresses: null,
            sendFailures: 0
          };
          let convInfo = churnConversationDriver(convId, oldConvInfo, messages);
          let sendInfo = {
            date: messageInfo.date,
            order: persistentState.sendOrderingCounter++
          };
          persistentState.messageIdsToSend.set(messageId, sendInfo);
          let modifyTaskMarkers = new Map();
          if (!memoryState.paused) {
            let marker = this._makeMarkerForMessage(rawTask.accountId, messageId, sendInfo.order);
            modifyTaskMarkers.set(marker.id, marker);
          }
          let reportProblem;
          if (memoryState.paused) {
            reportProblem = "outbox-paused";
          } else if (ctx.accountProblem) {
            reportProblem = "account-problem";
          } else if (!ctx.online) {
            reportProblem = "offline";
          } else {
            reportProblem = null;
          }
          await ctx.finishTask({
            mutations: {
              conversations: new Map([[convId, convInfo]]),
              messages: new Map([[messageId, messageInfo]])
            },
            taskMarkers: modifyTaskMarkers,
            complexTaskState: persistentState
          });
          return ctx.returnValue(reportProblem);
        },
        async _planAbort(ctx, persistentState, memoryState, rawTask) {
          const { messageId } = rawTask;
          if (!persistentState.messageIdsToSend.has(messageId)) {
            throw new Error("moot");
          }
          if (memoryState.activelySending.has(messageId)) {
            throw new Error("moot");
          }
          let convId = convIdFromMessageId(messageId);
          let fromDb = await ctx.beginMutate({
            conversations: new Map([[convId, null]]),
            messagesByConversation: new Map([[convId, null]])
          });
          let oldConvInfo = fromDb.conversations.get(convId);
          let messages = fromDb.messagesByConversation.get(convId);
          let messageInfo = messages.find((msg) => msg.id === messageId);
          let foldersToc = await ctx.universe.acquireAccountFoldersTOC(ctx, ctx.accountId);
          let draftsFolder = foldersToc.getCanonicalFolderByType("localdrafts");
          messageInfo.folderIds = new Set([draftsFolder.id]);
          let convInfo = churnConversationDriver(convId, oldConvInfo, messages);
          let markerId = this._markerIdForMessage(messageId);
          persistentState.messageIdsToSend.delete(messageId);
          await ctx.finishTask({
            mutations: {
              conversations: new Map([[convId, convInfo]]),
              messages: new Map([[messageId, messageInfo]])
            },
            taskMarkers: new Map([[markerId, null]]),
            complexTaskState: persistentState
          });
        },
        async _planSetPaused(ctx, persistentState, memoryState, rawTask) {
          if (rawTask.paused === memoryState.paused) {
            await ctx.finishTask({});
            return;
          }
          let bePaused = memoryState.paused = rawTask.paused;
          let modifyTaskMarkers = new Map();
          if (bePaused) {
            for (let messageId of persistentState.messageIdsToSend.keys()) {
              modifyTaskMarkers.set(this._markerIdForMessage(messageId), null);
            }
          } else {
            let accountId = ctx.accountId;
            for (let [messageId, { order }] of persistentState.messageIdsToSend) {
              let marker = this._makeMarkerForMessage(accountId, messageId, order);
              modifyTaskMarkers.set(marker.id, marker);
            }
          }
          await ctx.finishTask({
            taskMarkers: modifyTaskMarkers,
            complexTaskState: persistentState
          });
        },
        plan(ctx, persistentState, memoryState, rawTask) {
          switch (rawTask.command) {
            case "send": {
              return this._planSend(ctx, persistentState, memoryState, rawTask);
            }
            case "abort": {
              return this._planAbort(ctx, persistentState, memoryState, rawTask);
            }
            case "setPaused": {
              return this._planSetPaused(ctx, persistentState, memoryState, rawTask);
            }
            default:
              throw new Error("bug");
          }
        },
        async execute(ctx, persistentState, memoryState, marker) {
          const { messageId } = marker;
          const { date } = persistentState.messageIdsToSend.get(messageId);
          const activeSendStatus = {
            progress: "building"
          };
          memoryState.activelySending.set(messageId, activeSendStatus);
          const account = await ctx.universe.acquireAccount(ctx, ctx.accountId);
          let messageKey = [messageId, date];
          let messageInfo = (await ctx.read({
            messages: new Map([[messageKey, null]])
          })).messages.get(messageId);
          const renewWakeLock = ctx.heartbeat.bind(ctx);
          const composer = new Composer(messageInfo, account, renewWakeLock);
          await composer.buildMessage({
            includeBcc: this.shouldIncludeBcc(account)
          });
          let { error: sendError, badAddresses } = await this.sendMessage(ctx, account, composer);
          let convId = convIdFromMessageId(messageId);
          let fromDb = await ctx.beginMutate({
            conversations: new Map([[convId, null]]),
            messagesByConversation: new Map([[convId, null]])
          });
          let messages = fromDb.messagesByConversation.get(convId);
          let oldConvInfo = fromDb.conversations.get(convId);
          messageInfo = messages.find((msg) => msg.id === messageId);
          let newTasks = [];
          let modifyMessages = new Map();
          let modifyConversations = new Map();
          if (sendError) {
            switch (sendError) {
              case "bad-message":
              case "bad-address":
                break;
              case "bad-user-or-pass":
                break;
              case "bad-security":
              case "server-maybe-offline":
              case "unresponsive-server":
              case "unknown":
              default:
                break;
            }
            messageInfo.draftInfo.sendProblems = {
              state: "error",
              error: sendError,
              badAddresses
            };
          } else {
            this.saveSentMessage({ ctx, newTasks, messages, messageInfo, account });
            if (messages.length) {
              if (messages.includes(messageInfo)) {
                modifyMessages.set(messageId, messageInfo);
              } else {
                modifyMessages.set(messageId, null);
              }
              let convInfo = churnConversationDriver(convId, oldConvInfo, messages);
              modifyConversations.set(convId, convInfo);
            } else {
              modifyConversations.set(convId, null);
            }
          }
          persistentState.messageIdsToSend.delete(messageId);
          memoryState.activelySending.delete(messageId);
          await ctx.finishTask({
            mutations: {
              conversations: modifyConversations,
              messages: modifyMessages
            },
            newData: {
              tasks: newTasks
            },
            complexTaskState: persistentState
          });
        },
        sendMessage(ctx, account, composer) {
          return account.sendMessage(composer);
        },
        saveSentMessage({ messages, messageInfo }) {
          messages.splice(messages.indexOf(messageInfo), 1);
        }
      };
    }
  });

  // src/backend/accounts/activesync/tasks/outbox_send.js
  var outbox_send_default;
  var init_outbox_send = __esm({
    "src/backend/accounts/activesync/tasks/outbox_send.js"() {
      init_task_definer();
      init_send_mail();
      init_send_mail_12x();
      init_mix_outbox_send();
      outbox_send_default = task_definer_default.defineComplexTask([
        mix_outbox_send_default,
        {
          shouldIncludeBcc() {
            return true;
          },
          async sendMessage(ctx, account, composer) {
            let conn;
            try {
              conn = await account.ensureConnection();
            } catch (ex) {
              return { error: ex.message };
            }
            let mimeBlob = composer.superBlob;
            let progress = () => {
              composer.heartbeat("ActiveSync sendMessage");
            };
            try {
              if (conn.currentVersion.gte("14.0")) {
                await sendMail(conn, { mimeBlob, progress });
              } else {
                await sendMail2(conn, { mimeBlob, progress });
              }
            } catch (ex) {
              return { error: ex.message };
            }
            return { error: null };
          }
        }
      ]);
    }
  });

  // src/backend/tasks/account_modify.js
  var account_modify_default;
  var init_account_modify = __esm({
    "src/backend/tasks/account_modify.js"() {
      init_logic();
      init_task_definer();
      init_date();
      account_modify_default = task_definer_default.defineSimpleTask([
        {
          name: "account_modify",
          async plan(ctx, rawTask) {
            const accountDef = ctx.readSingle("accounts", rawTask.accountId);
            const accountClobbers = new Map();
            for (let key in rawTask.mods) {
              const val = rawTask.mods[key];
              switch (key) {
                case "name":
                  accountClobbers.set(["map"], val);
                  break;
                case "username":
                  if (accountDef.credentials.outgoingUsername === accountDef.credentials.username) {
                    accountClobbers.set(["credentials", "outgoingUsername"], val);
                  }
                  accountClobbers.set(["credentials", "username"], val);
                  break;
                case "incomingUsername":
                  accountClobbers.set(["credentials", "username"], val);
                  break;
                case "outgoingUsername":
                  accountClobbers.set(["credentials", "outgoingUsername"], val);
                  break;
                case "password":
                  if (accountDef.credentials.outgoingPassword === accountDef.credentials.password) {
                    accountClobbers.set(["credentials", "outgoingPassword"], val);
                  }
                  accountClobbers.set(["credentials", "password"], val);
                  break;
                case "incomingPassword":
                  accountClobbers.set(["credentials", "password"], val);
                  break;
                case "outgoingPassword":
                  accountClobbers.set(["credentials", "outgoingPassword"], val);
                  break;
                case "oauthTokens":
                  accountClobbers.set(["credentials", "oauth2", "accessToken"], val.accessToken);
                  accountClobbers.set(["credentials", "oauth2", "refreshToken"], val.refreshToken);
                  accountClobbers.set(["credentials", "oauth2", "expireTimeMS"], val.expireTimeMS);
                  break;
                case "identities":
                  break;
                case "servers":
                  break;
                case "syncRange":
                  accountClobbers.set(["syncRange"], val);
                  break;
                case "syncInterval":
                  accountClobbers.set(["syncInterval"], val);
                  break;
                case "notifyOnNew":
                  accountClobbers.set(["notifyOnNew"], val);
                  break;
                case "playSoundOnSend":
                  accountClobbers.set(["playSoundOnSend"], val);
                  break;
                case "setAsDefault":
                  if (val) {
                    accountClobbers.set(["defaultPriority"], NOW());
                  }
                  break;
                default:
                  logic(ctx, "badModifyAccountKey", { key });
                  break;
              }
            }
            await ctx.finishTask({
              atomicClobbers: {
                accounts: new Map([[rawTask.accountId, accountClobbers]])
              }
            });
          }
        }
      ]);
    }
  });

  // src/backend/tasks/identity_modify.js
  var identity_modify_default;
  var init_identity_modify = __esm({
    "src/backend/tasks/identity_modify.js"() {
      init_logic();
      init_task_definer();
      identity_modify_default = task_definer_default.defineSimpleTask([
        {
          name: "identity_modify",
          async plan(ctx, rawTask) {
            const accountClobbers = new Map();
            const identIndex = 0;
            const identPath = ["identities", identIndex];
            for (let key in rawTask.mods) {
              const val = rawTask.mods[key];
              switch (key) {
                case "name":
                  accountClobbers.set(identPath.concat("name"), val);
                  break;
                case "address":
                  accountClobbers.set(identPath.concat("address"), val);
                  break;
                case "replyTo":
                  accountClobbers.set(identPath.concat("replyTo"), val);
                  break;
                case "signature":
                  accountClobbers.set(identPath.concat("signature"), val);
                  break;
                case "signatureEnabled":
                  accountClobbers.set(identPath.concat("signatureEnabled"), val);
                  break;
                default:
                  logic(ctx, "badModifyIdentityKey", { key });
                  break;
              }
            }
            await ctx.finishTask({
              atomicClobbers: {
                accounts: new Map([[rawTask.accountId, accountClobbers]])
              }
            });
          }
        }
      ]);
    }
  });

  // src/app_logic/new_message_summarizer.js
  function extractRelevantMessageInfoForChurning(message) {
    return {
      date: message.date,
      authorNameish: message.author.name || message.author.address,
      subject: message.subject
    };
  }
  var init_new_message_summarizer = __esm({
    "src/app_logic/new_message_summarizer.js"() {
    }
  });

  // src/backend/tasks/new_tracking.js
  var new_tracking_default;
  var init_new_tracking = __esm({
    "src/backend/tasks/new_tracking.js"() {
      init_task_definer();
      init_new_message_summarizer();
      init_id_conversions();
      new_tracking_default = task_definer_default.defineComplexTask([
        {
          name: "new_tracking",
          initPersistentState() {
            return {
              compareDate: null,
              pendingDate: 0,
              newByConv: new Map()
            };
          },
          deriveMemoryStateFromPersistentState(persistentState, accountId, accountInfo, foldersTOC) {
            let inboxFolder = foldersTOC.getCanonicalFolderByType("inbox");
            return {
              memoryState: {
                inboxFolderId: inboxFolder && inboxFolder.id,
                foldersTOC,
                pendingTaskGroupId: null,
                complexStateMap: new Map([[[accountId, this.name], persistentState]]),
                newFlushTaskReq: {
                  type: "new_flush"
                }
              },
              markers: []
            };
          },
          async plan(ctx, persistentState, memoryState, req) {
            if (!persistentState.newByConv.size) {
              await ctx.finishTask({});
              return;
            }
            let newTasks = [];
            if (req.op === "clear") {
              if (!req.silent) {
                newTasks.push({
                  type: "new_flush"
                });
              }
              persistentState.newByConv.clear();
            }
            await ctx.finishTask({
              newData: { tasks: newTasks },
              complexTaskState: persistentState
            });
          },
          execute: null,
          consult(askingCtx, persistentState) {
            return persistentState.newByConv;
          },
          "trigger_msg!*!add": function(persistentState, memoryState, triggerCtx, message) {
            if (!memoryState.inboxFolderId) {
              let inboxFolder = memoryState.foldersTOC.getCanonicalFolderByType("inbox");
              memoryState.inboxFolderId = inboxFolder && inboxFolder.id;
              if (!memoryState.inboxFolderId) {
                return;
              }
            }
            if (!message.folderIds.has(memoryState.inboxFolderId)) {
              return;
            }
            if (message.flags.includes("\\Seen")) {
              return;
            }
            let curTaskGroupId = triggerCtx.rootTaskGroupId;
            let dirty = false;
            if (curTaskGroupId !== memoryState.pendingTaskGroupId) {
              persistentState.compareDate = persistentState.pendingDate;
              memoryState.pendingTaskGroupId = curTaskGroupId;
              dirty = true;
            }
            if (message.date >= persistentState.pendingDate) {
              dirty = true;
              persistentState.pendingDate = Math.max(persistentState.pendingDate, message.date);
              let convId = convIdFromMessageId(message.id);
              let summary = extractRelevantMessageInfoForChurning(message);
              let messageMap = persistentState.newByConv.get(convId);
              if (!messageMap) {
                messageMap = new Map();
                persistentState.newByConv.set(convId, messageMap);
              }
              messageMap.set(message.id, summary);
            }
            if (dirty) {
              triggerCtx.modify({
                complexTaskStates: memoryState.complexStateMap,
                rootGroupDeferredTask: memoryState.newFlushTaskReq
              });
            }
          },
          "trigger_msg!*!change": function(persistentState, memoryState, triggerCtx, messageId, preInfo, message, added, kept, removed) {
            if (removed.has(memoryState.inboxFolderId) || message && message.flags.includes("\\Seen")) {
              let convId = convIdFromMessageId(messageId);
              let messageMap = persistentState.newByConv.get(convId);
              if (!messageMap) {
                return;
              }
              if (messageMap.delete(messageId)) {
                if (messageMap.size === 0) {
                  persistentState.newByConv.delete(convId);
                }
                triggerCtx.modify({
                  complexTaskStates: memoryState.complexStateMap,
                  rootGroupDeferredTask: memoryState.newFlushTaskReq
                });
              }
            }
          }
        }
      ]);
    }
  });

  // src/backend/accounts/activesync/activesync_tasks.js
  var activesync_tasks_exports = {};
  __export(activesync_tasks_exports, {
    default: () => activesync_tasks_default
  });
  var activesync_tasks_default;
  var init_activesync_tasks = __esm({
    "src/backend/accounts/activesync/activesync_tasks.js"() {
      init_sync_folder_list();
      init_sync_refresh();
      init_sync_conv();
      init_sync_body();
      init_store_flags();
      init_draft_save();
      init_draft_attach();
      init_draft_detach();
      init_draft_delete();
      init_outbox_send();
      init_account_modify();
      init_identity_modify();
      init_new_tracking();
      activesync_tasks_default = [
        sync_folder_list_default,
        sync_refresh_default,
        sync_conv_default,
        sync_body_default,
        store_flags_default,
        draft_save_default,
        draft_attach_default,
        draft_detach_default,
        draft_delete_default,
        outbox_send_default,
        account_modify_default,
        identity_modify_default,
        new_tracking_default
      ];
    }
  });

  // src/backend/accounts/feed/tasks/sync_folder_list.js
  var sync_folder_list_default2;
  var init_sync_folder_list2 = __esm({
    "src/backend/accounts/feed/tasks/sync_folder_list.js"() {
      init_task_definer();
      init_mix_sync_folder_list();
      sync_folder_list_default2 = task_definer_default.defineSimpleTask([
        mix_sync_folder_list_default,
        {
          essentialOfflineFolders: [
            {
              type: "inbox",
              displayName: "Feed"
            }
          ],
          async syncFolders() {
            return {
              newFolders: void 0,
              newTasks: void 0,
              modifiedFolders: void 0,
              modifiedSyncStates: void 0
            };
          }
        }
      ]);
    }
  });

  // src/backend/date_priority_adjuster.js
  function prioritizeNewer(dateTS) {
    return Math.max(-MAX_PRIORITY_BOOST, MAX_PRIORITY_BOOST - (NOW() - dateTS) / ONE_HOUR_IN_MSECS);
  }
  var MAX_PRIORITY_BOOST, ONE_HOUR_IN_MSECS;
  var init_date_priority_adjuster = __esm({
    "src/backend/date_priority_adjuster.js"() {
      init_date();
      MAX_PRIORITY_BOOST = 99999;
      ONE_HOUR_IN_MSECS = 60 * 60 * 1e3;
    }
  });

  // src/backend/accounts/feed/chew_item.js
  var FeedItemChewer;
  var init_chew_item = __esm({
    "src/backend/accounts/feed/chew_item.js"() {
      init_mail_rep();
      init_mailchew();
      FeedItemChewer = class {
        constructor({ convId, item, foldersTOC }) {
          this.convId = convId;
          this.item = item;
          this.foldersTOC = foldersTOC;
          this.inboxFolder = foldersTOC.getCanonicalFolderByType("inbox");
          this.allMessages = [];
        }
        chewItem() {
          const item = this.item;
          let contentBlob, snippet, authoredBodySize;
          let bodyReps = [];
          const msgId = this.convId;
          if (item.description) {
            const description = item.description;
            ({ contentBlob, snippet, authoredBodySize } = processMessageContent(description, "html", true, true));
            bodyReps.push(makeBodyPart({
              type: "html",
              part: null,
              sizeEstimate: description.length,
              amountDownloaded: description.length,
              isDownloaded: true,
              _partInfo: null,
              contentBlob,
              authoredBodySize
            }));
          }
          const msgInfo = makeMessageInfo({
            id: msgId,
            umid: null,
            guid: item.guid,
            date: item.date,
            dateModified: item.dateModified,
            author: item.author,
            flags: [],
            folderIds: new Set([this.inboxFolder.id]),
            subject: item.title,
            snippet,
            attachments: [],
            relatedParts: null,
            references: null,
            bodyReps,
            authoredBodySize,
            draftInfo: null
          });
          this.allMessages.push(msgInfo);
        }
      };
    }
  });

  // src/backend/accounts/feed/tasks/sync_item.js
  var sync_item_default;
  var init_sync_item = __esm({
    "src/backend/accounts/feed/tasks/sync_item.js"() {
      init_util();
      init_date_priority_adjuster();
      init_task_definer();
      init_conv_churn_driver();
      init_chew_item();
      sync_item_default = task_definer_default.defineSimpleTask([
        {
          name: "sync_item",
          async plan(ctx, rawTask) {
            let plannedTask = shallowClone2(rawTask);
            plannedTask.exclusiveResources = [`conv:${rawTask.convId}`];
            plannedTask.priorityTags = [`view:conv:${rawTask.convId}`];
            if (rawTask.mostRecent) {
              plannedTask.relPriority = prioritizeNewer(rawTask.mostRecent);
            }
            await ctx.finishTask({
              taskState: plannedTask
            });
          },
          async execute(ctx, req) {
            const account = await ctx.universe.acquireAccount(ctx, req.accountId);
            const foldersTOC = await ctx.universe.acquireAccountFoldersTOC(ctx, account.id);
            const fromDb = await ctx.beginMutate({
              conversations: new Map([[req.convId, null]])
            });
            const oldConvInfo = fromDb.conversations.get(req.convId);
            if (oldConvInfo) {
              await ctx.finishTask({});
              return;
            }
            const itemChewer = new FeedItemChewer({
              convId: req.convId,
              item: req.item,
              foldersTOC
            });
            itemChewer.chewItem();
            const convInfo = churnConversationDriver(req.convId, null, itemChewer.allMessages);
            await ctx.finishTask({
              newData: {
                conversations: [convInfo],
                messages: itemChewer.allMessages
              }
            });
          }
        }
      ]);
    }
  });

  // src/backend/accounts/feed/sync_state_helper.js
  var FeedSyncStateHelper;
  var init_sync_state_helper = __esm({
    "src/backend/accounts/feed/sync_state_helper.js"() {
      init_logic();
      init_date();
      FeedSyncStateHelper = class {
        constructor(ctx, rawSyncState, accountId, why) {
          logic.defineScope(this, "FeedSyncState", { ctxId: ctx.id, why });
          if (!rawSyncState) {
            logic(ctx, "creatingDefaultSyncState", {});
            rawSyncState = {
              lastChangeDatestamp: NOW()
            };
          }
          this._accountId = accountId;
          this.rawSyncState = rawSyncState;
          this.tasksToSchedule = [];
        }
        _makeItemConvTask({ convId, item }) {
          const task = {
            type: "sync_item",
            accountId: this._accountId,
            convId,
            item
          };
          this.tasksToSchedule.push(task);
          return task;
        }
        _makeDefaultData() {
          return {
            author: "No author",
            title: "No title",
            description: ""
          };
        }
        ingestItem(item) {
          const data = this._makeDefaultData();
          if (item.guid) {
            data.guid = typeof item.guid === "string" ? item.guid : item.guid["#content"];
          } else {
            data.guid = item.title || item.description;
          }
          data.date = data.dateModified = (item.pubDate || NOW()).valueOf();
          data.author = item.author || data.author;
          data.title = item.title || data.title;
          data.description = item.description || data.description;
          const convId = `${this._accountId}.${data.guid}`;
          this._makeItemConvTask({
            convId,
            item: data
          });
        }
        ingestEntry(entry) {
          const data = this._makeDefaultData();
          data.guid = entry.id || entry.title || entry.description || NOW().valueOf().toString();
          data.date = (entry.published || entry.updated || NOW()).valueOf();
          data.dateModified = entry.updated?.valueOf() || data.date;
          const author = entry.author?.[0];
          if (author?.name && author?.email) {
            data.author = `${author.name} (${author.email})`;
          } else {
            data.author = author?.name || author?.email || data.author;
          }
          data.title = entry.title || data.title;
          data.description = entry.summary || data.description;
          const convId = `${this._accountId}.${data.guid}`;
          this._makeItemConvTask({
            convId,
            item: data
          });
        }
      };
    }
  });

  // src/backend/accounts/feed/tasks/sync_refresh.js
  var sync_refresh_default2;
  var init_sync_refresh2 = __esm({
    "src/backend/accounts/feed/tasks/sync_refresh.js"() {
      init_logic();
      init_feed_parser();
      init_util();
      init_date();
      init_task_definer();
      init_sync_state_helper();
      init_id_conversions();
      init_sync_overlay_helpers();
      sync_refresh_default2 = task_definer_default.defineAtMostOnceTask([
        {
          name: "sync_refresh",
          binByArg: "accountId",
          helped_overlay_accounts: syncNormalOverlay,
          helped_prefix_overlay_folders: [accountIdFromFolderId, syncPrefixOverlay],
          helped_invalidate_overlays(accountId, dataOverlayManager) {
            dataOverlayManager.announceUpdatedOverlayData("accounts", accountId);
            dataOverlayManager.announceUpdatedOverlayData("accountCascadeToFolders", accountId);
          },
          helped_already_planned(ctx, rawTask) {
            return Promise.resolve({
              result: ctx.trackMeInTaskGroup("sync_refresh:" + rawTask.accountId)
            });
          },
          helped_plan(ctx, rawTask) {
            let plannedTask = shallowClone2(rawTask);
            plannedTask.resources = [
              "online",
              `credentials!${rawTask.accountId}`,
              `happy!${rawTask.accountId}`
            ];
            plannedTask.priorityTags = [`view:folder:${rawTask.folderId}`];
            let groupPromise = ctx.trackMeInTaskGroup("sync_refresh:" + rawTask.accountId);
            return Promise.resolve({
              taskState: plannedTask,
              remainInProgressUntil: groupPromise,
              result: groupPromise
            });
          },
          async helped_execute(ctx, req) {
            let fromDb = await ctx.beginMutate({
              syncStates: new Map([[req.accountId, null]])
            });
            let rawSyncState = fromDb.syncStates.get(req.accountId);
            let syncState = new FeedSyncStateHelper(ctx, rawSyncState, req.accountId, "refresh");
            let account = await ctx.universe.acquireAccount(ctx, req.accountId);
            let syncDate = NOW();
            logic(ctx, "syncStart", { syncDate });
            const feedResp = await fetch(account.feedUrl);
            const feedText = await feedResp.text();
            const parsed = parseFeed(feedText);
            if (parsed?.rss?.channel.item) {
              for (const item of parsed.rss.channel.item) {
                syncState.ingestItem(item);
              }
            } else if (parsed?.feed.entry) {
              for (const entry of parsed.feed.entry) {
                syncState.ingestEntry(entry);
              }
            } else if (parsed?.entry) {
              syncState.ingestEntry(parsed.entry);
            }
            logic(ctx, "syncEnd", {});
            return {
              mutations: {
                syncStates: new Map([[req.accountId, syncState.rawSyncState]])
              },
              newData: {
                tasks: syncState.tasksToSchedule
              },
              atomicClobbers: {
                accounts: new Map([
                  [
                    req.accountId,
                    {
                      syncInfo: {
                        lastSuccessfulSyncAt: syncDate,
                        lastAttemptedSyncAt: syncDate,
                        failedSyncsSinceLastSuccessfulSync: 0
                      }
                    }
                  ]
                ])
              }
            };
          }
        }
      ]);
    }
  });

  // src/backend/accounts/feed/feed_tasks.js
  var feed_tasks_exports = {};
  __export(feed_tasks_exports, {
    default: () => feed_tasks_default
  });
  var feed_tasks_default;
  var init_feed_tasks = __esm({
    "src/backend/accounts/feed/feed_tasks.js"() {
      init_sync_folder_list2();
      init_sync_item();
      init_sync_refresh2();
      init_account_modify();
      init_identity_modify();
      init_new_tracking();
      feed_tasks_default = [
        sync_folder_list_default2,
        sync_item_default,
        sync_refresh_default2,
        account_modify_default,
        identity_modify_default,
        new_tracking_default
      ];
    }
  });

  // src/backend/accounts/ical/tasks/sync_folder_list.js
  var sync_folder_list_default3;
  var init_sync_folder_list3 = __esm({
    "src/backend/accounts/ical/tasks/sync_folder_list.js"() {
      init_task_definer();
      init_mix_sync_folder_list();
      sync_folder_list_default3 = task_definer_default.defineSimpleTask([
        mix_sync_folder_list_default,
        {
          essentialOfflineFolders: [
            {
              type: "inbox",
              displayName: "Events"
            }
          ],
          async syncFolders() {
            return {
              newFolders: void 0,
              newTasks: void 0,
              modifiedFolders: void 0,
              modifiedSyncStates: void 0
            };
          }
        }
      ]);
    }
  });

  // src/backend/accounts/ical/chew_event_bundle.js
  var import_ical2, RecurringEventBundleChewer;
  var init_chew_event_bundle = __esm({
    "src/backend/accounts/ical/chew_event_bundle.js"() {
      import_ical2 = __toModule(require_ical());
      init_mail_rep();
      init_mailchew();
      RecurringEventBundleChewer = class {
        constructor({
          convId,
          uid,
          rangeOldestTS,
          rangeNewestTS,
          jcalEvents,
          oldConvInfo,
          oldMessages,
          foldersTOC
        }) {
          this.convId = convId;
          this.uid = uid;
          this.rangeOldestTS = rangeOldestTS;
          this.rangeNewestTS = rangeNewestTS;
          this.jcalEvents = jcalEvents;
          this.oldConvInfo = oldConvInfo;
          this.oldMessages = oldMessages;
          this.foldersTOC = foldersTOC;
          this.inboxFolder = foldersTOC.getCanonicalFolderByType("inbox");
          const oldById = this.oldById = new Map();
          for (const old of oldMessages) {
            oldById.set(old.id, old);
          }
          this.unifiedEvents = [];
          this.contentsChanged = true;
          this.modifiedMessageMap = new Map();
          this.newMessages = [];
          this.allMessages = [];
        }
        chewEventBundle() {
          if (!this.jcalEvents.length) {
            return;
          }
          this.rootComponent = new import_ical2.default.Component(["vcalendar", [], this.jcalEvents]);
          const rootEvent = new import_ical2.default.Event(this.rootComponent.getFirstSubcomponent());
          if (!rootEvent.isRecurring()) {
            if (rootEvent.endDate.toJSDate().valueOf() < this.rangeOldestTS || rootEvent.startDate.toJSDate().valueOf() > this.rangeNewestTS) {
              return;
            }
            const fakeOccur = {
              recurrenceId: rootEvent.startDate,
              item: rootEvent,
              startDate: rootEvent.startDate,
              endDate: rootEvent.endDate
            };
            this._chewOccurrence(fakeOccur);
          } else {
            const calIter = rootEvent.iterator();
            let stepCount = 0;
            for (calIter.next(); calIter.complete === false && stepCount < 1024 && calIter.last.toJSDate().valueOf() <= this.rangeNewestTS; calIter.next(), stepCount++) {
              const curOccur = calIter.last;
              const occurInfo = rootEvent.getOccurrenceDetails(curOccur);
              if (occurInfo.endDate.toJSDate().valueOf() < this.rangeOldestTS || occurInfo.startDate.toJSDate().valueOf() > this.rangeNewestTS) {
                continue;
              }
              this._chewOccurrence(occurInfo);
            }
          }
        }
        _chewCalAddress(calAddress) {
          if (!calAddress) {
            return {
              name: "Omitted",
              address: "",
              nick: null
            };
          }
          const cn = calAddress.getParameter("cn");
          const mailto = calAddress.getFirstValue().replace(/^mailto:/g, "");
          return {
            name: cn,
            address: mailto,
            nick: null
          };
        }
        _chewOccurrence({ recurrenceId, item, startDate, endDate }) {
          const msgId = `${this.convId}.${recurrenceId}.0`;
          const component = item.component;
          if (!this.contentsChanged && this.oldById.has(msgId)) {
            const oldInfo = this.oldById.get(msgId);
            this.allMessages.push(oldInfo);
            return;
          }
          let contentBlob, snippet, authoredBodySize;
          let bodyReps = [];
          {
            const attrs = [
              {
                name: "Event",
                type: "date-range",
                startDate,
                endDate
              }
            ];
            if (component.hasProperty("location")) {
              attrs.push({
                name: "Location",
                type: "string-value",
                value: component.getFirstPropertyValue("location")
              });
            }
            ({ contentBlob, snippet, authoredBodySize } = processAttributeContent(attrs));
            bodyReps.push(makeBodyPart({
              type: "attr",
              part: null,
              sizeEstimate: contentBlob.size,
              amountDownloaded: contentBlob.size,
              isDownloaded: true,
              _partInfo: null,
              contentBlob,
              authoredBodySize
            }));
          }
          let description = component.getFirstPropertyValue("description");
          if (description) {
            description = description.replace(/\\n/g, "\n");
            ({ contentBlob, snippet, authoredBodySize } = processMessageContent(description, "html", true, true));
            bodyReps.push(makeBodyPart({
              type: "html",
              part: null,
              sizeEstimate: description.length,
              amountDownloaded: description.length,
              isDownloaded: true,
              _partInfo: null,
              contentBlob,
              authoredBodySize
            }));
          }
          const summary = component.getFirstPropertyValue("summary");
          const organizer = this._chewCalAddress(component.getFirstProperty("organizer"));
          const attendees = component.getAllProperties("attendee").map((who) => this._chewCalAddress(who));
          const msgInfo = makeMessageInfo({
            id: msgId,
            umid: null,
            guid: null,
            date: startDate.toJSDate().valueOf(),
            author: organizer,
            to: attendees,
            flags: [],
            folderIds: new Set([this.inboxFolder.id]),
            subject: summary,
            snippet,
            attachments: [],
            relatedParts: null,
            references: null,
            bodyReps,
            authoredBodySize,
            draftInfo: null
          });
          this.allMessages.push(msgInfo);
          if (this.oldById.has(msgId)) {
            this.modifiedMessageMap.set(msgId, msgInfo);
          } else {
            this.newMessages.push(msgInfo);
          }
        }
      };
    }
  });

  // src/backend/accounts/ical/tasks/sync_uid.js
  var sync_uid_default;
  var init_sync_uid = __esm({
    "src/backend/accounts/ical/tasks/sync_uid.js"() {
      init_util();
      init_date_priority_adjuster();
      init_task_definer();
      init_conv_churn_driver();
      init_chew_event_bundle();
      sync_uid_default = task_definer_default.defineSimpleTask([
        {
          name: "sync_uid",
          async plan(ctx, rawTask) {
            let plannedTask = shallowClone2(rawTask);
            plannedTask.exclusiveResources = [`conv:${rawTask.convId}`];
            plannedTask.priorityTags = [`view:conv:${rawTask.convId}`];
            if (rawTask.mostRecent) {
              plannedTask.relPriority = prioritizeNewer(rawTask.mostRecent);
            }
            await ctx.finishTask({
              taskState: plannedTask
            });
          },
          async execute(ctx, req) {
            let account = await ctx.universe.acquireAccount(ctx, req.accountId);
            let foldersTOC = await ctx.universe.acquireAccountFoldersTOC(ctx, account.id);
            let fromDb = await ctx.beginMutate({
              conversations: new Map([[req.convId, null]]),
              messagesByConversation: new Map([[req.convId, null]])
            });
            const oldMessages = fromDb.messagesByConversation.get(req.convId);
            const oldConvInfo = fromDb.conversations.get(req.convId);
            const eventChewer = new RecurringEventBundleChewer({
              convId: req.convId,
              uid: req.uid,
              rangeOldestTS: req.rangeOldestTS,
              rangeNewestTS: req.rangeNewestTS,
              jcalEvents: req.jcalEvents,
              oldConvInfo,
              oldMessages,
              foldersTOC
            });
            eventChewer.chewEventBundle();
            let convInfo;
            if (eventChewer.allMessages.length) {
              convInfo = churnConversationDriver(req.convId, oldConvInfo, eventChewer.allMessages);
            } else {
              convInfo = null;
            }
            let modifiedConversations, newConversations;
            if (oldConvInfo) {
              modifiedConversations = new Map([[req.convId, convInfo]]);
            } else if (convInfo) {
              newConversations = [convInfo];
            }
            await ctx.finishTask({
              mutations: {
                conversations: modifiedConversations,
                messages: eventChewer.modifiedMessageMap
              },
              newData: {
                conversations: newConversations,
                messages: eventChewer.newMessages
              }
            });
          }
        }
      ]);
    }
  });

  // src/backend/accounts/ical/sync_state_helper.js
  var ICalSyncStateHelper;
  var init_sync_state_helper2 = __esm({
    "src/backend/accounts/ical/sync_state_helper.js"() {
      init_logic();
      init_a64();
      init_date();
      ICalSyncStateHelper = class {
        constructor(ctx, rawSyncState, accountId, why) {
          logic.defineScope(this, "ICalSyncState", { ctxId: ctx.id, why });
          if (!rawSyncState) {
            logic(ctx, "creatingDefaultSyncState", {});
            rawSyncState = {
              nextConvId: 1,
              rangeOldestTS: makeDaysAgo(30),
              rangeNewestTS: makeDaysAgo(-30),
              uidToConvIdAndLastModified: new Map()
            };
          }
          this._accountId = accountId;
          this.rawSyncState = rawSyncState;
          this.uidToConvIdAndLastModified = rawSyncState.uidToConvIdAndLastModified;
          this.unseenUids = new Set(rawSyncState.uidToConvIdAndLastModified.keys());
          this.eventsByUid = new Map();
          this.tasksToSchedule = [];
          this.convMutations = null;
        }
        _makeUidConvTask({
          convId,
          uid,
          lastModifiedTS,
          jcalEvents,
          rangeOldestTS,
          rangeNewestTS
        }) {
          let task = {
            type: "sync_uid",
            accountId: this._accountId,
            convId,
            uid,
            lastModifiedTS,
            rangeOldestTS,
            rangeNewestTS,
            jcalEvents
          };
          this.tasksToSchedule.push(task);
          return task;
        }
        _issueUniqueConvId() {
          return this._accountId + "." + encodeInt(this.rawSyncState.nextConvId++);
        }
        ingestEvent(event) {
          const uid = event.getFirstPropertyValue("uid");
          let eventArray = this.eventsByUid.get(uid);
          if (!eventArray) {
            eventArray = [];
            this.eventsByUid.set(uid, eventArray);
          }
          eventArray.push(event);
        }
        processEvents() {
          for (const [uid, eventArray] of this.eventsByUid.entries()) {
            const event = eventArray[0];
            const lastModifiedDateTime = event.getFirstPropertyValue("last-modified");
            const lastModifiedTS = lastModifiedDateTime.toJSDate().valueOf();
            let existingSyncInfo = this.uidToConvIdAndLastModified.get(uid);
            let convId;
            let needsIndexing = false;
            if (!existingSyncInfo) {
              convId = this._issueUniqueConvId();
              this.uidToConvIdAndLastModified.set(uid, { convId, lastModifiedTS });
              needsIndexing = true;
            } else {
              this.unseenUids.delete(uid);
              convId = existingSyncInfo.convId;
              if (existingSyncInfo.lastModifiedTS !== lastModifiedTS) {
                needsIndexing = true;
                existingSyncInfo.lastModifiedTS = lastModifiedTS;
              }
            }
            if (needsIndexing) {
              eventArray.sort((cA, cB) => {
                const aVal = cA.hasProperty("recurrence-id") ? 1 : 0;
                const bVal = cB.hasProperty("recurrence-id") ? 1 : 0;
                return bVal - aVal;
              });
              const jcalEvents = eventArray.map((cEvent) => cEvent.toJSON());
              this._makeUidConvTask({
                convId,
                uid,
                lastModifiedTS,
                jcalEvents,
                rangeOldestTS: this.rawSyncState.rangeOldestTS,
                rangeNewestTS: this.rawSyncState.rangeNewestTS
              });
            }
          }
          if (this.unseenUids.size) {
            this.convMutations = new Map();
            for (const uid of this.unseenUids) {
              const existingSyncInfo = this.uidToConvIdAndLastModified.get(uid);
              this.uidToConvIdAndLastModified.delete(uid);
              this._makeUidConvTask({
                convId: existingSyncInfo.convId,
                uid,
                lastModifiedTS: 0,
                jcalEvents: [],
                rangeOldestTS: this.rawSyncState.rangeOldestTS,
                rangeNewestTS: this.rawSyncState.rangeNewestTS
              });
            }
          }
        }
      };
    }
  });

  // src/backend/accounts/ical/tasks/sync_refresh.js
  var import_ical3, sync_refresh_default3;
  var init_sync_refresh3 = __esm({
    "src/backend/accounts/ical/tasks/sync_refresh.js"() {
      init_logic();
      import_ical3 = __toModule(require_ical());
      init_util();
      init_date();
      init_task_definer();
      init_sync_state_helper2();
      init_id_conversions();
      init_sync_overlay_helpers();
      sync_refresh_default3 = task_definer_default.defineAtMostOnceTask([
        {
          name: "sync_refresh",
          binByArg: "accountId",
          helped_overlay_accounts: syncNormalOverlay,
          helped_prefix_overlay_folders: [accountIdFromFolderId, syncPrefixOverlay],
          helped_invalidate_overlays(accountId, dataOverlayManager) {
            dataOverlayManager.announceUpdatedOverlayData("accounts", accountId);
            dataOverlayManager.announceUpdatedOverlayData("accountCascadeToFolders", accountId);
          },
          helped_already_planned(ctx, rawTask) {
            return Promise.resolve({
              result: ctx.trackMeInTaskGroup("sync_refresh:" + rawTask.accountId)
            });
          },
          helped_plan(ctx, rawTask) {
            let plannedTask = shallowClone2(rawTask);
            plannedTask.resources = [
              "online",
              `credentials!${rawTask.accountId}`,
              `happy!${rawTask.accountId}`
            ];
            plannedTask.priorityTags = [`view:folder:${rawTask.folderId}`];
            let groupPromise = ctx.trackMeInTaskGroup("sync_refresh:" + rawTask.accountId);
            return Promise.resolve({
              taskState: plannedTask,
              remainInProgressUntil: groupPromise,
              result: groupPromise
            });
          },
          async helped_execute(ctx, req) {
            let fromDb = await ctx.beginMutate({
              syncStates: new Map([[req.accountId, null]])
            });
            let rawSyncState = fromDb.syncStates.get(req.accountId);
            let syncState = new ICalSyncStateHelper(ctx, rawSyncState, req.accountId, "refresh");
            let account = await ctx.universe.acquireAccount(ctx, req.accountId);
            let syncDate = NOW();
            logic(ctx, "syncStart", { syncDate });
            const icalResp = await fetch(account.calendarUrl);
            const icalText = await icalResp.text();
            const parsed = import_ical3.default.parse(icalText);
            const root = new import_ical3.default.Component(parsed);
            for (const event of root.getAllSubcomponents("vevent")) {
              syncState.ingestEvent(event);
            }
            syncState.processEvents();
            logic(ctx, "syncEnd", {});
            return {
              mutations: {
                syncStates: new Map([[req.accountId, syncState.rawSyncState]])
              },
              newData: {
                tasks: syncState.tasksToSchedule
              },
              atomicClobbers: {
                accounts: new Map([
                  [
                    req.accountId,
                    {
                      syncInfo: {
                        lastSuccessfulSyncAt: syncDate,
                        lastAttemptedSyncAt: syncDate,
                        failedSyncsSinceLastSuccessfulSync: 0
                      }
                    }
                  ]
                ])
              }
            };
          }
        }
      ]);
    }
  });

  // src/backend/accounts/ical/ical_tasks.js
  var ical_tasks_exports = {};
  __export(ical_tasks_exports, {
    default: () => ical_tasks_default
  });
  var ical_tasks_default;
  var init_ical_tasks = __esm({
    "src/backend/accounts/ical/ical_tasks.js"() {
      init_sync_folder_list3();
      init_sync_uid();
      init_sync_refresh3();
      init_account_modify();
      init_identity_modify();
      init_new_tracking();
      ical_tasks_default = [
        sync_folder_list_default3,
        sync_uid_default,
        sync_refresh_default3,
        account_modify_default,
        identity_modify_default,
        new_tracking_default
      ];
    }
  });

  // src/vendor/fibonacci-heap.js
  var require_fibonacci_heap = __commonJS({
    "src/vendor/fibonacci-heap.js"(exports, module) {
      (function(root, factory) {
        "use strict";
        if (typeof define === "function" && define.amd) {
          define([], function() {
            return root.FibonacciHeap = factory();
          });
        } else if (typeof exports === "object") {
          module.exports = factory();
        } else {
          root.FibonacciHeap = factory();
        }
      })(exports, function() {
        "use strict";
        var FibonacciHeap2 = function(customCompare) {
          this.minNode = void 0;
          this.nodeCount = 0;
          if (customCompare) {
            this.compare = customCompare;
          }
        };
        FibonacciHeap2.prototype.clear = function() {
          this.minNode = void 0;
          this.nodeCount = 0;
        };
        FibonacciHeap2.prototype.decreaseKey = function(node, newKey) {
          if (typeof node === "undefined") {
            throw "Cannot decrease key of non-existent node";
          }
          if (this.compare({ key: newKey }, { key: node.key }) > 0) {
            throw "New key is larger than old key";
          }
          node.key = newKey;
          var parent2 = node.parent;
          if (parent2 && this.compare(node, parent2) < 0) {
            cut(node, parent2, this.minNode, this.compare);
            cascadingCut(parent2, this.minNode, this.compare);
          }
          if (this.compare(node, this.minNode) < 0) {
            this.minNode = node;
          }
        };
        FibonacciHeap2.prototype.delete = function(node) {
          node.isMinimum = true;
          var parent2 = node.parent;
          if (parent2) {
            cut(node, parent2, this.minNode, this.compare);
            cascadingCut(parent2, this.minNode, this.compare);
          }
          this.minNode = node;
          this.extractMinimum();
        };
        FibonacciHeap2.prototype.extractMinimum = function() {
          var extractedMin = this.minNode;
          if (extractedMin) {
            if (extractedMin.child) {
              var child = extractedMin.child;
              do {
                child.parent = void 0;
                child = child.next;
              } while (child !== extractedMin.child);
            }
            var nextInRootList;
            if (this.minNode.next !== this.minNode) {
              nextInRootList = this.minNode.next;
            }
            removeNodeFromList(extractedMin);
            this.nodeCount--;
            this.minNode = mergeLists(nextInRootList, extractedMin.child, this.compare);
            if (nextInRootList) {
              this.minNode = nextInRootList;
              this.minNode = consolidate(this.minNode, this.compare);
            }
          }
          return extractedMin;
        };
        FibonacciHeap2.prototype.findMinimum = function() {
          return this.minNode;
        };
        FibonacciHeap2.prototype.insert = function(key, value) {
          var node = new Node(key, value);
          this.minNode = mergeLists(this.minNode, node, this.compare);
          this.nodeCount++;
          return node;
        };
        FibonacciHeap2.prototype.isEmpty = function() {
          return this.minNode === void 0;
        };
        FibonacciHeap2.prototype.size = function() {
          if (this.isEmpty()) {
            return 0;
          }
          return getNodeListSize(this.minNode);
        };
        FibonacciHeap2.prototype.union = function(other) {
          this.minNode = mergeLists(this.minNode, other.minNode, this.compare);
          this.nodeCount += other.nodeCount;
        };
        FibonacciHeap2.prototype.compare = function(a, b) {
          if (a.key > b.key) {
            return 1;
          }
          if (a.key < b.key) {
            return -1;
          }
          return 0;
        };
        function cut(node, parent2, minNode, compare) {
          removeNodeFromList(node);
          parent2.degree--;
          if (node.next === node) {
            parent2.child = void 0;
          } else {
            parent2.child = node.next;
          }
          minNode = mergeLists(minNode, node, compare);
          node.isMarked = false;
          return minNode;
        }
        function cascadingCut(node, minNode, compare) {
          var parent2 = node.parent;
          if (parent2) {
            if (node.isMarked) {
              minNode = cut(node, parent2, minNode, compare);
              minNode = cascadingCut(parent2, minNode, compare);
            } else {
              node.isMarked = true;
            }
          }
          return minNode;
        }
        function consolidate(minNode, compare) {
          var aux = [];
          var it = new NodeListIterator(minNode);
          while (it.hasNext()) {
            var current = it.next();
            while (aux[current.degree]) {
              if (compare(current, aux[current.degree]) > 0) {
                var temp = current;
                current = aux[current.degree];
                aux[current.degree] = temp;
              }
              linkHeaps(aux[current.degree], current, compare);
              aux[current.degree] = void 0;
              current.degree++;
            }
            aux[current.degree] = current;
          }
          minNode = void 0;
          for (var i = 0; i < aux.length; i++) {
            if (aux[i]) {
              aux[i].next = aux[i];
              aux[i].prev = aux[i];
              minNode = mergeLists(minNode, aux[i], compare);
            }
          }
          return minNode;
        }
        function removeNodeFromList(node) {
          var prev = node.prev;
          var next = node.next;
          prev.next = next;
          next.prev = prev;
          node.next = node;
          node.prev = node;
        }
        function linkHeaps(max, min, compare) {
          removeNodeFromList(max);
          min.child = mergeLists(max, min.child, compare);
          max.parent = min;
          max.isMarked = false;
        }
        function mergeLists(a, b, compare) {
          if (!a && !b) {
            return void 0;
          }
          if (!a) {
            return b;
          }
          if (!b) {
            return a;
          }
          var temp = a.next;
          a.next = b.next;
          a.next.prev = a;
          b.next = temp;
          b.next.prev = b;
          return compare(a, b) < 0 ? a : b;
        }
        function getNodeListSize(node) {
          var count = 0;
          var current = node;
          do {
            count++;
            if (current.child) {
              count += getNodeListSize(current.child);
            }
            current = current.next;
          } while (current !== node);
          return count;
        }
        function Node(key, value) {
          this.key = key;
          this.value = value;
          this.prev = this;
          this.next = this;
          this.degree = 0;
          this.parent = void 0;
          this.child = void 0;
          this.isMarked = void 0;
          this.isMinimum = void 0;
        }
        var NodeListIterator = function(start) {
          if (!start) {
            return;
          }
          this.items = [];
          var current = start;
          do {
            this.items.push(current);
            current = current.next;
          } while (start !== current);
        };
        NodeListIterator.prototype.hasNext = function() {
          return this.items.length > 0;
        };
        NodeListIterator.prototype.next = function() {
          return this.items.shift();
        };
        return FibonacciHeap2;
      });
    }
  });

  // src/vendor/streams.js
  var require_streams = __commonJS({
    "src/vendor/streams.js"(exports, module) {
      (function(f) {
        if (typeof exports === "object" && typeof module !== "undefined") {
          module.exports = f();
        } else if (typeof define === "function" && define.amd) {
          define([], f);
        } else {
          var g;
          if (typeof window !== "undefined") {
            g = window;
          } else if (typeof global !== "undefined") {
            g = global;
          } else if (typeof self !== "undefined") {
            g = self;
          } else {
            g = this;
          }
          g.Streams = f();
        }
      })(function() {
        var define2, module2, exports2;
        return function e(t, n, r) {
          function s(o2, u) {
            if (!n[o2]) {
              if (!t[o2]) {
                var a = typeof __require == "function" && __require;
                if (!u && a)
                  return a(o2, true);
                if (i)
                  return i(o2, true);
                var f = new Error("Cannot find module '" + o2 + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
              }
              var l = n[o2] = { exports: {} };
              t[o2][0].call(l.exports, function(e2) {
                var n2 = t[o2][1][e2];
                return s(n2 ? n2 : e2);
              }, l, l.exports, e, t, n, r);
            }
            return n[o2].exports;
          }
          var i = typeof __require == "function" && __require;
          for (var o = 0; o < r.length; o++)
            s(r[o]);
          return s;
        }({ 1: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.assert = assert;
          function assert(val, msg) {
            if (!val) {
              throw new Error("AssertionError: " + msg);
            }
          }
        }, {}], 2: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _helpers = require2("./helpers");
          var ByteLengthQueuingStrategy = function() {
            function ByteLengthQueuingStrategy2(_ref) {
              var highWaterMark = _ref.highWaterMark;
              _classCallCheck(this, ByteLengthQueuingStrategy2);
              (0, _helpers.createDataProperty)(this, "highWaterMark", highWaterMark);
            }
            _createClass(ByteLengthQueuingStrategy2, [{
              key: "size",
              value: function size(chunk) {
                return chunk.byteLength;
              }
            }]);
            return ByteLengthQueuingStrategy2;
          }();
          exports3["default"] = ByteLengthQueuingStrategy;
          module3.exports = exports3["default"];
        }, { "./helpers": 4 }], 3: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _helpers = require2("./helpers");
          var CountQueuingStrategy2 = function() {
            function CountQueuingStrategy3(_ref) {
              var highWaterMark = _ref.highWaterMark;
              _classCallCheck(this, CountQueuingStrategy3);
              (0, _helpers.createDataProperty)(this, "highWaterMark", highWaterMark);
            }
            _createClass(CountQueuingStrategy3, [{
              key: "size",
              value: function size(chunk) {
                return 1;
              }
            }]);
            return CountQueuingStrategy3;
          }();
          exports3["default"] = CountQueuingStrategy2;
          module3.exports = exports3["default"];
        }, { "./helpers": 4 }], 4: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.promiseCall = promiseCall;
          exports3.typeIsObject = typeIsObject;
          exports3.toInteger = toInteger;
          exports3.createDataProperty = createDataProperty;
          exports3.createArrayFromList = createArrayFromList;
          exports3.CreateIterResultObject = CreateIterResultObject;
          exports3.InvokeOrNoop = InvokeOrNoop;
          exports3.PromiseInvokeOrNoop = PromiseInvokeOrNoop;
          exports3.PromiseInvokeOrFallbackOrNoop = PromiseInvokeOrFallbackOrNoop;
          exports3.ValidateAndNormalizeQueuingStrategy = ValidateAndNormalizeQueuingStrategy;
          var _assert = require2("./assert");
          function promiseCall(func) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            try {
              return Promise.resolve(func.apply(void 0, args));
            } catch (e) {
              return Promise.reject(e);
            }
          }
          function typeIsObject(x) {
            return typeof x === "object" && x !== null || typeof x === "function";
          }
          function toInteger(v) {
            v = Number(v);
            if (isNaN(v)) {
              return 0;
            }
            if (v < 0) {
              return -1 * Math.floor(Math.abs(v));
            }
            return Math.floor(Math.abs(v));
          }
          function createDataProperty(o, p, v) {
            (0, _assert.assert)(typeIsObject(o));
            Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });
          }
          function createArrayFromList(elements) {
            return elements.slice();
          }
          function CreateIterResultObject(value, done) {
            (0, _assert.assert)(typeof done === "boolean");
            var obj = {};
            Object.defineProperty(obj, "value", { value, enumerable: true, writable: true, configurable: true });
            Object.defineProperty(obj, "done", { value: done, enumerable: true, writable: true, configurable: true });
            return obj;
          }
          function InvokeOrNoop(O, P, args) {
            var method = O[P];
            if (method === void 0) {
              return void 0;
            }
            return method.apply(O, args);
          }
          function PromiseInvokeOrNoop(O, P, args) {
            var method = void 0;
            try {
              method = O[P];
            } catch (methodE) {
              return Promise.reject(methodE);
            }
            if (method === void 0) {
              return Promise.resolve(void 0);
            }
            try {
              return Promise.resolve(method.apply(O, args));
            } catch (e) {
              return Promise.reject(e);
            }
          }
          function PromiseInvokeOrFallbackOrNoop(O, P1, args1, P2, args2) {
            var method = void 0;
            try {
              method = O[P1];
            } catch (methodE) {
              return Promise.reject(methodE);
            }
            if (method === void 0) {
              return PromiseInvokeOrNoop(O, P2, args2);
            }
            try {
              return Promise.resolve(method.apply(O, args1));
            } catch (e) {
              return Promise.reject(e);
            }
          }
          function ValidateAndNormalizeQueuingStrategy(size, highWaterMark) {
            if (size !== void 0 && typeof size !== "function") {
              throw new TypeError("size property of a queuing strategy must be a function");
            }
            highWaterMark = Number(highWaterMark);
            if (Number.isNaN(highWaterMark)) {
              throw new TypeError("highWaterMark property of a queuing strategy must be convertible to a non-NaN number");
            }
            if (highWaterMark < 0) {
              throw new RangeError("highWaterMark property of a queuing strategy must be nonnegative");
            }
            return { size, highWaterMark };
          }
        }, { "./assert": 1 }], 5: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          var _byteLengthQueuingStrategyJs = require2("./byte-length-queuing-strategy.js");
          var _byteLengthQueuingStrategyJs2 = _interopRequireDefault(_byteLengthQueuingStrategyJs);
          var _countQueuingStrategyJs = require2("./count-queuing-strategy.js");
          var _countQueuingStrategyJs2 = _interopRequireDefault(_countQueuingStrategyJs);
          var _readableStreamJs = require2("./readable-stream.js");
          var _readableStreamJs2 = _interopRequireDefault(_readableStreamJs);
          var _transformStreamJs = require2("./transform-stream.js");
          var _transformStreamJs2 = _interopRequireDefault(_transformStreamJs);
          var _writableStreamJs = require2("./writable-stream.js");
          var _writableStreamJs2 = _interopRequireDefault(_writableStreamJs);
          var Streams = {
            ByteLengthQueuingStrategy: _byteLengthQueuingStrategyJs2["default"],
            CountQueuingStrategy: _countQueuingStrategyJs2["default"],
            ReadableStream: _readableStreamJs2["default"],
            TransformStream: _transformStreamJs2["default"],
            WritableStream: _writableStreamJs2["default"]
          };
          exports3["default"] = Streams;
          module3.exports = exports3["default"];
        }, { "./byte-length-queuing-strategy.js": 2, "./count-queuing-strategy.js": 3, "./readable-stream.js": 7, "./transform-stream.js": 8, "./writable-stream.js": 10 }], 6: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.DequeueValue = DequeueValue;
          exports3.EnqueueValueWithSize = EnqueueValueWithSize;
          exports3.GetTotalQueueSize = GetTotalQueueSize;
          exports3.PeekQueueValue = PeekQueueValue;
          var _assert = require2("./assert");
          function DequeueValue(queue) {
            (0, _assert.assert)(queue.length > 0, "Spec-level failure: should never dequeue from an empty queue.");
            var pair = queue.shift();
            return pair.value;
          }
          function EnqueueValueWithSize(queue, value, size) {
            size = Number(size);
            if (Number.isNaN(size) || size === Infinity || size === -Infinity) {
              throw new RangeError("Size must be a finite, non-NaN number.");
            }
            queue.push({ value, size });
          }
          function GetTotalQueueSize(queue) {
            var totalSize = 0;
            queue.forEach(function(pair) {
              (0, _assert.assert)(typeof pair.size === "number" && !Number.isNaN(pair.size) && pair.size !== Infinity && pair.size !== -Infinity, "Spec-level failure: should never find an invalid size in the queue.");
              totalSize += pair.size;
            });
            return totalSize;
          }
          function PeekQueueValue(queue) {
            (0, _assert.assert)(queue.length > 0, "Spec-level failure: should never peek at an empty queue.");
            var pair = queue[0];
            return pair.value;
          }
        }, { "./assert": 1 }], 7: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _slicedToArray(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = void 0;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"])
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _assert = require2("./assert");
          var _helpers = require2("./helpers");
          var _utils = require2("./utils");
          var _queueWithSizes = require2("./queue-with-sizes");
          var ReadableStream = function() {
            function ReadableStream2() {
              var _this = this;
              var underlyingSource = arguments[0] === void 0 ? {} : arguments[0];
              var _ref = arguments[1] === void 0 ? {} : arguments[1];
              var size = _ref.size;
              var _ref$highWaterMark = _ref.highWaterMark;
              var highWaterMark = _ref$highWaterMark === void 0 ? 1 : _ref$highWaterMark;
              _classCallCheck(this, ReadableStream2);
              this._underlyingSource = underlyingSource;
              this._queue = [];
              this._state = "readable";
              this._started = false;
              this._closeRequested = false;
              this._pulling = false;
              this._pullAgain = false;
              this._reader = void 0;
              this._storedError = void 0;
              var normalizedStrategy = (0, _helpers.ValidateAndNormalizeQueuingStrategy)(size, highWaterMark);
              this._strategySize = normalizedStrategy.size;
              this._strategyHWM = normalizedStrategy.highWaterMark;
              this._controller = new ReadableStreamController(this);
              var startResult = (0, _helpers.InvokeOrNoop)(underlyingSource, "start", [this._controller]);
              Promise.resolve(startResult).then(function() {
                _this._started = true;
                RequestReadableStreamPull(_this);
              }, function(r) {
                if (_this._state === "readable") {
                  return ErrorReadableStream(_this, r);
                }
              })["catch"](_utils.rethrowAssertionErrorRejection);
            }
            _createClass(ReadableStream2, [{
              key: "cancel",
              value: function cancel(reason) {
                if (IsReadableStream(this) === false) {
                  return Promise.reject(new TypeError("ReadableStream.prototype.cancel can only be used on a ReadableStream"));
                }
                if (IsReadableStreamLocked(this) === true) {
                  return Promise.reject(new TypeError("Cannot cancel a stream that already has a reader"));
                }
                return CancelReadableStream(this, reason);
              }
            }, {
              key: "getReader",
              value: function getReader() {
                if (IsReadableStream(this) === false) {
                  throw new TypeError("ReadableStream.prototype.getReader can only be used on a ReadableStream");
                }
                return AcquireReadableStreamReader(this);
              }
            }, {
              key: "pipeThrough",
              value: function pipeThrough(_ref2, options) {
                var writable = _ref2.writable;
                var readable = _ref2.readable;
                this.pipeTo(writable, options);
                return readable;
              }
            }, {
              key: "pipeTo",
              value: function pipeTo(dest) {
                var _ref3 = arguments[1] === void 0 ? {} : arguments[1];
                var preventClose = _ref3.preventClose;
                var preventAbort = _ref3.preventAbort;
                var preventCancel = _ref3.preventCancel;
                preventClose = Boolean(preventClose);
                preventAbort = Boolean(preventAbort);
                preventCancel = Boolean(preventCancel);
                var source = this;
                var reader = void 0;
                var lastRead = void 0;
                var lastWrite = void 0;
                var closedPurposefully = false;
                var resolvePipeToPromise = void 0;
                var rejectPipeToPromise = void 0;
                return new Promise(function(resolve, reject) {
                  resolvePipeToPromise = resolve;
                  rejectPipeToPromise = reject;
                  reader = source.getReader();
                  reader.closed["catch"](abortDest);
                  dest.closed.then(function() {
                    if (!closedPurposefully) {
                      cancelSource(new TypeError("destination is closing or closed and cannot be piped to anymore"));
                    }
                  }, cancelSource);
                  doPipe();
                });
                function doPipe() {
                  lastRead = reader.read();
                  Promise.all([lastRead, dest.ready]).then(function(_ref4) {
                    var _ref42 = _slicedToArray(_ref4, 1);
                    var _ref42$0 = _ref42[0];
                    var value = _ref42$0.value;
                    var done = _ref42$0.done;
                    if (Boolean(done) === true) {
                      closeDest();
                    } else if (dest.state === "writable") {
                      lastWrite = dest.write(value);
                      doPipe();
                    }
                  });
                }
                function cancelSource(reason) {
                  if (preventCancel === false) {
                    reader.cancel(reason);
                    rejectPipeToPromise(reason);
                  } else {
                    lastRead.then(function() {
                      reader.releaseLock();
                      rejectPipeToPromise(reason);
                    });
                  }
                }
                function closeDest() {
                  reader.releaseLock();
                  var destState = dest.state;
                  if (preventClose === false && (destState === "waiting" || destState === "writable")) {
                    closedPurposefully = true;
                    dest.close().then(resolvePipeToPromise, rejectPipeToPromise);
                  } else if (lastWrite !== void 0) {
                    lastWrite.then(resolvePipeToPromise, rejectPipeToPromise);
                  } else {
                    resolvePipeToPromise();
                  }
                }
                function abortDest(reason) {
                  reader.releaseLock();
                  if (preventAbort === false) {
                    dest.abort(reason);
                  }
                  rejectPipeToPromise(reason);
                }
              }
            }, {
              key: "tee",
              value: function tee() {
                if (IsReadableStream(this) === false) {
                  throw new TypeError("ReadableStream.prototype.tee can only be used on a ReadableStream");
                }
                var branches = TeeReadableStream(this, false);
                return (0, _helpers.createArrayFromList)(branches);
              }
            }]);
            return ReadableStream2;
          }();
          exports3["default"] = ReadableStream;
          var ReadableStreamController = function() {
            function ReadableStreamController2(stream) {
              _classCallCheck(this, ReadableStreamController2);
              if (IsReadableStream(stream) === false) {
                throw new TypeError("ReadableStreamController can only be constructed with a ReadableStream instance");
              }
              if (stream._controller !== void 0) {
                throw new TypeError("ReadableStreamController instances can only be created by the ReadableStream constructor");
              }
              this._controlledReadableStream = stream;
            }
            _createClass(ReadableStreamController2, [{
              key: "desiredSize",
              get: function() {
                if (IsReadableStreamController(this) === false) {
                  throw new TypeError("ReadableStreamController.prototype.desiredSize can only be used on a ReadableStreamController");
                }
                return GetReadableStreamDesiredSize(this._controlledReadableStream);
              }
            }, {
              key: "close",
              value: function close() {
                if (IsReadableStreamController(this) === false) {
                  throw new TypeError("ReadableStreamController.prototype.close can only be used on a ReadableStreamController");
                }
                var stream = this._controlledReadableStream;
                if (stream._closeRequested === true) {
                  throw new TypeError("The stream has already been closed; do not close it again! " + new Error().stack);
                }
                if (stream._state === "errored") {
                  throw new TypeError("The stream is in an errored state and cannot be closed");
                }
                return CloseReadableStream(stream);
              }
            }, {
              key: "enqueue",
              value: function enqueue(chunk) {
                if (IsReadableStreamController(this) === false) {
                  throw new TypeError("ReadableStreamController.prototype.enqueue can only be used on a ReadableStreamController");
                }
                var stream = this._controlledReadableStream;
                if (stream._state === "errored") {
                  throw stream._storedError;
                }
                if (stream._closeRequested === true) {
                  throw new TypeError("stream is closed or draining" + new Error().stack);
                }
                return EnqueueInReadableStream(stream, chunk);
              }
            }, {
              key: "error",
              value: function error(e) {
                if (IsReadableStreamController(this) === false) {
                  throw new TypeError("ReadableStreamController.prototype.error can only be used on a ReadableStreamController");
                }
                if (this._controlledReadableStream._state !== "readable") {
                  throw new TypeError("The stream is " + this._controlledReadableStream._state + " and so cannot be errored");
                }
                return ErrorReadableStream(this._controlledReadableStream, e);
              }
            }]);
            return ReadableStreamController2;
          }();
          var ReadableStreamReader = function() {
            function ReadableStreamReader2(stream) {
              var _this2 = this;
              _classCallCheck(this, ReadableStreamReader2);
              if (IsReadableStream(stream) === false) {
                throw new TypeError("ReadableStreamReader can only be constructed with a ReadableStream instance");
              }
              if (IsReadableStreamLocked(stream) === true) {
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              }
              stream._reader = this;
              this._ownerReadableStream = stream;
              this._state = "readable";
              this._storedError = void 0;
              this._readRequests = [];
              this._closedPromise = new Promise(function(resolve, reject) {
                _this2._closedPromise_resolve = resolve;
                _this2._closedPromise_reject = reject;
              });
              if (stream._state === "closed" || stream._state === "errored") {
                ReleaseReadableStreamReader(this);
              }
            }
            _createClass(ReadableStreamReader2, [{
              key: "closed",
              get: function() {
                if (IsReadableStreamReader(this) === false) {
                  return Promise.reject(new TypeError("ReadableStreamReader.prototype.closed can only be used on a ReadableStreamReader"));
                }
                return this._closedPromise;
              }
            }, {
              key: "cancel",
              value: function cancel(reason) {
                if (IsReadableStreamReader(this) === false) {
                  return Promise.reject(new TypeError("ReadableStreamReader.prototype.cancel can only be used on a ReadableStreamReader"));
                }
                if (this._state === "closed") {
                  return Promise.resolve(void 0);
                }
                if (this._state === "errored") {
                  return Promise.reject(this._storedError);
                }
                (0, _assert.assert)(this._ownerReadableStream !== void 0);
                (0, _assert.assert)(this._ownerReadableStream._state === "readable");
                return CancelReadableStream(this._ownerReadableStream, reason);
              }
            }, {
              key: "read",
              value: function read() {
                if (IsReadableStreamReader(this) === false) {
                  return Promise.reject(new TypeError("ReadableStreamReader.prototype.read can only be used on a ReadableStreamReader"));
                }
                return ReadFromReadableStreamReader(this);
              }
            }, {
              key: "releaseLock",
              value: function releaseLock() {
                if (IsReadableStreamReader(this) === false) {
                  throw new TypeError("ReadableStreamReader.prototype.releaseLock can only be used on a ReadableStreamReader");
                }
                if (this._ownerReadableStream === void 0) {
                  return void 0;
                }
                if (this._readRequests.length > 0) {
                  throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                }
                return ReleaseReadableStreamReader(this);
              }
            }]);
            return ReadableStreamReader2;
          }();
          function AcquireReadableStreamReader(stream) {
            return new ReadableStreamReader(stream);
          }
          function CancelReadableStream(stream, reason) {
            if (stream._state === "closed") {
              return Promise.resolve(void 0);
            }
            if (stream._state === "errored") {
              return Promise.reject(stream._storedError);
            }
            stream._queue = [];
            FinishClosingReadableStream(stream);
            var sourceCancelPromise = (0, _helpers.PromiseInvokeOrNoop)(stream._underlyingSource, "cancel", [reason]);
            return sourceCancelPromise.then(function() {
              return void 0;
            });
          }
          function CloseReadableStream(stream) {
            (0, _assert.assert)(stream._closeRequested === false);
            (0, _assert.assert)(stream._state !== "errored");
            if (stream._state === "closed") {
              return void 0;
            }
            stream._closeRequested = true;
            if (stream._queue.length === 0) {
              return FinishClosingReadableStream(stream);
            }
          }
          function EnqueueInReadableStream(stream, chunk) {
            (0, _assert.assert)(stream._closeRequested === false);
            (0, _assert.assert)(stream._state !== "errored");
            if (stream._state === "closed") {
              return void 0;
            }
            if (IsReadableStreamLocked(stream) === true && stream._reader._readRequests.length > 0) {
              var readRequest = stream._reader._readRequests.shift();
              readRequest._resolve((0, _helpers.CreateIterResultObject)(chunk, false));
            } else {
              var chunkSize = 1;
              if (stream._strategySize !== void 0) {
                try {
                  chunkSize = stream._strategySize(chunk);
                } catch (chunkSizeE) {
                  ErrorReadableStream(stream, chunkSizeE);
                  throw chunkSizeE;
                }
              }
              try {
                (0, _queueWithSizes.EnqueueValueWithSize)(stream._queue, chunk, chunkSize);
              } catch (enqueueE) {
                ErrorReadableStream(stream, enqueueE);
                throw enqueueE;
              }
            }
            RequestReadableStreamPull(stream);
            return void 0;
          }
          function ErrorReadableStream(stream, e) {
            (0, _assert.assert)(stream._state === "readable");
            stream._queue = [];
            stream._storedError = e;
            stream._state = "errored";
            if (IsReadableStreamLocked(stream) === true) {
              return ReleaseReadableStreamReader(stream._reader);
            }
          }
          function FinishClosingReadableStream(stream) {
            (0, _assert.assert)(stream._state === "readable");
            stream._state = "closed";
            if (IsReadableStreamLocked(stream) === true) {
              return ReleaseReadableStreamReader(stream._reader);
            }
            return void 0;
          }
          function GetReadableStreamDesiredSize(stream) {
            var queueSize = (0, _queueWithSizes.GetTotalQueueSize)(stream._queue);
            return stream._strategyHWM - queueSize;
          }
          function IsReadableStream(x) {
            if (!(0, _helpers.typeIsObject)(x)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x, "_underlyingSource")) {
              return false;
            }
            return true;
          }
          function IsReadableStreamLocked(stream) {
            (0, _assert.assert)(IsReadableStream(stream) === true, "IsReadableStreamLocked should only be used on known readable streams");
            if (stream._reader === void 0) {
              return false;
            }
            return true;
          }
          function IsReadableStreamController(x) {
            if (!(0, _helpers.typeIsObject)(x)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
              return false;
            }
            return true;
          }
          function IsReadableStreamReader(x) {
            if (!(0, _helpers.typeIsObject)(x)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x, "_ownerReadableStream")) {
              return false;
            }
            return true;
          }
          function ReadFromReadableStreamReader(reader) {
            if (reader._state === "closed") {
              return Promise.resolve((0, _helpers.CreateIterResultObject)(void 0, true));
            }
            if (reader._state === "errored") {
              return Promise.reject(reader._storedError);
            }
            (0, _assert.assert)(reader._ownerReadableStream !== void 0);
            (0, _assert.assert)(reader._ownerReadableStream._state === "readable");
            if (reader._ownerReadableStream._queue.length > 0) {
              var chunk = (0, _queueWithSizes.DequeueValue)(reader._ownerReadableStream._queue);
              if (reader._ownerReadableStream._closeRequested === true && reader._ownerReadableStream._queue.length === 0) {
                FinishClosingReadableStream(reader._ownerReadableStream);
              } else {
                RequestReadableStreamPull(reader._ownerReadableStream);
              }
              return Promise.resolve((0, _helpers.CreateIterResultObject)(chunk, false));
            } else {
              var _ret = function() {
                var readRequest = {};
                readRequest.promise = new Promise(function(resolve, reject) {
                  readRequest._resolve = resolve;
                  readRequest._reject = reject;
                });
                reader._readRequests.push(readRequest);
                RequestReadableStreamPull(reader._ownerReadableStream);
                return {
                  v: readRequest.promise
                };
              }();
              if (typeof _ret === "object")
                return _ret.v;
            }
          }
          function ReleaseReadableStreamReader(reader) {
            (0, _assert.assert)(reader._ownerReadableStream !== void 0);
            if (reader._ownerReadableStream._state === "errored") {
              reader._state = "errored";
              var e = reader._ownerReadableStream._storedError;
              reader._storedError = e;
              reader._closedPromise_reject(e);
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = void 0;
              try {
                for (var _iterator = reader._readRequests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var _reject = _step.value._reject;
                  _reject(e);
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            } else {
              reader._state = "closed";
              reader._closedPromise_resolve(void 0);
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = void 0;
              try {
                for (var _iterator2 = reader._readRequests[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var _resolve = _step2.value._resolve;
                  _resolve((0, _helpers.CreateIterResultObject)(void 0, true));
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                    _iterator2["return"]();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
            reader._readRequests = [];
            reader._ownerReadableStream._reader = void 0;
            reader._ownerReadableStream = void 0;
          }
          function RequestReadableStreamPull(stream) {
            var shouldPull = ShouldReadableStreamPull(stream);
            if (shouldPull === false) {
              return void 0;
            }
            if (stream._pulling === true) {
              stream._pullAgain = true;
              return void 0;
            }
            stream._pulling = true;
            var pullPromise = (0, _helpers.PromiseInvokeOrNoop)(stream._underlyingSource, "pull", [stream._controller]);
            pullPromise.then(function() {
              stream._pulling = false;
              if (stream._pullAgain === true) {
                stream._pullAgain = false;
                return RequestReadableStreamPull(stream);
              }
            }, function(e) {
              if (stream._state === "readable") {
                return ErrorReadableStream(stream, e);
              }
            })["catch"](_utils.rethrowAssertionErrorRejection);
            return void 0;
          }
          function ShouldReadableStreamPull(stream) {
            if (stream._state === "closed" || stream._state === "errored") {
              return false;
            }
            if (stream._closeRequested === true) {
              return false;
            }
            if (stream._started === false) {
              return false;
            }
            if (IsReadableStreamLocked(stream) === true && stream._reader._readRequests.length > 0) {
              return true;
            }
            var desiredSize = GetReadableStreamDesiredSize(stream);
            if (desiredSize > 0) {
              return true;
            }
            return false;
          }
          function TeeReadableStream(stream, shouldClone) {
            (0, _assert.assert)(IsReadableStream(stream) === true);
            (0, _assert.assert)(typeof shouldClone === "boolean");
            var reader = AcquireReadableStreamReader(stream);
            var teeState = {
              closedOrErrored: false,
              canceled1: false,
              canceled2: false,
              reason1: void 0,
              reason2: void 0
            };
            teeState.promise = new Promise(function(resolve) {
              return teeState._resolve = resolve;
            });
            var pull = create_TeeReadableStreamPullFunction();
            pull._reader = reader;
            pull._teeState = teeState;
            pull._shouldClone = shouldClone;
            var cancel1 = create_TeeReadableStreamBranch1CancelFunction();
            cancel1._stream = stream;
            cancel1._teeState = teeState;
            var cancel2 = create_TeeReadableStreamBranch2CancelFunction();
            cancel2._stream = stream;
            cancel2._teeState = teeState;
            var underlyingSource1 = Object.create(Object.prototype);
            (0, _helpers.createDataProperty)(underlyingSource1, "pull", pull);
            (0, _helpers.createDataProperty)(underlyingSource1, "cancel", cancel1);
            var branch1 = new ReadableStream(underlyingSource1);
            var underlyingSource2 = Object.create(Object.prototype);
            (0, _helpers.createDataProperty)(underlyingSource2, "pull", pull);
            (0, _helpers.createDataProperty)(underlyingSource2, "cancel", cancel2);
            var branch2 = new ReadableStream(underlyingSource2);
            pull._branch1 = branch1;
            pull._branch2 = branch2;
            reader._closedPromise["catch"](function(r) {
              if (teeState.closedOrErrored === true) {
                return void 0;
              }
              ErrorReadableStream(branch1, r);
              ErrorReadableStream(branch2, r);
              teeState.closedOrErrored = true;
            });
            return [branch1, branch2];
          }
          function create_TeeReadableStreamPullFunction() {
            var f = function f2() {
              var reader = f2._reader;
              var branch1 = f2._branch1;
              var branch2 = f2._branch2;
              var teeState = f2._teeState;
              var shouldClone = f2._shouldClone;
              return ReadFromReadableStreamReader(reader).then(function(result) {
                (0, _assert.assert)((0, _helpers.typeIsObject)(result));
                var value = result.value;
                var done = result.done;
                (0, _assert.assert)(typeof done === "boolean");
                if (done === true && teeState.closedOrErrored === false) {
                  CloseReadableStream(branch1);
                  CloseReadableStream(branch2);
                  teeState.closedOrErrored = true;
                }
                if (teeState.closedOrErrored === true) {
                  return void 0;
                }
                if (teeState.canceled1 === false) {
                  var value1 = value;
                  EnqueueInReadableStream(branch1, value1);
                }
                if (teeState.canceled2 === false) {
                  var value2 = value;
                  EnqueueInReadableStream(branch2, value2);
                }
              });
            };
            return f;
          }
          function create_TeeReadableStreamBranch1CancelFunction() {
            var f = function f2(reason) {
              var stream = f2._stream;
              var teeState = f2._teeState;
              teeState.canceled1 = true;
              teeState.reason1 = reason;
              if (teeState.canceled2 === true) {
                var compositeReason = (0, _helpers.createArrayFromList)([teeState.reason1, teeState.reason2]);
                var cancelResult = CancelReadableStream(stream, compositeReason);
                teeState._resolve(cancelResult);
              }
              return teeState.promise;
            };
            return f;
          }
          function create_TeeReadableStreamBranch2CancelFunction() {
            var f = function f2(reason) {
              var stream = f2._stream;
              var teeState = f2._teeState;
              teeState.canceled2 = true;
              teeState.reason2 = reason;
              if (teeState.canceled1 === true) {
                var compositeReason = (0, _helpers.createArrayFromList)([teeState.reason1, teeState.reason2]);
                var cancelResult = CancelReadableStream(stream, compositeReason);
                teeState._resolve(cancelResult);
              }
              return teeState.promise;
            };
            return f;
          }
          module3.exports = exports3["default"];
        }, { "./assert": 1, "./helpers": 4, "./queue-with-sizes": 6, "./utils": 9 }], 8: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _readableStream = require2("./readable-stream");
          var _readableStream2 = _interopRequireDefault(_readableStream);
          var _writableStream = require2("./writable-stream");
          var _writableStream2 = _interopRequireDefault(_writableStream);
          var TransformStream2 = function TransformStream3(transformer) {
            _classCallCheck(this, TransformStream3);
            if (transformer.flush === void 0) {
              transformer.flush = function(enqueue, close) {
                return close();
              };
            }
            if (typeof transformer.transform !== "function") {
              throw new TypeError("transform must be a function");
            }
            var writeChunk = void 0, writeDone = void 0, errorWritable = void 0;
            var transforming = false;
            var chunkWrittenButNotYetTransformed = false;
            this.writable = new _writableStream2["default"]({
              start: function start(error) {
                errorWritable = error;
              },
              write: function write(chunk) {
                writeChunk = chunk;
                chunkWrittenButNotYetTransformed = true;
                var p = new Promise(function(resolve) {
                  return writeDone = resolve;
                });
                maybeDoTransform();
                return p;
              },
              abort(e) {
                errorReadable(e);
              },
              close: function close() {
                try {
                  transformer.flush(enqueueInReadable, closeReadable);
                } catch (e) {
                  errorWritable(e);
                  errorReadable(e);
                }
              }
            }, transformer.writableStrategy);
            var enqueueInReadable = void 0, closeReadable = void 0, errorReadable = void 0;
            this.readable = new _readableStream2["default"]({
              start: function start(c) {
                enqueueInReadable = c.enqueue.bind(c);
                closeReadable = c.close.bind(c);
                errorReadable = c.error.bind(c);
              },
              pull: function pull() {
                if (chunkWrittenButNotYetTransformed === true) {
                  maybeDoTransform();
                }
              }
            }, transformer.readableStrategy);
            function maybeDoTransform() {
              if (transforming === false) {
                transforming = true;
                try {
                  transformer.transform(writeChunk, enqueueInReadable, transformDone);
                  writeChunk = void 0;
                  chunkWrittenButNotYetTransformed = false;
                } catch (e) {
                  transforming = false;
                  errorWritable(e);
                  errorReadable(e);
                }
              }
            }
            function transformDone() {
              transforming = false;
              writeDone();
            }
          };
          exports3["default"] = TransformStream2;
          module3.exports = exports3["default"];
        }, { "./readable-stream": 7, "./writable-stream": 10 }], 9: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.rethrowAssertionErrorRejection = rethrowAssertionErrorRejection;
          var _assert = require2("./assert");
          function rethrowAssertionErrorRejection(e) {
            if (e && e.constructor === _assert.assert.AssertionError) {
              setTimeout(function() {
                throw e;
              }, 0);
            }
          }
        }, { "./assert": 1 }], 10: [function(require2, module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          exports3.IsWritableStream = IsWritableStream;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var _assert = require2("./assert");
          var _helpers = require2("./helpers");
          var _utils = require2("./utils");
          var _queueWithSizes = require2("./queue-with-sizes");
          var _countQueuingStrategy = require2("./count-queuing-strategy");
          var _countQueuingStrategy2 = _interopRequireDefault(_countQueuingStrategy);
          var WritableStream2 = function() {
            function WritableStream3() {
              var _this = this;
              var underlyingSink = arguments[0] === void 0 ? {} : arguments[0];
              var _ref = arguments[1] === void 0 ? {} : arguments[1];
              var size = _ref.size;
              var _ref$highWaterMark = _ref.highWaterMark;
              var highWaterMark = _ref$highWaterMark === void 0 ? 0 : _ref$highWaterMark;
              _classCallCheck(this, WritableStream3);
              this._underlyingSink = underlyingSink;
              this._closedPromise = new Promise(function(resolve, reject) {
                _this._closedPromise_resolve = resolve;
                _this._closedPromise_reject = reject;
              });
              this._readyPromise = Promise.resolve(void 0);
              this._readyPromise_resolve = null;
              this._queue = [];
              this._state = "writable";
              this._started = false;
              this._writing = false;
              var normalizedStrategy = (0, _helpers.ValidateAndNormalizeQueuingStrategy)(size, highWaterMark);
              this._strategySize = normalizedStrategy.size;
              this._strategyHWM = normalizedStrategy.highWaterMark;
              SyncWritableStreamStateWithQueue(this);
              var error = closure_WritableStreamErrorFunction();
              error._stream = this;
              var startResult = (0, _helpers.InvokeOrNoop)(underlyingSink, "start", [error]);
              this._startedPromise = Promise.resolve(startResult);
              this._startedPromise.then(function() {
                _this._started = true;
                _this._startedPromise = void 0;
              });
              this._startedPromise["catch"](function(r) {
                return ErrorWritableStream(_this, r);
              })["catch"](_utils.rethrowAssertionErrorRejection);
            }
            _createClass(WritableStream3, [{
              key: "closed",
              get: function() {
                if (!IsWritableStream(this)) {
                  return Promise.reject(new TypeError("WritableStream.prototype.closed can only be used on a WritableStream"));
                }
                return this._closedPromise;
              }
            }, {
              key: "state",
              get: function() {
                if (!IsWritableStream(this)) {
                  throw new TypeError("WritableStream.prototype.state can only be used on a WritableStream");
                }
                return this._state;
              }
            }, {
              key: "abort",
              value: function abort(reason) {
                if (!IsWritableStream(this)) {
                  return Promise.reject(new TypeError("WritableStream.prototype.abort can only be used on a WritableStream"));
                }
                if (this._state === "closed") {
                  return Promise.resolve(void 0);
                }
                if (this._state === "errored") {
                  return Promise.reject(this._storedError);
                }
                ErrorWritableStream(this, reason);
                var sinkAbortPromise = (0, _helpers.PromiseInvokeOrFallbackOrNoop)(this._underlyingSink, "abort", [reason], "close", []);
                return sinkAbortPromise.then(function() {
                  return void 0;
                });
              }
            }, {
              key: "close",
              value: function close() {
                if (!IsWritableStream(this)) {
                  return Promise.reject(new TypeError("WritableStream.prototype.close can only be used on a WritableStream"));
                }
                if (this._state === "closing") {
                  return Promise.reject(new TypeError("cannot close an already-closing stream"));
                }
                if (this._state === "closed") {
                  return Promise.reject(new TypeError("cannot close an already-closed stream"));
                }
                if (this._state === "errored") {
                  return Promise.reject(this._storedError);
                }
                if (this._state === "waiting") {
                  this._readyPromise_resolve(void 0);
                }
                this._state = "closing";
                (0, _queueWithSizes.EnqueueValueWithSize)(this._queue, "close", 0);
                CallOrScheduleWritableStreamAdvanceQueue(this);
                return this._closedPromise;
              }
            }, {
              key: "ready",
              get: function() {
                if (!IsWritableStream(this)) {
                  return Promise.reject(new TypeError("WritableStream.prototype.ready can only be used on a WritableStream"));
                }
                return this._readyPromise;
              }
            }, {
              key: "write",
              value: function write(chunk) {
                if (!IsWritableStream(this)) {
                  return Promise.reject(new TypeError("WritableStream.prototype.write can only be used on a WritableStream"));
                }
                if (this._state === "closing") {
                  return Promise.reject(new TypeError("cannot write while stream is closing"));
                }
                if (this._state === "closed") {
                  return Promise.reject(new TypeError("cannot write after stream is closed" + new Error().stack));
                }
                if (this._state === "errored") {
                  return Promise.reject(this._storedError);
                }
                (0, _assert.assert)(this._state === "waiting" || this._state === "writable");
                var chunkSize = 1;
                if (this._strategySize !== void 0) {
                  try {
                    chunkSize = this._strategySize(chunk);
                  } catch (chunkSizeE) {
                    ErrorWritableStream(this, chunkSizeE);
                    return Promise.reject(chunkSizeE);
                  }
                }
                var resolver = void 0, rejecter = void 0;
                var promise = new Promise(function(resolve, reject) {
                  resolver = resolve;
                  rejecter = reject;
                });
                var writeRecord = { promise, chunk, _resolve: resolver, _reject: rejecter };
                try {
                  (0, _queueWithSizes.EnqueueValueWithSize)(this._queue, writeRecord, chunkSize);
                } catch (enqueueResultE) {
                  ErrorWritableStream(this, enqueueResultE);
                  return Promise.reject(enqueueResultE);
                }
                try {
                  SyncWritableStreamStateWithQueue(this);
                } catch (syncResultE) {
                  ErrorWritableStream(this, syncResultE);
                  return promise;
                }
                CallOrScheduleWritableStreamAdvanceQueue(this);
                return promise;
              }
            }]);
            return WritableStream3;
          }();
          exports3["default"] = WritableStream2;
          function closure_WritableStreamErrorFunction() {
            var f = function f2(e) {
              return ErrorWritableStream(f2._stream, e);
            };
            return f;
          }
          function CallOrScheduleWritableStreamAdvanceQueue(stream) {
            if (stream._started === false) {
              stream._startedPromise.then(function() {
                WritableStreamAdvanceQueue(stream);
              })["catch"](_utils.rethrowAssertionErrorRejection);
              return void 0;
            }
            if (stream._started === true) {
              return WritableStreamAdvanceQueue(stream);
            }
          }
          function CloseWritableStream(stream) {
            (0, _assert.assert)(stream._state === "closing", "stream must be in closing state while calling CloseWritableStream");
            var sinkClosePromise = (0, _helpers.PromiseInvokeOrNoop)(stream._underlyingSink, "close");
            sinkClosePromise.then(function() {
              if (stream._state === "errored") {
                return;
              }
              (0, _assert.assert)(stream._state === "closing");
              stream._closedPromise_resolve(void 0);
              stream._state = "closed";
            }, function(r) {
              return ErrorWritableStream(stream, r);
            })["catch"](_utils.rethrowAssertionErrorRejection);
          }
          function ErrorWritableStream(stream, e) {
            if (stream._state === "closed" || stream._state === "errored") {
              return void 0;
            }
            while (stream._queue.length > 0) {
              var writeRecord = (0, _queueWithSizes.DequeueValue)(stream._queue);
              if (writeRecord !== "close") {
                writeRecord._reject(e);
              }
            }
            stream._storedError = e;
            if (stream._state === "waiting") {
              stream._readyPromise_resolve(void 0);
            }
            stream._closedPromise_reject(e);
            stream._state = "errored";
          }
          function IsWritableStream(x) {
            if (!(0, _helpers.typeIsObject)(x)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x, "_underlyingSink")) {
              return false;
            }
            return true;
          }
          function SyncWritableStreamStateWithQueue(stream) {
            if (stream._state === "closing") {
              return void 0;
            }
            (0, _assert.assert)(stream._state === "writable" || stream._state === "waiting", "stream must be in a writable or waiting state while calling SyncWritableStreamStateWithQueue");
            var queueSize = (0, _queueWithSizes.GetTotalQueueSize)(stream._queue);
            var shouldApplyBackpressure = queueSize > stream._strategyHWM;
            if (shouldApplyBackpressure === true && stream._state === "writable") {
              stream._state = "waiting";
              stream._readyPromise = new Promise(function(resolve, reject) {
                stream._readyPromise_resolve = resolve;
              });
            }
            if (shouldApplyBackpressure === false && stream._state === "waiting") {
              stream._state = "writable";
              stream._readyPromise_resolve(void 0);
            }
            return void 0;
          }
          function WritableStreamAdvanceQueue(stream) {
            if (stream._queue.length === 0 || stream._writing === true) {
              return void 0;
            }
            var writeRecord = (0, _queueWithSizes.PeekQueueValue)(stream._queue);
            if (writeRecord === "close") {
              (0, _assert.assert)(stream._state === "closing", "can't process final write record unless already closing");
              (0, _queueWithSizes.DequeueValue)(stream._queue);
              (0, _assert.assert)(stream._queue.length === 0, "queue must be empty once the final write record is dequeued");
              return CloseWritableStream(stream);
            } else {
              stream._writing = true;
              (0, _helpers.PromiseInvokeOrNoop)(stream._underlyingSink, "write", [writeRecord.chunk]).then(function() {
                if (stream._state === "errored") {
                  return;
                }
                stream._writing = false;
                writeRecord._resolve(void 0);
                (0, _queueWithSizes.DequeueValue)(stream._queue);
                try {
                  SyncWritableStreamStateWithQueue(stream);
                } catch (syncResultE) {
                  return ErrorWritableStream(stream, syncResultE);
                }
                return WritableStreamAdvanceQueue(stream);
              }, function(r) {
                return ErrorWritableStream(stream, r);
              })["catch"](_utils.rethrowAssertionErrorRejection);
            }
          }
        }, { "./assert": 1, "./count-queuing-strategy": 3, "./helpers": 4, "./queue-with-sizes": 6, "./utils": 9 }] }, {}, [5])(5);
      });
    }
  });

  // src/backend/worker-setup.js
  init_logic();

  // src/backend/worker-router.js
  var listeners = {};
  function receiveMessage(evt12) {
    var data = evt12.data;
    var listener = listeners[data.type];
    if (listener) {
      listener(data, evt12.source);
    }
  }
  function receiveConnect(evt12) {
    const port = evt12.ports[0];
    if (!defaultPort) {
      defaultPort = port;
      resolveDefaultPort(defaultPort);
    }
    port.onmessage = receiveMessage;
  }
  var inSharedWorker = "onconnect" in globalThis;
  var defaultPort;
  var defaultPortPromise;
  var resolveDefaultPort = null;
  if (!inSharedWorker) {
    defaultPort = globalThis;
    defaultPortPromise = Promise.resolve(defaultPort);
    globalThis.addEventListener("message", receiveMessage);
  } else {
    globalThis.addEventListener("connect", receiveConnect);
    defaultPortPromise = new Promise((resolve) => {
      resolveDefaultPort = resolve;
    });
  }
  async function eventuallySendToDefault(message) {
    await defaultPortPromise;
    defaultPort.postMessage(message);
  }
  function unregister(type) {
    delete listeners[type];
  }
  function registerSimple(type, callback) {
    listeners[type] = callback;
    return function sendSimpleMessage(cmd, args) {
      eventuallySendToDefault({ type, uid: null, cmd, args });
    };
  }
  var callbackSenders = {};
  function registerCallbackType(type) {
    if (callbackSenders.hasOwnProperty(type)) {
      return callbackSenders[type];
    }
    var callbacks = {};
    var uid = 0;
    listeners[type] = function receiveCallbackMessage(data) {
      var callback = callbacks[data.uid];
      if (!callback) {
        return;
      }
      delete callbacks[data.uid];
      callback(data.args);
    };
    var sender = function sendCallbackMessage(cmd, args) {
      return new Promise((resolve) => {
        callbacks[uid] = resolve;
        eventuallySendToDefault({ type, uid: uid++, cmd, args });
      });
    };
    callbackSenders[type] = sender;
    return sender;
  }
  function registerInstanceType(type) {
    var uid = 0;
    var instanceMap = {};
    listeners[type] = function receiveInstanceMessage(data) {
      var instanceListener = instanceMap[data.uid];
      if (!instanceListener) {
        return;
      }
      instanceListener(data);
    };
    return {
      register(instanceListener, explicitPort) {
        const usePort = explicitPort || defaultPort;
        var thisUid = uid++;
        instanceMap[thisUid] = instanceListener;
        return {
          sendMessage: function sendInstanceMessage(cmd, args, transferArgs) {
            usePort.postMessage({ type, uid: thisUid, cmd, args }, transferArgs);
          },
          unregister: function unregisterInstance() {
            delete instanceMap[thisUid];
          }
        };
      }
    };
  }

  // src/backend/mailbridge.js
  init_logic();
  init_mailchew_strings();

  // src/backend/bridge/bridge_context.js
  init_logic();
  function NamedContext(name, type, bridgeContext) {
    logic.defineScope(this, type, {
      name,
      bridge: bridgeContext.bridge.name
    });
    this.name = name;
    this._bridgeContext = bridgeContext;
    this._active = true;
    this._stuffToRelease = [];
    this.__childContexts = [];
    this.pendingCommand = null;
    this.commandQueue = [];
  }
  NamedContext.prototype = {
    get batchManager() {
      return this._bridgeContext.batchManager;
    },
    get dataOverlayManager() {
      return this._bridgeContext.dataOverlayManager;
    },
    acquire(acquireable) {
      if (!this._active) {
        throw new Error("we have already cleaned up!");
      }
      this._stuffToRelease.push(acquireable);
      return acquireable.__acquire(this);
    },
    sendMessage(type, data) {
      this._bridgeContext.bridge.__sendMessage({
        type,
        handle: this.name,
        data
      });
    },
    runAtCleanup(func) {
      this._stuffToRelease.push({
        __release: func
      });
    },
    cleanup() {
      this._active = false;
      for (let acquireable of this._stuffToRelease) {
        try {
          acquireable.__release(this);
        } catch (ex) {
          logic(this, "problemReleasing", {
            what: acquireable,
            ex,
            stack: ex && ex.stack
          });
        }
      }
    }
  };
  function BridgeContext({
    bridge,
    batchManager,
    dataOverlayManager
  }) {
    logic.defineScope(this, "BridgeContext", { name: bridge.name });
    this.bridge = bridge;
    this.batchManager = batchManager;
    this.dataOverlayManager = dataOverlayManager;
    this._namedContexts = new Map();
  }
  BridgeContext.prototype = {
    createNamedContext(name, type, parentContext) {
      let ctx = new NamedContext(name, type, this);
      this._namedContexts.set(name, ctx);
      if (parentContext) {
        parentContext.__childContexts.push(ctx);
      }
      return ctx;
    },
    getNamedContextOrThrow(name) {
      if (this._namedContexts.has(name)) {
        return this._namedContexts.get(name);
      }
      throw new Error("no such namedContext: " + name);
    },
    maybeGetNamedContext(name) {
      return this._namedContexts.get(name);
    },
    cleanupNamedContext(name) {
      if (!this._namedContexts.has(name)) {
        return;
      }
      const ctx = this._namedContexts.get(name);
      for (let childContext of ctx.__childContexts) {
        this.cleanupNamedContext(childContext.name);
      }
      this._namedContexts.delete(name);
      ctx.cleanup();
    },
    cleanupAll() {
      for (let namedContext of this._namedContext.values()) {
        namedContext.cleanup();
      }
      this._namedContexts.clear();
    }
  };

  // src/backend/bridge/batch_manager.js
  init_logic();
  function BatchManager(db) {
    logic.defineScope(this, "BatchManager");
    this._db = db;
    this._pendingProxies = new Set();
    this._timer = null;
    this._bound_timerFired = this._flushPending.bind(this, true);
    this._bound_dbFlush = this._flushPending.bind(this, false);
    this.flushDelayMillis = 100;
    this._db.on("cacheDrop", this._bound_dbFlush);
  }
  BatchManager.prototype = {
    __cleanup() {
      this._db.removeListener("cacheDrop", this._bound_dbFlush);
    },
    _flushPending(timerFired) {
      if (!timerFired) {
        globalThis.clearTimeout(this._timer);
      }
      this._timer = null;
      logic(this, "flushing", {
        proxyCount: this._pendingProxies.size,
        tocTypes: Array.from(this._pendingProxies).map((proxy) => {
          return proxy.toc.type;
        }),
        timerFired
      });
      for (let proxy of this._pendingProxies) {
        let payload = proxy.flush();
        if (payload) {
          proxy.ctx.sendMessage("update", payload);
        }
      }
      this._pendingProxies.clear();
    },
    registerDirtyView(proxy, flushMode) {
      logic(this, "dirtying", {
        tocType: proxy.toc.type,
        ctxName: proxy.ctx.name,
        flushMode,
        alreadyDirty: this._pendingProxies.has(proxy)
      });
      this._pendingProxies.add(proxy);
      if (flushMode) {
        if (flushMode === "immediate") {
          this._flushPending(false);
        } else if (this._timer !== true) {
          if (this._timer) {
            globalThis.clearTimeout(this._timer);
          }
          Promise.resolve().then(() => {
            this._flushPending(false);
          });
          this._timer = true;
        }
      } else if (!this._timer) {
        this._timer = globalThis.setTimeout(this._bound_timerFired, this.flushDelayMillis);
      }
    }
  };

  // src/backend/bridge/entire_list_proxy.js
  init_logic();
  function EntireListProxy(toc, ctx) {
    logic.defineScope(this, "EntireListProxy", { tocType: toc.type });
    this.toc = toc;
    this.ctx = ctx;
    this.batchManager = ctx.batchManager;
    this.overlayResolver = ctx.dataOverlayManager.makeBoundResolver(toc.overlayNamespace, ctx);
    this._bound_onAdd = this.onAdd.bind(this);
    this._bound_onChange = this.onChange.bind(this);
    this._bound_onOverlayPush = this.onOverlayPush.bind(this);
    this._bound_onRemove = this.onRemove.bind(this);
    this._pendingChanges = [];
    this._idToChangeIndex = new Map();
    this.dirty = true;
    this._active = false;
  }
  EntireListProxy.prototype = {
    populateFromList() {
      let items = this.toc.getAllItems();
      for (let i = 0; i < items.length; i++) {
        this.onAdd(items[i], i);
      }
      this.batchManager.registerDirtyView(this, "immediate");
      this.toc.on("add", this._bound_onAdd);
      this.toc.on("change", this._bound_onChange);
      this.toc.on("remove", this._bound_onRemove);
      this.ctx.dataOverlayManager.on(this.toc.overlayNamespace, this._bound_onOverlayPush);
    },
    __acquire() {
      return Promise.resolve(this);
    },
    __release() {
      if (!this._active) {
        return;
      }
      this._active = false;
      this.toc.removeListener("add", this._bound_onAdd);
      this.toc.removeListener("change", this._bound_onChange);
      this.toc.removeListener("remove", this._bound_onRemove);
      this.ctx.dataOverlayManager.removeListener(this.toc.overlayNamespace, this._bound_onOverlayPush);
    },
    _dirty() {
      if (this.dirty) {
        return;
      }
      this.dirty = true;
      this.batchManager.registerDirtyView(this);
    },
    onAdd(item, index) {
      this._dirty();
      this._idToChangeIndex.set(item.id, this._pendingChanges.length);
      this._pendingChanges.push({
        type: "add",
        index,
        state: item,
        overlays: this.overlayResolver(item.id)
      });
    },
    onChange(item, index) {
      if (this._idToChangeIndex.has(item.id)) {
        let changeIndex = this._idToChangeIndex.get(item.id);
        this._pendingChanges[changeIndex].state = item;
        return;
      }
      this._dirty();
      this._idToChangeIndex.set(item.id, this._pendingChanges.length);
      this._pendingChanges.push({
        type: "change",
        index,
        state: item,
        overlays: null
      });
    },
    onOverlayPush(itemId) {
      if (!this.toc.itemsById.has(itemId)) {
        return;
      }
      let overlays = this.overlayResolver(itemId);
      if (this._idToChangeIndex.has(itemId)) {
        let changeIndex = this._idToChangeIndex.get(itemId);
        this._pendingChanges[changeIndex].overlays = overlays;
        return;
      }
      this._dirty();
      this._idToChangeIndex.set(itemId, this._pendingChanges.length);
      this._pendingChanges.push({
        type: "change",
        index: this.toc.getItemIndexById(itemId),
        state: null,
        overlays
      });
    },
    onRemove(id, index) {
      this._dirty();
      this._pendingChanges.push({
        type: "remove",
        index
      });
      this._idToChangeIndex.delete(id);
    },
    flush() {
      let changes = this._pendingChanges;
      this._pendingChanges = [];
      this._idToChangeIndex.clear();
      this.dirty = false;
      return {
        changes
      };
    }
  };

  // src/backend/bridge/windowed_list_proxy.js
  function WindowedListProxy(toc, ctx) {
    this.toc = toc;
    this.ctx = ctx;
    this.batchManager = ctx.batchManager;
    this.dirty = false;
    this.dirtyMeta = true;
    this.validDataSet = new Set();
    this.pendingBroadcastEvents = [];
    this.validOverlaySet = new Set();
    this._bound_onChange = this.onChange.bind(this);
    this._bound_onTOCMetaChange = this.onTOCMetaChange.bind(this);
    this._bound_onBroadcastEvent = this.onBroadcastEvent.bind(this);
    this._bound_onOverlayPush = this.onOverlayPush.bind(this);
  }
  WindowedListProxy.prototype = {
    __acquire() {
      this.toc.on("change", this._bound_onChange);
      this.toc.on("tocMetaChange", this._bound_onTOCMetaChange);
      this.toc.on("broadcastEvent", this._bound_onBroadcastEvent);
      this.ctx.dataOverlayManager.on(this.toc.overlayNamespace, this._bound_onOverlayPush);
      return Promise.resolve(this);
    },
    __release() {
      this.toc.removeListener("change", this._bound_onChange);
      this.toc.removeListener("tocMetaChange", this._bound_onTOCMetaChange);
      this.toc.removeListener("broadcastEvent", this._bound_onBroadcastEvent);
      this.ctx.dataOverlayManager.removeListener(this.toc.overlayNamespace, this._bound_onOverlayPush);
    },
    seek(req) {
      if (req.mode === "top") {
        this.mode = req.mode;
        this.focusKey = null;
        this.bufferAbove = 0;
        this.visibleAbove = 0;
        this.visibleBelow = req.visibleDesired;
        this.bufferBelow = req.bufferDesired;
      } else if (req.mode === "bottom") {
        this.mode = req.mode;
        this.focusKey = null;
        this.bufferAbove = req.bufferDesired;
        this.visibleAbove = req.visibleDesired;
        this.visibleBelow = 0;
        this.bufferBelow = 0;
      } else if (req.mode === "focus") {
        this.mode = req.mode;
        this.focusKey = req.focusKey;
        this.bufferAbove = req.bufferAbove;
        this.visibleAbove = req.visibleAbove;
        this.visibleBelow = req.visibleBelow;
        this.bufferBelow = req.bufferBelow;
      } else if (req.mode === "focusIndex") {
        this.mode = "focus";
        this.focusKey = this.toc.getOrderingKeyForIndex(req.index);
        this.bufferAbove = req.bufferAbove;
        this.visibleAbove = req.visibleAbove;
        this.visibleBelow = req.visibleBelow;
        this.bufferBelow = req.bufferBelow;
      } else if (req.mode === "coordinates") {
        if (this.toc.heightAware) {
          this.mode = req.mode;
          let focalOffset = req.offset + req.before;
          let { orderingKey, offset } = this.toc.getInfoForOffset(focalOffset);
          this.focusKey = orderingKey;
          let focusUnitsNotVisible = Math.max(0, focalOffset - offset);
          this.bufferAbove = req.before - focusUnitsNotVisible;
          this.visibleAbove = 0;
          this.visibleBelow = req.visible - (offset - focalOffset);
          this.bufferBelow = req.after;
        } else {
          this.mode = "focus";
          this.focusKey = this.toc.getOrderingKeyForIndex(req.offset);
          this.bufferAbove = req.before;
          this.visibleAbove = 0;
          this.visibleBelow = req.visible;
          this.bufferBelow = req.after;
        }
      } else {
        throw new Error("bogus seek mode: " + req.mode);
      }
      this.dirty = true;
      this.batchManager.registerDirtyView(this, "immediate");
    },
    onChange(id, dataOnly) {
      if (id === true) {
        this.validDataSet.clear();
      } else if (id !== null) {
        if (!this.validDataSet.has(id) && dataOnly) {
          return;
        }
        this.validDataSet.delete(id);
      }
      if (this.dirty) {
        return;
      }
      this.dirty = true;
      this.batchManager.registerDirtyView(this);
    },
    onOverlayPush(id) {
      if (!this.validOverlaySet.has(id)) {
        return;
      }
      this.validOverlaySet.delete(id);
      if (this.dirty) {
        return;
      }
      this.dirty = true;
      this.batchManager.registerDirtyView(this);
    },
    onTOCMetaChange() {
      this.dirtyMeta = true;
      if (this.dirty) {
        return;
      }
      this.dirty = true;
      this.batchManager.registerDirtyView(this);
    },
    onBroadcastEvent(eventName, eventData) {
      this.pendingBroadcastEvents.push({ name: eventName, data: eventData });
      this.dirty = true;
      this.batchManager.registerDirtyView(this, "soon");
    },
    flush() {
      if (this.dirty && this.toc.flush) {
        this.toc.flush();
      }
      let beginBufferedInclusive, beginVisibleInclusive, endVisibleExclusive, endBufferedExclusive, heightOffset;
      if (this.mode === "top") {
        beginBufferedInclusive = beginVisibleInclusive = 0;
        endVisibleExclusive = Math.min(this.toc.length, this.visibleBelow + 1);
        endBufferedExclusive = Math.min(this.toc.length, endVisibleExclusive + this.bufferBelow);
      } else if (this.mode === "bottom") {
        endBufferedExclusive = endVisibleExclusive = this.toc.length;
        beginVisibleInclusive = Math.max(0, endVisibleExclusive - this.visibleAbove);
        beginBufferedInclusive = Math.max(0, beginVisibleInclusive - this.bufferedAbove);
      } else if (this.mode === "focus") {
        let focusIndex = this.toc.findIndexForOrderingKey(this.focusKey);
        beginVisibleInclusive = Math.max(0, focusIndex - this.visibleAbove);
        beginBufferedInclusive = Math.max(0, beginVisibleInclusive - this.bufferAbove);
        endVisibleExclusive = Math.min(this.toc.length, focusIndex + this.visibleBelow + 1);
        endBufferedExclusive = Math.min(this.toc.length, endVisibleExclusive + this.bufferBelow);
      } else if (this.mode === "coordinates") {
        ({
          beginBufferedInclusive,
          beginVisibleInclusive,
          endVisibleExclusive,
          endBufferedExclusive,
          heightOffset
        } = this.toc.findIndicesFromCoordinateSoup({
          orderingKey: this.focusKey,
          bufferAbove: this.bufferAbove,
          visibleAbove: this.visibleAbove,
          visibleBelow: this.visibleBelow,
          bufferBelow: this.bufferBelow
        }));
      }
      this.dirty = false;
      let {
        ids,
        state,
        readPromise,
        newValidDataSet
      } = this.toc.getDataForSliceRange(beginBufferedInclusive, endBufferedExclusive, this.validDataSet, this.validOverlaySet);
      this.validDataSet = newValidDataSet;
      this.validOverlaySet = new Set(newValidDataSet);
      if (readPromise) {
        readPromise.then(() => {
          this.batchManager.registerDirtyView(this, "immediate");
        });
      }
      let sendMeta = null;
      if (this.dirtyMeta) {
        sendMeta = this.toc.tocMeta;
        this.dirtyMeta = false;
      }
      let sendEvents = null;
      if (this.pendingBroadcastEvents.length) {
        sendEvents = this.pendingBroadcastEvents;
        this.pendingBroadcastEvents = [];
      }
      return {
        offset: beginBufferedInclusive,
        heightOffset: heightOffset || beginBufferedInclusive,
        totalCount: this.toc.length,
        totalHeight: this.toc.totalHeight,
        tocMeta: sendMeta,
        ids,
        values: state,
        events: sendEvents
      };
    }
  };

  // src/backend/mailbridge.js
  function MailBridge(universe2, db, name) {
    logic.defineScope(this, "MailBridge", { name });
    this.name = name;
    this.universe = universe2;
    this.universe.registerBridge(this);
    this.db = db;
    this.batchManager = new BatchManager(db);
    this.bridgeContext = new BridgeContext({
      bridge: this,
      batchManager: this.batchManager,
      dataOverlayManager: this.universe.dataOverlayManager
    });
  }
  MailBridge.prototype = {
    __sendMessage() {
      throw new Error("This is supposed to get hidden by an instance var.");
    },
    __receiveMessage(msg) {
      var implCmdName = "_cmd_" + msg.type;
      if (!(implCmdName in this)) {
        logic(this, "badMessageTypeError", { type: msg.type });
        return;
      }
      try {
        let namedContext = msg.handle && this.bridgeContext.maybeGetNamedContext(msg.handle);
        if (namedContext) {
          if (namedContext.pendingCommand) {
            console.warn("deferring", msg);
            namedContext.commandQueue.push(msg);
          } else {
            let promise = namedContext.pendingCommand = this._processCommand(msg, implCmdName);
            if (promise) {
              this._trackCommandForNamedContext(namedContext, promise);
            }
          }
        } else {
          let promise = this._processCommand(msg, implCmdName);
          if (promise && msg.handle) {
            namedContext = this.bridgeContext.maybeGetNamedContext(msg.handle);
            if (namedContext) {
              namedContext.pendingCommand = promise;
              this._trackCommandForNamedContext(namedContext, promise);
            }
          }
        }
      } catch (ex) {
        logic(this, "cmdError", { type: msg.type, ex, stack: ex.stack });
      }
    },
    _trackCommandForNamedContext(namedContext, promise) {
      let successNext = () => {
        this._commandCompletedProcessNextCommandInQueue(namedContext);
      };
      let errorNext = (err) => {
        logic(this, "cmdAsyncError", { err, stack: err.stack });
        this._commandCompletedProcessNextCommandInQueue(namedContext);
      };
      promise.then(successNext, errorNext);
    },
    _commandCompletedProcessNextCommandInQueue(namedContext) {
      if (namedContext.commandQueue.length) {
        console.warn("processing deferred command");
        let promise = namedContext.pendingCommand = this._processCommand(namedContext.commandQueue.shift());
        if (promise) {
          let runNext = () => {
            this._commandCompletedProcessNextCommandInQueue(namedContext);
          };
          promise.then(runNext, runNext);
        }
      } else {
        namedContext.pendingCommand = null;
      }
    },
    broadcast(name, data) {
      this.__sendMessage({
        type: "broadcast",
        payload: { name, data }
      });
    },
    _processCommand(msg, implCmdName) {
      if (!implCmdName) {
        implCmdName = "_cmd_" + msg.type;
      }
      logic(this, "cmd", {
        type: msg.type,
        msg
      });
      try {
        let result = this[implCmdName](msg);
        if (result && result.then) {
          logic.await(this, "asyncCommand", { type: msg.type }, result);
          return result;
        }
      } catch (ex) {
        console.error("problem processing", implCmdName, ex, ex.stack);
        logic.fail(ex);
        return null;
      }
      return null;
    },
    _cmd_ping(msg) {
      this.__sendMessage({
        type: "pong",
        handle: msg.handle
      });
    },
    _cmd_setInteractive() {
      this.universe.setInteractive();
    },
    _cmd_localizedStrings(msg) {
      set(msg.strings);
    },
    _cmd_learnAboutAccount(msg) {
      this.universe.learnAboutAccount(msg.details).then((info) => {
        this.__sendMessage({
          type: "promisedResult",
          handle: msg.handle,
          data: info
        });
      }, () => {
        this.__sendMessage({
          type: "promisedResult",
          handle: msg.handle,
          data: { result: "no-config-info", configInfo: null }
        });
      });
    },
    _cmd_tryToCreateAccount(msg) {
      this.universe.tryToCreateAccount(msg.userDetails, msg.domainInfo).then((result) => {
        this.__sendMessage({
          type: "promisedResult",
          handle: msg.handle,
          data: {
            accountId: result.accountId || null,
            error: result.error,
            errorDetails: result.errorDetails
          }
        });
      });
    },
    _cmd_syncFolderList(msg) {
      this.universe.syncFolderList(msg.accountId, "bridge");
    },
    async _cmd_clearAccountProblems(msg) {
      var account = this.universe.getAccountForAccountId(msg.accountId), self2 = this;
      let [incomingErr, outgoingErr] = await account.checkAccount();
      let canIgnoreError = function(err) {
        return !err || err !== "bad-user-or-pass" && err !== "bad-address" && err !== "needs-oauth-reauth" && err !== "imap-disabled";
      };
      if (canIgnoreError(incomingErr) && canIgnoreError(outgoingErr)) {
        self2.universe.clearAccountProblems(account);
      }
      self2.__sendMessage({
        type: "clearAccountProblems",
        handle: msg.handle
      });
    },
    _cmd_modifyConfig(msg) {
      this.universe.modifyConfig(msg.mods, "bridge").then(() => {
        this.__sendMessage({
          type: "promisedResult",
          handle: msg.handle,
          data: null
        });
      });
    },
    _cmd_modifyAccount(msg) {
      this.universe.modifyAccount(msg.accountId, msg.mods, "bridge").then(() => {
        this.__sendMessage({
          type: "promisedResult",
          handle: msg.handle,
          data: null
        });
      });
    },
    _cmd_recreateAccount(msg) {
      this.universe.recreateAccount(msg.accountId, "bridge");
    },
    _cmd_deleteAccount(msg) {
      this.universe.deleteAccount(msg.accountId, "bridge");
    },
    _cmd_modifyIdentity(msg) {
      this.universe.modifyIdentity(msg.identityId, msg.mods, "bridge").then(() => {
        this.__sendMessage({
          type: "promisedResult",
          handle: msg.handle,
          data: null
        });
      });
    },
    notifyBadLogin(account, problem, whichSide) {
      this.__sendMessage({
        type: "badLogin",
        account: account.toBridgeWire(),
        problem,
        whichSide
      });
    },
    _cmd_requestBodies(msg) {
      var self2 = this;
      this.universe.downloadBodies(msg.messages, msg.options, function() {
        self2.__sendMessage({
          type: "requestBodiesComplete",
          handle: msg.handle,
          requestId: msg.requestId
        });
      });
    },
    async _cmd_viewAccounts(msg) {
      let ctx = this.bridgeContext.createNamedContext(msg.handle, "AccountsView");
      let toc = await this.universe.acquireAccountsTOC(ctx);
      ctx.proxy = new EntireListProxy(toc, ctx);
      await ctx.acquire(ctx.proxy);
      ctx.proxy.populateFromList();
    },
    async _cmd_viewFolders(msg) {
      let ctx = this.bridgeContext.createNamedContext(msg.handle, "FoldersView");
      let toc = await this.universe.acquireAccountFoldersTOC(ctx, msg.accountId);
      ctx.proxy = new EntireListProxy(toc, ctx);
      await ctx.acquire(ctx.proxy);
      ctx.proxy.populateFromList();
    },
    async _cmd_viewRawList(msg) {
      let ctx = this.bridgeContext.createNamedContext(msg.handle, "RawListView");
      ctx.viewing = {
        type: "raw",
        namespace: msg.namespace,
        name: msg.name
      };
      let toc = await this.universe.acquireExtensionTOC(ctx, msg.namespace, msg.name);
      ctx.proxy = new WindowedListProxy(toc, ctx);
      await ctx.acquire(ctx.proxy);
    },
    async _cmd_viewFolderConversations(msg) {
      let ctx = this.bridgeContext.createNamedContext(msg.handle, "FolderConversationsView");
      ctx.viewing = {
        type: "folder",
        folderId: msg.folderId
      };
      let toc = await this.universe.acquireFolderConversationsTOC(ctx, msg.folderId);
      ctx.proxy = new WindowedListProxy(toc, ctx);
      await ctx.acquire(ctx.proxy);
      this.universe.syncRefreshFolder(msg.folderId, "viewFolderConversations");
    },
    async _cmd_searchFolderConversations(msg) {
      let ctx = this.bridgeContext.createNamedContext(msg.handle, "FolderConversationsSearchView");
      ctx.viewing = {
        type: "folder",
        folderId: msg.spec.folderId
      };
      let spec = msg.spec;
      if (msg.viewDefsWithHandles) {
        let viewDefsWithContexts = msg.viewDefsWithHandles.map(({ handle, viewDef }) => {
          let viewCtx = this.bridgeContext.createNamedContext(handle, "DerivedView", ctx);
          viewCtx.viewing = {
            type: "derived"
          };
          return { ctx: viewCtx, viewDef };
        });
        spec = Object.assign({}, spec, { viewDefsWithContexts });
      }
      let toc = await this.universe.acquireSearchConversationsTOC(ctx, spec);
      ctx.proxy = new WindowedListProxy(toc, ctx);
      await ctx.acquire(ctx.proxy);
    },
    async _cmd_viewFolderMessages(msg) {
      let ctx = this.bridgeContext.createNamedContext(msg.handle, "FolderMessagesView");
      ctx.viewing = {
        type: "folder",
        folderId: msg.folderId
      };
      let toc = await this.universe.acquireFolderMessagesTOC(ctx, msg.folderId);
      ctx.proxy = new WindowedListProxy(toc, ctx);
      await ctx.acquire(ctx.proxy);
      this.universe.syncRefreshFolder(msg.folderId, "viewFolderMessages");
    },
    async _cmd_viewConversationMessages(msg) {
      let ctx = this.bridgeContext.createNamedContext(msg.handle, "ConversationMessagesView");
      ctx.viewing = {
        type: "conversation",
        conversationId: msg.conversationId
      };
      let toc = await this.universe.acquireConversationTOC(ctx, msg.conversationId);
      ctx.proxy = new WindowedListProxy(toc, ctx);
      await ctx.acquire(ctx.proxy);
    },
    async _cmd_searchConversationMessages(msg) {
      let ctx = this.bridgeContext.createNamedContext(msg.handle, "ConversationSearchView");
      ctx.viewing = {
        type: "conversation",
        conversationId: msg.conversationId
      };
      let toc = await this.universe.acquireSearchConversationMessagesTOC(ctx, msg.spec);
      ctx.proxy = new WindowedListProxy(toc, ctx);
      await ctx.acquire(ctx.proxy);
    },
    async _cmd_refreshView(msg) {
      let ctx = this.bridgeContext.getNamedContextOrThrow(msg.handle);
      if (ctx.viewing.type === "folder") {
        await this.universe.syncRefreshFolder(ctx.viewing.folderId, "refreshView");
      } else {
      }
    },
    _cmd_growView(msg) {
      let ctx = this.bridgeContext.getNamedContextOrThrow(msg.handle);
      if (ctx.viewing.type === "folder") {
        this.universe.syncGrowFolder(ctx.viewing.folderId, "growView");
      } else {
      }
    },
    _cmd_seekProxy(msg) {
      let ctx = this.bridgeContext.getNamedContextOrThrow(msg.handle);
      ctx.proxy.seek(msg);
    },
    async _cmd_getItemAndTrackUpdates(msg) {
      let requests = {};
      let idRequestMap = new Map();
      idRequestMap.set(msg.itemId, null);
      let rawToWireRep, eventArgsToRaw;
      let normId;
      let readKey;
      switch (msg.itemType) {
        case "conv":
          normId = msg.itemId;
          requests.conversations = idRequestMap;
          readKey = "conversations";
          rawToWireRep = (x) => x;
          eventArgsToRaw = (id, convInfo) => {
            return convInfo;
          };
          break;
        case "msg":
          normId = msg.itemId[0];
          requests.messages = idRequestMap;
          readKey = "messages";
          rawToWireRep = (x) => x;
          eventArgsToRaw = (id, messageInfo) => {
            return messageInfo;
          };
          break;
        default:
          throw new Error("unsupported item type: " + msg.itemType);
      }
      let eventId = msg.itemType + "!" + normId + "!change";
      let ctx = this.bridgeContext.createNamedContext(msg.handle, eventId);
      let fromDb = await this.db.read(ctx, requests);
      let dbWireRep = rawToWireRep(fromDb[readKey].get(normId));
      const dataOverlayManager = this.universe.dataOverlayManager;
      let boundOverlayResolver = dataOverlayManager.makeBoundResolver(readKey);
      let dataEventHandler = (arg1, arg2) => {
        let rep = eventArgsToRaw(arg1, arg2);
        if (rep) {
          rep = rawToWireRep(rep);
          ctx.sendMessage("updateItem", {
            state: rep,
            overlays: null
          });
        } else {
          ctx.sendMessage("updateItem", null);
        }
      };
      let overlayEventHandler = (modId) => {
        if (modId === normId) {
          ctx.sendMessage("updateItem", {
            state: null,
            overlays: boundOverlayResolver(normId)
          });
        }
      };
      this.db.on(eventId, dataEventHandler);
      dataOverlayManager.on(readKey, overlayEventHandler);
      ctx.runAtCleanup(() => {
        this.db.removeListener(eventId, dataEventHandler);
        dataOverlayManager.removeListener(readKey, overlayEventHandler);
      });
      ctx.sendMessage("gotItemNowTrackingUpdates", {
        state: dbWireRep,
        overlays: boundOverlayResolver(normId)
      });
    },
    _cmd_updateTrackedItemPriorityTags() {
    },
    _cmd_cleanupContext(msg) {
      this.bridgeContext.cleanupNamedContext(msg.handle);
      this.__sendMessage({
        type: "contextCleanedUp",
        handle: msg.handle
      });
    },
    _cmd_fetchSnippets(msg) {
      if (msg.convIds) {
        this.universe.fetchConversationSnippets(msg.convIds, "bridge");
      }
    },
    _cmd_downloadBodyReps(msg) {
      this.universe.fetchMessageBody(msg.id, msg.date, "bridge");
    },
    _cmd_downloadAttachments(msg) {
      this.universe.downloadMessageAttachments(msg.downloadReq).then(() => {
        this.__sendMessage({
          type: "promisedResult",
          handle: msg.handle,
          data: null
        });
      });
    },
    __accumulateUndoTasksAndReply(sourceMsg, promises) {
      Promise.all(promises).then((nestedUndoTasks) => {
        let undoTasks = [];
        undoTasks = undoTasks.concat.apply(undoTasks, nestedUndoTasks);
        this.__sendMessage({
          type: "promisedResult",
          handle: sourceMsg.handle,
          data: undoTasks
        });
      });
    },
    _cmd_store_labels(msg) {
      this.__accumulateUndoTasksAndReply(msg, msg.conversations.map((convInfo) => {
        return this.universe.storeLabels(convInfo.id, convInfo.messageIds, convInfo.messageSelector, msg.add, msg.remove);
      }));
    },
    _cmd_store_flags(msg) {
      this.__accumulateUndoTasksAndReply(msg, msg.conversations.map((convInfo) => {
        return this.universe.storeFlags(convInfo.id, convInfo.messageIds, convInfo.messageSelector, msg.add, msg.remove);
      }));
    },
    _cmd_outboxSetPaused(msg) {
      this.universe.outboxSetPaused(msg.accountId, msg.bePaused).then(() => {
        this.__sendMessage({
          type: "promisedResult",
          handle: msg.handle,
          data: null
        });
      });
    },
    _cmd_undo(msg) {
      this.universe.undo(msg.undoTasks);
    },
    _cmd_createDraft(msg) {
      this.universe.createDraft({
        draftType: msg.draftType,
        mode: msg.mode,
        refMessageId: msg.refMessageId,
        refMessageDate: msg.refMessageDate,
        folderId: msg.folderId
      }).then(({ messageId, messageDate }) => {
        this.__sendMessage({
          type: "promisedResult",
          handle: msg.handle,
          data: {
            messageId,
            messageDate
          }
        });
      });
    },
    _cmd_attachBlobToDraft(msg) {
      this.universe.attachBlobToDraft(msg.messageId, msg.attachmentDef);
    },
    _cmd_detachAttachmentFromDraft(msg) {
      this.universe.detachAttachmentFromDraft(msg.messageId, msg.attachmentRelId);
    },
    _cmd_doneCompose(msg) {
      if (msg.command === "delete") {
        this.universe.deleteDraft(msg.messageId);
        return;
      }
      this.universe.saveDraft(msg.messageId, msg.draftFields);
      if (msg.command === "send") {
        this.universe.outboxSendDraft(msg.messageId).then((sendProblem) => {
          this.__sendMessage({
            type: "promisedResult",
            handle: msg.handle,
            data: sendProblem
          });
        });
      }
    },
    _cmd_clearNewTrackingForAccount(msg) {
      this.universe.clearNewTrackingForAccount({
        accountId: msg.accountId,
        silent: msg.silent
      });
    },
    _cmd_flushNewAggregates() {
      this.universe.flushNewAggregates();
    },
    _cmd_debugForceCronSync(msg) {
      this.universe.cronSyncSupport.onAlarm(msg.accountIds, "fake-interval", "fake-wakelock", msg.notificationAccountIds);
    }
  };

  // src/backend/mailuniverse.js
  init_logic();

  // src/backend/maildb.js
  var import_evt3 = __toModule(require_evt());
  init_logic();
  init_id_conversions();
  var {
    indexedDB,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction,
    IDBRequest,
    IDBKeyRange
  } = globalThis;
  var CUR_VERSION = 123;
  var FRIENDLY_LAZY_DB_UPGRADE_VERSION = 122;
  var TBL_CONFIG = "config";
  var CONFIG_KEYPREFIX_ACCOUNT_DEF = "accountDef:";
  var TBL_SYNC_STATES = "syncStates";
  var TBL_TASKS = "tasks";
  var TBL_COMPLEX_TASKS = "complexTasks";
  var TBL_FOLDER_INFO = "folderInfo";
  var TBL_CONV_INFO = "convInfo";
  var TBL_CONV_IDS_BY_FOLDER = "convIdsByFolder";
  var TBL_MSG_IDS_BY_FOLDER = "msgIdsByFolder";
  var TBL_MESSAGES = "messages";
  var TBL_HEADER_ID_MAP = "headerIdMap";
  var TBL_UMID_LOCATION = "umidLocationMap";
  var TBL_UMID_NAME = "umidNameMap";
  var TBL_BOUNDED_LOGS = "logs";
  var BOUNDED_LOG_KEEP_TIME_MILLIS = 14 * 24 * 60 * 60 * 1e3;
  var TASK_MUTATION_STORES = [
    TBL_CONFIG,
    TBL_SYNC_STATES,
    TBL_TASKS,
    TBL_COMPLEX_TASKS,
    TBL_FOLDER_INFO,
    TBL_CONV_INFO,
    TBL_CONV_IDS_BY_FOLDER,
    TBL_MESSAGES,
    TBL_MSG_IDS_BY_FOLDER,
    TBL_HEADER_ID_MAP,
    TBL_UMID_LOCATION,
    TBL_UMID_NAME,
    TBL_BOUNDED_LOGS
  ];
  function analyzeAndLogErrorEvent(event) {
    function explainSource(source) {
      if (!source) {
        return "unknown source";
      }
      if (source instanceof IDBObjectStore) {
        return 'object store "' + source.name + '"';
      }
      if (source instanceof IDBIndex) {
        return 'index "' + source.name + '" on object store "' + source.objectStore.name + '"';
      }
      if (source instanceof IDBCursor) {
        return "cursor on " + explainSource(source.source);
      }
      return "unexpected source";
    }
    var explainedSource, target = event.target;
    if (target instanceof IDBTransaction) {
      explainedSource = "transaction (" + target.mode + ")";
    } else if (target instanceof IDBRequest) {
      explainedSource = "request as part of " + (target.transaction ? target.transaction.mode : "NO") + " transaction on " + explainSource(target.source);
    } else {
      explainedSource = target.toString();
    }
    var str = "indexedDB error:" + target.error.name + " from " + explainedSource;
    console.error(str);
    return str;
  }
  function analyzeAndRejectErrorEvent(rejectFunc, event) {
    rejectFunc(analyzeAndRejectErrorEvent(event));
  }
  function computeSetDelta(before, after) {
    let added = new Set();
    let kept = new Set();
    let removed = new Set();
    for (let key of before) {
      if (after.has(key)) {
        kept.add(key);
      } else {
        removed.add(key);
      }
    }
    for (let key of after) {
      if (!before.has(key)) {
        added.add(key);
      }
    }
    return { added, kept, removed };
  }
  var applyDeltasToObj = function(deltas, obj) {
    for (var key of Object.keys(deltas)) {
      obj[key] += deltas[key];
    }
  };
  var applyClobbersToObj = function(clobbers, obj) {
    if (clobbers instanceof Map) {
      for (let [keyPath, value] of clobbers) {
        let effObj = obj;
        for (let keyPart of keyPath.slice(0, -1)) {
          effObj = effObj[keyPart];
        }
        effObj[keyPath.slice(-1)[0]] = value;
      }
    } else {
      for (let key of Object.keys(clobbers)) {
        obj[key] = clobbers[key];
      }
    }
  };
  function valueIterator(arrayOrMap) {
    if (Array.isArray(arrayOrMap)) {
      return arrayOrMap;
    }
    return arrayOrMap.values();
  }
  var convEventForFolderId = (folderId) => "fldr!" + folderId + "!convs!tocChange";
  var messageEventForFolderId = (folderId) => "fldr!" + folderId + "!messages!tocChange";
  function wrapReq(idbRequest) {
    return new Promise(function(resolve, reject) {
      idbRequest.onsuccess = function(event) {
        resolve(event.target.result);
      };
      idbRequest.onerror = function(event) {
        reject(analyzeAndLogErrorEvent(event));
      };
    });
  }
  function wrapTrans(idbTransaction) {
    return new Promise(function(resolve, reject) {
      idbTransaction.oncomplete = function() {
        resolve();
      };
      idbTransaction.onerror = function(event) {
        reject(analyzeAndLogErrorEvent(event));
      };
    });
  }
  function genericUncachedLookups(store, requestMap) {
    let dbReqCount = 0;
    for (let unlatchedKey of requestMap.keys()) {
      let key = unlatchedKey;
      dbReqCount++;
      let req = store.get(key);
      let handler = (event) => {
        let value;
        if (req.error) {
          value = null;
          analyzeAndLogErrorEvent(event);
        } else {
          value = req.result;
        }
        requestMap.set(key, value);
      };
      req.onsuccess = handler;
      req.onerror = handler;
    }
    return dbReqCount;
  }
  function genericUncachedWrites(trans, tableName, writeMap) {
    if (writeMap) {
      let store = trans.objectStore(tableName);
      for (let [key, value] of writeMap) {
        if (value !== null) {
          store.put(value, key);
        } else {
          store.delete(key);
        }
      }
    }
  }
  function genericCachedLookups(store, requestMap, cache) {
    let dbReqCount = 0;
    for (let unlatchedKey of requestMap.keys()) {
      let key = unlatchedKey;
      if (cache.has(key)) {
        requestMap.set(key, cache.get(key));
        continue;
      }
      dbReqCount++;
      let req = store.get(key);
      let handler = (event) => {
        if (req.error) {
          analyzeAndLogErrorEvent(event);
        } else {
          let value = req.result;
          if (!cache.has(key)) {
            cache.set(key, value);
          }
          requestMap.set(key, value);
        }
      };
      req.onsuccess = handler;
      req.onerror = handler;
    }
    return dbReqCount;
  }
  function MailDB({ universe: universe2, testOptions }) {
    import_evt3.default.Emitter.call(this);
    logic.defineScope(this, "MailDB");
    this.universe = universe2;
    this._db = null;
    this.triggerManager = null;
    this.accountManager = null;
    this._lazyConfigCarryover = null;
    this.convCache = new Map();
    this.messageCache = new Map();
    let dbVersion = CUR_VERSION;
    if (testOptions && testOptions.dbDelta) {
      dbVersion += testOptions.dbDelta;
    }
    if (testOptions && testOptions.dbVersion) {
      dbVersion = testOptions.dbVersion;
    }
    this._dbPromise = new Promise((resolve, reject) => {
      let openRequest = indexedDB.open("companion-workshop", dbVersion);
      openRequest.onsuccess = () => {
        this._db = openRequest.result;
        resolve();
      };
      openRequest.onupgradeneeded = (event) => {
        logic(this, "upgradeNeeded", {
          oldVersion: event.oldVersion,
          curVersion: dbVersion
        });
        let db = openRequest.result;
        if (event.oldVersion < FRIENDLY_LAZY_DB_UPGRADE_VERSION || testOptions && testOptions.nukeDb) {
          this._nukeDB(db);
        } else {
          var trans = openRequest.transaction;
          let objectStores = Array.from(db.objectStoreNames);
          if (objectStores.includes(TBL_CONFIG)) {
            this._getConfig(trans).then((carryover) => {
              if (carryover) {
                carryover.oldVersion = event.oldVersion;
                this._lazyConfigCarryover = carryover;
              }
            });
            this._nukeDB(db);
          } else {
            logic(this, "failsafeNuke", { objectStores });
            this._nukeDB(db);
          }
        }
      };
      openRequest.onerror = analyzeAndRejectErrorEvent.bind(null, reject);
    });
  }
  MailDB.prototype = import_evt3.default.mix({
    _nukeDB(db) {
      logic(this, "nukeDB", {});
      let existingNames = db.objectStoreNames;
      for (let i = 0; i < existingNames.length; i++) {
        db.deleteObjectStore(existingNames[i]);
      }
      db.createObjectStore(TBL_CONFIG);
      db.createObjectStore(TBL_SYNC_STATES);
      db.createObjectStore(TBL_TASKS);
      db.createObjectStore(TBL_COMPLEX_TASKS);
      db.createObjectStore(TBL_FOLDER_INFO);
      db.createObjectStore(TBL_CONV_INFO);
      db.createObjectStore(TBL_CONV_IDS_BY_FOLDER);
      db.createObjectStore(TBL_MESSAGES);
      db.createObjectStore(TBL_MSG_IDS_BY_FOLDER);
      db.createObjectStore(TBL_HEADER_ID_MAP);
      db.createObjectStore(TBL_UMID_NAME);
      db.createObjectStore(TBL_UMID_LOCATION);
      db.createObjectStore(TBL_BOUNDED_LOGS);
    },
    close() {
      if (this._db) {
        this._db.close();
        this._db = null;
      }
    },
    getConfig() {
      return this._dbPromise.then(() => {
        if (this._lazyConfigCarryover) {
          let carryover = this._lazyConfigCarryover;
          this._lazyConfigCarryover = null;
          return { config: null, accountDefs: null, carryover };
        }
        return this._getConfig();
      });
    },
    _getConfig(trans) {
      logic(this, "_getConfig", { trans: !!trans });
      let transaction = trans || this._db.transaction([TBL_CONFIG], "readonly");
      let configStore = transaction.objectStore(TBL_CONFIG);
      return wrapReq(configStore.getAll()).then((configRows) => {
        let config = null;
        let accountDefs = [];
        for (let i = 0; i < configRows.length; i++) {
          let obj = configRows[i];
          if (obj.id === "config") {
            config = obj;
          } else {
            accountDefs.push(obj);
          }
        }
        return { config, accountDefs };
      });
    },
    saveConfig(config) {
      return wrapTrans(this._db.transaction(TBL_CONFIG, "readwrite").objectStore(TBL_CONFIG).put(config, "config"));
    },
    saveAccountDef(config, accountDef, folderInfo, callback) {
      var trans = this._db.transaction([TBL_CONFIG, TBL_FOLDER_INFO], "readwrite");
      var configStore = trans.objectStore(TBL_CONFIG);
      configStore.put(config, "config");
      configStore.put(accountDef, CONFIG_KEYPREFIX_ACCOUNT_DEF + accountDef.id);
      if (folderInfo) {
        trans.objectStore(TBL_FOLDER_INFO).put(folderInfo, accountDef.id);
      }
      trans.onerror = analyzeAndLogErrorEvent;
      if (callback) {
        trans.oncomplete = function() {
          callback();
        };
      }
    },
    addBoundedLogs(entries) {
      let trans = this._db.transaction(TBL_BOUNDED_LOGS, "readwrite");
      let store = trans.objectStore(TBL_BOUNDED_LOGS);
      for (let entry of entries) {
        store.add(entry.entry, [entry.timestamp, entry.type, entry.id]);
      }
      return wrapTrans(trans);
    },
    updateBoundedLogs(entries) {
      let trans = this._db.transaction(TBL_BOUNDED_LOGS, "readwrite");
      let store = trans.objectStore(TBL_BOUNDED_LOGS);
      for (let entry of entries) {
        store.put(entry.entry, [entry.timestamp, entry.type, entry.id]);
      }
      return wrapTrans(trans);
    },
    reapOldBoundedLogs() {
      let trans = this._db.transaction(TBL_BOUNDED_LOGS, "readwrite");
      let store = trans.objectStore(TBL_BOUNDED_LOGS);
      let deleteRange = IDBKeyRange.bound([0], [Date.now() - BOUNDED_LOG_KEEP_TIME_MILLIS, []], true, true);
      store.delete(deleteRange);
      return wrapTrans(trans);
    },
    _considerCachePressure() {
      if (this._emptyingCache) {
        return;
      }
      this._emptyingCache = globalThis.setTimeout(() => {
        this._emptyingCache = null;
        this.emptyCache();
      }, 100);
    },
    emptyCache() {
      this.emit("cacheDrop");
      this.convCache.clear();
      this.messageCache.clear();
    },
    _bufferChangeEventsIdiom(eventId) {
      let bufferedEvents = [];
      let bufferFunc = (change) => {
        bufferedEvents.push(change);
      };
      let drainEvents = (changeHandler) => {
        this.removeListener(eventId, bufferFunc);
        for (let change of bufferedEvents) {
          changeHandler(change);
        }
      };
      this.on(eventId, bufferFunc);
      return {
        drainEvents,
        eventId
      };
    },
    read(ctx, requests) {
      return new Promise((resolve) => {
        logic(this, "read:begin", { ctxId: ctx.id });
        let trans = this._db.transaction(TASK_MUTATION_STORES, "readonly");
        let dbReqCount = 0;
        if (requests.config) {
          requests.config = this.universe.config;
        }
        if (requests.accounts) {
          let accountReqs = requests.accounts;
          for (let accountId of accountReqs.keys()) {
            accountReqs.set(accountId, this.accountManager.getAccountDefById(accountId));
          }
        }
        if (requests.folders) {
          let folderReqs = requests.folders;
          for (let folderId of folderReqs.keys()) {
            folderReqs.set(folderId, this.accountManager.getFolderById(folderId));
          }
        }
        if (requests.syncStates) {
          dbReqCount += genericUncachedLookups(trans.objectStore(TBL_SYNC_STATES), requests.syncStates);
        }
        if (requests.headerIdMaps) {
          dbReqCount += genericUncachedLookups(trans.objectStore(TBL_HEADER_ID_MAP), requests.headerIdMaps);
        }
        if (requests.umidNames) {
          dbReqCount += genericUncachedLookups(trans.objectStore(TBL_UMID_NAME), requests.umidNames);
        }
        if (requests.umidLocations) {
          dbReqCount += genericUncachedLookups(trans.objectStore(TBL_UMID_LOCATION), requests.umidLocations);
        }
        if (requests.complexTaskStates) {
          dbReqCount += genericUncachedLookups(trans.objectStore(TBL_COMPLEX_TASKS), requests.complexTaskStates);
        }
        if (requests.conversations) {
          dbReqCount += genericCachedLookups(trans.objectStore(TBL_CONV_INFO), requests.conversations, this.convCache);
        }
        if (requests.messagesByConversation) {
          let messageStore = trans.objectStore(TBL_MESSAGES);
          let messageCache = this.messageCache;
          let requestsMap = requests.messagesByConversation;
          for (let unlatchedConvId of requestsMap.keys()) {
            let convId = unlatchedConvId;
            let messageRange = IDBKeyRange.bound([convId], [convId, []], true, true);
            dbReqCount++;
            let req = messageStore.getAll(messageRange);
            let handler = (event) => {
              if (req.error) {
                analyzeAndLogErrorEvent(event);
              } else {
                let messages = req.result;
                for (let message of messages) {
                  if (!messageCache.has(message.id)) {
                    messageCache.set(message.id, message);
                  }
                }
                requestsMap.set(convId, messages);
              }
            };
            req.onsuccess = handler;
            req.onerror = handler;
          }
        }
        if (requests.messages) {
          let messageStore = trans.objectStore(TBL_MESSAGES);
          let messageCache = this.messageCache;
          let messageRequestsMap = requests.messages;
          let messageResultsMap = requests.messages = new Map();
          let flushedRead = requests.flushedMessageReads || false;
          for (let [unlatchedMessageId, date] of messageRequestsMap.keys()) {
            let messageId = unlatchedMessageId;
            if (!flushedRead && messageCache.has(messageId)) {
              messageResultsMap.set(messageId, messageCache.get(messageId));
              continue;
            }
            let key = [
              convIdFromMessageId(messageId),
              date,
              messageSpecificIdFromMessageId(messageId)
            ];
            dbReqCount++;
            let req = messageStore.get(key);
            let handler = (event) => {
              if (req.error) {
                analyzeAndLogErrorEvent(event);
              } else {
                let message = req.result;
                if (flushedRead || !messageCache.has(messageId)) {
                  messageCache.set(messageId, message);
                }
                messageResultsMap.set(messageId, message);
              }
            };
            req.onsuccess = handler;
            req.onerror = handler;
          }
        }
        if (!dbReqCount) {
          resolve(requests);
        } else {
          trans.oncomplete = () => {
            logic(this, "read:end", { ctxId: ctx.id, dbReqCount });
            resolve(requests);
            this._considerCachePressure("read", ctx);
          };
        }
      });
    },
    beginMutate(ctx, mutateRequests, options) {
      return this.read(ctx, mutateRequests, options).then(() => {
        let preMutateStates = ctx._preMutateStates = ctx._preMutateStates || {};
        if (mutateRequests.conversations) {
          let preConv = preMutateStates.conversations = new Map();
          for (let conv of mutateRequests.conversations.values()) {
            if (!conv) {
              continue;
            }
            preConv.set(conv.id, {
              date: conv.date,
              folderIds: new Set(conv.folderIds),
              hasUnread: conv.hasUnread,
              height: conv.height
            });
          }
        }
        if (mutateRequests.messagesByConversation || mutateRequests.messages) {
          let preMessages = preMutateStates.messages = new Map();
          if (mutateRequests.messagesByConversation) {
            for (let convMessages of mutateRequests.messagesByConversation.values()) {
              for (let message of convMessages) {
                preMessages.set(message.id, {
                  date: message.date,
                  folderIds: new Set(message.folderIds)
                });
              }
            }
          }
          if (mutateRequests.messages) {
            for (let message of mutateRequests.messages.values()) {
              preMessages.set(message.id, {
                date: message.date,
                folderIds: new Set(message.folderIds)
              });
            }
          }
        }
        return mutateRequests;
      });
    },
    loadTasks() {
      let trans = this._db.transaction([TBL_TASKS, TBL_COMPLEX_TASKS], "readonly");
      let taskStore = trans.objectStore(TBL_TASKS);
      let complexTaskStore = trans.objectStore([TBL_COMPLEX_TASKS]);
      return Promise.all([
        wrapReq(taskStore.getAll()),
        wrapReq(complexTaskStore.getAllKeys()),
        wrapReq(complexTaskStore.getAll())
      ]).then(([wrappedTasks, complexTaskStateKeys, complexTaskStateValues]) => {
        return {
          wrappedTasks,
          complexTaskStates: [complexTaskStateKeys, complexTaskStateValues]
        };
      });
    },
    loadFoldersByAccount(accountId) {
      let trans = this._db.transaction(TBL_FOLDER_INFO, "readonly");
      let store = trans.objectStore(TBL_FOLDER_INFO);
      let accountStringPrefix = IDBKeyRange.bound(accountId + ".", accountId + ".\uFFF0", true, true);
      return wrapReq(store.getAll(accountStringPrefix));
    },
    async loadFolderConversationIdsAndListen(folderId) {
      let eventId = "fldr!" + folderId + "!convs!tocChange";
      let retval = this._bufferChangeEventsIdiom(eventId);
      let trans = this._db.transaction(TBL_CONV_IDS_BY_FOLDER, "readonly");
      let convIdsStore = trans.objectStore(TBL_CONV_IDS_BY_FOLDER);
      let folderRange = IDBKeyRange.bound([folderId], [folderId, []], true, true);
      let tuples = await wrapReq(convIdsStore.getAll(folderRange));
      logic(this, "loadFolderConversationIdsAndListen", {
        convCount: tuples.length,
        eventId: retval.eventId
      });
      tuples.reverse();
      retval.idsWithDates = tuples.map(function(x) {
        return { date: x[1], id: x[2], height: x[3] };
      });
      return retval;
    },
    _processConvAdditions(trans, convs) {
      let convStore = trans.objectStore(TBL_CONV_INFO);
      let convIdsStore = trans.objectStore(TBL_CONV_IDS_BY_FOLDER);
      for (let convInfo of valueIterator(convs)) {
        convStore.add(convInfo, convInfo.id);
        this.convCache.set(convInfo.id, convInfo);
        const eventDeltaInfo = {
          id: convInfo.id,
          item: convInfo,
          removeDate: null,
          addDate: convInfo.date,
          height: convInfo.height,
          oldHeight: 0
        };
        for (let folderId of convInfo.folderIds) {
          this.emit("conv!*!add", convInfo);
          this.emit(convEventForFolderId(folderId), eventDeltaInfo);
          convIdsStore.add([folderId, convInfo.date, convInfo.id, convInfo.height], [folderId, convInfo.date, convInfo.id]);
        }
      }
    },
    _processConvMutations(trans, preStates, convs) {
      let convStore = trans.objectStore(TBL_CONV_INFO);
      let convIdsStore = trans.objectStore(TBL_CONV_IDS_BY_FOLDER);
      for (let [convId, convInfo] of convs) {
        let preInfo = preStates.get(convId);
        let convFolderIds;
        if (convInfo === null) {
          convStore.delete(convId);
          this.convCache.delete(convId);
          convFolderIds = new Set();
          let messageRange = IDBKeyRange.bound([convId], [convId, []], true, true);
          trans.objectStore(TBL_MESSAGES).delete(messageRange);
        } else {
          convFolderIds = convInfo.folderIds;
          convStore.put(convInfo, convId);
          this.convCache.set(convId, convInfo);
        }
        this.emit("conv!" + convId + "!change", convId, convInfo);
        let { added, kept, removed } = computeSetDelta(preInfo.folderIds, convFolderIds);
        this.emit("conv!*!change", convId, preInfo, convInfo, added, kept, removed);
        for (let folderId of added) {
          this.emit(convEventForFolderId(folderId), {
            id: convId,
            item: convInfo,
            removeDate: null,
            addDate: convInfo.date,
            height: convInfo.height,
            oldHeight: 0
          });
        }
        for (let folderId of kept) {
          this.emit(convEventForFolderId(folderId), {
            id: convId,
            item: convInfo,
            removeDate: preInfo.date,
            addDate: convInfo.date,
            height: convInfo.height,
            oldHeight: preInfo.height
          });
        }
        for (let folderId of removed) {
          this.emit(convEventForFolderId(folderId), {
            id: convId,
            item: convInfo,
            removeDate: preInfo.date,
            addDate: null,
            height: 0,
            oldHeight: preInfo.height
          });
        }
        if (!convInfo || preInfo.date !== convInfo.date || preInfo.height !== convInfo.height) {
          for (let folderId of preInfo.folderIds) {
            convIdsStore.delete([folderId, preInfo.date, convId]);
          }
          if (convInfo) {
            for (let folderId of convFolderIds) {
              convIdsStore.add([folderId, convInfo.date, convId, convInfo.height], [folderId, convInfo.date, convId]);
            }
          }
        } else {
          for (let folderId of removed) {
            convIdsStore.delete([folderId, convInfo.date, convId]);
          }
          for (let folderId of added) {
            convIdsStore.add([folderId, convInfo.date, convId, convInfo.height], [folderId, convInfo.date, convId]);
          }
        }
      }
    },
    async loadFolderMessageIdsAndListen(folderId) {
      let eventId = "fldr!" + folderId + "!messages!tocChange";
      let retval = this._bufferChangeEventsIdiom(eventId);
      let trans = this._db.transaction(TBL_MSG_IDS_BY_FOLDER, "readonly");
      let msgIdsStore = trans.objectStore(TBL_MSG_IDS_BY_FOLDER);
      let folderRange = IDBKeyRange.bound([folderId], [folderId, []], true, true);
      let tuples = await wrapReq(msgIdsStore.getAll(folderRange));
      logic(this, "loadFolderMessageIdsAndListen", {
        msgCount: tuples.length,
        eventId: retval.eventId
      });
      tuples.reverse();
      retval.idsWithDates = tuples.map(function(x) {
        return { date: x[1], id: x[2] };
      });
      return retval;
    },
    async loadConversationMessageIdsAndListen(convId) {
      let tocEventId = "conv!" + convId + "!messages!tocChange";
      let convEventId = "conv!" + convId + "!change";
      let { drainEvents } = this._bufferChangeEventsIdiom(tocEventId);
      let trans = this._db.transaction(TBL_MESSAGES, "readonly");
      let messageStore = trans.objectStore(TBL_MESSAGES);
      let messageRange = IDBKeyRange.bound([convId], [convId, []], true, true);
      let messages = await wrapReq(messageStore.getAll(messageRange));
      let messageCache = this.messageCache;
      let idsWithDates = messages.map(function(message) {
        if (!messageCache.has(message.id)) {
          messageCache.set(message.id, message);
        }
        return { date: message.date, id: message.id };
      });
      return { tocEventId, convEventId, idsWithDates, drainEvents };
    },
    _processMessageAdditions(trans, messages) {
      let store = trans.objectStore(TBL_MESSAGES);
      let idsStore = trans.objectStore(TBL_MSG_IDS_BY_FOLDER);
      let messageCache = this.messageCache;
      for (let message of valueIterator(messages)) {
        let convId = convIdFromMessageId(message.id);
        let key = [
          convId,
          message.date,
          messageSpecificIdFromMessageId(message.id)
        ];
        store.add(message, key);
        messageCache.set(message.id, message);
        this.emit("msg!*!add", message);
        const convTocEventId = "conv!" + convId + "!messages!tocChange";
        const eventDeltaInfo = {
          id: message.id,
          preDate: null,
          postDate: message.date,
          item: message,
          freshlyAdded: true,
          matchInfo: null
        };
        this.emit(convTocEventId, eventDeltaInfo);
        for (const folderId of message.folderIds) {
          this.emit(messageEventForFolderId(folderId), eventDeltaInfo);
          idsStore.add([folderId, message.date, message.id], [folderId, message.date, message.id]);
        }
      }
    },
    _processMessageMutations(trans, preStates, messages) {
      let store = trans.objectStore(TBL_MESSAGES);
      let idsStore = trans.objectStore(TBL_MSG_IDS_BY_FOLDER);
      let messageCache = this.messageCache;
      for (let [messageId, message] of messages) {
        let convId = convIdFromMessageId(messageId);
        let preInfo = preStates.get(messageId);
        let preDate = preInfo.date;
        let postDate = message && message.date;
        let preKey = [
          convId,
          preDate,
          messageSpecificIdFromMessageId(messageId)
        ];
        if (message === null) {
          store.delete(preKey);
          messageCache.delete(messageId);
        } else if (preDate !== postDate) {
          store.delete(preKey);
          let postKey = [
            convId,
            postDate,
            messageSpecificIdFromMessageId(messageId)
          ];
          store.put(message, postKey);
        } else {
          store.put(message, preKey);
          messageCache.set(messageId, message);
        }
        let { added, kept, removed } = computeSetDelta(preInfo.folderIds, message ? message.folderIds : new Set());
        let convEventId = "conv!" + convId + "!messages!tocChange";
        this.emit(convEventId, {
          id: messageId,
          preDate,
          postDate,
          item: message,
          freshlyAdded: false,
          matchInfo: null
        });
        let messageEventId = "msg!" + messageId + "!change";
        this.emit(messageEventId, messageId, message);
        for (const folderId of added) {
          this.emit(messageEventForFolderId(folderId), {
            id: messageId,
            preDate,
            postDate,
            item: message,
            freshlyAdded: true,
            matchInfo: null
          });
        }
        for (const folderId of kept) {
          this.emit(messageEventForFolderId(folderId), {
            id: messageId,
            preDate,
            postDate,
            item: message,
            freshlyAdded: false,
            matchInfo: null
          });
        }
        for (const folderId of removed) {
          this.emit(messageEventForFolderId(folderId), {
            id: messageId,
            preDate,
            postDate,
            item: message,
            freshlyAdded: false,
            matchInfo: null
          });
        }
        this.emit("msg!*!change", messageId, preInfo, message, added, kept, removed);
        if (!message) {
          this.emit("msg!" + messageId + "!remove", messageId);
          this.emit("msg!*!remove", messageId);
        }
        if (!message || preDate !== postDate) {
          for (const folderId of preInfo.folderIds) {
            idsStore.delete([folderId, preInfo.date, messageId]);
          }
          if (message) {
            for (const folderId of message.folderIds) {
              idsStore.add([folderId, message.date, message.id], [folderId, message.date, message.id]);
            }
          }
        } else {
          for (const folderId of removed) {
            idsStore.delete([folderId, message.date, messageId]);
          }
          for (const folderId of added) {
            idsStore.add([folderId, message.date, message.id], [folderId, message.date, message.id]);
          }
        }
      }
    },
    _applyAtomics(atomics, rootMutations) {
      let { atomicDeltas, atomicClobbers } = atomics;
      const accountManager = this.accountManager;
      if (atomicDeltas) {
        if (atomicDeltas.config) {
          if (!rootMutations.config) {
            rootMutations.config = this.universe.config;
          }
          applyDeltasToObj(atomicDeltas.config, rootMutations.config);
        }
        if (atomicDeltas.accounts) {
          if (!rootMutations.accounts) {
            rootMutations.accounts = new Map();
          }
          let accountMutations = rootMutations.accounts;
          for (let [accountId, deltas] of atomicDeltas.accounts) {
            let accountDef = accountManager.getAccountDefById(accountId);
            applyDeltasToObj(deltas, accountDef);
            accountMutations.set(accountId, accountDef);
          }
        }
        if (atomicDeltas.folders) {
          if (!rootMutations.folders) {
            rootMutations.folders = new Map();
          }
          let folderMutations = rootMutations.folders;
          for (let [folderId, deltas] of atomicDeltas.folders) {
            let folder = accountManager.getFolderById(folderId);
            applyDeltasToObj(deltas, folder);
            folderMutations.set(folderId, folder);
          }
        }
      }
      if (atomicClobbers) {
        if (atomicClobbers.config) {
          if (!rootMutations.config) {
            rootMutations.config = this.universe.config;
          }
          applyClobbersToObj(atomicClobbers.config, rootMutations.config);
        }
        if (atomicClobbers.accounts) {
          if (!rootMutations.accounts) {
            rootMutations.accounts = new Map();
          }
          let accountMutations = rootMutations.accounts;
          for (let [accountId, clobbers] of atomicClobbers.accounts) {
            let accountDef = accountManager.getAccountDefById(accountId);
            applyClobbersToObj(clobbers, accountDef);
            accountMutations.set(accountId, accountDef);
          }
        }
        if (atomicClobbers.folders) {
          if (!rootMutations.folders) {
            rootMutations.folders = new Map();
          }
          let folderMutations = rootMutations.folders;
          for (let [folderId, clobbers] of atomicClobbers.folders) {
            let folder = accountManager.getFolderById(folderId);
            applyClobbersToObj(clobbers, folder);
            folderMutations.set(folderId, folder);
          }
        }
      }
    },
    _processAccountDeletion(trans, accountId) {
      let accountStringPrefix = IDBKeyRange.bound(accountId + ".", accountId + ".\uFFF0", true, true);
      let accountArrayItemPrefix = IDBKeyRange.bound([accountId + "."], [accountId + ".\uFFF0"], true, true);
      let accountFirstElementArray = IDBKeyRange.bound([accountId], [accountId, []], true, true);
      trans.objectStore(TBL_CONFIG).delete(CONFIG_KEYPREFIX_ACCOUNT_DEF + accountId);
      trans.objectStore(TBL_SYNC_STATES).delete(accountId);
      trans.objectStore(TBL_SYNC_STATES).delete(accountStringPrefix);
      trans.objectStore(TBL_COMPLEX_TASKS).delete(accountFirstElementArray);
      trans.objectStore(TBL_FOLDER_INFO).delete(accountStringPrefix);
      trans.objectStore(TBL_CONV_INFO).delete(accountStringPrefix);
      trans.objectStore(TBL_CONV_IDS_BY_FOLDER).delete(accountArrayItemPrefix);
      trans.objectStore(TBL_MESSAGES).delete(accountArrayItemPrefix);
      trans.objectStore(TBL_MSG_IDS_BY_FOLDER).delete(accountArrayItemPrefix);
      trans.objectStore(TBL_HEADER_ID_MAP).delete(accountFirstElementArray);
      trans.objectStore(TBL_UMID_LOCATION).delete(accountStringPrefix);
      trans.objectStore(TBL_UMID_NAME).delete(accountStringPrefix);
    },
    _addRawTasks(trans, wrappedTasks) {
      let store = trans.objectStore(TBL_TASKS);
      wrappedTasks.forEach((wrappedTask) => {
        store.add(wrappedTask, wrappedTask.id);
      });
    },
    addTasks(wrappedTasks) {
      let trans = this._db.transaction([TBL_TASKS], "readwrite");
      this._addRawTasks(trans, wrappedTasks);
      return wrapTrans(trans);
    },
    dangerousIncrementalWrite(ctx, mutations) {
      logic(this, "dangerousIncrementalWrite:begin", { ctxId: ctx.id });
      let trans = this._db.transaction(TASK_MUTATION_STORES, "readwrite");
      if (mutations.messages) {
        this._processMessageMutations(trans, ctx._preMutateStates.messages, mutations.messages);
      }
      return wrapTrans(trans).then(() => {
        logic(this, "dangerousIncrementalWrite:end", { ctxId: ctx.id });
      });
    },
    finishMutate(ctx, data, taskData) {
      logic(this, "finishMutate:begin", { ctxId: ctx.id });
      let trans = this._db.transaction(TASK_MUTATION_STORES, "readwrite");
      let derivedMutations = [];
      this.triggerManager.__setState(ctx, derivedMutations);
      let newData = data.newData;
      if (newData) {
        if (newData.accounts) {
          for (let accountDef of newData.accounts) {
            trans.objectStore(TBL_CONFIG).put(accountDef, CONFIG_KEYPREFIX_ACCOUNT_DEF + accountDef.id);
            this.emit("accounts!tocChange", accountDef.id, accountDef, true);
          }
        }
        if (newData.folders) {
          let store = trans.objectStore(TBL_FOLDER_INFO);
          for (let folderInfo of newData.folders) {
            let accountId = accountIdFromFolderId(folderInfo.id);
            store.put(folderInfo, folderInfo.id);
            this.emit(`acct!${accountId}!folders!tocChange`, folderInfo.id, folderInfo, true);
          }
        }
        if (newData.conversations) {
          this._processConvAdditions(trans, newData.conversations);
        }
        if (newData.messages) {
          this._processMessageAdditions(trans, newData.messages);
        }
      }
      let mutations = data.mutations;
      if (mutations) {
        genericUncachedWrites(trans, TBL_SYNC_STATES, mutations.syncStates);
        genericUncachedWrites(trans, TBL_HEADER_ID_MAP, mutations.headerIdMaps);
        genericUncachedWrites(trans, TBL_UMID_NAME, mutations.umidNames);
        genericUncachedWrites(trans, TBL_UMID_LOCATION, mutations.umidLocations);
        if (mutations.conversations) {
          this._processConvMutations(trans, ctx._preMutateStates.conversations, mutations.conversations);
        }
        if (mutations.messages) {
          this._processMessageMutations(trans, ctx._preMutateStates.messages, mutations.messages);
        }
      } else {
        mutations = {};
      }
      this.triggerManager.__clearState();
      this._applyAtomics(data, mutations);
      if (derivedMutations.length) {
        for (let derivedMut of derivedMutations) {
          this._applyAtomics(derivedMut, mutations);
          if (derivedMut.complexTaskStates) {
            if (!mutations.complexTaskStates) {
              mutations.complexTaskStates = new Map();
            }
            for (let [key, value] of derivedMut.complexTaskStates) {
              mutations.complexTaskStates.set(key, value);
            }
          }
          if (derivedMut.rootGroupDeferredTask) {
            ctx.ensureRootTaskGroupFollowOnTask(derivedMut.rootGroupDeferredTask);
          }
        }
      }
      if (mutations.complexTaskStates) {
        for (let [key, complexTaskState] of mutations.complexTaskStates) {
          trans.objectStore(TBL_COMPLEX_TASKS).put(complexTaskState, key);
        }
      }
      if (mutations.folders) {
        let store = trans.objectStore(TBL_FOLDER_INFO);
        for (let [folderId, folderInfo] of mutations.folders) {
          let accountId = accountIdFromFolderId(folderId);
          if (folderInfo !== null) {
            store.put(folderInfo, folderId);
          } else {
            store.delete(folderId);
          }
          this.emit(`fldr!${folderId}!change`, folderId, folderInfo);
          this.emit(`acct!${accountId}!folders!tocChange`, folderId, folderInfo, false);
        }
      }
      if (mutations.accounts) {
        for (let [accountId, accountDef] of mutations.accounts) {
          if (accountDef) {
            trans.objectStore(TBL_CONFIG).put(accountDef, CONFIG_KEYPREFIX_ACCOUNT_DEF + accountId);
          } else {
            this._processAccountDeletion(trans, accountId);
          }
          this.emit(`acct!${accountId}!change`, accountId, accountDef);
          this.emit("accounts!tocChange", accountId, accountDef, false);
        }
      }
      if (mutations.config) {
        trans.objectStore(TBL_CONFIG).put(mutations.config, "config");
        this.emit("config", mutations.config);
      }
      if (taskData.revisedTaskInfo) {
        let revisedTaskInfo = taskData.revisedTaskInfo;
        if (revisedTaskInfo.state) {
          trans.objectStore(TBL_TASKS).put(revisedTaskInfo.state, revisedTaskInfo.id);
        } else {
          trans.objectStore(TBL_TASKS).delete(revisedTaskInfo.id);
        }
      }
      if (taskData.wrappedTasks) {
        let taskStore = trans.objectStore(TBL_TASKS);
        for (let wrappedTask of taskData.wrappedTasks) {
          taskStore.put(wrappedTask, wrappedTask.id);
        }
      }
      return wrapTrans(trans).then(() => {
        logic(this, "finishMutate:end", { ctxId: ctx.id });
        this._considerCachePressure("mutate", ctx);
      });
    }
  });
  MailDB.prototype._emit = MailDB.prototype.emit;
  MailDB.prototype.emit = function(eventName) {
    var listeners2 = this._events[eventName];
    var listenerCount = listeners2 ? listeners2.length : 0;
    logic(this, "emit", { name: eventName, listenerCount });
    this._emit.apply(this, arguments);
  };
  MailDB.prototype._on = MailDB.prototype.on;
  MailDB.prototype.on = function(eventName) {
    if (!eventName) {
      throw new Error("no event type provided!");
    }
    logic(this, "on", { name: eventName });
    this._on.apply(this, arguments);
  };
  MailDB.prototype._removeListener = MailDB.prototype.removeListener;
  MailDB.prototype.removeListener = function(eventName) {
    if (!eventName) {
      throw new Error("no event type provided!");
    }
    logic(this, "removeListener", { name: eventName });
    this._removeListener.apply(this, arguments);
  };
  var maildb_default = MailDB;

  // src/backend/universe/account_manager.js
  init_logic();
  init_id_conversions();

  // src/backend/engine_glue.js
  var configuratorModules = new Map([
    [
      "activesync",
      async function() {
        const mod = await Promise.resolve().then(() => (init_configurator(), configurator_exports));
        return mod.default;
      }
    ],
    [
      "feed",
      async function() {
        const mod = await Promise.resolve().then(() => (init_configurator2(), configurator_exports2));
        return mod.default;
      }
    ],
    [
      "ical",
      async function() {
        const mod = await Promise.resolve().then(() => (init_configurator3(), configurator_exports3));
        return mod.default;
      }
    ]
  ]);
  var validatorModules = new Map([
    [
      "activesync",
      async function() {
        const mod = await Promise.resolve().then(() => (init_validator(), validator_exports));
        return mod.default;
      }
    ],
    [
      "feed",
      async function() {
        const mod = await Promise.resolve().then(() => (init_validator2(), validator_exports2));
        return mod.default;
      }
    ],
    [
      "ical",
      async function() {
        const mod = await Promise.resolve().then(() => (init_validator3(), validator_exports3));
        return mod.default;
      }
    ]
  ]);
  var accountModules = new Map([
    [
      "activesync",
      async function() {
        const mod = await Promise.resolve().then(() => (init_account(), account_exports));
        return mod.default;
      }
    ],
    [
      "feed",
      async function() {
        const mod = await Promise.resolve().then(() => (init_account2(), account_exports2));
        return mod.default;
      }
    ],
    [
      "ical",
      async function() {
        const mod = await Promise.resolve().then(() => (init_account3(), account_exports3));
        return mod.default;
      }
    ]
  ]);
  var engineTaskMappings = new Map([
    [
      "activesync",
      async function() {
        const mod = await Promise.resolve().then(() => (init_activesync_tasks(), activesync_tasks_exports));
        return mod.default;
      }
    ],
    [
      "feed",
      async function() {
        const mod = await Promise.resolve().then(() => (init_feed_tasks(), feed_tasks_exports));
        return mod.default;
      }
    ],
    [
      "ical",
      async function() {
        const mod = await Promise.resolve().then(() => (init_ical_tasks(), ical_tasks_exports));
        return mod.default;
      }
    ]
  ]);
  var engineHacks = new Map([
    [
      "activesync",
      {
        unselectableFolderTypes: new Set()
      }
    ],
    [
      "feed",
      {
        unselectableFolderTypes: new Set()
      }
    ],
    [
      "ical",
      {
        unselectableFolderTypes: new Set()
      }
    ]
  ]);
  var engineBackEndFacts = new Map([
    [
      "activesync",
      {
        syncGranularity: "folder"
      }
    ],
    [
      "feed",
      {
        syncGranularity: "account"
      }
    ],
    [
      "ical",
      {
        syncGranularity: "account"
      }
    ]
  ]);
  var engineFrontEndAccountMeta = new Map([
    [
      "activesync",
      {
        engineFacts: {
          syncGranularity: "folder"
        },
        usesArchiveMetaphor: false
      }
    ],
    [
      "feed",
      {
        engineFacts: {
          syncGranularity: "account"
        },
        usesArchiveMetaphor: false
      }
    ],
    [
      "ical",
      {
        engineFacts: {
          syncGranularity: "account"
        },
        usesArchiveMetaphor: false
      }
    ]
  ]);
  var engineFrontEndFolderMeta = new Map([
    [
      "activesync",
      {
        syncGranularity: "folder"
      }
    ],
    [
      "feed",
      {
        syncGranularity: "account"
      }
    ],
    [
      "ical",
      {
        syncGranularity: "account"
      }
    ]
  ]);

  // src/backend/db/accounts_toc.js
  var import_evt7 = __toModule(require_evt());
  init_logic();
  init_util();
  function accountDefComparator(a, b) {
    if (!a.name) {
      return -1;
    } else if (!b.name) {
      return 1;
    }
    return a.name.localeCompare(b.name);
  }
  function AccountsTOC() {
    import_evt7.default.Emitter.call(this);
    logic.defineScope(this, "AccountsTOC");
    this.accountDefs = this.items = [];
    this.accountDefsById = this.itemsById = new Map();
  }
  AccountsTOC.prototype = import_evt7.default.mix({
    type: "AccountsTOC",
    overlayNamespace: "accounts",
    __acquire() {
      return Promise.resolve(this);
    },
    __release() {
    },
    isKnownAccount(accountId) {
      return this.accountDefsById.has(accountId);
    },
    getAllItems() {
      return this.accountDefs.map(this.accountDefToWireRep);
    },
    getItemIndexById(id) {
      const item = this.itemsById.get(id);
      return this.items.indexOf(item);
    },
    __addAccount(accountDef) {
      let idx = bsearchForInsert(this.accountDefs, accountDef, accountDefComparator);
      this.accountDefs.splice(idx, 0, accountDef);
      this.accountDefsById.set(accountDef.id, accountDef);
      logic(this, "addAccount", { accountId: accountDef.id, index: idx });
      let wireRep = this.accountDefToWireRep(accountDef);
      this.emit("add", wireRep, idx);
    },
    __accountModified(accountDef) {
      let idx = this.accountDefs.indexOf(accountDef);
      if (idx === -1) {
        throw new Error("how do you have a different object?");
      }
      this.emit("change", this.accountDefToWireRep(accountDef), idx);
    },
    __removeAccountById(accountId) {
      let accountDef = this.accountDefsById.get(accountId);
      let idx = this.accountDefs.indexOf(accountDef);
      logic(this, "removeAccountById", { accountId, index: idx });
      this.accountDefsById.delete(accountId);
      this.accountDefs.splice(idx, 1);
      this.emit("remove", accountId, idx);
    },
    accountDefToWireRep(accountDef) {
      return Object.assign({
        id: accountDef.id,
        name: accountDef.name,
        type: accountDef.type,
        engine: accountDef.engine,
        defaultPriority: accountDef.defaultPriority,
        enabled: true,
        problems: [],
        syncRange: accountDef.syncRange,
        syncInterval: accountDef.syncInterval,
        notifyOnNew: accountDef.notifyOnNew,
        playSoundOnSend: accountDef.playSoundOnSend,
        identities: accountDef.identities,
        credentials: {
          username: accountDef.credentials.username,
          outgoingUsername: accountDef.credentials.outgoingUsername,
          oauth2: accountDef.credentials.oauth2
        },
        servers: [
          {
            type: accountDef.receiveType,
            connInfo: accountDef.receiveConnInfo,
            activeConns: 0
          },
          {
            type: accountDef.sendType,
            connInfo: accountDef.sendConnInfo,
            activeConns: 0
          }
        ]
      }, engineFrontEndAccountMeta.get(accountDef.engine));
    }
  });

  // src/backend/db/folders_toc.js
  init_logic();
  init_util();
  var import_evt8 = __toModule(require_evt());
  init_a64();
  init_id_conversions();
  init_folder_info_rep();
  var FOLDER_TYPE_TO_SORT_PRIORITY = {
    account: "a",
    inbox: "c",
    starred: "e",
    important: "f",
    drafts: "g",
    localdrafts: "h",
    outbox: "i",
    queue: "j",
    sent: "k",
    junk: "l",
    trash: "n",
    archive: "p",
    normal: "z",
    nomail: "z"
  };
  function strcmp(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    }
    return 0;
  }
  function FoldersTOC({
    db,
    accountDef,
    folders,
    dataOverlayManager
  }) {
    import_evt8.default.Emitter.call(this);
    logic.defineScope(this, "FoldersTOC");
    this.accountDef = accountDef;
    this.engineFolderMeta = engineFrontEndFolderMeta.get(accountDef.engine);
    this.engineHacks = engineHacks.get(accountDef.engine);
    this.accountId = accountDef.id;
    this._dataOverlayManager = dataOverlayManager;
    this.foldersById = this.itemsById = new Map();
    this.foldersByPath = new Map();
    this._pendingFoldersByPath = new Map();
    this._pendingTaskContextIdsToPendingPaths = new Map();
    this.items = this.folders = [];
    this.folderSortStrings = [];
    let nextFolderNum = 0;
    for (let folderInfo of folders) {
      this._addFolder(folderInfo);
      nextFolderNum = Math.max(nextFolderNum, decodeSpecificFolderIdFromFolderId(folderInfo.id) + 1);
    }
    this._nextFolderNum = nextFolderNum;
    db.on(`acct!${accountDef.id}!change`, this._onAccountChange.bind(this));
    db.on(`acct!${accountDef.id}!folders!tocChange`, this._onTOCChange.bind(this));
    dataOverlayManager.on("accountCascadeToFolders", this._onAccountOverlayCascade.bind(this));
  }
  FoldersTOC.prototype = import_evt8.default.mix({
    type: "FoldersTOC",
    overlayNamespace: "folders",
    __acquire() {
      return Promise.resolve(this);
    },
    __release() {
    },
    issueFolderId() {
      return this.accountId + "." + encodeInt(this._nextFolderNum++);
    },
    ensureLocalVirtualFolder(taskContext, folderPath) {
      let folderInfo = this.foldersByPath.get(folderPath);
      if (folderInfo) {
        return folderInfo;
      }
      let taskPendingPaths = this._pendingTaskContextIdsToPendingPaths.get(taskContext.id);
      if (!taskPendingPaths) {
        taskPendingPaths = new Set();
        taskContext.__decorateFinish(this._onTaskFinishing.bind(this));
        this._pendingTaskContextIdsToPendingPaths.set(taskContext.id, taskPendingPaths);
      }
      taskPendingPaths.add(folderPath);
      folderInfo = this._pendingFoldersByPath.get(folderPath);
      if (folderInfo) {
        return folderInfo;
      }
      const pathParts = folderPath.split("/");
      folderInfo = makeFolderMeta({
        id: this.issueFolderId(),
        serverId: null,
        name: folderPath,
        type: "normal",
        path: folderPath,
        serverPath: null,
        delim: "/",
        depth: pathParts.length,
        syncGranularity: "local-only"
      });
      this._pendingFoldersByPath.set(folderPath, folderInfo);
      return folderInfo;
    },
    _isFolderPathPending(folderPath) {
      for (const taskPendingPaths of this._pendingTaskContextIdsToPendingPaths.values()) {
        if (taskPendingPaths.has(folderPath)) {
          return true;
        }
      }
      return false;
    },
    _onTaskFinishing(taskCtx, success, finishData) {
      const taskPendingPaths = this._pendingTaskContextIdsToPendingPaths.get(taskCtx.id);
      this._pendingTaskContextIdsToPendingPaths.delete(taskCtx.id);
      for (const folderPath of taskPendingPaths) {
        const folderInfo = this._pendingFoldersByPath.get(folderPath);
        if (!folderInfo) {
          continue;
        }
        if (!success) {
          if (this._isFolderPathPending(folderPath)) {
            continue;
          }
        }
        this._pendingFoldersByPath.delete(folderPath);
        if (!success) {
          continue;
        }
        if (!finishData.newData) {
          finishData.newData = {};
        }
        if (!finishData.newData.folders) {
          finishData.newData.folders = [];
        }
        finishData.newData.folders.push(folderInfo);
      }
    },
    getAllItems() {
      return this.items;
    },
    getItemIndexById(id) {
      return this.items.findIndex((item) => {
        return item.id === id;
      });
    },
    _makeFolderSortString(folderInfo) {
      if (!folderInfo) {
        return "";
      }
      var parentFolderInfo = this.foldersById.get(folderInfo.parentId);
      return this._makeFolderSortString(parentFolderInfo) + "!" + FOLDER_TYPE_TO_SORT_PRIORITY[folderInfo.type] + "!" + folderInfo.name.toLocaleLowerCase();
    },
    _onAccountOverlayCascade(accountId) {
      if (accountId === this.accountId) {
        for (let i = 0; i < this.items.length; i++) {
          let folder = this.items[i];
          this._dataOverlayManager.announceUpdatedOverlayData(this.overlayNamespace, folder.id);
        }
      }
    },
    _onAccountChange() {
      this._fakeFolderDataChanges();
    },
    _fakeFolderDataChanges(filterFunc) {
      for (let i = 0; i < this.items.length; i++) {
        let folder = this.items[i];
        if (!filterFunc || filterFunc(folder)) {
          this.emit("change", this.folderInfoToWireRep(folder), i);
        }
      }
    },
    _onTOCChange(folderId, folderInfo, isNew) {
      if (isNew) {
        this._addFolder(folderInfo);
      } else if (folderInfo) {
        this.emit("change", this.folderInfoToWireRep(folderInfo), this.items.indexOf(folderInfo));
      } else {
        this._removeFolderById(folderId);
      }
    },
    _addFolder(folderInfo) {
      let sortString = this._makeFolderSortString(folderInfo);
      let idx = bsearchForInsert(this.folderSortStrings, sortString, strcmp);
      this.items.splice(idx, 0, folderInfo);
      logic(this, "addFolder", {
        id: folderInfo.id,
        index: idx,
        _folderInfo: folderInfo
      });
      this.folderSortStrings.splice(idx, 0, sortString);
      this.foldersById.set(folderInfo.id, folderInfo);
      this.foldersByPath.set(folderInfo.path, folderInfo);
      this.emit("add", this.folderInfoToWireRep(folderInfo), idx);
    },
    _removeFolderById(id) {
      let folderInfo = this.foldersById.get(id);
      let idx = this.items.indexOf(folderInfo);
      logic(this, "removeFolderById", { id, index: idx });
      if (!folderInfo || idx === -1) {
        throw new Error("the folder did not exist?");
      }
      this.foldersById.delete(id);
      this.foldersByPath.delete(folderInfo.path);
      this.items.splice(idx, 1);
      this.folderSortStrings.splice(idx, 1);
      this.emit("remove", id, idx);
    },
    getCanonicalFolderByType(type) {
      return this.items.find((folder) => folder.type === type) || null;
    },
    generatePersistenceInfo() {
      return this._foldersDbState;
    },
    folderInfoToWireRep(folder) {
      let mixFromAccount;
      if (this.engineFolderMeta.syncGranularity === "account" && this.accountDef.syncInfo) {
        let syncInfo = this.accountDef.syncInfo;
        mixFromAccount = {
          lastSuccessfulSyncAt: syncInfo.lastSuccessfulSyncAt,
          lastAttemptedSyncAt: syncInfo.lastAttemptedSyncAt,
          failedSyncsSinceLastSuccessfulSync: syncInfo.failedSyncsSinceLastSuccessfulSync
        };
      }
      return Object.assign({}, folder, this.engineFolderMeta, {
        engineSaysUnselectable: this.engineHacks.unselectableFolderTypes.has(folder.type)
      }, mixFromAccount);
    }
  });

  // src/backend/universe/account_manager.js
  function prereqify(mapPropName, func, forgetOnResolve) {
    return function(id) {
      let map = this[mapPropName];
      let promise = map.get(id);
      if (promise) {
        return promise;
      }
      try {
        promise = func.apply(this, arguments);
      } catch (ex) {
        return Promise.reject(ex);
      }
      map.set(id, promise);
      if (forgetOnResolve) {
        promise.then(() => {
          map.delete(id);
        });
      }
      return promise;
    };
  }
  function AccountManager({
    db,
    universe: universe2,
    taskRegistry,
    taskResources
  }) {
    logic.defineScope(this, "AccountManager");
    this.db = db;
    db.accountManager = this;
    this.universe = universe2;
    this.taskRegistry = taskRegistry;
    this.taskResources = taskResources;
    this._immediateAccountDefsById = new Map();
    this.accountsTOC = new AccountsTOC();
    this._taskTypeLoads = new Map();
    this._accountFoldersTOCLoads = new Map();
    this._accountLoads = new Map();
    this._stashedConnectionsByAccountId = new Map();
    this.accountFoldersTOCs = new Map();
    this.accounts = new Map();
    this.db.on("accounts!tocChange", this._onTOCChange.bind(this));
  }
  AccountManager.prototype = {
    initFromDB(accountDefs) {
      let waitFor = [];
      for (let accountDef of accountDefs) {
        waitFor.push(this._accountAdded(accountDef));
      }
      return Promise.all(waitFor);
    },
    stashAccountConnection(accountId, conn) {
      this._stashedConnectionsByAccountId.set(accountId, conn);
    },
    _ensureTasksLoaded: prereqify("_taskTypeLoads", function(engineId) {
      return engineTaskMappings.get(engineId)().then((tasks) => {
        this.taskRegistry.registerPerAccountTypeTasks(engineId, tasks);
        return true;
      });
    }),
    _ensureAccountFoldersTOC: prereqify("_accountFoldersTOCLoads", function(accountId) {
      return this.db.loadFoldersByAccount(accountId).then((folders) => {
        let accountDef = this.getAccountDefById(accountId);
        let foldersTOC = new FoldersTOC({
          db: this.db,
          accountDef,
          folders,
          dataOverlayManager: this.universe.dataOverlayManager
        });
        this.accountFoldersTOCs.set(accountId, foldersTOC);
        return foldersTOC;
      });
    }, true),
    _ensureAccount: prereqify("_accountLoads", function(accountId) {
      return this._ensureAccountFoldersTOC(accountId).then((foldersTOC) => {
        let accountDef = this.getAccountDefById(accountId);
        return accountModules.get(accountDef.type)().then((accountConstructor) => {
          let stashedConn = this._stashedConnectionsByAccountId.get(accountId);
          this._stashedConnectionsByAccountId.delete(accountId);
          let account = new accountConstructor(this.universe, accountDef, foldersTOC, this.db, stashedConn);
          this.accounts.set(accountId, account);
          if (this.universe.online) {
            this.universe.syncFolderList(accountId, "loadAccount");
          }
          return account;
        });
      });
    }, true),
    acquireAccountsTOC(ctx) {
      return ctx.acquire(this.accountsTOC);
    },
    acquireAccount(ctx, accountId) {
      let account = this.accounts.get(accountId);
      if (account) {
        return ctx.acquire(account);
      }
      return this._ensureAccount(accountId).then((_account) => {
        return ctx.acquire(_account);
      });
    },
    acquireAccountFoldersTOC(ctx, accountId) {
      let foldersTOC = this.accountFoldersTOCs.get(accountId);
      if (foldersTOC) {
        return ctx.acquire(foldersTOC);
      }
      return this._ensureAccountFoldersTOC(accountId).then((_foldersTOC) => {
        return ctx.acquire(_foldersTOC);
      });
    },
    getAccountDefById(accountId) {
      return this._immediateAccountDefsById.get(accountId);
    },
    getAccountEngineBackEndFacts(accountId) {
      let accountDef = this._immediateAccountDefsById.get(accountId);
      return engineBackEndFacts.get(accountDef.engine);
    },
    getAllAccountDefs() {
      return this._immediateAccountDefsById.values();
    },
    getFolderById(folderId) {
      let accountId = accountIdFromFolderId(folderId);
      let foldersTOC = this.accountFoldersTOCs.get(accountId);
      return foldersTOC.foldersById.get(folderId);
    },
    _onTOCChange(accountId, accountDef, isNew) {
      if (isNew) {
        this._accountAdded(accountDef);
      } else if (!accountDef) {
        this._accountRemoved(accountId);
      } else if (this.accountFoldersTOCs.has(accountId)) {
        this.accountsTOC.__accountModified(accountDef);
      }
    },
    _accountAdded(accountDef) {
      logic(this, "accountExists", { accountId: accountDef.id });
      this.taskResources.resourceAvailable(`credentials!${accountDef.id}`);
      this.taskResources.resourceAvailable(`happy!${accountDef.id}`);
      this._immediateAccountDefsById.set(accountDef.id, accountDef);
      let waitFor = [
        this._ensureTasksLoaded(accountDef.engine),
        this._ensureAccountFoldersTOC(accountDef.id)
      ];
      return Promise.all(waitFor).then(() => {
        if (this._stashedConnectionsByAccountId.has(accountDef.id)) {
          this._ensureAccount(accountDef.id);
        }
        this.accountsTOC.__addAccount(accountDef);
      });
    },
    _accountRemoved(accountId) {
      this._immediateAccountDefsById.delete(accountId);
      let doAccountCleanup = () => {
        let account = this.accounts.get(accountId);
        this.accounts.delete(accountId);
        this._accountLoads.delete(accountId);
        if (account) {
          account.shutdown();
        }
      };
      if (this.accounts.has(accountId)) {
        doAccountCleanup();
      } else if (this._accountLoads.has(accountId)) {
        this._accountLoads.get(accountId).then(doAccountCleanup);
      }
      let doFolderCleanup = () => {
        this.accountFoldersTOCs.delete(accountId);
        this._accountFoldersTOCLoads.delete(accountId);
        this.accountsTOC.__removeAccountById(accountId);
      };
      if (this.accountFoldersTOCs.has(accountId)) {
        doFolderCleanup();
      } else if (this._accountFoldersTOCLoads.has(accountId)) {
        this._accountFoldersTOCLoads.then(doFolderCleanup);
      }
    }
  };

  // src/backend/universe/cronsync_support.js
  init_logic();
  init_syncbase();

  // src/backend/wakelocks.js
  init_logic();
  var sendWakeLockMessage = registerCallbackType("wakelocks");
  function SmartWakeLock(opts) {
    logic.defineScope(this, "SmartWakeLock", { types: opts.locks });
    var locks = this.locks = {};
    this.timeoutMs = opts.timeout || SmartWakeLock.DEFAULT_TIMEOUT_MS;
    this._timeout = null;
    this.imminentDoomHandler = opts.imminentDoomHandler || null;
    if (opts.__existingLockId) {
      this.locks[opts.locks[0]] = opts.__existingLockId;
      logic(this, "reusedMainthreadLock");
      this._readyPromise = Promise.resolve();
      this.renew();
      return;
    }
    logic(this, "requestLock", { durationMs: this.timeoutMs });
    this._readyPromise = Promise.all(opts.locks.map((type) => {
      return sendWakeLockMessage("requestWakeLock", [type]).then((lockId) => {
        locks[type] = lockId;
      });
    })).then(() => {
      logic(this, "locked", {});
      this.renew();
    });
  }
  SmartWakeLock.DEFAULT_TIMEOUT_MS = 45e3;
  SmartWakeLock.prototype = {
    renew(reason) {
      return this._readyPromise.then(() => {
        if (this._timeout) {
          clearTimeout(this._timeout);
          logic(this, "renew", {
            reason,
            renewDurationMs: this.timeoutMs,
            durationLeftMs: this.timeoutMs - (Date.now() - this._timeLastRenewed)
          });
        }
        this._timeLastRenewed = Date.now();
        this._timeout = setTimeout(() => {
          logic(this, "timeoutUnlock");
          if (this.imminentDoomHandler) {
            try {
              this.imminentDoomHandler();
            } catch (ex) {
            }
          }
          this.unlock("timeout");
        }, this.timeoutMs);
      });
    },
    unlock(reason) {
      return this._readyPromise.then(() => {
        var locks = this.locks;
        this.locks = {};
        clearTimeout(this._timeout);
        this._timeout = null;
        logic(this, "unlock", { reason });
        return Promise.all(Object.keys(locks).map((type) => {
          return sendWakeLockMessage("unlock", [locks[type]], () => {
            return type;
          });
        })).then(() => {
          logic(this, "unlocked", { reason });
        });
      });
    },
    toString() {
      return Object.keys(this.locks).join("+") || "(no locks)";
    }
  };
  function wrapMainThreadAcquiredWakelock({
    wakelockId,
    timeout,
    imminentDoomHandler
  }) {
    return new SmartWakeLock({
      locks: ["mainthread-acquired"],
      timeout,
      imminentDoomHandler,
      __existingLockId: wakelockId
    });
  }

  // src/backend/universe/cronsync_support.js
  init_date();
  function CronSyncSupport({ universe: universe2, db, accountManager }) {
    this._universe = universe2;
    this._db = db;
    this._accountManager = accountManager;
    logic.defineScope(this, "CronSync");
    this._ensureSyncPromise = null;
    this._ensureSyncResolve = null;
    this._activeWakeLock = null;
    this._activeCronSyncLogConclusion = null;
    this._activelyCronSyncingAccounts = new Set();
    this.sendCronSync = registerSimple("cronsync", (data) => {
      var args = data.args;
      logic(this, "message", { cmd: data.cmd });
      switch (data.cmd) {
        case "alarm":
          this.onAlarm.apply(this, args);
          break;
        case "syncEnsured":
          this.onSyncEnsured.apply(this, args);
          break;
        default:
          break;
      }
    });
    this._bound_cronsyncSuccess = this._cronsyncVictoriousCompletion.bind(this);
    this._bound_cronsyncImminentDoom = this._cronsyncImminentDoom.bind(this);
  }
  CronSyncSupport.prototype = {
    systemReady() {
      this.sendCronSync("hello");
    },
    ensureSync(why) {
      if (this._ensureSyncPromise) {
        logic(this, "ensureSyncConsolidated", { why });
        return this._ensureSyncPromise;
      }
      logic(this, "ensureSync:begin", { why });
      this._ensureSyncPromise = new Promise((resolve) => {
        this._ensureSyncResolve = resolve;
      });
      let syncData = {};
      for (let accountDef of this._accountManager.getAllAccountDefs()) {
        let interval = accountDef.syncInterval, intervalKey = "interval" + interval;
        if (!syncData.hasOwnProperty(intervalKey)) {
          syncData[intervalKey] = [];
        }
        syncData[intervalKey].push(accountDef.id);
      }
      this.sendCronSync("ensureSync", [syncData]);
      return null;
    },
    onSyncEnsured() {
      logic(this, "ensureSync:end");
      this._ensureSyncResolve();
      this._ensureSyncPromise = null;
      this._ensureSyncResolve = null;
    },
    cronsyncAccount({ accountId, logTimestamp }) {
      let cronsyncLogEntry = {
        accountId,
        startTS: null,
        endTS: null,
        status: null
      };
      let cronsyncLogWrapped = {
        type: "cronsync",
        timestamp: logTimestamp,
        id: accountId,
        entry: cronsyncLogEntry
      };
      if (this._activelyCronSyncingAccounts.has(accountId)) {
        cronsyncLogEntry.status = "already-active";
        this._db.addBoundedLogs([cronsyncLogWrapped]);
        return false;
      }
      let foldersTOC = this._accountManager.accountFoldersTOCs.get(accountId);
      if (!foldersTOC) {
        cronsyncLogEntry.status = "account-dead";
        this._db.addBoundedLogs([cronsyncLogWrapped]);
        return false;
      }
      let inboxFolderId = foldersTOC.getCanonicalFolderByType("inbox").id;
      this._universe.syncRefreshFolder(inboxFolderId, "cronsync").then(() => {
        this._activelyCronSyncingAccounts.delete(accountId);
        cronsyncLogEntry.endTS = NOW();
        cronsyncLogEntry.status = "completed...somehow";
        this._db.updateBoundedLogs([cronsyncLogWrapped]);
      });
      this._activelyCronSyncingAccounts.add(accountId);
      cronsyncLogEntry.startTS = logTimestamp;
      cronsyncLogEntry.status = "issued";
      this._db.addBoundedLogs([cronsyncLogWrapped]);
      return true;
    },
    onAlarm(syncAccountIds, interval, wakelockId, accountIdsWithNotifications) {
      logic(this, "alarmFired", { syncAccountIds, interval, wakelockId });
      let logTimestamp = NOW();
      let wakelock = wrapMainThreadAcquiredWakelock({
        wakelockId,
        timeout: CRONSYNC_MAX_DURATION_MS
      });
      let cronsyncLogEntry = {
        startTS: logTimestamp,
        startOnline: this._universe.online,
        accountIds: syncAccountIds,
        endTS: null,
        endOnline: null,
        result: null
      };
      let cronsyncLogWrapped = {
        type: "cronsync",
        timestamp: logTimestamp,
        id: "cronsync",
        entry: cronsyncLogEntry
      };
      this._db.addBoundedLogs([cronsyncLogWrapped]);
      this.ensureSync("alarm");
      for (let accountDef of this._accountManager.getAllAccountDefs()) {
        if (accountIdsWithNotifications(accountDef.id)) {
          this._universe.clearNewTrackingForAccount({
            accountId: accountDef.id,
            silent: true
          });
        }
      }
      let cronsyncsIssued = 0;
      for (let accountId of syncAccountIds) {
        if (this.cronsyncAccount({ accountId, logTimestamp })) {
          cronsyncsIssued++;
        }
      }
      let logConclusion = (result) => {
        cronsyncLogEntry.endTS = NOW();
        cronsyncLogEntry.endOnline = this._universe.online;
        cronsyncLogEntry.result = result;
        this._db.updateBoundedLogs([cronsyncLogWrapped]);
      };
      if (this._activeWakeLock) {
        if (cronsyncsIssued) {
          logic(this, "cronSync:handoff");
          this._activeWakeLock.unlock();
          this._activeWakeLock = wakelock;
          this._activeWakeLock.imminentDoomHandler = this._bound_cronsyncImminentDoom;
          this._activeCronSyncLogConclusion("superseded");
          this._activeCronSyncLogConclusion = logConclusion;
        } else {
          logic(this, "cronSync:no-sync-no-handoff");
          wakelock.unlock();
          logConclusion("ignored-ineffective");
        }
      } else {
        logic(this, "cronSync:begin");
        this._activeWakeLock = wakelock;
        this._activeWakeLock.imminentDoomHandler = this._bound_cronsyncImminentDoom;
        this._activeCronSyncLogConclusion = logConclusion;
        this._universe.taskManager.once("taskQueueEmpty", this._bound_cronsyncSuccess);
      }
    },
    _cronsyncVictoriousCompletion() {
      let wakelockOnEntry = this._activeWakeLock;
      let logConclusionOnEntry = this._activeCronSyncLogConclusion;
      this._activeWakeLock = null;
      this._activeCronSyncLogConclusion = null;
      let realCompletion = () => {
        if (this._activeWakeLock) {
          logic(this, "cronSync:last-minute-handoff");
          logConclusionOnEntry("success-left-open");
          wakelockOnEntry.unlock();
          return;
        }
        logic(this, "cronSync:end");
        this._universe.broadcastOverBridges("cronSyncComplete", {});
        logConclusionOnEntry("success");
        wakelockOnEntry.unlock();
      };
      if (this._ensureSyncPromise) {
        this._ensureSyncPromise.then(realCompletion);
      } else {
        realCompletion();
      }
    },
    _cronsyncImminentDoom() {
      logic(this, "cronSyncEpicFail");
      this._universe.broadcastOverBridges("cronSyncEpicFail", {
        epicnessLevel: "so epic"
      });
    },
    shutdown() {
      unregister("cronsync");
    }
  };

  // src/backend/universe/extension_manager.js
  init_logic();
  function ExtensionManager({ derivedViewManager, tocManager }) {
    logic.defineScope(this, "ExtensionManager");
    this._extensionDefs = [];
    this._derivedViewManager = derivedViewManager;
    this._tocManager = tocManager;
  }
  ExtensionManager.prototype = {
    registerExtension(extDef, source) {
      logic(this, "registerExtension", { name: extDef.name, source });
      this._extensionDefs.push(extDef);
      if (extDef.derivedViews) {
        for (let namespace of Object.keys(extDef.derivedViews)) {
          extDef.derivedViews[namespace]().then((provider) => {
            this._derivedViewManager.registerDerivedViewProvider(namespace, provider);
          }, (ex) => {
            logic(this, "extensionRequireError", {
              name: extDef.name,
              entryPoint: "derivedView",
              ex,
              stack: ex.stack
            });
          });
        }
      }
      if (extDef.tocs) {
        for (let namespace of Object.keys(extDef.tocs)) {
          extDef.tocs[namespace]().then((provider) => {
            this._tocManager.registerNamespaceProvider(namespace, provider);
          }, (ex) => {
            logic(this, "extensionRequireError", {
              name: extDef.name,
              entryPoint: "tocs",
              ex,
              stack: ex.stack
            });
          });
        }
      }
    },
    registerExtensions(extensionDefs, source) {
      logic(this, "registerExtensions", { source });
      for (let extDef of extensionDefs) {
        this.registerExtension(extDef, source);
      }
    }
  };

  // src/backend/db/static_toc.js
  init_logic();

  // src/backend/db/base_toc.js
  var import_evt9 = __toModule(require_evt());
  init_logic();

  // src/backend/refed_resource.js
  function RefedResource({ onForgotten }) {
    this._activatePromise = null;
    this._valid = false;
    this._activeConsumers = [];
    this._onForgotten = onForgotten;
  }
  RefedResource.prototype = {
    async __acquire(ctx) {
      if (this._activeConsumers.includes(ctx)) {
        throw new Error("context already refs this resource!");
      }
      this._activeConsumers.push(ctx);
      if (!this._valid && this._activeConsumers.length === 1) {
        this._activatePromise = this.__activate();
        await this._activatePromise;
        this._valid = true;
        this._activatePromise = null;
      } else if (this._activatePromise) {
        await this._activatePromise;
      }
      return this;
    },
    __release(ctx) {
      let idx = this._activeConsumers.indexOf(ctx);
      if (idx === -1) {
        throw new Error("context does not ref this resource!");
      }
      this._activeConsumers.splice(idx, 1);
      if (this._activeConsumers.length === 0) {
        this.__deactivate();
        if (this._onForgotten) {
          this._onForgotten(this, this.convId);
        }
        this._onForgotten = null;
      }
      return Promise.resolve();
    }
  };
  RefedResource.mix = function(obj) {
    Object.keys(RefedResource.prototype).forEach(function(prop) {
      if (obj.hasOwnProperty(prop)) {
        throw new Error('Object already has a property "' + prop + '"');
      }
      obj[prop] = RefedResource.prototype[prop];
    });
    return obj;
  };
  var refed_resource_default = RefedResource;

  // src/backend/db/base_toc.js
  function BaseTOC({ metaHelpers }) {
    refed_resource_default.apply(this, arguments);
    import_evt9.default.Emitter.call(this);
    this._metaHelpers = metaHelpers || [];
    this.tocMeta = {};
    this._everActivated = false;
  }
  BaseTOC.prototype = import_evt9.default.mix(refed_resource_default.mix({
    __activate() {
      this._everActivated = true;
      for (let metaHelper of this._metaHelpers) {
        logic(this, "activatingMetaHelper", {
          name: metaHelper.constructor && metaHelper.constructor.name
        });
        metaHelper.activate(this);
      }
      return this.__activateTOC.apply(this, arguments);
    },
    __deactivate() {
      if (this._everActivated) {
        for (let metaHelper of this._metaHelpers) {
          metaHelper.deactivate(this);
        }
      }
      return this.__deactivateTOC.apply(this, arguments);
    },
    flush: null,
    applyTOCMetaChanges(changes) {
      const tocMeta = this.tocMeta;
      let somethingChanged = false;
      for (let key of Object.keys(changes)) {
        let value = changes[key];
        if (tocMeta[key] !== value) {
          tocMeta[key] = value;
          somethingChanged = true;
        }
      }
      if (somethingChanged) {
        this.emit("tocMetaChange", tocMeta);
      }
    },
    broadcastEvent(eventName, eventData) {
      this.emit("broadcastEvent", eventName, eventData);
    }
  }));
  BaseTOC.mix = function(obj) {
    Object.keys(BaseTOC.prototype).forEach(function(prop) {
      if (!obj.hasOwnProperty(prop)) {
        obj[prop] = BaseTOC.prototype[prop];
      } else if (BaseTOC.prototype[prop]) {
        throw new Error("object and base both have truthy property: " + prop);
      }
    });
    return obj;
  };

  // src/backend/db/static_toc.js
  function StaticTOC({ items }) {
    BaseTOC.apply(this, arguments);
    logic.defineScope(this, "StaticTOC");
    this.items = items;
    this.__deactivate(true);
  }
  StaticTOC.prototype = BaseTOC.mix({
    type: "StaticTOC",
    overlayNamespace: null,
    heightAware: false,
    __activateTOC() {
      return Promise.resolve(this);
    },
    __deactivateTOC() {
    },
    get length() {
      return this.items.length;
    },
    get totalHeight() {
      return this.items.length;
    },
    getTopOrderingKey() {
      return 0;
    },
    getOrderingKeyForIndex(index) {
      return index;
    },
    findIndexForOrderingKey(key) {
      return key;
    },
    getDataForSliceRange(beginInclusive, endExclusive, alreadyKnownData) {
      beginInclusive = Math.max(0, beginInclusive);
      endExclusive = Math.min(endExclusive, this.items.length);
      let sendState = new Map();
      let newKnownSet = new Set();
      let items = this.items;
      let ids = [];
      for (let i = beginInclusive; i < endExclusive; i++) {
        let id = i;
        ids.push(id);
        let haveData = alreadyKnownData.has(id);
        if (haveData) {
          newKnownSet.add(id);
          continue;
        }
        newKnownSet.add(id);
        sendState.set(id, [items[i], null, null]);
      }
      return {
        ids,
        state: sendState,
        pendingReads: null,
        readPromise: null,
        newValidDataSet: newKnownSet
      };
    }
  });

  // src/backend/universe/static_toc_namespace_provider.js
  function makeStaticTOCNamespaceProvider(staticMap) {
    const tocCache = new Map();
    return function(args) {
      const { name } = args;
      const entry = staticMap[name];
      if (!entry) {
        throw new Error("bad namespace key name: " + name);
      }
      if (typeof entry === "function") {
        return entry(args);
      }
      if (!Array.isArray(entry)) {
        throw new Error("namespace entry data not an array");
      }
      let toc = tocCache.get(name);
      if (!toc) {
        toc = new StaticTOC({
          items: entry,
          onForgotten: () => {
            tocCache.delete(name);
          }
        });
        tocCache.set(name, toc);
      }
      return args.ctx.acquire(toc);
    };
  }

  // src/backend/universe/toc_manager.js
  function TOCManager() {
    this._namespaceProviders = new Map();
  }
  TOCManager.prototype = {
    registerNamespaceProvider(namespace, provider) {
      switch (typeof provider) {
        case "object":
          provider = makeStaticTOCNamespaceProvider(provider);
          break;
        case "function":
          break;
        default:
          throw new Error("Bad provider!");
      }
      this._namespaceProviders.set(namespace, provider);
    },
    acquireExtensionTOC(ctx, namespace, name) {
      const provider = this._namespaceProviders.get(namespace);
      if (!provider) {
        throw new Error("No such namespace:" + namespace);
      }
      return provider({ ctx, name });
    }
  };

  // src/backend/universe/derived_view_manager.js
  init_logic();
  function DerivedViewManager() {
    logic.defineScope(this, "DerivedViewManager");
    this._providersByName = new Map();
  }
  DerivedViewManager.prototype = {
    registerDerivedViewProvider(name, provider) {
      logic(this, "registerDerivedViewProvider", { name });
      this._providersByName.set(name, provider);
    },
    createDerivedView({ viewDef, ctx }) {
      const viewMaker = this._providersByName.get(viewDef.provider);
      if (!viewMaker) {
        console.warn("ViewMaker requested for", viewDef.provider, "but not found");
        return null;
      }
      const { toc, derivedView } = viewMaker(viewDef);
      ctx.proxy = new WindowedListProxy(toc, ctx);
      ctx.acquire(ctx.proxy).catch((err) => {
        logic(this, "derivedViewAcquireError", { name: viewDef.provider, err });
      });
      return derivedView;
    }
  };

  // src/backend/db/data_overlay_manager.js
  var import_evt10 = __toModule(require_evt());
  init_logic();
  function DataOverlayManager() {
    import_evt10.default.Emitter.call(this);
    logic.defineScope(this, "DataOverlayManager");
    this.registeredProvidersByNamespace = new Map([
      ["accounts", new Map()],
      ["folders", new Map()],
      ["conversations", new Map()],
      ["messages", new Map()]
    ]);
  }
  DataOverlayManager.prototype = import_evt10.default.mix({
    registerProvider(namespace, name, func) {
      let providersForNamespace = this.registeredProvidersByNamespace.get(namespace);
      if (!providersForNamespace) {
        logic(this, "badNamespace", { namespace });
      }
      let funcs = providersForNamespace.get(name);
      if (!funcs) {
        funcs = [];
        providersForNamespace.set(name, funcs);
      }
      funcs.push(func);
    },
    announceUpdatedOverlayData(namespace, id) {
      logic(this, "announceUpdatedOverlayData", { namespace, id });
      this.emit(namespace, id);
    },
    makeBoundResolver(namespace) {
      return this._resolveOverlays.bind(this, this.registeredProvidersByNamespace.get(namespace));
    },
    _resolveOverlays(providersForNamespace, itemId) {
      let overlays = {};
      for (let [name, funcs] of providersForNamespace) {
        for (let func of funcs) {
          let contrib = func(itemId);
          if (contrib != null) {
            overlays[name] = contrib;
            break;
          }
        }
      }
      return overlays;
    }
  });

  // src/backend/db/folder_convs_toc.js
  init_logic();
  init_util();
  init_comparators();
  function FolderConversationsTOC({
    db,
    query,
    dataOverlayManager
  }) {
    BaseTOC.apply(this, arguments);
    logic.defineScope(this, "FolderConversationsTOC");
    this._db = db;
    this.query = query;
    this._overlayResolver = dataOverlayManager.makeBoundResolver(this.overlayNamespace, null);
    this._bound_onTOCChange = this.onTOCChange.bind(this);
    this.__deactivate(true);
  }
  FolderConversationsTOC.prototype = BaseTOC.mix({
    type: "FolderConversationsTOC",
    overlayNamespace: "conversations",
    heightAware: true,
    async __activateTOC() {
      let idsWithDates = await this.query.execute();
      this.idsWithDates = idsWithDates;
      let totalHeight = 0;
      for (let info of idsWithDates) {
        totalHeight += info.height;
      }
      this.totalHeight = totalHeight;
      this.query.bind(this, this.onTOCChange);
    },
    __deactivateTOC(firstTime) {
      this.idsWithDates = [];
      this.totalHeight = 0;
      if (!firstTime) {
        this.query.destroy(this);
      }
    },
    get length() {
      return this.idsWithDates.length;
    },
    onTOCChange(change) {
      let dataOnly = change.removeDate === change.addDate;
      if (!dataOnly) {
        let oldIndex = -1;
        if (change.removeDate) {
          let oldKey = { date: change.removeDate, id: change.id };
          oldIndex = bsearchMaybeExists(this.idsWithDates, oldKey, folderConversationComparator);
          if (oldIndex !== -1) {
            this.totalHeight -= change.oldHeight;
            this.idsWithDates.splice(oldIndex, 1);
          } else {
            throw new Error("freakout! item should exist");
          }
        }
        let newIndex = -1;
        if (change.addDate) {
          let newKey = {
            date: change.addDate,
            id: change.id,
            height: change.height,
            matchInfo: change.matchInfo
          };
          newIndex = bsearchForInsert(this.idsWithDates, newKey, folderConversationComparator);
          this.totalHeight += change.height;
          this.idsWithDates.splice(newIndex, 0, newKey);
        }
        this.emit("_indexChange", oldIndex, newIndex);
        if (oldIndex === newIndex) {
          dataOnly = true;
        }
      } else {
        this.totalHeight += change.height - change.oldHeight;
      }
      this.emit("change", change.id, dataOnly);
    },
    sliceIds(begin, end) {
      let ids = [];
      let idsWithDates = this.idsWithDates;
      for (let i = begin; i < end; i++) {
        ids.push(idsWithDates[i].id);
      }
      return ids;
    },
    getOrderingKeyForIndex(index) {
      if (this.idsWithDates.length === 0) {
        return this.getTopOrderingKey();
      } else if (index < 0) {
        index = 0;
      } else if (index >= this.idsWithDates.length) {
        index = this.idsWithDates.length - 1;
      }
      return this.idsWithDates[index];
    },
    getTopOrderingKey() {
      return {
        date: new Date(2200, 0),
        id: "",
        height: 0
      };
    },
    findIndexForOrderingKey(key) {
      let index = bsearchForInsert(this.idsWithDates, key, folderConversationComparator);
      return index;
    },
    getInfoForOffset(desiredOffset) {
      var actualOffset = 0;
      var idsWithDates = this.idsWithDates;
      var len = idsWithDates.length;
      var meta;
      for (var i = 0; i < len; i++) {
        meta = idsWithDates[i];
        if (desiredOffset < actualOffset + meta.height) {
          break;
        }
        actualOffset += meta.height;
      }
      if (!len) {
        meta = this.getTopOrderingKey();
      }
      return {
        orderingKey: meta,
        offset: actualOffset,
        cumulativeHeight: actualOffset + meta.height
      };
    },
    getHeightOffsetForIndex(desiredIndex) {
      let height = 0;
      let idsWithDates = this.idsWithDates;
      desiredIndex = Math.min(desiredIndex, idsWithDates.length);
      for (let i = 0; i < desiredIndex; i++) {
        height += idsWithDates[i].height;
      }
      return height;
    },
    _walkToCoverHeight(startIndex, delta, heightToConsume) {
      let index = startIndex;
      let idsWithDates = this.idsWithDates;
      let info = index < idsWithDates.length && idsWithDates[index];
      let tooHigh = idsWithDates.length - 1;
      while (heightToConsume > 0 && index < tooHigh && index + delta >= 0) {
        index += delta;
        info = this.idsWithDates[index];
        heightToConsume -= info.height;
      }
      return {
        index,
        overconsumed: Math.abs(heightToConsume)
      };
    },
    findIndicesFromCoordinateSoup(req) {
      let focusIndex = this.findIndexForOrderingKey(req.orderingKey);
      if (focusIndex >= this.idsWithDates.length && this.idsWithDates.length) {
        focusIndex--;
      }
      let {
        index: beginVisibleInclusive,
        overconsumed: beforeOverconsumed
      } = this._walkToCoverHeight(focusIndex, -1, req.visibleAbove);
      let { index: beginBufferedInclusive } = this._walkToCoverHeight(beginVisibleInclusive, -1, req.bufferAbove - beforeOverconsumed);
      let {
        index: endVisibleInclusive,
        overconsumed: afterOverconsumed
      } = this._walkToCoverHeight(focusIndex, 1, req.visibleBelow);
      let { index: endBufferedInclusive } = this._walkToCoverHeight(endVisibleInclusive, 1, req.bufferBelow - afterOverconsumed);
      let rval = {
        beginBufferedInclusive,
        beginVisibleInclusive,
        endVisibleExclusive: endVisibleInclusive + 1,
        endBufferedExclusive: endBufferedInclusive + 1,
        heightOffset: this.getHeightOffsetForIndex(beginBufferedInclusive)
      };
      return rval;
    },
    getDataForSliceRange(beginInclusive, endExclusive, alreadyKnownData, alreadyKnownOverlays) {
      beginInclusive = Math.max(0, beginInclusive);
      endExclusive = Math.min(endExclusive, this.idsWithDates.length);
      let overlayResolver = this._overlayResolver;
      let sendState = new Map();
      let needData = new Map();
      let newKnownSet = new Set();
      let idsWithDates = this.idsWithDates;
      let convCache = this._db.convCache;
      let ids = [];
      for (let i = beginInclusive; i < endExclusive; i++) {
        let id = idsWithDates[i].id;
        ids.push(id);
        let haveData = alreadyKnownData.has(id);
        let haveOverlays = alreadyKnownOverlays.has(id);
        if (haveData && haveOverlays) {
          newKnownSet.add(id);
          continue;
        }
        if (haveData) {
          sendState.set(id, [null, overlayResolver(id)], null);
        } else if (convCache.has(id)) {
          newKnownSet.add(id);
          sendState.set(id, [
            convCache.get(id),
            overlayResolver(id),
            idsWithDates[i].matchInfo
          ]);
        } else {
          needData.set(id, null);
        }
      }
      let readPromise = null;
      if (needData.size) {
        readPromise = this._db.read(this, {
          conversations: needData
        });
      } else {
        needData = null;
      }
      return {
        ids,
        state: sendState,
        pendingReads: needData,
        readPromise,
        newValidDataSet: newKnownSet
      };
    }
  });

  // src/backend/db/conv_toc.js
  init_logic();
  init_util();
  init_comparators();
  function ConversationTOC({ db, query, dataOverlayManager }) {
    BaseTOC.apply(this, arguments);
    logic.defineScope(this, "ConversationTOC");
    this._db = db;
    this.query = query;
    this._overlayResolver = dataOverlayManager.makeBoundResolver(this.overlayNamespace, null);
    this.__deactivate(true);
  }
  ConversationTOC.prototype = BaseTOC.mix({
    type: "ConversationTOC",
    overlayNamespace: "messages",
    heightAware: false,
    async __activateTOC() {
      let idsWithDates = await this.query.execute();
      idsWithDates.sort(conversationMessageComparator);
      this.idsWithDates = idsWithDates;
      this.query.bind(this, this.onTOCChange, this.onConvChange);
    },
    __deactivateTOC(firstTime) {
      this.idsWithDates = [];
      if (!firstTime) {
        this.query.destroy(this);
      }
    },
    get length() {
      return this.idsWithDates.length;
    },
    get totalHeight() {
      return this.idsWithDates.length;
    },
    onTOCChange({ id, preDate, postDate, item, freshlyAdded, matchInfo }) {
      let metadataOnly = item && !freshlyAdded;
      if (freshlyAdded) {
        let newKey = { date: postDate, id, matchInfo };
        let newIndex = bsearchForInsert(this.idsWithDates, newKey, conversationMessageComparator);
        this.idsWithDates.splice(newIndex, 0, newKey);
      } else if (!item) {
        let oldKey = { date: preDate, id };
        let oldIndex = bsearchMaybeExists(this.idsWithDates, oldKey, conversationMessageComparator);
        this.idsWithDates.splice(oldIndex, 1);
      } else if (preDate !== postDate) {
        let oldKey = { date: preDate, id };
        let oldIndex = bsearchMaybeExists(this.idsWithDates, oldKey, conversationMessageComparator);
        this.idsWithDates.splice(oldIndex, 1);
        let newKey = { date: postDate, id, matchInfo };
        let newIndex = bsearchForInsert(this.idsWithDates, newKey, conversationMessageComparator);
        this.idsWithDates.splice(newIndex, 0, newKey);
        metadataOnly = false;
      }
      this.emit("change", id, metadataOnly);
    },
    onConvChange(convId, convInfo) {
      if (convInfo === null) {
        this.idsWithDates.splice(0, this.idsWithDates.length);
        this.emit("change", null);
      }
    },
    sliceIds(begin, end) {
      let ids = [];
      let idsWithDates = this.idsWithDates;
      for (let i = begin; i < end; i++) {
        ids.push(idsWithDates[i].id);
      }
      return ids;
    },
    getTopOrderingKey() {
      return {
        date: new Date(2200, 0),
        id: ""
      };
    },
    getOrderingKeyForIndex(index) {
      if (this.idsWithDates.length === 0) {
        return this.getTopOrderingKey();
      } else if (index < 0) {
        index = 0;
      } else if (index >= this.idsWithDates.length) {
        index = this.idsWithDates.length - 1;
      }
      return this.idsWithDates[index];
    },
    findIndexForOrderingKey(key) {
      let index = bsearchForInsert(this.idsWithDates, key, conversationMessageComparator);
      return index;
    },
    getDataForSliceRange(beginInclusive, endExclusive, alreadyKnownData, alreadyKnownOverlays) {
      beginInclusive = Math.max(0, beginInclusive);
      endExclusive = Math.min(endExclusive, this.idsWithDates.length);
      let overlayResolver = this._overlayResolver;
      let sendState = new Map();
      let needData = new Map();
      let newKnownSet = new Set();
      let idsWithDates = this.idsWithDates;
      let messageCache = this._db.messageCache;
      let ids = [];
      for (let i = beginInclusive; i < endExclusive; i++) {
        let id = idsWithDates[i].id;
        ids.push(id);
        let haveData = alreadyKnownData.has(id);
        let haveOverlays = alreadyKnownOverlays.has(id);
        if (haveData && haveOverlays) {
          newKnownSet.add(id);
          continue;
        }
        if (haveData) {
          sendState.set(id, [null, overlayResolver(id)]);
        } else if (messageCache.has(id)) {
          newKnownSet.add(id);
          sendState.set(id, [
            messageCache.get(id),
            overlayResolver(id),
            idsWithDates[i].matchInfo
          ]);
        } else {
          let date = idsWithDates[i].date;
          needData.set([id, date], null);
        }
      }
      let readPromise = null;
      if (needData.size) {
        readPromise = this._db.read(this, {
          messages: needData
        });
      } else {
        needData = null;
      }
      return {
        ids,
        state: sendState,
        pendingReads: needData,
        readPromise,
        newValidDataSet: newKnownSet
      };
    }
  });

  // src/backend/db/toc_meta/sync_lifecycle.js
  function SyncLifecycle({
    folderId,
    syncStampSource,
    dataOverlayManager
  }) {
    this.folderId = folderId;
    this.syncStampSource = syncStampSource;
    this.newishIndexExclusive = 0;
    this.toc = null;
    this.firstTime = true;
    this.syncActive = false;
    this.dataOverlayManager = dataOverlayManager;
    this.resolveFolderOverlay = dataOverlayManager.makeBoundResolver("folders");
    this._bound_onIndexChange = this.onIndexChange.bind(this);
    this._bound_onOverlayChange = this.onOverlayChange.bind(this);
  }
  SyncLifecycle.prototype = {
    constructor: SyncLifecycle,
    activate(toc) {
      this.toc = toc;
      this.newIndex = 0;
      this.toc.on("_indexChange", this._bound_onIndexChange);
      this.dataOverlayManager.on("folders", this._bound_onOverlayChange);
      this.firstTime = true;
      this.syncActive = false;
      this.onOverlayChange(this.folderId);
    },
    deactivate() {
      this.toc.removeListener("_indexChange", this._bound_onIndexChange);
      this.dataOverlayManager.removeListener("folders", this._bound_onOverlayChange);
    },
    onIndexChange(oldIndex, newIndex) {
      if (newIndex === -1) {
        if (oldIndex < this.newishIndexExclusive) {
          this.newishIndexExclusive--;
        }
      } else if (newIndex <= this.newishIndexExclusive) {
        if (oldIndex === -1 || oldIndex >= this.newishIndexExclusive) {
          this.newishIndexExclusive++;
        }
      }
    },
    onOverlayChange(changedFolderId) {
      if (changedFolderId !== this.folderId) {
        return;
      }
      let overlays = this.resolveFolderOverlay(changedFolderId);
      let syncOverlay = overlays ? overlays.sync_refresh || overlays.sync_grow || {} : {};
      const reviseMeta = {};
      reviseMeta.syncStatus = syncOverlay.status || null;
      reviseMeta.syncBlocked = syncOverlay.blocked || null;
      let newSyncActive = !!syncOverlay.status;
      let syncFinished = this.syncActive && !newSyncActive;
      if (syncFinished || this.firstTime) {
        this.firstTime = false;
        const syncStampSource = this.syncStampSource.syncInfo || this.syncStampSource;
        reviseMeta.lastSuccessfulSyncAt = syncStampSource.lastSuccessfulSyncAt;
        reviseMeta.lastAttemptedSyncAt = syncStampSource.lastAttemptedSyncAt;
        this.toc.applyTOCMetaChanges(reviseMeta);
        if (syncFinished) {
          this.toc.broadcastEvent("syncComplete", {
            newishCount: this.newishIndexExclusive
          });
          this.newishIndexExclusive = 0;
        }
      } else {
        this.toc.applyTOCMetaChanges(reviseMeta);
      }
      this.syncActive = newSyncActive;
    }
  };

  // src/backend/task_infra/task_manager.js
  var import_evt11 = __toModule(require_evt());
  init_logic();

  // src/backend/task_infra/task_context.js
  init_logic();
  function TaskContext(taskThing, universe2) {
    this.id = taskThing.id;
    this._taskThing = taskThing;
    this.__taskInstance = null;
    this.isMarker = !!taskThing.type;
    this.isPlanning = this.isMarker ? false : taskThing.state === null;
    this.universe = universe2;
    logic.defineScope(this, "Task", {
      id: taskThing.id,
      taskType: this.taskType,
      accountId: this.accountId
    });
    this._stuffToRelease = [];
    this._preMutateStates = null;
    this._subtaskCounter = 0;
    this._decoratorCallbacks = [];
    this.state = "prep";
  }
  TaskContext.prototype = {
    get taskMode() {
      if (this.isPlannning) {
        return "planning";
      }
      return "executing";
    },
    get taskType() {
      if (this.isMarker) {
        return this._taskThing.type;
      }
      if (this.isPlanning) {
        return this._taskThing.rawTask.type;
      }
      return this._taskThing.plannedTask.type;
    },
    get accountId() {
      if (this.isMarker) {
        return this._taskThing.accountId || null;
      }
      if (this.isPlanning) {
        return this._taskThing.rawTask.accountId || null;
      }
      return this._taskThing.plannedTask.accountId || null;
    },
    get deviceOnline() {
      return this.universe.online;
    },
    get accountProblem() {
      return false;
    },
    get _taskManager() {
      return this.universe.taskManager;
    },
    get _taskRegistry() {
      return this.universe.taskRegistry;
    },
    get _taskGroupTracker() {
      return this.universe.taskGroupTracker;
    },
    acquire(acquireable) {
      this._stuffToRelease.push(acquireable);
      return acquireable.__acquire(this);
    },
    acquireAccountsTOC() {
      return this.universe.acquireAccountsTOC(this);
    },
    _releaseEverything() {
      for (let acquireable of this._stuffToRelease) {
        try {
          acquireable.__release(this);
        } catch (ex) {
          logic(this, "problemReleasing", {
            what: acquireable,
            ex,
            stack: ex && ex.stack
          });
        }
      }
    },
    synchronouslyConsultOtherTask(consultWhat, argDict) {
      return this._taskRegistry.__synchronouslyConsultOtherTask(this, consultWhat, argDict);
    },
    trackMeInTaskGroup(groupName) {
      return this._taskGroupTracker.ensureNamedTaskGroup(groupName, this.id);
    },
    get rootTaskGroupId() {
      let rootTaskGroup = this._taskGroupTracker.getRootTaskGroupForTask(this.id);
      if (rootTaskGroup) {
        return rootTaskGroup.groupId;
      }
      return null;
    },
    ensureRootTaskGroupFollowOnTask(taskToPlan) {
      this._taskGroupTracker.ensureRootTaskGroupFollowOnTask(this.id, taskToPlan);
    },
    setFailureTasks() {
    },
    heartbeat() {
      this._taskManager.__renewWakeLock();
    },
    broadcastOverBridges(name, data) {
      return this.universe.broadcastOverBridges(name, data);
    },
    announceUpdatedOverlayData(namespace, id) {
      this.universe.dataOverlayManager.announceUpdatedOverlayData(namespace, id);
    },
    read(what) {
      return this.universe.db.read(this, what);
    },
    readSingle(namespace, reqId, readbackId) {
      let readMap = new Map();
      readMap.set(reqId, null);
      let req = {
        [namespace]: readMap
      };
      return this.universe.db.read(this, req).then((results) => {
        return results[namespace].get(readbackId || reqId);
      });
    },
    mutateSingle(namespace, reqId, readbackId) {
      let readMap = new Map();
      readMap.set(reqId, null);
      let req = {
        [namespace]: readMap
      };
      return this.universe.db.beginMutate(this, req).then((results) => {
        return results[namespace].get(readbackId || reqId);
      });
    },
    beginMutate(what) {
      if (this.state !== "prep") {
        throw new Error("Cannot switch to mutate state from state: " + this.state);
      }
      this.state = "mutate";
      return this.universe.db.beginMutate(this, what);
    },
    spawnSubtask(subtaskFunc, argObj) {
      let subId = "sub:" + this.id + ":" + this._subtaskCounter++;
      let subThing = {
        id: subId,
        type: "subtask"
      };
      let subContext = new TaskContext(subThing, this.universe);
      return this._taskManager.__trackAndWrapSubtask(this, subContext, subtaskFunc, argObj);
    },
    spawnSimpleMutationSubtask({ namespace, id }, mutateFunc) {
      return this.spawnSubtask(this._simpleMutationSubtask, {
        mutateFunc,
        namespace,
        id
      });
    },
    async _simpleMutationSubtask(subctx, { mutateFunc, namespace, id }) {
      let obj = await subctx.mutateSingle(namespace, id);
      let writeObj = mutateFunc.call(this, obj);
      await subctx.finishTask({
        mutations: {
          [namespace]: new Map([[id, writeObj]])
        }
      });
      return writeObj;
    },
    flushedWriteRetainingLock() {
      throw new Error();
    },
    mutateMore(what) {
      if (this.state !== "mutate") {
        throw new Error("You should already be mutating, not in state: " + this.state);
      }
      return this.universe.db.beginMutate(this, what);
    },
    dangerousIncrementalWrite(mutations) {
      return this.universe.db.dangerousIncrementalWrite(this, mutations);
    },
    finishTask(finishData) {
      if (this.state === "finishing") {
        throw new Error("already finishing! did you put finishTask in a loop?");
      }
      this.state = "finishing";
      const taskManager = this.universe.taskManager;
      let revisedTaskInfo;
      if (!this.isMarker) {
        if (finishData.taskState) {
          this._taskThing.state = "planned";
          this._taskThing.plannedTask = finishData.taskState;
          revisedTaskInfo = {
            id: this.id,
            value: this._taskThing
          };
          taskManager.__queueTasksOrMarkers([this._taskThing], this.id, true);
        } else {
          revisedTaskInfo = {
            id: this.id,
            value: null
          };
        }
        if (this._taskThing.nonpersistent) {
          revisedTaskInfo = null;
        }
      }
      if (finishData.complexTaskState) {
        if (!finishData.mutations) {
          finishData.mutations = {};
        }
        finishData.mutations.complexTaskStates = new Map([
          [[this.accountId, this.taskType], finishData.complexTaskState]
        ]);
      }
      if (finishData.taskMarkers) {
        for (let [markerId, taskMarker] of finishData.taskMarkers) {
          if (taskMarker) {
            taskManager.__queueTasksOrMarkers([taskMarker], this.id, true);
          } else {
            taskManager.__removeTaskOrMarker(markerId, this.id);
          }
        }
      }
      let wrappedTasks = null;
      if (finishData.newData && finishData.newData.tasks) {
        wrappedTasks = taskManager.__wrapTasks(finishData.newData.tasks);
      }
      if (finishData.undoTasks) {
        taskManager.emit(`undoTasks:${this.id}`, finishData.undoTasks);
      }
      for (const decoratorCallback of this._decoratorCallbacks) {
        decoratorCallback(this, true, finishData);
      }
      return this.universe.db.finishMutate(this, finishData, {
        revisedTaskInfo,
        wrappedTasks
      }).then(() => {
        if (wrappedTasks) {
          taskManager.__enqueuePersistedTasksForPlanning(wrappedTasks, this.id);
        }
      });
    },
    returnValue(value) {
      return { wrappedResult: value };
    },
    __failsafeFinalize() {
      if (this.state === "finishing") {
        return;
      }
      logic(this, "failsafeFinalize");
      for (const decoratorCallback of this._decoratorCallbacks) {
        try {
          decoratorCallback(this, false, null);
        } catch (ex) {
          logic(this, "decoratorFailsafeFail", { ex });
        }
      }
      this._decoratorCallbacks = [];
      this.finishTask({});
    },
    __decorateFinish(callback) {
      this._decoratorCallbacks.push(callback);
    }
  };

  // src/backend/task_infra/task_manager.js
  function TaskManager({
    universe: universe2,
    db,
    taskRegistry,
    taskResources,
    taskPriorities,
    accountManager
  }) {
    import_evt11.default.Emitter.call(this);
    logic.defineScope(this, "TaskManager");
    this._universe = universe2;
    this._db = db;
    this._registry = taskRegistry;
    this._resources = taskResources;
    this._priorities = taskPriorities;
    this._accountManager = accountManager;
    this._accountsTOC = accountManager.accountsTOC;
    let idBase = Date.now() - 14e11;
    if (idBase < 0) {
      throw new Error("clock is bad, correctness compromised, giving up.");
    }
    this._nextId = idBase * 100;
    this._tasksToPlan = [];
    this._pendingPlanWrites = 0;
    this._activePromise = Promise.resolve(null);
    this._activeWakeLock = null;
  }
  TaskManager.prototype = import_evt11.default.mix({
    async __restoreFromDB() {
      let { wrappedTasks, complexTaskStates } = await this._db.loadTasks();
      logic(this, "restoreFromDB", { count: wrappedTasks.length });
      for (let wrappedTask of wrappedTasks) {
        if (wrappedTask.state === null) {
          this._tasksToPlan.push(wrappedTask);
        } else {
          this.__queueTasksOrMarkers([wrappedTask], "restored:simple", true);
        }
      }
      let pendingInitPromises = [];
      this._registry.initializeFromDatabaseState(complexTaskStates);
      pendingInitPromises.push(this._registry.initGlobalTasks().then((markers) => {
        this.__queueTasksOrMarkers(markers, "restored:complex", true);
      }));
      this._accountsTOC.getAllItems().forEach((accountInfo) => {
        let foldersTOC = this._accountManager.accountFoldersTOCs.get(accountInfo.id);
        pendingInitPromises.push(this._registry.accountExistsInitTasks(accountInfo.id, accountInfo.engine, accountInfo, foldersTOC).then((markers) => {
          this.__queueTasksOrMarkers(markers, "restored:complex", true);
        }));
      });
      this._accountsTOC.on("add", (accountInfo) => {
        let foldersTOC = this._accountManager.accountFoldersTOCs.get(accountInfo.id);
        this._registry.accountExistsInitTasks(accountInfo.id, accountInfo.engine, accountInfo, foldersTOC).then((markers) => {
          this.__queueTasksOrMarkers(markers, "restored:complex", true);
        });
      });
      this._accountsTOC.on("remove", (accountInfo) => {
        this._registry.accountRemoved(accountInfo.id);
      });
      Promise.all(pendingInitPromises).then(() => {
        this._activePromise = null;
        logic(this, "starting", {
          numTasksToPlan: this._tasksToPlan.length,
          numPrioritizedTasks: this._priorities.numTasksToExecute
        });
        this._maybeDoStuff();
      });
    },
    _ensureWakeLock(why) {
      if (!this._activeWakeLock) {
        logic(this, "ensureWakeLock", { why });
        this._activeWakeLock = new SmartWakeLock({ locks: ["cpu"] });
      } else {
        this._activeWakeLock.renew("TaskManager:ensure");
      }
    },
    __renewWakeLock() {
      if (this._activeWakeLock) {
        this._activeWakeLock.renew("TaskManager:explicit");
      } else {
        logic.fail("explicit renew propagated without a wakelock?");
      }
    },
    _releaseWakeLock() {
      if (this._activeWakeLock) {
        this._activeWakeLock.unlock("TaskManager:release");
        this._activeWakeLock = null;
      }
    },
    scheduleTasks(rawTasks, why) {
      this._ensureWakeLock(why);
      let wrappedTasks = this.__wrapTasks(rawTasks);
      logic(this, "schedulePersistent", { why, tasks: wrappedTasks });
      this._pendingPlanWrites++;
      return this._db.addTasks(wrappedTasks).then(() => {
        this._pendingPlanWrites--;
        this.__enqueuePersistedTasksForPlanning(wrappedTasks);
        return wrappedTasks.map((x) => x.id);
      });
    },
    waitForTasksToBePlanned(taskIds) {
      return Promise.all(taskIds.map((taskId) => {
        return new Promise((resolve) => {
          this.once("planned:" + taskId, resolve);
        });
      }));
    },
    scheduleTaskAndWaitForPlannedResult(rawTask, why) {
      return this.scheduleTasks([rawTask], why).then((taskIds) => {
        return this.waitForTasksToBePlanned(taskIds);
      }).then((results) => {
        return results[0];
      });
    },
    scheduleTaskAndWaitForPlannedUndoTasks(rawTask, why) {
      return this.scheduleTasks([rawTask], why).then(([taskId]) => {
        return new Promise((resolve) => {
          let undoHandler = (undoTasks) => {
            resolve(undoTasks);
          };
          let ensureCleanup = () => {
            this.removeListener(`undoTasks:${taskId}`, undoHandler);
            resolve([]);
          };
          this.on(`undoTasks:${taskId}`, undoHandler);
          this.once(`planned:${taskId}`, ensureCleanup);
        });
      });
    },
    scheduleTaskAndWaitForExecutedResult(rawTask, why) {
      return this.scheduleTasks([rawTask], why).then((taskIds) => {
        return this.waitForTasksToBeExecuted(taskIds);
      }).then((results) => {
        return results[0];
      });
    },
    waitForTasksToBeExecuted(taskIds) {
      return Promise.all(taskIds.map((taskId) => {
        return new Promise((resolve) => {
          this.once("executed:" + taskId, resolve);
        });
      }));
    },
    scheduleNonPersistentTasks(rawTasks, why) {
      this._ensureWakeLock(why);
      let wrappedTasks = this.__wrapTasks(rawTasks);
      logic(this, "scheduleNonPersistent", { why, tasks: wrappedTasks });
      wrappedTasks.forEach((wrapped) => {
        wrapped.nonpersistent = true;
      });
      this.__enqueuePersistedTasksForPlanning(wrappedTasks);
      return Promise.resolve(wrappedTasks.map((x) => x.id));
    },
    scheduleNonPersistentTaskAndWaitForPlannedResult(rawTask, why) {
      return this.scheduleNonPersistentTasks([rawTask], why).then((taskIds) => {
        return this.waitForTasksToBePlanned(taskIds);
      }).then((results) => {
        return results[0];
      });
    },
    scheduleNonPersistentTaskAndWaitForExecutedResult(rawTask, why) {
      return this.scheduleNonPersistentTasks([rawTask], why).then((taskIds) => {
        return this.waitForTasksToBeExecuted(taskIds);
      }).then((results) => {
        return results[0];
      });
    },
    __wrapTasks(rawTasks) {
      return rawTasks.map((rawTask) => {
        return {
          id: this._nextId++,
          rawTask,
          state: null
        };
      });
    },
    __enqueuePersistedTasksForPlanning(wrappedTasks, sourceId) {
      this._ensureWakeLock();
      for (let wrappedTask of wrappedTasks) {
        this.emit("willPlan", wrappedTask, sourceId);
      }
      this._tasksToPlan.splice(this._tasksToPlan.length, 0, ...wrappedTasks);
      this._maybeDoStuff();
    },
    __queueTasksOrMarkers(taskThings, sourceId, noTrigger) {
      let prioritized = 0;
      for (let taskThing of taskThings) {
        logic(this, "queueing", { taskThing, sourceId });
        this.emit("willExecute", taskThing, sourceId);
        if (this._resources.ownOrRelayTaskThing(taskThing)) {
          prioritized++;
        }
      }
      if (prioritized && !noTrigger && !this._activePromise) {
        Promise.resolve().then(() => {
          this._maybeDoStuff();
        });
      }
    },
    __removeTaskOrMarker(taskId) {
      logic(this, "removing", { taskId });
      this._resources.removeTaskThing(taskId);
    },
    _maybeDoStuff() {
      if (this._activePromise) {
        return;
      }
      if (this._tasksToPlan.length) {
        this._activePromise = this._planNextTask();
      } else if (!this._priorities.hasTasksToExecute()) {
        this._activePromise = this._executeNextTask();
      } else {
        logic(this, "nothingToDo");
        if (this._pendingPlanWrites === 0) {
          this.emit("taskQueueEmpty");
        }
        this._releaseWakeLock();
        return;
      }
      if (!this._activePromise) {
        if (this._tasksToPlan.length || !this._priorities.hasTasksToExecute()) {
          setTimeout(() => {
            this._maybeDoStuff();
          }, 0);
        }
        return;
      }
      this._activePromise.then(() => {
        this._activePromise = null;
        this._maybeDoStuff();
      }, (error) => {
        this._activePromise = null;
        logic(this, "taskError", { error, stack: error.stack });
        this._maybeDoStuff();
      });
    },
    _planNextTask() {
      let wrappedTask = this._tasksToPlan.shift();
      logic(this, "planning:begin", { task: wrappedTask });
      let ctx = new TaskContext(wrappedTask, this._universe);
      let planResult = this._registry.planTask(ctx, wrappedTask);
      if (planResult) {
        planResult.then((maybeResult) => {
          let result = maybeResult && maybeResult.wrappedResult || void 0;
          logic(this, "planning:end", { success: true, task: wrappedTask });
          this.emit("planned:" + wrappedTask.id, result);
          this.emit("planned", wrappedTask.id, result);
        }, (err) => {
          logic(this, "planning:end", {
            success: false,
            err,
            task: wrappedTask
          });
          this.emit("planned:" + wrappedTask.id, null);
          this.emit("planned", wrappedTask.id, null);
        });
      } else {
        logic(this, "planning:end", { moot: true, task: wrappedTask });
        this.emit("planned:" + wrappedTask.id, void 0);
        this.emit("planned", wrappedTask.id, void 0);
      }
      return planResult;
    },
    _executeNextTask() {
      let taskThing = this._priorities.popNextAvailableTask();
      logic(this, "executing:begin", { task: taskThing });
      let ctx = new TaskContext(taskThing, this._universe);
      let execResult = this._registry.executeTask(ctx, taskThing);
      if (execResult) {
        execResult.then((maybeResult) => {
          let result = maybeResult && maybeResult.wrappedResult || void 0;
          logic(this, "executing:end", { success: true, task: taskThing });
          this.emit("executed:" + taskThing.id, result);
          this.emit("executed", taskThing.id, result);
        }, (err) => {
          logic(this, "executing:end", {
            success: false,
            err,
            task: taskThing
          });
          this.emit("executed:" + taskThing.id, null);
          this.emit("executed", taskThing.id, null);
        });
      } else {
        logic(this, "executing:end", { moot: true, task: taskThing });
        this.emit("executed:" + taskThing.id, void 0);
        this.emit("executed", taskThing.id, void 0);
      }
      return execResult;
    },
    __trackAndWrapSubtask(ctx, subctx, subtaskFunc, subtaskArg) {
      logic(this, "subtask:begin", { taskId: ctx.id, subtaskId: subctx.id });
      let subtaskResult = subtaskFunc.call(subctx.__taskInstance, subctx, subtaskArg);
      return subtaskResult.then((result) => {
        logic(this, "subtask:end", { taskId: ctx.id, subtaskId: subctx.id });
        return result;
      });
    }
  });

  // src/backend/task_infra/task_registry.js
  init_logic();
  function TaskRegistry({
    dataOverlayManager,
    triggerManager,
    taskResources
  }) {
    logic.defineScope(this, "TaskRegistry");
    this._dataOverlayManager = dataOverlayManager;
    this._triggerManager = triggerManager;
    this._taskResources = taskResources;
    this._globalTasks = new Map();
    this._globalTaskRegistry = new Map();
    this._perAccountTypeTasks = new Map();
    this._perAccountIdTaskRegistry = new Map();
    this._perAccountTypeTasks.set(null, this._globalTasks);
    this._perAccountIdTaskRegistry.set(null, this._globalTaskRegistry);
    this._dbDataByAccount = new Map();
  }
  TaskRegistry.prototype = {
    registerGlobalTasks(taskImpls) {
      for (let taskImpl of taskImpls) {
        this._globalTasks.set(taskImpl.name, taskImpl);
      }
    },
    isAccountTypeKnown(accountType) {
      return this._perAccountTypeTasks.has(accountType);
    },
    registerPerAccountTypeTasks(accountType, taskImpls) {
      let perTypeTasks = this._perAccountTypeTasks.get(accountType);
      if (!perTypeTasks) {
        perTypeTasks = new Map();
        this._perAccountTypeTasks.set(accountType, perTypeTasks);
      }
      for (let taskImpl of taskImpls) {
        perTypeTasks.set(taskImpl.name, taskImpl);
      }
    },
    initializeFromDatabaseState([stateKeys, stateValues]) {
      if (stateKeys.length !== stateValues.length) {
        throw new Error("impossible complex state inconsistency issue");
      }
      for (let i = 0; i < stateKeys.length; i++) {
        let [accountId, taskType, taskKey] = stateKeys[i];
        let value = stateValues[i];
        let dataByTaskType = this._dbDataByAccount.get(accountId);
        if (!dataByTaskType) {
          dataByTaskType = new Map();
          this._dbDataByAccount.set(accountId, dataByTaskType);
        }
        if (taskKey !== void 0) {
          let map = dataByTaskType.get(taskType);
          if (!map) {
            map = new Map();
            dataByTaskType.set(taskType, map);
          }
          map.set(taskKey, value);
        } else {
          dataByTaskType.set(taskType, value);
        }
      }
    },
    _registerComplexTaskImplWithEventSources(accountId, meta) {
      let taskImpl = meta.impl;
      let blockedTaskChecker = this._taskResources.whatIsTaskBlockedBy.bind(this._taskResources);
      for (let key of Object.keys(taskImpl)) {
        let overlayMatch = /^overlay_(.+)$/.exec(key);
        if (overlayMatch) {
          logic(this, "registerOverlayProvider", {
            accountId,
            taskName: taskImpl.name,
            overlayType: overlayMatch[1]
          });
          this._dataOverlayManager.registerProvider(overlayMatch[1], taskImpl.name, taskImpl[key].bind(taskImpl, meta.persistentState, meta.memoryState, blockedTaskChecker));
        }
        let triggerMatch = /^trigger_(.+$)$/.exec(key);
        if (triggerMatch) {
          logic(this, "registerTriggerHandler", {
            accountId,
            taskName: taskImpl.name,
            trigger: triggerMatch[1]
          });
          this._triggerManager.registerTriggerFunc(triggerMatch[1], taskImpl.name, taskImpl[key].bind(taskImpl, meta.persistentState, meta.memoryState));
        }
      }
    },
    initGlobalTasks() {
      return this.accountExistsInitTasks(null, null, null, null);
    },
    accountExistsInitTasks(accountId, accountType, accountInfo, foldersTOC) {
      logic(this, "accountExistsInitTasks:begin", { accountId, accountType });
      let taskImpls = this._perAccountTypeTasks.get(accountType);
      if (!taskImpls) {
        logic(this, "noPerAccountTypeTasks", { accountId, accountType });
      }
      let accountMarkers = [];
      let pendingPromises = [];
      let dataByTaskType = this._dbDataByAccount.get(accountId);
      if (!dataByTaskType) {
        dataByTaskType = new Map();
      }
      let taskMetas = this._perAccountIdTaskRegistry.get(accountId);
      if (!taskMetas) {
        taskMetas = new Map();
        this._perAccountIdTaskRegistry.set(accountId, taskMetas);
      }
      let simpleCount = 0;
      let complexCount = 0;
      for (let unlatchedTaskImpl of taskImpls.values()) {
        let taskImpl = unlatchedTaskImpl;
        let taskType = taskImpl.name;
        let meta = {
          impl: taskImpl,
          persistentState: dataByTaskType.get(taskType),
          memoryState: null
        };
        if (taskImpl.isComplex) {
          complexCount++;
          logic(this, "initializingComplexTask", {
            accountId,
            taskType,
            hasPersistentState: !!meta.persistentState
          });
          if (!meta.persistentState) {
            meta.persistentState = taskImpl.initPersistentState();
          }
          let maybePromise = taskImpl.deriveMemoryStateFromPersistentState(meta.persistentState, accountId, accountInfo, foldersTOC);
          let saveOffMemoryState = ({ memoryState, markers }) => {
            meta.memoryState = memoryState;
            if (markers) {
              accountMarkers.push(...markers);
            }
            this._registerComplexTaskImplWithEventSources(accountId, meta);
          };
          if (maybePromise.then) {
            pendingPromises.push(maybePromise.then(saveOffMemoryState));
          } else {
            saveOffMemoryState(maybePromise);
          }
        } else {
          simpleCount++;
        }
        taskMetas.set(taskType, meta);
      }
      return Promise.all(pendingPromises).then(() => {
        logic(this, "accountExistsInitTasks:end", {
          accountId,
          accountType,
          simpleCount,
          complexCount,
          markerCount: accountMarkers.length
        });
        return accountMarkers;
      });
    },
    accountRemoved() {
    },
    _forceFinalize(ctx, maybePromiseResult) {
      if (maybePromiseResult.then) {
        let doFinalize = () => {
          ctx.__failsafeFinalize();
        };
        maybePromiseResult.then(doFinalize, doFinalize);
      } else {
        ctx.__failsafeFinalize();
      }
    },
    planTask(ctx, wrappedTask) {
      let rawTask = wrappedTask.rawTask;
      let taskType = rawTask.type;
      let taskMeta;
      if (this._globalTaskRegistry.has(taskType)) {
        taskMeta = this._globalTaskRegistry.get(taskType);
      } else {
        let accountId = rawTask.accountId;
        let perAccountTasks = this._perAccountIdTaskRegistry.get(accountId);
        if (!perAccountTasks) {
          logic(this, "noSuchAccount", { taskType, accountId });
          return null;
        }
        taskMeta = perAccountTasks.get(taskType);
        if (!taskMeta) {
          logic(this, "noSuchTaskProvider", { taskType, accountId });
          return null;
        }
      }
      ctx.__taskInstance = taskMeta.impl;
      let maybePromiseResult;
      try {
        if (taskMeta.impl.isComplex) {
          maybePromiseResult = taskMeta.impl.plan(ctx, taskMeta.persistentState, taskMeta.memoryState, rawTask);
        } else {
          return taskMeta.impl.plan(ctx, rawTask);
        }
      } catch (ex) {
        logic.fail(ex);
      }
      this._forceFinalize(ctx, maybePromiseResult);
      return maybePromiseResult;
    },
    executeTask(ctx, taskThing) {
      let isMarker = !!taskThing.type;
      let taskType = isMarker ? taskThing.type : taskThing.plannedTask.type;
      let taskMeta;
      if (this._globalTaskRegistry.has(taskType)) {
        taskMeta = this._globalTaskRegistry.get(taskType);
      } else {
        let accountId = isMarker ? taskThing.accountId : taskThing.plannedTask.accountId;
        taskMeta = this._perAccountIdTaskRegistry.get(accountId).get(taskType);
      }
      if (!taskMeta.impl.execute) {
        return Promise.resolve();
      }
      if (isMarker !== taskMeta.impl.isComplex) {
        throw new Error("Trying to exec " + taskType + " but isComplex:" + taskMeta.impl.isComplex);
      }
      ctx.__taskInstance = taskMeta.impl;
      let maybePromiseResult;
      if (isMarker) {
        maybePromiseResult = taskMeta.impl.execute(ctx, taskMeta.persistentState, taskMeta.memoryState, taskThing);
      } else {
        maybePromiseResult = taskMeta.impl.execute(ctx, taskThing.plannedTask);
      }
      this._forceFinalize(ctx, maybePromiseResult);
      return maybePromiseResult;
    },
    __synchronouslyConsultOtherTask(ctx, consultWhat, argDict) {
      let taskType = consultWhat.name;
      let taskMeta;
      if (this._globalTaskRegistry.has(taskType)) {
        taskMeta = this._globalTaskRegistry.get(taskType);
      } else {
        let accountId = consultWhat.accountId;
        taskMeta = this._perAccountIdTaskRegistry.get(accountId).get(taskType);
      }
      if (!taskMeta.impl.consult) {
        throw new Error("implementation has no consult method");
      }
      return taskMeta.impl.consult(ctx, taskMeta.persistentState, taskMeta.memoryState, argDict);
    }
  };

  // src/backend/task_infra/task_priorities.js
  init_logic();
  var import_fibonacci_heap = __toModule(require_fibonacci_heap());
  function TaskPriorities() {
    logic.defineScope(this, "TaskPriorities");
    this._prioritizedTasks = new import_fibonacci_heap.default();
    this._taskIdToHeapNode = new Map();
    this._priorityTagToHeapNodes = new Map();
    this._priorityTagsByOwner = new Map();
    this._summedPriorityTags = new Map();
  }
  TaskPriorities.prototype = {
    hasTasksToExecute() {
      return this._prioritizedTasks.isEmpty();
    },
    get numTasksToExecute() {
      return this._prioritizedTasks.nodeCount;
    },
    popNextAvailableTask() {
      let priorityNode = this._prioritizedTasks.extractMinimum();
      if (!priorityNode) {
        return null;
      }
      let taskThing = priorityNode.value;
      this._taskIdToHeapNode.delete(taskThing.id);
      this._cleanupTaskPriorityTracking(taskThing, priorityNode);
      return taskThing;
    },
    _computePriorityForTags(priorityTags) {
      let summedPriorityTags = this._summedPriorityTags;
      let priority = 0;
      if (priorityTags) {
        for (let priorityTag of priorityTags) {
          priority += summedPriorityTags.get(priorityTag) || 0;
        }
      }
      return priority;
    },
    setPriorityBoostTags(owningId, tagsWithValues) {
      let existingValues = this._priorityTagsByOwner.get(owningId) || new Map();
      let newValues = tagsWithValues || new Map();
      let perThingDeltas = new Map();
      let summedPriorityTags = this._summedPriorityTags;
      let priorityTagToHeapNodes = this._priorityTagToHeapNodes;
      if (tagsWithValues) {
        this._priorityTagsByOwner.set(owningId, tagsWithValues);
      } else {
        this._priorityTagsByOwner.delete(owningId);
      }
      let applyDelta = (priorityTag, delta) => {
        let newSum = (summedPriorityTags.get(priorityTag) || 0) + delta;
        if (newSum) {
          summedPriorityTags.set(priorityTag, newSum);
        } else {
          summedPriorityTags.delete(priorityTag);
        }
        let nodes = priorityTagToHeapNodes.get(priorityTag);
        if (nodes) {
          for (let node of nodes) {
            let aggregateDelta = (perThingDeltas.get(node) || 0) + delta;
            perThingDeltas.set(node, aggregateDelta);
          }
        }
      };
      for (let [priorityTag, newPriority] of newValues.entries()) {
        let oldPriority = existingValues.get(priorityTag) || 0;
        let priorityDelta = newPriority - oldPriority;
        applyDelta(priorityTag, priorityDelta);
      }
      for (let [priorityTag, oldPriority] of existingValues.entries()) {
        if (newValues.has(priorityTag)) {
          continue;
        }
        applyDelta(priorityTag, -oldPriority);
      }
      for (let [node, aggregateDelta] of perThingDeltas.values()) {
        let newKey = node.key - aggregateDelta;
        this._reprioritizeHeapNode(node, newKey);
      }
    },
    _reprioritizeHeapNode(node, newKey) {
      let prioritizedTasks = this._prioritizedTasks;
      if (newKey < node.key) {
        prioritizedTasks.decreaseKey(node, newKey);
      } else if (newKey > node.key) {
        let taskThing = node.value;
        prioritizedTasks.delete(node);
        prioritizedTasks.insert(newKey, taskThing);
      }
    },
    prioritizeTaskThing(taskThing) {
      let isMarker = !!taskThing.type;
      let priorityTags = isMarker ? taskThing.priorityTags : taskThing.plannedTask.priorityTags;
      let relPriority = (isMarker ? taskThing.relPriority : taskThing.plannedTask.relPriority) || 0;
      let priority = relPriority + this._computePriorityForTags(priorityTags);
      let nodeKey = -priority;
      let priorityNode = this._taskIdToHeapNode.get(taskThing.id);
      if (priorityNode) {
        this._reprioritizeHeapNode(priorityNode, nodeKey);
        let oldTaskThing = priorityNode.value;
        this._cleanupTaskPriorityTracking(oldTaskThing);
        priorityNode.value = taskThing;
      } else {
        priorityNode = this._prioritizedTasks.insert(nodeKey, taskThing);
        this._taskIdToHeapNode.set(taskThing.id, priorityNode);
      }
      this._setupTaskPriorityTracking(taskThing, priorityNode);
    },
    _setupTaskPriorityTracking(taskThing, priorityNode) {
      let isTask = !taskThing.type;
      let priorityTags = isTask ? taskThing.plannedTask.priorityTags : taskThing.priorityTags;
      let priorityTagToHeapNodes = this._priorityTagToHeapNodes;
      if (priorityTags) {
        for (let priorityTag of priorityTags) {
          let nodes = priorityTagToHeapNodes.get(priorityTag);
          if (nodes) {
            nodes.push(priorityNode);
          } else {
            priorityTagToHeapNodes.set(priorityTag, [priorityNode]);
          }
        }
      }
    },
    _cleanupTaskPriorityTracking(taskThing, priorityNode) {
      let isTask = !taskThing.type;
      let priorityTags = isTask ? taskThing.plannedTask.priorityTags : taskThing.priorityTags;
      let priorityTagToHeapNodes = this._priorityTagToHeapNodes;
      if (priorityTags) {
        for (let priorityTag of priorityTags) {
          let nodes = priorityTagToHeapNodes.get(priorityTag);
          if (nodes) {
            let idx = nodes.indexOf(priorityNode);
            if (idx !== -1) {
              nodes.splice(idx, 1);
            }
            if (nodes.length === 0) {
              priorityTagToHeapNodes.delete(priorityTag);
            }
          }
        }
      }
    },
    removeTaskThing(taskId, priorityNode) {
      if (!priorityNode) {
        priorityNode = this._taskIdToHeapNode.get(taskId);
      }
      if (priorityNode) {
        let taskThing = priorityNode.value;
        this._prioritizedTasks.delete(priorityNode);
        this._taskIdToHeapNode.delete(taskId);
        this._cleanupTaskPriorityTracking(taskThing, priorityNode);
      }
    },
    removeTasksUsingFilter(shouldRemove) {
      for (let priorityNode of this._taskIdToHeapNode.values()) {
        const taskThing = priorityNode.value;
        if (shouldRemove(taskThing)) {
          this.removeTaskThing(taskThing.id, priorityNode);
        }
      }
    }
  };

  // src/backend/task_infra/task_resources.js
  init_logic();
  function TaskResources(priorities) {
    logic.defineScope(this, "TaskResources");
    this._priorities = priorities;
    this._availableResources = new Set();
    this._blockedTasksByResource = new Map();
    this._blockedTasksById = new Map();
    this._resourceTimeouts = new Map();
  }
  TaskResources.prototype = {
    resourceAvailable(resourceId) {
      if (this._availableResources.has(resourceId)) {
        logic(this, "resourceAlreadyAvailable", { resourceId });
        return 0;
      }
      logic(this, "resourceAvailable", { resourceId });
      this._availableResources.add(resourceId);
      this._clearResourceTimeouts(resourceId);
      if (!this._blockedTasksByResource.has(resourceId)) {
        return 0;
      }
      let taskThings = this._blockedTasksByResource.get(resourceId);
      this._blockedTasksByResource.delete(resourceId);
      let prioritized = 0;
      for (let taskThing of taskThings) {
        this._blockedTasksById.delete(taskThing.id);
        if (this.ownOrRelayTaskThing(taskThing)) {
          prioritized++;
        }
      }
      return prioritized;
    },
    resourcesNoLongerAvailable(removedResourceIds) {
      let removedCount = 0;
      for (let removedResourceId of removedResourceIds) {
        if (this._availableResources.has(removedResourceId)) {
          this._availableResources.delete(removedResourceId);
          removedCount++;
        }
      }
      if (removedCount === 0) {
        logic(this, "resourcesAlreadyUnavailable", { removedResourceIds });
        return;
      }
      logic(this, "resourcesNoLongerAvailable", { removedResourceIds });
      const nowBlocked = [];
      this._priorities.removeTasksUsingFilter((taskThing) => {
        if (taskThing.resources) {
          for (let resourceId of taskThing.resources) {
            if (removedResourceIds.includes(resourceId)) {
              nowBlocked.push(taskThing);
              return true;
            }
          }
        }
        return false;
      });
      for (let taskThing of nowBlocked) {
        this.ownOrRelayTaskThing(taskThing);
      }
    },
    _clearResourceTimeouts(resourceId) {
      if (this._resourceTimeouts.has(resourceId)) {
        clearTimeout(this._resourceTimeouts.get(resourceId));
        this._resourceTimeouts.delete(resourceId);
      }
    },
    restoreResourceAfterTimeout(resourceId, timeoutMillis) {
      this._clearResourceTimeouts();
      let timeoutId = setTimeout(() => {
        this.resourceAvailable(resourceId);
      }, timeoutMillis);
      this._resourceTimeouts.set(resourceId, timeoutId);
    },
    whatIsTaskBlockedBy(taskId) {
      const taskThing = this._blockedTasksById.get(taskId);
      if (!taskThing) {
        return null;
      }
      const blockedBy = [];
      for (let resource of taskThing.resources) {
        if (!this._availableResources.has(resource)) {
          blockedBy.push(resource);
        }
      }
      return blockedBy;
    },
    ownOrRelayTaskThing(taskThing) {
      if (this._blockedTasksById.has(taskThing.id)) {
        this.removeTaskThing(taskThing.id);
      }
      if (taskThing.resources) {
        for (let resourceId of taskThing.resources) {
          if (!this._availableResources.has(resourceId)) {
            this._priorities.removeTaskThing(taskThing.id);
            logic(this, "taskBlockedOnResource", {
              taskId: taskThing.id,
              resourceId
            });
            this._blockedTasksById.set(taskThing.id, taskThing);
            if (this._blockedTasksByResource.has(resourceId)) {
              this._blockedTasksByResource.get(resourceId).push(taskThing);
            } else {
              this._blockedTasksByResource.set(resourceId, [taskThing]);
            }
            return false;
          }
        }
      }
      this._priorities.prioritizeTaskThing(taskThing);
      return true;
    },
    removeTaskThing(taskId) {
      if (!this._blockedTasksById.has(taskId)) {
        this._priorities.removeTaskThing(taskId);
        return;
      }
      let taskThing = this._blockedTasksById.get(taskId);
      this._blockedTasksById.delete(taskId);
      for (let [resourceId, blockedThings] of this._blockedTasksByResource) {
        let idx = blockedThings.indexOf(taskThing);
        if (idx === -1) {
          continue;
        }
        blockedThings.splice(idx, 1);
        if (blockedThings.length === 0) {
          this._blockedTasksByResource.delete(resourceId);
        }
        break;
      }
    }
  };

  // src/backend/task_infra/task_group_tracker.js
  init_logic();
  function TaskGroupTracker(taskManager) {
    logic.defineScope(this, "TaskGroupTracker");
    this.taskManager = taskManager;
    this._nextGroupId = 1;
    this._groupsByName = new Map();
    this._taskIdsToGroups = new Map();
    this._pendingTaskIdReuses = new Set();
    this.__registerListeners(taskManager);
  }
  TaskGroupTracker.prototype = {
    __registerListeners(emitter) {
      emitter.on("willPlan", this, this._onWillPlan);
      emitter.on("willExecute", this, this._onWillExecute);
      emitter.on("planned", this, this._onPlanned);
      emitter.on("executed", this, this._onExecuted);
    },
    _ensureNamedTaskGroup(groupName, taskId) {
      let group = this._groupsByName.get(groupName);
      if (!group) {
        group = this._makeTaskGroup(groupName);
        logic(this, "createGroup", { groupName, taskId });
      } else {
        logic(this, "reuseGroup", { groupName, taskId });
      }
      let existingOwningGroup = this._taskIdsToGroups.get(taskId) || null;
      if (existingOwningGroup !== group) {
        group.parentGroup = existingOwningGroup;
      }
      group.pendingCount++;
      group.totalCount++;
      this._taskIdsToGroups.set(taskId, group);
      return group;
    },
    ensureNamedTaskGroup(groupName, taskId) {
      let group = this._ensureNamedTaskGroup(groupName, taskId);
      return group.promise;
    },
    getRootTaskGroupForTask(taskId) {
      let taskGroup = this._taskIdsToGroups.get(taskId);
      if (!taskGroup) {
        return taskGroup;
      }
      while (taskGroup.parentGroup !== null) {
        taskGroup = taskGroup.parentGroup;
      }
      return taskGroup;
    },
    ensureRootTaskGroupFollowOnTask(taskId, taskToPlan) {
      let rootTaskGroup = this.getRootTaskGroupForTask(taskId);
      if (!rootTaskGroup) {
        rootTaskGroup = this._ensureNamedTaskGroup("ensured:" + this._nextGroupId, taskId);
      }
      if (!rootTaskGroup.tasksToScheduleOnCompletion) {
        rootTaskGroup.tasksToScheduleOnCompletion = new Set();
      }
      rootTaskGroup.tasksToScheduleOnCompletion.add(taskToPlan);
    },
    _makeTaskGroup(groupName) {
      let group = {
        groupName,
        groupId: this._nextGroupId++,
        pendingCount: 0,
        totalCount: 0,
        parentGroup: null,
        promise: null,
        resolve: null,
        tasksToScheduleOnCompletion: null
      };
      group.promise = new Promise((resolve) => {
        group.resolve = resolve;
      });
      this._groupsByName.set(groupName, group);
      return group;
    },
    _onWillPlan(taskThing, sourceId) {
      if (!sourceId) {
        return;
      }
      let sourceGroup = this._taskIdsToGroups.get(sourceId);
      if (sourceGroup) {
        sourceGroup.pendingCount++;
        sourceGroup.totalCount++;
        this._taskIdsToGroups.set(taskThing.id, sourceGroup);
      }
    },
    _onWillExecute(taskThing, sourceId) {
      if (!sourceId) {
        return;
      }
      let sourceGroup = this._taskIdsToGroups.get(sourceId);
      if (sourceGroup) {
        if (sourceId === taskThing.id) {
          this._pendingTaskIdReuses.add(sourceId);
        } else {
          sourceGroup.pendingCount++;
        }
        sourceGroup.totalCount++;
        this._taskIdsToGroups.set(taskThing.id, sourceGroup);
      }
    },
    _decrementGroupPendingCount(group) {
      if (--group.pendingCount === 0) {
        logic(this, "resolveGroup", {
          groupName: group.groupName,
          totalCount: group.totalCount
        });
        group.resolve();
        this._groupsByName.delete(group.groupName);
        if (group.tasksToScheduleOnCompletion) {
          this.taskManager.scheduleTasks(Array.from(group.tasksToScheduleOnCompletion), "deferred-group:" + group.groupName);
        }
        if (group.parentGroup) {
          this._decrementGroupPendingCount(group.parentGroup);
        }
      }
    },
    _onPlanned(taskId) {
      if (this._pendingTaskIdReuses.has(taskId)) {
        this._pendingTaskIdReuses.delete(taskId);
        return;
      }
      let group = this._taskIdsToGroups.get(taskId);
      if (group) {
        this._taskIdsToGroups.delete(taskId);
        this._decrementGroupPendingCount(group);
      }
    },
    _onExecuted(taskId) {
      let group = this._taskIdsToGroups.get(taskId);
      if (group) {
        this._taskIdsToGroups.delete(taskId);
        this._decrementGroupPendingCount(group);
      }
    }
  };

  // src/backend/search/query_manager.js
  init_logic();

  // src/backend/search/query/direct_folder_conv_query.js
  function DirectFolderConversationsQuery({ db, folderId }) {
    this._db = db;
    this.folderId = folderId;
    this._eventId = null;
    this._drainEvents = null;
    this._boundListener = null;
  }
  DirectFolderConversationsQuery.prototype = {
    async execute() {
      let idsWithDates;
      ({
        idsWithDates,
        drainEvents: this._drainEvents,
        eventId: this._eventId
      } = await this._db.loadFolderConversationIdsAndListen(this.folderId));
      return idsWithDates;
    },
    bind(listenerObj, listenerMethod) {
      let boundListener = this._boundListener = listenerMethod.bind(listenerObj);
      this._db.on(this._eventId, boundListener);
      this._drainEvents(boundListener);
      this._drainEvents = null;
    },
    destroy() {
      this._db.removeListener(this._eventId, this._boundListener);
    }
  };

  // src/backend/search/filtering_stream.js
  init_logic();
  var import_streams = __toModule(require_streams());
  init_util();
  function FilteringStream({
    ctx,
    filterRunner,
    rootGatherer,
    preDerivers,
    postDerivers,
    isDeletion,
    inputToGatherInto,
    mutateChangeToResembleAdd,
    mutateChangeToResembleDeletion,
    onFilteredUpdate
  }) {
    const queuedSet = new Set();
    const knownFilteredSet = new Set();
    const notifyAdded = (deriverList, gathered) => {
      for (let deriver of deriverList) {
        deriver.itemAdded(gathered);
      }
    };
    const notifyRemoved = (deriverList, id) => {
      for (let deriver of deriverList) {
        deriver.itemRemoved(id);
      }
    };
    const gatherStream = new import_streams.TransformStream({
      flush(enqueue, close) {
        close();
      },
      transform(change, enqueue, done) {
        if (isDeletion(change)) {
          enqueue({ change, gather: null });
        } else if (queuedSet.has(change.id)) {
          logic(ctx, "gathering", { id: change.id });
          let gatherInto = inputToGatherInto(change);
          enqueue({ change, gather: rootGatherer.gather(gatherInto) });
        }
        done();
      },
      writableStrategy: new import_streams.CountQueuingStrategy({ highWaterMark: 1 }),
      readableStrategy: new import_streams.CountQueuingStrategy({ highWaterMark: 1 })
    });
    const filterStream = new import_streams.TransformStream({
      flush(enqueue, close) {
        close();
      },
      transform({ change, gather }, enqueue, done) {
        if (!gather) {
          enqueue(change);
          notifyRemoved(preDerivers, change.id);
          if (knownFilteredSet.delete(change.id)) {
            notifyRemoved(postDerivers, change.id);
          }
          done();
        } else {
          logic(ctx, "gatherWait", { id: change.id });
          gather.then((gathered) => {
            logic(ctx, "gathered", { id: change.id });
            if (!queuedSet.has(change.id)) {
              logic(ctx, "notInQueuedSet");
              done();
              return;
            }
            queuedSet.delete(change.id);
            notifyAdded(preDerivers, gathered);
            let matchInfo = filterRunner.filter(gathered);
            logic(ctx, "maybeMatch", { matched: !!matchInfo });
            if (matchInfo) {
              change = shallowClone2(change);
              if (!knownFilteredSet.has(change.id)) {
                mutateChangeToResembleAdd(change);
                knownFilteredSet.add(change.id);
                notifyAdded(postDerivers, gathered);
              }
              change.matchInfo = matchInfo;
              enqueue(change);
            } else if (knownFilteredSet.delete(change.id)) {
              change = shallowClone2(change);
              mutateChangeToResembleDeletion(change);
              enqueue(change);
              notifyRemoved(postDerivers, change.id);
            }
            done();
          });
        }
      },
      writableStrategy: new import_streams.CountQueuingStrategy({ highWaterMark: 1 }),
      readableStrategy: new import_streams.CountQueuingStrategy({ highWaterMark: 1 })
    });
    gatherStream.readable.pipeThrough(filterStream).pipeTo(new import_streams.WritableStream({
      start() {
      },
      write(change) {
        onFilteredUpdate(change);
      },
      close() {
      },
      abort(ex) {
        logic(ctx, "filteringStreamAbortError", { ex, stack: ex.stack });
      }
    }, new import_streams.CountQueuingStrategy({ highWaterMark: 1 })));
    return {
      consider: (change) => {
        if (!isDeletion(change)) {
          queuedSet.add(change.id);
          gatherStream.writable.write(change);
        } else {
          queuedSet.delete(change.id);
          if (knownFilteredSet.has(change.id)) {
            gatherStream.writable.write(change);
          } else {
            notifyRemoved(preDerivers, change.id);
          }
        }
      },
      destroy: () => {
        gatherStream.writable.close();
      }
    };
  }

  // src/backend/search/query/filtering_folder_query.js
  function FilteringFolderQuery({
    ctx,
    db,
    folderId,
    filterRunner,
    rootGatherer,
    preDerivers,
    postDerivers
  }) {
    this._db = db;
    this.folderId = folderId;
    this._eventId = null;
    this._drainEvents = null;
    this._boundListener = null;
    this._filteringStream = new FilteringStream({
      ctx,
      filterRunner,
      rootGatherer,
      preDerivers,
      postDerivers,
      isDeletion: (change) => {
        return !change.addDate;
      },
      inputToGatherInto: (change) => {
        return {
          convId: change.id
        };
      },
      mutateChangeToResembleAdd: (change) => {
        change.removeDate = null;
      },
      mutateChangeToResembleDeletion: (change) => {
        change.item = null;
        change.addDate = null;
        change.height = 0;
      },
      onFilteredUpdate: (change) => {
        this._boundListener(change);
      }
    });
    this._bound_filteringTOCChange = this._filteringTOCChange.bind(this);
  }
  FilteringFolderQuery.prototype = {
    async execute() {
      let idsWithDates;
      ({
        idsWithDates,
        drainEvents: this._drainEvents,
        eventId: this._eventId
      } = await this._db.loadFolderConversationIdsAndListen(this.folderId));
      for (let idWithDate of idsWithDates) {
        this._filteringStream.consider({
          id: idWithDate.id,
          item: null,
          removeDate: null,
          addDate: idWithDate.date,
          height: idWithDate.height,
          oldHeight: 0,
          matchInfo: null
        });
      }
      return [];
    },
    bind(listenerObj, listenerMethod) {
      this._boundListener = listenerMethod.bind(listenerObj);
      this._db.on(this._eventId, this._bound_filteringTOCChange);
      this._drainEvents(this._bound_filteringTOCChange);
      this._drainEvents = null;
    },
    _filteringTOCChange(change) {
      this._filteringStream.consider(change);
    },
    destroy() {
      this._db.removeListener(this._eventId, this._bound_filteringTOCChange);
      this._filteringStream.destroy();
    }
  };

  // src/backend/search/query/direct_folder_messages_query.js
  function DirectFolderMessagesQuery({ db, folderId }) {
    this._db = db;
    this.folderId = folderId;
    this._eventId = null;
    this._drainEvents = null;
    this._boundListener = null;
  }
  DirectFolderMessagesQuery.prototype = {
    async execute() {
      let idsWithDates;
      ({
        idsWithDates,
        drainEvents: this._drainEvents,
        eventId: this._eventId
      } = await this._db.loadFolderMessageIdsAndListen(this.folderId));
      return idsWithDates;
    },
    bind(listenerObj, listenerMethod) {
      let boundListener = this._boundListener = listenerMethod.bind(listenerObj);
      this._db.on(this._eventId, boundListener);
      this._drainEvents(boundListener);
      this._drainEvents = null;
    },
    destroy() {
      this._db.removeListener(this._eventId, this._boundListener);
    }
  };

  // src/backend/search/query/direct_conv_messages_query.js
  function DirectConversationMessagesQuery({
    db,
    conversationId
  }) {
    this._db = db;
    this.conversationId = conversationId;
    this._tocEventId = null;
    this._convEventId = null;
    this._drainEvents = null;
    this._boundTOCListener = null;
    this._boundConvListener = null;
  }
  DirectConversationMessagesQuery.prototype = {
    async execute() {
      let idsWithDates;
      ({
        idsWithDates,
        drainEvents: this._drainEvents,
        tocEventId: this._tocEventId,
        convEventId: this._convEventId
      } = await this._db.loadConversationMessageIdsAndListen(this.conversationId));
      return idsWithDates;
    },
    bind(listenerObj, tocListenerMethod, convListenerMethod) {
      this._boundTOCListener = tocListenerMethod.bind(listenerObj);
      this._boundConvListener = convListenerMethod.bind(listenerObj);
      this._db.on(this._tocEventId, this._boundTOCListener);
      this._db.on(this._convEventId, this._boundConvListener);
      this._drainEvents(this._boundTOCListener);
      this._drainEvents = null;
    },
    destroy() {
      this._db.removeListener(this._tocEventId, this._boundTOCListener);
      this._db.removeListener(this._convEventId, this._boundConvListener);
    }
  };

  // src/backend/search/query/filtering_conv_query.js
  function FilteringConversationMessagesQuery({
    ctx,
    db,
    conversationId,
    filterRunner,
    rootGatherer
  }) {
    this._db = db;
    this.conversationId = conversationId;
    this._tocEventId = null;
    this._convEventId = null;
    this._drainEvents = null;
    this._boundTOCListener = null;
    this._boundConvListener = null;
    this._filteringStream = new FilteringStream({
      ctx,
      filterRunner,
      rootGatherer,
      isDeletion: (change) => {
        return !change.postDate;
      },
      inputToGatherInto: (change) => {
        return {
          messageId: change.id,
          date: change.postDate
        };
      },
      mutateChangeToResembleAdd: (change) => {
        change.preDate = null;
        change.freshlyAdded = true;
      },
      mutateChangeToResembleDeletion: (change) => {
        change.item = null;
        change.postDate = null;
      },
      onFilteredUpdate: (change) => {
        this._boundTOCListener(change);
      }
    });
    this._bound_filteringTOCChange = this._filteringTOCChange.bind(this);
  }
  FilteringConversationMessagesQuery.prototype = {
    async execute() {
      let idsWithDates;
      ({
        idsWithDates,
        drainEvents: this._drainEvents,
        tocEventId: this._tocEventId,
        convEventId: this._convEventId
      } = await this._db.loadConversationMessageIdsAndListen(this.conversationId));
      for (let idWithDate of idsWithDates) {
        this._filteringStream.consider({
          id: idWithDate.id,
          preDate: null,
          postDate: idWithDate.date,
          item: null,
          freshlyAdded: true,
          matchInfo: null
        });
      }
      return [];
    },
    bind(listenerObj, tocListenerMethod, convListenerMethod) {
      this._boundTOCListener = tocListenerMethod.bind(listenerObj);
      this._boundConvListener = convListenerMethod.bind(listenerObj);
      this._db.on(this._tocEventId, this._bound_filteringTOCChange);
      this._db.on(this._convEventId, this._boundConvListener);
      this._drainEvents(this._boundTOCListener);
      this._drainEvents = null;
    },
    _filteringTOCChange(change) {
      this._filteringStream.consider(change);
    },
    destroy() {
      this._db.removeListener(this._tocEventId, this._bound_filteringTOCChange);
      this._db.removeListener(this._convEventId, this._boundConvListener);
      this._filteringStream.destroy();
    }
  };

  // src/backend/search/filter_runner.js
  function FilterRunner({ filters }) {
    this.filters = filters.concat();
    this.filters.sort((a, b) => {
      return a.cost - b.cost;
    });
  }
  FilterRunner.prototype = {
    filter(gathered) {
      let matchInfo = {};
      let matched = this.filters.length === 0;
      for (let filter of this.filters) {
        let matchDetails = null;
        if (!matched || filter.alwaysRun) {
          matchDetails = filter.test(gathered);
          if (matchDetails) {
            matched = true;
          }
        }
        matchInfo[filter.resultKey] = matchDetails;
      }
      if (matched) {
        return matchInfo;
      }
      return null;
    }
  };

  // src/backend/search/nested_gatherer.js
  function NestedGatherer(rootKey, rootGatherer) {
    this.rootKey = rootKey;
    this.rootGatherer = rootGatherer;
    this.gatherers = new Map();
  }
  NestedGatherer.prototype = {
    nested: true,
    hasGatherer(key) {
      return this.gatherers.has(key) || key === this.rootKey;
    },
    getGatherer(key) {
      return this.gatherers.get(key);
    },
    addGatherer(key, gatherer) {
      this.gatherers.set(key, gatherer);
    },
    makeNestedGatherer(key, rootKey, rootGatherer) {
      let nestedGatherer = new NestedGatherer(rootKey, rootGatherer);
      this.gatherers.set(key, nestedGatherer);
      return nestedGatherer;
    },
    _gatherChildren(gatherInto) {
      let allPromises = [];
      for (let [ukey, ugatherer] of this.gatherers.entries()) {
        let key = ukey;
        let gatherer = ugatherer;
        if (gatherInto[key] && !gatherer.nested) {
          continue;
        }
        let promise = gatherer.gather(gatherInto);
        allPromises.push(promise.then((value) => {
          gatherInto[key] = value;
        }));
      }
      return Promise.all(allPromises).then(() => {
        return gatherInto;
      });
    },
    gather(gathered) {
      if (this.rootGatherer) {
        let rootGather;
        if (gathered[this.rootKey]) {
          rootGather = Promise.resolve(gathered[this.rootKey]);
        } else {
          rootGather = this.rootGatherer.gather(gathered);
        }
        return rootGather.then((rootResult) => {
          if (this.rootGatherer.plural) {
            let childPromises = [];
            let pluralGathers = rootResult.map((item) => {
              let childGather = {
                [this.rootKey]: item
              };
              childPromises.push(this._gatherChildren(childGather));
              return childGather;
            });
            return Promise.all(childPromises).then(() => {
              return pluralGathers;
            });
          }
          let subGather = {
            [this.rootKey]: rootResult
          };
          return this._gatherChildren(subGather);
        });
      }
      return this._gatherChildren(gathered);
    }
  };

  // src/backend/search/msg_filters.js
  init_syncbase();

  // src/backend/search/filters/search_pattern_from_args.js
  function regExpEscape(str) {
    return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function searchPatternFromArgs(args, opts) {
    let phrase;
    if (!opts) {
      opts = {};
    }
    if (typeof args === "string" || args instanceof RegExp) {
      phrase = args;
    } else if (args && args.phrase) {
      phrase = args.phrase;
    } else {
      throw new Error("unable to figure out a search pattern from the args");
    }
    if (typeof phrase === "string") {
      let pattern = regExpEscape(phrase);
      if (opts.exact) {
        pattern = "^" + pattern + "$";
      }
      return new RegExp(pattern, "i");
    }
    return phrase;
  }

  // src/backend/search/match_regexp_or_string.js
  function matchRegexpOrString(phrase, input, fromIndex) {
    if (!input) {
      return null;
    }
    if (phrase instanceof RegExp) {
      return phrase.exec(fromIndex ? input.slice(fromIndex) : input);
    }
    var idx = input.indexOf(phrase, fromIndex);
    if (idx === -1) {
      return null;
    }
    var ret = [phrase];
    ret.index = idx - fromIndex;
    return ret;
  }

  // src/backend/search/match_verbatim_highlight.js
  function matchVerbatimHighlight(searchPattern, value, path) {
    var match = matchRegexpOrString(searchPattern, value, 0);
    if (!match) {
      return null;
    }
    return {
      text: value,
      offset: 0,
      matchRuns: [{ start: match.index, length: match[0].length }],
      path: path || null
    };
  }

  // src/backend/search/filters/message/author_filter.js
  function AuthorFilter(params, args) {
    this.searchPattern = searchPatternFromArgs(args);
  }
  AuthorFilter.prototype = {
    gather: {},
    cost: 10,
    alwaysRun: true,
    test(gathered) {
      let searchPattern = this.searchPattern;
      function checkList(addressPairs) {
        if (!addressPairs) {
          return null;
        }
        for (let addressPair of addressPairs) {
          if (addressPair.name) {
            let matchInfo2 = matchVerbatimHighlight(searchPattern, addressPair.name);
            if (matchInfo2) {
              return matchInfo2;
            }
          }
          let matchInfo = matchVerbatimHighlight(searchPattern, addressPair.address);
          if (matchInfo) {
            return matchInfo;
          }
        }
        return null;
      }
      let message = gathered.message;
      return checkList([message.author]) || checkList(message.replyTo);
    }
  };

  // src/backend/search/filters/message/author_address_filter.js
  function AuthorAddressFilter(params, args) {
    this.searchPattern = searchPatternFromArgs(args, { exact: true });
  }
  AuthorAddressFilter.prototype = {
    gather: {},
    cost: 10,
    alwaysRun: true,
    test(gathered) {
      let searchPattern = this.searchPattern;
      function checkList(addressPairs) {
        if (!addressPairs) {
          return null;
        }
        for (let addressPair of addressPairs) {
          let matchInfo = matchVerbatimHighlight(searchPattern, addressPair.address);
          if (matchInfo) {
            return matchInfo;
          }
        }
        return null;
      }
      let message = gathered.message;
      return checkList([message.author]) || checkList(message.replyTo);
    }
  };

  // src/backend/search/filters/message/recipients_filter.js
  function RecipientsFilter(params, args) {
    this.searchPattern = searchPatternFromArgs(args);
  }
  RecipientsFilter.prototype = {
    gather: {},
    cost: 20,
    alwaysRun: true,
    test(gathered) {
      let searchPattern = this.searchPattern;
      function checkList(recipients) {
        if (!recipients) {
          return null;
        }
        for (let recipient of recipients) {
          if (recipient.name) {
            let matchInfo2 = matchVerbatimHighlight(searchPattern, recipient.name);
            if (matchInfo2) {
              return matchInfo2;
            }
          }
          let matchInfo = matchVerbatimHighlight(searchPattern, recipient.address);
          if (matchInfo) {
            return matchInfo;
          }
        }
        return null;
      }
      let message = gathered.message;
      return checkList(message.to) || checkList(message.cc) || checkList(message.bcc);
    }
  };

  // src/backend/search/match_excerpt_highlight.js
  function matchExcerptHighlight(searchPattern, value, path, excerptSettings) {
    var match = matchRegexpOrString(searchPattern, value, 0);
    if (!match) {
      return null;
    }
    let {
      charsBefore: contextBefore,
      charsAfter: contextAfter
    } = excerptSettings;
    let start = match.index;
    let length = match[0].length;
    if (contextBefore > start) {
      contextBefore = start;
    }
    let offset = value.indexOf(" ", start - contextBefore);
    if (offset === -1 || offset >= start - 1) {
      offset = start - contextBefore;
    } else {
      offset++;
    }
    var endIdx;
    if (start + length + contextAfter >= value.length) {
      endIdx = value.length;
    } else {
      endIdx = value.lastIndexOf(" ", start + length + contextAfter - 1);
      if (endIdx <= start + length) {
        endIdx = start + length + contextAfter;
      }
    }
    var snippet = value.substring(offset, endIdx);
    return {
      text: snippet,
      offset,
      matchRuns: [{ start: start - offset, length }],
      path
    };
  }

  // src/backend/search/filters/message/subject_filter.js
  function SubjectFilter(params, args) {
    this.excerptSettings = params.excerptSettings;
    this.searchPattern = searchPatternFromArgs(args);
  }
  SubjectFilter.prototype = {
    gather: {},
    cost: 10,
    alwaysRun: true,
    test(gathered) {
      return matchExcerptHighlight(this.searchPattern, gathered.message.subject, null, this.excerptSettings);
    }
  };

  // src/backend/search/filters/message/body_filter.js
  var CT_AUTHORED_CONTENT2 = 1;
  function BodyFilter(params, args) {
    this.includeQuotes = params.includeQuotes;
    this.excerptSettings = params.excerptSettings;
    this.searchPattern = searchPatternFromArgs(args);
    this.gather = {
      bodyContents: { includeQuotes: this.includeQuotes }
    };
  }
  BodyFilter.prototype = {
    cost: 100,
    alwaysRun: true,
    test(gathered) {
      let { searchPattern, excerptSettings, includeQuotes } = this;
      for (let bodyContent of gathered.bodyContents) {
        if (bodyContent.type === "html") {
          let match = matchExcerptHighlight(searchPattern, bodyContent.textBody, null, excerptSettings);
          if (match) {
            return match;
          }
        } else if (bodyContent.type === "plain") {
          let bodyRep = bodyContent.rep;
          for (var iRep = 0; iRep < bodyRep.length; iRep += 2) {
            var etype = bodyRep[iRep] & 15, block = bodyRep[iRep + 1];
            if (!includeQuotes && etype !== CT_AUTHORED_CONTENT2) {
              continue;
            }
            let match = matchExcerptHighlight(searchPattern, block, null, excerptSettings);
            if (match) {
              return match;
            }
          }
        }
      }
      return null;
    }
  };

  // src/backend/search/msg_filters.js
  var msg_filters_default = {
    author: {
      constructor: AuthorFilter,
      params: null
    },
    authorAddress: {
      constructor: AuthorAddressFilter,
      params: null
    },
    recipients: {
      constructor: RecipientsFilter,
      params: null
    },
    subject: {
      constructor: SubjectFilter,
      params: {
        excerptSettings: DEFAULT_SEARCH_EXCERPT_SETTINGS
      }
    },
    body: {
      constructor: BodyFilter,
      params: {
        excerptSettings: DEFAULT_SEARCH_EXCERPT_SETTINGS,
        includeQuotes: false
      }
    },
    bodyAndQuotes: {
      constructor: BodyFilter,
      params: {
        excerptSettings: DEFAULT_SEARCH_EXCERPT_SETTINGS,
        includeQuotes: true
      }
    }
  };

  // src/backend/search/filters/conversation/participants_filter.js
  function ParticipantsFilter(params, args) {
    this.searchPattern = searchPatternFromArgs(args);
  }
  ParticipantsFilter.prototype = {
    gather: {
      conversation: true
    },
    cost: 10,
    alwaysRun: true,
    test(gathered) {
      let searchPattern = this.searchPattern;
      for (let author of gathered.conversation.authors) {
        if (author.name) {
          let matchInfo2 = matchVerbatimHighlight(searchPattern, author.name);
          if (matchInfo2) {
            return matchInfo2;
          }
        }
        let matchInfo = matchVerbatimHighlight(searchPattern, author.address);
        if (matchInfo) {
          return matchInfo;
        }
      }
      return null;
    }
  };

  // src/backend/search/filters/conversation/message_spread_filter.js
  function MessageSpreadFilter({ wrappedFilterDef }, args) {
    this.wrappedFilter = new wrappedFilterDef.constructor(wrappedFilterDef.params, args);
    this.gather = {
      messages: this.wrappedFilter.gather
    };
    this.cost = this.wrappedFilter.cost * 20;
    this.alwaysRun = this.wrappedFilter.alwaysRun;
  }
  MessageSpreadFilter.prototype = {
    test(gathered) {
      let wrappedFilter = this.wrappedFilter;
      for (let messageContext of gathered.messages) {
        let matchInfo = wrappedFilter.test(messageContext);
        if (matchInfo) {
          return matchInfo;
        }
      }
      return null;
    }
  };

  // src/backend/search/conv_filters.js
  var convFilters = {
    participants: {
      constructor: ParticipantsFilter,
      params: null
    }
  };
  for (let key of Object.keys(msg_filters_default)) {
    let msgFilterDef = msg_filters_default[key];
    convFilters[key] = {
      constructor: MessageSpreadFilter,
      params: { wrappedFilterDef: msgFilterDef }
    };
  }
  var conv_filters_default = convFilters;

  // src/backend/search/gatherers/conv.js
  function GatherConversation({ db, ctx }) {
    this._db = db;
    this._ctx = ctx;
  }
  GatherConversation.prototype = {
    gather(gathered) {
      return this._db.read(this._ctx, {
        conversations: new Map([[gathered.convId, null]])
      }).then(({ conversations }) => {
        return conversations.get(gathered.convId);
      });
    }
  };

  // src/backend/search/gatherers/conv_messages.js
  function GatherConversationMessages({ db, ctx }) {
    this._db = db;
    this._ctx = ctx;
  }
  GatherConversationMessages.prototype = {
    plural: true,
    gather(gathered) {
      return this._db.read(this._ctx, {
        messagesByConversation: new Map([[gathered.convId, null]])
      }).then(({ messagesByConversation }) => {
        return messagesByConversation.get(gathered.convId);
      });
    }
  };

  // src/backend/search/gatherers/message.js
  function GatherMessage({ db, ctx }) {
    this._db = db;
    this._ctx = ctx;
  }
  GatherMessage.prototype = {
    plural: false,
    gather(gathered) {
      let messageKey = [gathered.messageId, gathered.date];
      return this._db.read(this._ctx, {
        messages: new Map([[messageKey, null]])
      }).then(({ messages }) => {
        return messages.get(gathered.messageId);
      });
    }
  };

  // src/backend/search/gatherers/message/message_bodies.js
  init_htmlchew();
  function GatherMessageBodies(ignoredParams, args) {
    this.includeQuotes = args ? args.includeQuotes || false : false;
  }
  GatherMessageBodies.prototype = {
    async gather(gathered) {
      let message = gathered.message;
      let bodyPromises = message.bodyReps.map((part) => {
        if (!part.contentBlob) {
          return null;
        }
        return part.contentBlob.text();
      });
      let fetchedBodies = await Promise.all(bodyPromises);
      let bodyResults = [];
      for (let i = 0; i < message.bodyReps.length; i++) {
        let bodyObj = fetchedBodies[i];
        if (!bodyObj) {
          continue;
        }
        let bodyRep = message.bodyReps[i];
        if (bodyRep.type === "html") {
          bodyResults.push({
            type: bodyRep.type,
            textBody: generateSearchableTextVersion(bodyObj, this.includeQuotes)
          });
        } else {
          bodyResults.push({
            type: bodyRep.type,
            rep: JSON.parse(bodyObj)
          });
        }
      }
      return bodyResults;
    }
  };

  // src/backend/search/gatherers/message/author_domain.js
  var RE_DOMAIN = /@(.+)$/;
  function AuthorDomain() {
  }
  AuthorDomain.prototype = {
    gather(gathered) {
      const { message } = gathered;
      const address = message.replyTo ? message.replyTo[0].address : message.author.address;
      const match = RE_DOMAIN.exec(address);
      return Promise.resolve(match && match[1].toLowerCase());
    }
  };

  // src/backend/search/gatherers/message/days_ago.js
  init_date();
  function DaysAgo() {
    let dateScratch = new Date(NOW());
    dateScratch.setHours(0, 0, 0, 0);
    this.tomorrowMidnight = dateScratch.valueOf() + DAY_MILLIS;
  }
  DaysAgo.prototype = {
    gather(gathered) {
      const { message } = gathered;
      let daysAgo = Math.floor((this.tomorrowMidnight - message.date) / DAY_MILLIS);
      if (daysAgo < 0) {
        daysAgo = 0;
      }
      return Promise.resolve(daysAgo);
    }
  };

  // src/backend/search/msg_gatherers.js
  var msg_gatherers_default = {
    message: {
      constructor: GatherMessage,
      params: null,
      nested: null
    },
    bodyContents: {
      constructor: GatherMessageBodies,
      params: null,
      nested: null
    },
    authorDomain: {
      constructor: AuthorDomain,
      params: null,
      nested: null
    },
    daysAgo: {
      constructor: DaysAgo,
      params: null,
      nested: null
    }
  };

  // src/backend/search/conv_gatherers.js
  var conv_gatherers_default = {
    conversation: {
      constructor: GatherConversation,
      params: null,
      nested: null
    },
    messages: {
      constructor: GatherConversationMessages,
      params: null,
      nestedRootKey: "message",
      nested: msg_gatherers_default
    }
  };

  // src/backend/search/query_manager.js
  function QueryManager({ db, derivedViewManager }) {
    logic.defineScope(this, "QueryManager");
    this._db = db;
    this._derivedViewManager = derivedViewManager;
  }
  QueryManager.prototype = {
    _buildFilters(filterSpec, filterers) {
      let filters = [];
      if (filterSpec) {
        for (let key of Object.keys(filterSpec)) {
          let filterDef = filterers[key];
          if (filterDef) {
            let filter = new filterDef.constructor(filterDef.params, filterSpec[key]);
            filter.resultKey = key;
            filters.push(filter);
          }
        }
      }
      return filters;
    },
    _buildGatherHierarchy({ consumers, rootGatherDefs, dbCtx, bootstrapKey }) {
      let traverse = (curGatherer, reqObj, gatherDefs) => {
        for (let key of Object.keys(reqObj)) {
          let gatherDef = gatherDefs[key];
          if (!gatherDef.nested) {
            if (!curGatherer.hasGatherer(key)) {
              curGatherer.addGatherer(key, new gatherDef.constructor(dbCtx, gatherDef.params));
            }
          } else {
            let childGatherer;
            if (!curGatherer.hasGatherer(key)) {
              childGatherer = curGatherer.makeNestedGatherer(key, gatherDef.nestedRootKey, new gatherDef.constructor(dbCtx, gatherDef.params));
            } else {
              childGatherer = curGatherer.getGatherer(key);
            }
            traverse(childGatherer, reqObj[key], gatherDef.nested);
          }
        }
      };
      let bootstrapGatherer = null;
      if (bootstrapKey) {
        let bootstrapDef = rootGatherDefs[bootstrapKey];
        bootstrapGatherer = new bootstrapDef.constructor(dbCtx, bootstrapDef.params);
      }
      let rootGatherer = new NestedGatherer(bootstrapKey, bootstrapGatherer);
      for (let consumer of consumers) {
        traverse(rootGatherer, consumer.gather, rootGatherDefs);
      }
      return rootGatherer;
    },
    _buildDerivedViews(viewDefsWithContexts) {
      if (!viewDefsWithContexts) {
        return [];
      }
      const derivedViews = viewDefsWithContexts.map((viewDefWithContext) => {
        return this._derivedViewManager.createDerivedView(viewDefWithContext);
      });
      return derivedViews;
    },
    queryConversations(ctx, spec) {
      if (spec.folderId && !spec.filter) {
        return new DirectFolderConversationsQuery({
          db: this._db,
          folderId: spec.folderId
        });
      }
      const filters = this._buildFilters(spec.filter, conv_filters_default);
      const dbCtx = {
        db: this._db,
        ctx
      };
      const preDerivers = this._buildDerivedViews(spec.viewDefsWithContexts);
      const postDerivers = [];
      const rootGatherer = this._buildGatherHierarchy({
        consumers: [].concat(filters, preDerivers, postDerivers),
        rootGatherDefs: conv_gatherers_default,
        dbCtx
      });
      return new FilteringFolderQuery({
        ctx,
        db: this._db,
        folderId: spec.folderId,
        filterRunner: new FilterRunner({ filters }),
        rootGatherer,
        preDerivers,
        postDerivers
      });
    },
    queryMessages(ctx, spec) {
      if (spec.folderId && !spec.filter) {
        return new DirectFolderMessagesQuery({
          db: this._db,
          folderId: spec.folderId
        });
      }
      throw new Error("No messages filtering yet!");
    },
    queryConversationMessages(ctx, spec) {
      if (spec.conversationId && !spec.filter) {
        return new DirectConversationMessagesQuery({
          db: this._db,
          conversationId: spec.conversationId
        });
      }
      let filters = this._buildFilters(spec.filter, msg_filters_default);
      let dbCtx = {
        db: this._db,
        ctx
      };
      let rootGatherer = this._buildGatherHierarchy({
        consumers: filters,
        rootGatherDefs: msg_gatherers_default,
        bootstrapKey: "message",
        dbCtx
      });
      return new FilteringConversationMessagesQuery({
        ctx,
        db: this._db,
        conversationId: spec.conversationId,
        filterRunner: new FilterRunner({ filters }),
        rootGatherer
      });
    }
  };

  // src/backend/db/trigger_manager.js
  init_logic();
  function TriggerContext(triggerManager, triggerName) {
    this._triggerManager = triggerManager;
    this.name = triggerName;
  }
  TriggerContext.prototype = {
    get rootTaskGroupId() {
      return this._triggerManager.sourceTaskContext.rootTaskGroupId;
    },
    modify(dict) {
      return this._triggerManager.__triggerMutate(this.name, dict);
    }
  };
  function TriggerManager({ db, triggers }) {
    logic.defineScope(this, "TriggerManager");
    this.db = db;
    db.triggerManager = this;
    this.derivedMutations = null;
    this.sourceTaskContext = null;
    for (let trigger of triggers) {
      this.registerTriggerDictionary(trigger);
    }
  }
  TriggerManager.prototype = {
    __setState(taskContext, derivedMutations) {
      this.sourceTaskContext = taskContext;
      this.derivedMutations = derivedMutations;
    },
    __clearState() {
      this.sourceTaskContext = null;
      this.derivedMutations = null;
    },
    __triggerMutate(triggerName, dict) {
      logic(this, "triggerMutate", { triggerName, dict });
      if (this.derivedMutations) {
        this.derivedMutations.push(dict);
      }
    },
    registerTriggerDictionary(triggerDef) {
      let triggerName = triggerDef.name;
      let triggerContext = new TriggerContext(this, triggerName);
      for (let key of Object.keys(triggerDef)) {
        switch (key) {
          case "name":
            break;
          default: {
            let handlerFunc = triggerDef[key];
            if (!handlerFunc || !handlerFunc.bind) {
              throw new Error(`${triggerName} has broken handler '${key}: ${handlerFunc}`);
            }
            let boundHandler = handlerFunc.bind(null, triggerContext);
            this.db.on(key, boundHandler);
          }
        }
      }
    },
    registerTriggerFunc(eventName, triggerName, handlerFunc) {
      let triggerContext = new TriggerContext(this, triggerName);
      let boundHandler = handlerFunc.bind(null, triggerContext);
      this.db.on(eventName, boundHandler);
    }
  };

  // src/backend/db_triggers/unread_count.js
  var unread_count_default = {
    name: "unread_count",
    "conv!*!add": function(triggerCtx, convInfo) {
      if (!convInfo.hasUnread) {
        return;
      }
      let folderDeltas = new Map();
      for (let folderId of convInfo.folderIds) {
        folderDeltas.set(folderId, {
          localUnreadConversations: 1
        });
      }
      triggerCtx.modify({
        atomicDeltas: {
          folders: folderDeltas
        }
      });
    },
    "conv!*!change": function(triggerCtx, convId, preInfo, convInfo, added, kept, removed) {
      let hasUnread = convInfo ? convInfo.hasUnread : false;
      if (!hasUnread && !preInfo.hasUnread) {
        return;
      }
      let folderDeltas = new Map();
      let applyDelta = (folderIds, delta) => {
        for (let folderId of folderIds) {
          folderDeltas.set(folderId, {
            localUnreadConversations: delta
          });
        }
      };
      if (hasUnread) {
        if (!preInfo.hasUnread) {
          applyDelta(convInfo.folderIds, 1);
        } else {
          applyDelta(added, 1);
          applyDelta(removed, -1);
        }
      } else {
        applyDelta(preInfo.folderIds, -1);
      }
      if (folderDeltas.size) {
        triggerCtx.modify({
          atomicDeltas: {
            folders: folderDeltas
          }
        });
      }
    }
  };

  // src/backend/db_triggers/message_count.js
  var message_count_default = {
    name: "message_count",
    "msg!*!add": function(triggerCtx, message) {
      let folderDeltas = new Map();
      for (let folderId of message.folderIds) {
        folderDeltas.set(folderId, {
          localMessageCount: 1
        });
      }
      triggerCtx.modify({
        atomicDeltas: {
          folders: folderDeltas
        }
      });
    },
    "msg!*!change": function(triggerCtx, messageId, preInfo, message, added, kept, removed) {
      if (!added.size && !removed.size) {
        return;
      }
      let folderDeltas = new Map();
      for (let folderId of added) {
        folderDeltas.set(folderId, {
          localMessageCount: 1
        });
      }
      for (let folderId of removed) {
        folderDeltas.set(folderId, {
          localMessageCount: -1
        });
      }
      triggerCtx.modify({
        atomicDeltas: {
          folders: folderDeltas
        }
      });
    }
  };

  // src/backend/db_triggers/all.js
  var all_default = [unread_count_default, message_count_default];

  // src/backend/tasks/account_autoconfig.js
  init_task_definer();

  // src/backend/autoconfig/autoconfig_lookup.js
  init_logic();

  // src/shared/allback.js
  function latchedWithRejections(namedPromises) {
    return new Promise(function(resolve) {
      var results = Object.create(null);
      var pending = 0;
      Object.keys(namedPromises).forEach(function(name) {
        pending++;
        var promise = namedPromises[name];
        promise.then(function(result) {
          results[name] = { resolved: true, value: result };
          if (--pending === 0) {
            resolve(results);
          }
        }, function(err) {
          results[name] = { resolved: false, value: err };
          if (--pending === 0) {
            resolve(results);
          }
        });
      });
      if (!pending) {
        resolve(results);
      }
    });
  }

  // src/backend/autoconfig/autoconfig_lookup.js
  init_syncbase();

  // src/backend/autoconfig/testing_hacks.js
  var testing_hacks_default = new Map();

  // src/backend/autoconfig/fill_config_placeholders.js
  function fillConfigPlaceholders(userDetails, sourceConfigInfo) {
    var configInfo = JSON.parse(JSON.stringify(sourceConfigInfo));
    var details = userDetails.emailAddress.split("@");
    var emailLocalPart = details[0], emailDomainPart = details[1];
    var placeholderFields = {
      incoming: ["username", "hostname", "server"],
      outgoing: ["username", "hostname"]
    };
    function fillPlaceholder(value) {
      return value.replace("%EMAILADDRESS%", userDetails.emailAddress).replace("%EMAILLOCALPART%", emailLocalPart).replace("%EMAILDOMAIN%", emailDomainPart).replace("%REALNAME%", userDetails.displayName);
    }
    for (var serverType in placeholderFields) {
      var fields = placeholderFields[serverType];
      var server = configInfo[serverType];
      if (!server) {
        continue;
      }
      for (var iField = 0; iField < fields.length; iField++) {
        var field = fields[iField];
        if (server.hasOwnProperty(field)) {
          server[field] = fillPlaceholder(server[field]);
        }
      }
    }
    return configInfo;
  }

  // src/backend/autoconfig/autoconfig_lookup.js
  function Autoconfigurator() {
    this.timeout = AUTOCONFIG_TIMEOUT_MS;
    logic.defineScope(this, "Autoconfigurator");
  }
  Autoconfigurator.prototype = {
    _fatalErrors: ["bad-user-or-pass", "not-authorized"],
    _isSuccessOrFatal(error) {
      return !error || this._fatalErrors.includes(error);
    },
    _getXmlConfig: function getXmlConfig(url) {
      return new Promise((resolve, reject) => {
        var scope4 = logic.subscope(this, { method: "GET", url });
        logic(scope4, "xhr:start");
        var xhr = new XMLHttpRequest({ mozSystem: true });
        xhr.open("GET", url, true);
        xhr.timeout = this.timeout;
        xhr.onload = function() {
          logic(scope4, "xhr:end", { status: xhr.status });
          if (xhr.status < 200 || xhr.status >= 300) {
            reject("status" + xhr.status);
            return;
          }
          self.postMessage({
            uid: 0,
            type: "configparser",
            cmd: "accountcommon",
            args: [xhr.responseText]
          });
          self.addEventListener("message", function onworkerresponse(evt12) {
            var data = evt12.data;
            if (data.type !== "configparser" || data.cmd !== "accountcommon") {
              return;
            }
            self.removeEventListener(evt12.type, onworkerresponse);
            var args = data.args;
            var config = args[0];
            resolve(config);
          });
        };
        xhr.ontimeout = function() {
          logic(scope4, "xhr:end", { status: "timeout" });
          reject("timeout");
        };
        xhr.onerror = function() {
          logic(scope4, "xhr:end", { status: "error" });
          reject("error");
        };
        try {
          xhr.send();
        } catch (e) {
          logic(scope4, "xhr:end", { status: "sync-error" });
          reject("status404");
        }
      });
    },
    _getConfigFromLocalFile: function getConfigFromLocalFile(domain) {
      return this._getXmlConfig("/autoconfig/" + encodeURIComponent(domain));
    },
    _checkAutodiscoverUrl(url) {
      return new Promise((resolve, reject) => {
        var scope4 = logic.subscope(this, { method: "POST", url });
        logic(scope4, "autodiscoverProbe:start");
        var xhr = new XMLHttpRequest({ mozSystem: true });
        xhr.open("POST", url, true);
        xhr.timeout = this.timeout;
        var victory = () => {
          resolve({
            type: "activesync",
            incoming: {
              autodiscoverEndpoint: url
            }
          });
        };
        xhr.onload = function() {
          logic(scope4, "autodiscoverProbe:end", { status: xhr.status });
          if (xhr.status === 401) {
            victory();
            return;
          }
          reject("status" + xhr.status);
        };
        xhr.ontimeout = function() {
          logic(scope4, "autodiscoverProbe:end", { status: "timeout" });
          reject("timeout");
        };
        xhr.onerror = function() {
          logic(scope4, "autodiscoverProbe:end", { status: "error" });
          reject("error");
        };
        try {
          xhr.send(null);
        } catch (e) {
          logic(scope4, "autodiscoverProbe:end", { status: "sync-error" });
          reject("status404");
        }
      });
    },
    _probeForAutodiscover(domain) {
      var subdirUrl = "https://" + domain + "/autodiscover/autodiscover.xml";
      var domainUrl = "https://autodiscover." + domain + "/autodiscover/autodiscover.xml";
      return latchedWithRejections({
        subdir: this._checkAutodiscoverUrl(subdirUrl),
        domain: this._checkAutodiscoverUrl(domainUrl)
      }).then((results) => {
        if (results.subdir.resolved && results.subdir.value) {
          return results.subdir.value;
        }
        if (results.domain.resolved && results.domain.value) {
          return results.domain.value;
        }
        return null;
      });
    },
    _getConfigFromISPDB(domain) {
      return this._getXmlConfig(ISPDB_AUTOCONFIG_ROOT + encodeURIComponent(domain));
    },
    _getMX: function getMX(domain) {
      return new Promise((resolve, reject) => {
        var scope4 = logic.subscope(this, { domain });
        logic(scope4, "mxLookup:begin");
        var xhr = new XMLHttpRequest({ mozSystem: true });
        xhr.open("GET", "https://live.mozillamessaging.com/dns/mx/" + encodeURIComponent(domain), true);
        xhr.timeout = this.timeout;
        xhr.onload = function() {
          var reportDomain = null;
          if (xhr.status === 200) {
            var normStr = xhr.responseText.split("\n")[0];
            if (normStr) {
              normStr = normStr.toLowerCase();
              var mxDomain = normStr.split(".").slice(-2).join(".");
              if (mxDomain !== domain) {
                reportDomain = mxDomain;
              }
            }
          }
          logic(scope4, "mxLookup:end", {
            raw: normStr,
            normalized: mxDomain,
            reporting: reportDomain
          });
          resolve(reportDomain);
        };
        xhr.ontimeout = function() {
          logic(scope4, "mxLookup:end", { status: "timeout" });
          reject("timeout");
        };
        xhr.onerror = function() {
          logic(scope4, "mxLookup:end", { status: "error" });
          reject("error");
        };
        xhr.send();
      });
    },
    _getHostedAndISPDBConfigs(domain, emailAddress) {
      var commonAutoconfigSuffix = "/mail/config-v1.1.xml?emailaddress=" + encodeURIComponent(emailAddress);
      var subdomainAutoconfigUrl = "https://autoconfig." + domain + commonAutoconfigSuffix;
      var wellKnownAutoconfigUrl = "https://" + domain + "/.well-known/autoconfig" + commonAutoconfigSuffix;
      return latchedWithRejections({
        autoconfigSubdomain: this._getXmlConfig(subdomainAutoconfigUrl),
        autoconfigWellKnown: this._getXmlConfig(wellKnownAutoconfigUrl),
        ispdb: this._getConfigFromISPDB(domain),
        mxDomain: this._getMX(domain)
      }).then((results) => {
        if (results.autoconfigSubdomain.resolved && results.autoconfigSubdomain.value) {
          return {
            type: "config",
            source: "autoconfig-subdomain",
            config: results.autoconfigSubdomain.value
          };
        }
        if (results.autoconfigWellKnown.resolved && results.autoconfigWellKnown.value) {
          return {
            type: "config",
            source: "autoconfig-wellknown",
            config: results.autoconfigWellKnown.value
          };
        }
        if (results.ispdb.resolved && results.ispdb.value) {
          return { type: "config", source: "ispdb", config: results.ispdb.value };
        }
        if (results.mxDomain.resolved && results.mxDomain.value && results.mxDomain.value !== domain) {
          return { type: "mx", domain: results.mxDomain.value };
        }
        return { type: null };
      });
    },
    _getConfigFromMX: function getConfigFromMX(domain, callback) {
      this._getMX(domain, (mxError, mxDomain, mxErrorDetails) => {
        if (mxError) {
          callback(mxError, null, mxErrorDetails);
          return;
        }
        console.log("  Found MX for", mxDomain);
        if (domain === mxDomain) {
          callback("no-config-info", null, { status: "mxsame" });
          return;
        }
        console.log("  Looking in local file store");
        this._getConfigFromLocalFile(mxDomain, (error, config, errorDetails) => {
          if (!error) {
            callback(error, config, errorDetails);
            return;
          }
          console.log("  Looking in the Mozilla ISPDB");
          this._getConfigFromDB(mxDomain, callback);
        });
      });
    },
    _checkGelamConfig(domain) {
      if (testing_hacks_default.has(domain)) {
        return testing_hacks_default.get(domain);
      }
      return null;
    },
    learnAboutAccount(details) {
      return new Promise((resolve) => {
        var emailAddress = details.emailAddress;
        var emailParts = emailAddress.split("@");
        var emailDomainPart = emailParts[1];
        var domain = emailDomainPart.toLowerCase();
        var scope4 = logic.subscope(this, { domain });
        logic(scope4, "autoconfig:begin");
        var selfHostedAndISPDBHandler, mxLocalHandler, autodiscoverHandler, mxISPDBHandler;
        var victory = (sourceConfigInfo, source) => {
          var configInfo = null, result;
          if (sourceConfigInfo) {
            configInfo = fillConfigPlaceholders(details, sourceConfigInfo);
            if (configInfo.incoming && configInfo.incoming.authentication === "xoauth2") {
              result = "need-oauth2";
            } else {
              result = "need-password";
            }
          } else {
            result = "no-config-info";
          }
          logic(scope4, "autoconfig:end", {
            result,
            source,
            configInfo
          });
          resolve({ result, source, configInfo });
        };
        var failsafeFailure = (error) => {
          logic(this, "autoconfig:end", {
            error: {
              message: error && error.message,
              stack: error && error.stack
            }
          });
          resolve({ result: "no-config-info", configInfo: null });
        };
        var coerceRejectionToNull = (error) => {
          logic(scope4, "autoconfig:coerceRejection", { error });
          return null;
        };
        var hardcodedConfig = this._checkGelamConfig(domain);
        if (hardcodedConfig) {
          victory(hardcodedConfig, "hardcoded");
          return;
        }
        var localConfigHandler = (info) => {
          if (info) {
            victory(info, "local");
            return null;
          }
          return this._getHostedAndISPDBConfigs(domain, emailAddress).then(selfHostedAndISPDBHandler);
        };
        var mxDomain;
        selfHostedAndISPDBHandler = (typedResult) => {
          if (typedResult.type === "config") {
            victory(typedResult.config, typedResult.source);
            return null;
          }
          if (typedResult.type === "mx") {
            mxDomain = typedResult.domain;
            return this._getConfigFromLocalFile(mxDomain).catch(coerceRejectionToNull).then(mxLocalHandler);
          }
          return this._probeForAutodiscover(domain).then(autodiscoverHandler);
        };
        mxLocalHandler = (info) => {
          if (info) {
            victory(info, "mx local");
            return null;
          }
          return this._getConfigFromISPDB(mxDomain).catch(coerceRejectionToNull).then(mxISPDBHandler);
        };
        mxISPDBHandler = (info) => {
          if (info) {
            victory(info, "mx ispdb");
            return null;
          }
          return this._probeForAutodiscover(domain).then(autodiscoverHandler);
        };
        autodiscoverHandler = (info) => {
          victory(info, info ? "autodiscover" : null);
          return null;
        };
        this._getConfigFromLocalFile(domain).catch(coerceRejectionToNull).then(localConfigHandler).catch(failsafeFailure);
      });
    }
  };
  function autoconfigLookup(details) {
    let autoconfigurator = new Autoconfigurator();
    return autoconfigurator.learnAboutAccount(details);
  }

  // src/backend/tasks/account_autoconfig.js
  var account_autoconfig_default = task_definer_default.defineSimpleTask([
    {
      name: "account_autoconfig",
      exclusiveResources() {
        return [];
      },
      priorityTags() {
        return [];
      },
      async execute(ctx, planned) {
        let result = await autoconfigLookup(planned.userDetails);
        await ctx.finishTask({});
        return ctx.returnValue(result);
      }
    }
  ]);

  // src/backend/tasks/account_create.js
  init_task_definer();
  init_a64();

  // src/backend/db/account_def_rep.js
  init_date();
  function makeAccountDef({
    infra,
    credentials,
    prefFields,
    typeFields,
    engineFields,
    connInfoFields,
    identities
  }) {
    let def = {
      id: infra.id,
      name: infra.name,
      defaultPriority: NOW(),
      type: infra.type,
      engine: engineFields.engine,
      engineData: engineFields.engineData,
      credentials,
      identities
    };
    for (let key of Object.keys(prefFields)) {
      def[key] = prefFields[key];
    }
    for (let key of Object.keys(typeFields)) {
      def[key] = typeFields[key];
    }
    for (let key of Object.keys(connInfoFields)) {
      def[key] = connInfoFields[key];
    }
    return def;
  }
  function makeIdentity(raw) {
    return {
      id: raw.id,
      name: raw.name,
      address: raw.address,
      replyTo: raw.replyTo,
      signature: raw.signature,
      signatureEnabled: raw.signatureEnabled
    };
  }

  // src/backend/default_prefs.js
  var DEFAULT_PREFS = {
    syncRange: "auto",
    syncInterval: 0,
    notifyOnNew: true,
    playSoundOnSend: true
  };
  var default_prefs_default = DEFAULT_PREFS;

  // src/backend/tasks/account_create.js
  var account_create_default = task_definer_default.defineSimpleTask([
    {
      name: "account_create",
      exclusiveResources() {
        return [];
      },
      priorityTags() {
        return [];
      },
      async execute(ctx, planned) {
        let { userDetails, domainInfo } = planned;
        let accountType = domainInfo.type;
        let [configurator, validator] = await Promise.all([
          configuratorModules.get(accountType)(),
          validatorModules.get(accountType)()
        ]);
        let fragments = configurator(userDetails, domainInfo);
        let validationResult = await validator(fragments);
        if (validationResult.error) {
          return ctx.returnValue(validationResult);
        }
        let accountNum = ctx.universe.config.nextAccountNum;
        let accountId = encodeInt(accountNum);
        if (validationResult.receiveProtoConn) {
          ctx.universe.accountManager.stashAccountConnection(accountId, validationResult.receiveProtoConn);
        }
        let identity = makeIdentity({
          id: accountId + "." + encodeInt(0),
          name: userDetails.displayName,
          address: userDetails.emailAddress,
          replyTo: null,
          signature: null,
          signatureEnabled: false
        });
        let accountDef = makeAccountDef({
          infra: {
            id: accountId,
            name: userDetails.emailAddress,
            type: accountType
          },
          credentials: fragments.credentials,
          prefFields: default_prefs_default,
          typeFields: fragments.typeFields,
          engineFields: validationResult.engineFields,
          connInfoFields: fragments.connInfoFields,
          identities: [identity]
        });
        await ctx.finishTask({
          newData: {
            accounts: [accountDef]
          },
          atomicClobbers: {
            config: {
              nextAccountNum: accountNum + 1
            }
          }
        });
        return ctx.returnValue({
          accountId,
          error: null,
          errorDetails: null
        });
      }
    }
  ]);

  // src/backend/tasks/account_delete.js
  init_task_definer();
  var account_delete_default = task_definer_default.defineSimpleTask([
    {
      name: "account_delete",
      args: ["accountId"],
      exclusiveResources(args) {
        return [`account:${args.accountId}`];
      },
      priorityTags() {
        return [];
      },
      async execute(ctx, planned) {
        await ctx.beginMutate({
          accounts: new Map([[planned.accountId, null]])
        });
        await ctx.finishTask({
          mutations: {
            accounts: new Map([[planned.accountId, null]])
          }
        });
      }
    }
  ]);

  // src/backend/tasks/account_migrate.js
  init_task_definer();
  var account_migrate_default = task_definer_default.defineSimpleTask([
    {
      name: "account_migrate",
      async plan(ctx, raw) {
        let { accountDef } = raw;
        await ctx.finishTask({
          newData: {
            accounts: [accountDef]
          }
        });
      },
      execute: null
    }
  ]);

  // src/backend/tasks/config_modify.js
  init_logic();
  init_task_definer();
  var config_modify_default = task_definer_default.defineSimpleTask([
    {
      name: "config_modify",
      async plan(ctx, rawTask) {
        const globalClobbers = new Map();
        for (let key in rawTask.mods) {
          const val = rawTask.mods[key];
          switch (key) {
            case "debugLogging":
              globalClobbers.set(["debugLogging"], val);
              logic.realtimeLogEverything = val === "realtime";
              break;
            default:
              logic(ctx, "badModifyConfigKey", { key });
              break;
          }
        }
        await ctx.finishTask({
          atomicClobbers: {
            config: globalClobbers
          }
        });
      }
    }
  ]);

  // src/backend/tasks/draft_create.js
  init_task_definer();
  init_id_conversions();
  init_date();
  init_mailchew();

  // src/backend/drafts/address_helpers.js
  function addressMatches(a, b) {
    return a.address === b.address;
  }
  function cloneRecipients(recipients) {
    return {
      to: recipients.to ? recipients.to.slice() : null,
      cc: recipients.cc ? recipients.cc.slice() : null,
      bcc: recipients.bcc ? recipients.bcc.slice : null
    };
  }
  function effectiveAuthorGivenReplyTo(fromAddressPair, replyToAddressPair) {
    return {
      name: fromAddressPair.name,
      address: replyToAddressPair && replyToAddressPair.address || fromAddressPair.address
    };
  }
  function checkIfAddressListContainsAddress(list, addrPair) {
    if (!list) {
      return false;
    }
    let checkAddress = addrPair.address;
    for (var i = 0; i < list.length; i++) {
      if (list[i].address === checkAddress) {
        return true;
      }
    }
    return false;
  }
  function filterOutIdentity(list, identity) {
    return list.filter((addressPair) => addressPair.address !== identity.address);
  }
  function addressPairFromIdentity(identity) {
    return {
      name: identity.name,
      address: identity.address
    };
  }
  function replyToFromIdentity(identity) {
    return { address: identity.replyTo };
  }

  // src/backend/drafts/derive_blank_draft.js
  init_mailchew();
  init_mail_rep();
  function deriveBlankDraft({
    identity,
    messageId,
    umid,
    guid,
    date,
    folderIds
  }) {
    let bodyReps = generateBaseComposeParts(identity);
    let draftInfo = makeDraftInfo({
      draftType: "blank",
      mode: null,
      refMessageId: null,
      refMessageDate: null
    });
    return makeMessageInfo({
      id: messageId,
      umid,
      guid,
      date,
      author: addressPairFromIdentity(identity),
      to: [],
      cc: [],
      bcc: [],
      replyTo: replyToFromIdentity(identity),
      flags: [],
      folderIds,
      hasAttachments: false,
      subject: "",
      snippet: "",
      attachments: [],
      relatedParts: [],
      references: [],
      bodyReps,
      draftInfo
    });
  }

  // src/backend/drafts/derive_inline_forward.js
  init_mailchew();
  init_mail_rep();
  async function deriveInlineForward({
    sourceMessage,
    identity,
    messageId,
    umid,
    guid,
    date,
    folderIds
  }) {
    let subject = generateForwardSubject(sourceMessage.subject);
    let bodyReps = await generateForwardParts(sourceMessage, identity);
    let draftInfo = makeDraftInfo({
      draftType: "forward",
      mode: null,
      refMessageId: sourceMessage.id,
      refMessageDate: sourceMessage.date
    });
    return makeMessageInfo({
      id: messageId,
      umid,
      guid,
      date,
      author: addressPairFromIdentity(identity),
      to: [],
      cc: [],
      bcc: [],
      replyTo: replyToFromIdentity(identity),
      flags: [],
      folderIds,
      hasAttachments: false,
      subject,
      snippet: "",
      attachments: [],
      relatedParts: [],
      references: [],
      bodyReps,
      draftInfo
    });
  }

  // src/backend/drafts/derive_quoted_reply.js
  init_mailchew();

  // src/backend/drafts/reply_all_recipients.js
  function replyAllRecipients(sourceRecipients, sourceAuthor, replyAuthor) {
    let rTo;
    if (checkIfAddressListContainsAddress(sourceRecipients.to, sourceAuthor) || checkIfAddressListContainsAddress(sourceRecipients.cc, sourceAuthor)) {
      rTo = sourceRecipients.to;
    } else if (sourceRecipients.to && sourceRecipients.to.length) {
      rTo = [sourceAuthor].concat(sourceRecipients.to);
    } else {
      rTo = [sourceAuthor];
    }
    if (rTo.length === 1 && (!sourceRecipients.cc || sourceRecipients.cc.length === 0) && checkIfAddressListContainsAddress(rTo, replyAuthor)) {
      return {
        to: rTo,
        cc: [],
        bcc: sourceRecipients.bcc
      };
    }
    return {
      to: filterOutIdentity(rTo, replyAuthor),
      cc: filterOutIdentity(sourceRecipients.cc || [], replyAuthor),
      bcc: sourceRecipients.bcc
    };
  }

  // src/backend/drafts/reply_to_sender_recipients.js
  function replyToSenderRecipients(sourceRecipients, sourceAuthor, replyAuthor) {
    if (addressMatches(sourceAuthor, replyAuthor)) {
      return cloneRecipients(sourceRecipients);
    }
    return {
      to: [sourceAuthor],
      cc: [],
      bcc: []
    };
  }

  // src/backend/drafts/derive_quoted_reply.js
  init_mail_rep();
  async function deriveQuotedReply({
    sourceMessage,
    replyMode,
    identity,
    messageId,
    umid,
    guid,
    date,
    folderIds
  }) {
    let sourceRecipients = {
      to: sourceMessage.to,
      cc: sourceMessage.cc,
      bcc: sourceMessage.bcc
    };
    let sourceEffectiveAuthor = effectiveAuthorGivenReplyTo(sourceMessage.author, sourceMessage.replyTo);
    let replyEffectiveAuthor = effectiveAuthorGivenReplyTo(identity, identity.replyTo && { address: identity.replyTo });
    let recipients;
    switch (replyMode) {
      case "sender":
        recipients = replyToSenderRecipients(sourceRecipients, sourceEffectiveAuthor, replyEffectiveAuthor);
        break;
      case "all":
        recipients = replyAllRecipients(sourceRecipients, sourceEffectiveAuthor, replyEffectiveAuthor);
        break;
      default:
        throw new Error("bad reply mode: " + replyMode);
    }
    let references = sourceMessage.references.slice();
    if (sourceMessage.guid) {
      references.push(sourceMessage.guid);
    }
    let subject = generateReplySubject(sourceMessage.subject);
    let bodyReps = await generateReplyParts(sourceMessage.bodyReps, sourceEffectiveAuthor, date, identity, sourceMessage.guid);
    let draftInfo = makeDraftInfo({
      draftType: "reply",
      mode: replyMode,
      refMessageId: sourceMessage.id,
      refMessageDate: sourceMessage.date
    });
    return makeMessageInfo({
      id: messageId,
      umid,
      guid,
      date,
      author: addressPairFromIdentity(identity),
      to: recipients.to,
      cc: recipients.cc,
      bcc: recipients.cc,
      replyTo: replyToFromIdentity(identity),
      flags: [],
      folderIds,
      hasAttachments: false,
      subject,
      snippet: "",
      attachments: [],
      relatedParts: [],
      references,
      bodyReps,
      draftInfo
    });
  }

  // src/backend/tasks/draft_create.js
  init_conv_churn_driver();
  var draft_create_default = task_definer_default.defineSimpleTask([
    {
      name: "draft_create",
      async plan(ctx, req) {
        let accountId;
        if (req.refMessageId) {
          accountId = accountIdFromMessageId(req.refMessageId);
        } else if (req.folderId) {
          accountId = accountIdFromFolderId(req.folderId);
        }
        let account = await ctx.universe.acquireAccount(ctx, accountId);
        let draftFolderInfo = account.getFirstFolderWithType("localdrafts");
        let identity = account.identities[0];
        let convId;
        let messageId;
        let messageIdPiece = "~" + ctx.id;
        let umid = accountId + "." + messageIdPiece;
        if (req.draftType === "blank" || req.draftType === "forward") {
          convId = accountId + "." + messageIdPiece;
          messageId = convId + "." + messageIdPiece;
        } else if (req.draftType === "reply") {
          convId = convIdFromMessageId(req.refMessageId);
          messageId = convId + "." + messageIdPiece;
        } else {
          throw new Error("invalid draft type: " + req.draftType);
        }
        let guid = generateMessageIdHeaderValue();
        let date = NOW();
        let allMessages;
        let oldConvInfo;
        let messageInfo;
        let folderIds = new Set([draftFolderInfo.id]);
        if (req.draftType === "blank") {
          messageInfo = deriveBlankDraft({
            identity,
            messageId,
            umid,
            guid,
            date,
            folderIds
          });
          allMessages = [messageInfo];
        } else if (req.draftType === "reply") {
          let fromDb = await ctx.beginMutate({
            conversations: new Map([[convId, null]]),
            messagesByConversation: new Map([[convId, null]])
          });
          oldConvInfo = fromDb.conversations.get(convId);
          let loadedMessages = fromDb.messagesByConversation.get(convId);
          let sourceMessage = loadedMessages.find((msg) => msg.id === req.refMessageId);
          messageInfo = await deriveQuotedReply({
            sourceMessage,
            replyMode: req.mode,
            identity,
            messageId,
            umid,
            guid,
            date,
            folderIds
          });
          allMessages = loadedMessages.concat([messageInfo]);
        } else {
          let sourceMessageKey = [req.refMessageId, req.refMessageDate];
          let fromDb = await ctx.beginMutate({
            messages: new Map([[sourceMessageKey, null]])
          });
          let sourceMessage = fromDb.messages.get(req.refMessageId);
          messageInfo = await deriveInlineForward({
            sourceMessage,
            identity,
            messageId,
            umid,
            guid,
            date,
            folderIds
          });
          allMessages = [messageInfo];
        }
        let convInfo = churnConversationDriver(convId, oldConvInfo, allMessages);
        if (oldConvInfo) {
          await ctx.finishTask({
            mutations: {
              conversations: new Map([[convId, convInfo]])
            },
            newData: {
              messages: [messageInfo]
            }
          });
        } else {
          await ctx.finishTask({
            newData: {
              conversations: [convInfo],
              messages: [messageInfo]
            }
          });
        }
        return ctx.returnValue({ messageId, messageDate: date });
      },
      execute: null
    }
  ]);

  // src/backend/tasks/new_flush.js
  init_task_definer();

  // src/app_logic/new_batch_churn.js
  function flattenConvHierarchyToMessagesNewestFirst(newByConv) {
    let messages = [];
    for (let messageMap of newByConv.values()) {
      for (let message of messageMap.values()) {
        messages.push(message);
      }
    }
    messages.sort((a, b) => b.date - a.date);
    return messages;
  }
  function churnPerAccount(multipleAccounts, accountInfo, newByConv) {
    if (newByConv.size === 0) {
      return null;
    }
    let messages = flattenConvHierarchyToMessagesNewestFirst(newByConv);
    let maybeAccountName = multipleAccounts ? accountInfo.name : null;
    if (messages.length === 1) {
      let message = messages[0];
      return {
        newMessageCount: 1,
        fromAddress: message.authorNameish,
        subject: message.subject,
        maybeAccountName
      };
    }
    let uniqueAddresses = [];
    let maxCount = 3;
    for (let message of messages) {
      let candidateAddress = message.authorNameish;
      if (!uniqueAddresses.includes(candidateAddress)) {
        uniqueAddresses.push(candidateAddress);
        if (uniqueAddresses.length >= maxCount) {
          break;
        }
      }
    }
    return {
      newMessageCount: messages.length,
      topFromAddresses: uniqueAddresses,
      maybeAccountName
    };
  }
  function churnAllNewMessages(ctx, newSetsWithAccount) {
    let perAccountResults = new Map();
    for (let { accountInfo, newByConv } of newSetsWithAccount) {
      perAccountResults.set(accountInfo.id, churnPerAccount(!!newSetsWithAccount.length, accountInfo, newByConv));
    }
    return Promise.resolve(perAccountResults);
  }

  // src/backend/tasks/new_flush.js
  var new_flush_default = task_definer_default.defineAtMostOnceTask([
    {
      name: "new_flush",
      binByArg: null,
      async helped_plan(ctx) {
        const accountsTOC = await ctx.acquireAccountsTOC();
        const accountInfos = accountsTOC.getAllItems();
        const newSetsWithAccount = [];
        for (let accountInfo of accountInfos) {
          let newByConv = ctx.synchronouslyConsultOtherTask({
            name: "new_tracking",
            accountId: accountInfo.id
          });
          newSetsWithAccount.push({
            accountInfo,
            newByConv
          });
        }
        let churned = await churnAllNewMessages(ctx, newSetsWithAccount);
        ctx.broadcastOverBridges("newMessagesUpdate", churned);
        return {
          taskState: null
        };
      }
    }
  ]);

  // src/backend/global_tasks.js
  var global_tasks_default = [
    config_modify_default,
    account_autoconfig_default,
    account_create_default,
    account_delete_default,
    account_migrate_default,
    draft_create_default,
    new_flush_default
  ];

  // src/backend/mailuniverse.js
  init_id_conversions();
  function MailUniverse({ online, testOptions, appExtensions }) {
    logic.defineScope(this, "Universe");
    this._initialized = false;
    this._appExtensions = appExtensions;
    const db = this.db = new maildb_default({
      universe: this,
      testOptions
    });
    const tocManager = this.tocManager = new TOCManager();
    const derivedViewManager = this.derivedViewManager = new DerivedViewManager();
    this.queryManager = new QueryManager({
      db,
      derivedViewManager
    });
    const triggerManager = this.triggerManager = new TriggerManager({
      db,
      triggers: all_default
    });
    this._bridges = [];
    this._folderConvsTOCs = new Map();
    this._folderMessagesTOCs = new Map();
    this._conversationTOCs = new Map();
    const dataOverlayManager = this.dataOverlayManager = new DataOverlayManager();
    const taskPriorities = this.taskPriorities = new TaskPriorities();
    const taskResources = this.taskResources = new TaskResources(this.taskPriorities);
    const taskRegistry = this.taskRegistry = new TaskRegistry({
      dataOverlayManager,
      triggerManager,
      taskResources
    });
    const accountManager = this.accountManager = new AccountManager({
      db,
      universe: this,
      taskRegistry,
      taskResources
    });
    const taskManager = this.taskManager = new TaskManager({
      universe: this,
      db,
      taskRegistry,
      taskResources,
      taskPriorities,
      accountManager
    });
    this.taskGroupTracker = new TaskGroupTracker(taskManager);
    this.taskRegistry.registerGlobalTasks(global_tasks_default);
    this.cronSyncSupport = new CronSyncSupport({
      universe: this,
      db,
      accountManager
    });
    this.extensionManager = new ExtensionManager({
      derivedViewManager,
      tocManager
    });
    this._testModeFakeNavigator = testOptions && testOptions.fakeNavigator || null;
    this.online = true;
    this._onConnectionChange(online);
    this._mode = "cron";
    this.config = null;
    this._logReaper = null;
    this._logBacklog = null;
    this._LOG = null;
  }
  MailUniverse.prototype = {
    _initLogging(config) {
      logic.bc = new BroadcastChannel("logic");
      if (config.debugLogging === "realtime") {
        logic.realtimeLogEverything = true;
      }
    },
    _generateMigrationTasks({ accountDefs }) {
      return accountDefs.map((accountDef) => {
        return {
          type: "account_migrate",
          accountDef
        };
      });
    },
    init() {
      if (this._initialized !== false) {
        throw new Error("misuse");
      }
      this._initialized = "initializing";
      return this.db.getConfig().then(({ config, accountDefs, carryover }) => {
        if (config) {
          return this._initFromConfig({ config, accountDefs });
        }
        let freshConfig = {
          id: "config",
          nextAccountNum: carryover ? carryover.config.nextAccountNum : 0,
          debugLogging: carryover ? carryover.config.debugLogging : false
        };
        let migrationTasks;
        if (carryover) {
          migrationTasks = this._generateMigrationTasks(carryover);
        }
        this.db.saveConfig(freshConfig);
        return this._initFromConfig({
          config: freshConfig,
          accountDefs: [],
          tasksToPlan: migrationTasks
        });
      });
    },
    _initFromConfig({ config, accountDefs, tasksToPlan }) {
      this._initialized = true;
      this.config = config;
      this._initLogging(config);
      logic(this, "START_OF_LOG");
      logic(this, "configLoaded", { config });
      this._bindStandardBroadcasts();
      this.extensionManager.registerExtensions(this._appExtensions, "app");
      let initPromise = this.accountManager.initFromDB(accountDefs).then(() => {
        return this.taskManager.__restoreFromDB();
      }).then(() => {
        if (tasksToPlan) {
          this.taskManager.scheduleTasks(tasksToPlan, "initFromConfig");
        }
        this.cronSyncSupport.systemReady();
        return this;
      });
      this.cronSyncSupport.ensureSync("universe-init");
      return initPromise;
    },
    setInteractive() {
      this._mode = "interactive";
    },
    _onConnectionChange(isOnline) {
      var wasOnline = this.online;
      this.online = this._testModeFakeNavigator ? this._testModeFakeNavigator.onLine : isOnline;
      logic(this, "connectionChange", { online: this.online, wasOnline });
      if (this.online) {
        this.taskResources.resourceAvailable("online");
      } else {
        this.taskResources.resourcesNoLongerAvailable(["online"]);
      }
    },
    registerBridge(mailBridge) {
      this._bridges.push(mailBridge);
    },
    unregisterBridge(mailBridge) {
      var idx = this._bridges.indexOf(mailBridge);
      if (idx !== -1) {
        this._bridges.splice(idx, 1);
      }
    },
    exposeConfigForClient() {
      const config = this.config;
      return {
        debugLogging: config.debugLogging
      };
    },
    _bindStandardBroadcasts() {
      this.db.on("config", () => {
        this.broadcastOverBridges("config", this.exposeConfigForClient());
      });
    },
    broadcastOverBridges(name, data) {
      for (let bridge of this._bridges) {
        bridge.broadcast(name, data);
      }
    },
    acquireAccountsTOC(ctx) {
      return this.accountManager.acquireAccountsTOC(ctx);
    },
    acquireAccount(ctx, accountId) {
      return this.accountManager.acquireAccount(ctx, accountId);
    },
    acquireAccountFoldersTOC(ctx, accountId) {
      return this.accountManager.acquireAccountFoldersTOC(ctx, accountId);
    },
    acquireExtensionTOC(ctx, namespace, name) {
      return this.tocManager.acquireExtensionTOC(ctx, namespace, name);
    },
    acquireFolderConversationsTOC(ctx, folderId) {
      let toc;
      if (this._folderConvsTOCs.has(folderId)) {
        toc = this._folderConvsTOCs.get(folderId);
      } else {
        let accountId = accountIdFromFolderId(folderId);
        let engineFacts = this.accountManager.getAccountEngineBackEndFacts(accountId);
        let syncStampSource;
        if (engineFacts.syncGranularity === "account") {
          syncStampSource = this.accountManager.getAccountDefById(accountId);
        } else {
          syncStampSource = this.accountManager.getFolderById(folderId);
        }
        toc = new FolderConversationsTOC({
          db: this.db,
          query: this.queryManager.queryConversations(ctx, { folderId }),
          dataOverlayManager: this.dataOverlayManager,
          metaHelpers: [
            new SyncLifecycle({
              folderId,
              syncStampSource,
              dataOverlayManager: this.dataOverlayManager
            })
          ],
          onForgotten: () => {
            this._folderConvsTOCs.delete(folderId);
          }
        });
        this._folderConvsTOCs.set(folderId, toc);
      }
      return ctx.acquire(toc);
    },
    acquireSearchConversationsTOC(ctx, spec) {
      let folderId = spec.folderId;
      let accountId = accountIdFromFolderId(folderId);
      let engineFacts = this.accountManager.getAccountEngineBackEndFacts(accountId);
      let syncStampSource;
      if (engineFacts.syncGranularity === "account") {
        syncStampSource = this.accountManager.getAccountDefById(accountId);
      } else {
        syncStampSource = this.accountManager.getFolderById(folderId);
      }
      let toc = new FolderConversationsTOC({
        db: this.db,
        query: this.queryManager.queryConversations(ctx, spec),
        dataOverlayManager: this.dataOverlayManager,
        metaHelpers: [
          new SyncLifecycle({
            folderId,
            syncStampSource,
            dataOverlayManager: this.dataOverlayManager
          })
        ],
        onForgotten: () => {
        }
      });
      return ctx.acquire(toc);
    },
    acquireFolderMessagesTOC(ctx, folderId) {
      let toc;
      if (this._folderMessagesTOCs.has(folderId)) {
        toc = this._folderMessagesTOCs.get(folderId);
      } else {
        let accountId = accountIdFromFolderId(folderId);
        let engineFacts = this.accountManager.getAccountEngineBackEndFacts(accountId);
        let syncStampSource;
        if (engineFacts.syncGranularity === "account") {
          syncStampSource = this.accountManager.getAccountDefById(accountId);
        } else {
          syncStampSource = this.accountManager.getFolderById(folderId);
        }
        toc = new ConversationTOC({
          db: this.db,
          query: this.queryManager.queryMessages(ctx, { folderId }),
          dataOverlayManager: this.dataOverlayManager,
          metaHelpers: [
            new SyncLifecycle({
              folderId,
              syncStampSource,
              dataOverlayManager: this.dataOverlayManager
            })
          ],
          onForgotten: () => {
            this._folderMessagesTOCs.delete(folderId);
          }
        });
        this._folderMessagesTOCs.set(folderId, toc);
      }
      return ctx.acquire(toc);
    },
    acquireConversationTOC(ctx, conversationId) {
      let toc;
      if (this._conversationTOCs.has(conversationId)) {
        toc = this._conversationTOCs.get(conversationId);
      } else {
        toc = new ConversationTOC({
          db: this.db,
          query: this.queryManager.queryConversationMessages(ctx, {
            conversationId
          }),
          dataOverlayManager: this.dataOverlayManager,
          onForgotten: () => {
            this._conversationTOCs.delete(conversationId);
          }
        });
        this._conversationTOCs.set(conversationId, toc);
      }
      return ctx.acquire(toc);
    },
    acquireSearchConversationMessagesTOC(ctx, spec) {
      let toc = new ConversationTOC({
        db: this.db,
        query: this.queryManager.queryConversationMessages(ctx, spec),
        dataOverlayManager: this.dataOverlayManager,
        onForgotten: () => {
        }
      });
      return ctx.acquire(toc);
    },
    learnAboutAccount(userDetails, why) {
      return this.taskManager.scheduleNonPersistentTaskAndWaitForExecutedResult({
        type: "account_autoconfig",
        userDetails
      }, why);
    },
    tryToCreateAccount(userDetails, domainInfo, why) {
      if (!this.online) {
        return Promise.resolve({ error: "offline" });
      }
      if (domainInfo) {
        return this.taskManager.scheduleNonPersistentTaskAndWaitForExecutedResult({
          type: "account_create",
          userDetails,
          domainInfo
        }, why);
      }
      return this.taskManager.scheduleNonPersistentTaskAndWaitForExecutedResult({
        type: "account_autoconfig",
        userDetails
      }, why).then((result) => {
        if (result.result !== "need-password") {
          return {
            error: result.result,
            errorDetails: null
          };
        }
        return this.taskManager.scheduleNonPersistentTaskAndWaitForExecutedResult({
          type: "account_create",
          userDetails,
          domainInfo: result.configInfo
        }, why);
      });
    },
    deleteAccount(accountId, why) {
      this.taskManager.scheduleTasks([
        {
          type: "account_delete",
          accountId
        }
      ], why);
    },
    recreateAccount(accountId, why) {
      let accountDef = this.accountManager.getAccountDefById(accountId);
      this.taskManager.scheduleTaskAndWaitForExecutedResult({
        type: "account_delete",
        accountId
      }, why).then(() => {
        this.taskManager.scheduleTasks([
          {
            type: "account_migrate",
            accountDef
          }
        ], why);
      });
    },
    saveAccountDef(accountDef, protoConn) {
      this.db.saveAccountDef(this.config, accountDef);
      if (this.accountsTOC.isKnownAccount(accountDef.id)) {
        this.accountsTOC.accountModified(accountDef);
      } else {
        let accountWireRep = this._accountExists(accountDef);
        if (protoConn) {
          return this._loadAccount(accountDef, this.accountFoldersTOCs.get(accountDef.id), protoConn).then(() => {
            return {
              error: null,
              errorDetails: null,
              accountId: accountDef.id,
              accountWireRep
            };
          });
        }
      }
      return null;
    },
    modifyConfig(mods, why) {
      return this.taskManager.scheduleTaskAndWaitForPlannedResult({
        type: "config_modify",
        mods
      }, why);
    },
    modifyAccount(accountId, mods, why) {
      return this.taskManager.scheduleTaskAndWaitForPlannedResult({
        type: "account_modify",
        accountId,
        mods
      }, why);
    },
    modifyIdentity(identityId, mods, why) {
      const accountId = accountIdFromIdentityId(identityId);
      return this.taskManager.scheduleTaskAndWaitForPlannedResult({
        type: "identity_modify",
        accountId,
        mods
      }, why);
    },
    shutdown(callback) {
      var waitCount = this.accounts.length;
      function accountShutdownCompleted() {
        if (--waitCount === 0) {
          callback();
        }
      }
      for (var iAcct = 0; iAcct < this.accounts.length; iAcct++) {
        var account = this.accounts[iAcct];
        account.shutdown(callback ? accountShutdownCompleted : null);
      }
      if (this._cronSync) {
        this._cronSync.shutdown();
      }
      this.db.close();
      if (!this.accounts.length) {
        callback();
      }
    },
    syncFolderList(accountId, why) {
      return this.taskManager.scheduleTasks([
        {
          type: "sync_folder_list",
          accountId
        }
      ], why);
    },
    syncGrowFolder(folderId, why) {
      console.log("in syncGrowFolder", folderId);
      const accountId = accountIdFromFolderId(folderId);
      return this.taskManager.scheduleTaskAndWaitForPlannedResult({
        type: "sync_grow",
        accountId,
        folderId
      }, why);
    },
    syncRefreshFolder(folderId, why) {
      const accountId = accountIdFromFolderId(folderId);
      return this.taskManager.scheduleTaskAndWaitForPlannedResult({
        type: "sync_refresh",
        accountId,
        folderId
      }, why);
    },
    fetchConversationSnippets(convIds, why) {
      let tasks = convIds.map((convId) => {
        return {
          type: "sync_body",
          accountId: accountIdFromConvId(convId),
          convId,
          amount: "snippet"
        };
      });
      return this.taskManager.scheduleTasks(tasks, why);
    },
    fetchMessageBody(messageId, messageDate, why) {
      return this.taskManager.scheduleTasks([
        {
          type: "sync_body",
          accountId: accountIdFromMessageId(messageId),
          convId: convIdFromMessageId(messageId),
          fullBodyMessageIds: new Set([messageId])
        }
      ], why);
    },
    storeLabels(conversationId, messageIds, messageSelector, addLabels, removeLabels) {
      return this.taskManager.scheduleTaskAndWaitForPlannedUndoTasks({
        type: "store_labels",
        accountId: accountIdFromConvId(conversationId),
        convId: conversationId,
        onlyMessages: messageIds || null,
        messageSelector: messageSelector || null,
        add: addLabels,
        remove: removeLabels
      });
    },
    storeFlags(conversationId, messageIds, messageSelector, addFlags, removeFlags) {
      return this.taskManager.scheduleTaskAndWaitForPlannedUndoTasks({
        type: "store_flags",
        accountId: accountIdFromConvId(conversationId),
        convId: conversationId,
        onlyMessages: messageIds || null,
        messageSelector: messageSelector || null,
        add: addFlags,
        remove: removeFlags
      });
    },
    undo(undoTasks) {
      this.taskManager.scheduleTasks(undoTasks);
    },
    createDraft({ draftType, mode, refMessageId, refMessageDate, folderId }, why) {
      return this.taskManager.scheduleNonPersistentTaskAndWaitForPlannedResult({
        type: "draft_create",
        draftType,
        mode,
        refMessageId,
        refMessageDate,
        folderId
      }, why);
    },
    attachBlobToDraft(messageId, attachmentDef, why) {
      return this.taskManager.scheduleNonPersistentTasks([
        {
          type: "draft_attach",
          accountId: accountIdFromMessageId(messageId),
          messageId,
          attachmentDef
        }
      ], why);
    },
    detachAttachmentFromDraft(messageId, attachmentRelId, why) {
      return this.taskManager.scheduleNonPersistentTasks([
        {
          type: "draft_detach",
          accountId: accountIdFromMessageId(messageId),
          messageId,
          attachmentRelId
        }
      ], why);
    },
    saveDraft(messageId, draftFields, why) {
      return this.taskManager.scheduleTasks([
        {
          type: "draft_save",
          accountId: accountIdFromMessageId(messageId),
          messageId,
          draftFields
        }
      ], why);
    },
    deleteDraft(messageId, why) {
      return this.taskManager.scheduleTasks([
        {
          type: "draft_delete",
          accountId: accountIdFromMessageId(messageId),
          messageId
        }
      ], why);
    },
    outboxSendDraft(messageId, why) {
      return this.taskManager.scheduleTaskAndWaitForPlannedResult({
        type: "outbox_send",
        command: "send",
        accountId: accountIdFromMessageId(messageId),
        messageId
      }, why);
    },
    outboxAbortSend(messageId) {
      return this.taskManager.scheduleTasks([
        {
          type: "outbox_send",
          command: "abort",
          accountId: accountIdFromMessageId(messageId),
          messageId
        }
      ]);
    },
    outboxSetPaused(accountId, bePaused) {
      return this.taskManager.scheduleTasks([
        {
          type: "outbox_send",
          command: "setPaused",
          accountId,
          pause: bePaused
        }
      ]);
    },
    downloadMessageAttachments({ messageId, messageDate, parts }) {
      return this.taskManager.scheduleTaskAndWaitForPlannedResult({
        type: "download",
        accountId: accountIdFromMessageId(messageId),
        messageId,
        messageDate,
        parts
      });
    },
    clearNewTrackingForAccount({ accountId, silent }) {
      this.taskManager.scheduleTasks([
        {
          type: "new_tracking",
          accountId,
          op: "clear",
          silent
        }
      ]);
    },
    flushNewAggregates() {
      this.taskManager.scheduleTasks([
        {
          type: "new_flush"
        }
      ]);
    },
    notifyOutboxSyncDone(account) {
      this.__notifyBackgroundSendStatus({
        accountId: account.id,
        state: "syncDone"
      });
    },
    createFolder() {
    }
  };

  // src/app_logic/worker_extensions.js
  var worker_extensions_default = [];

  // src/backend/worker-setup.js
  var routerBridgeMaker = registerInstanceType("bridge");
  var bridgeUniqueIdentifier = 0;
  function createBridgePair(universe2, usePort) {
    var uid = bridgeUniqueIdentifier++;
    var TMB = new MailBridge(universe2, universe2.db, uid);
    var routerInfo = routerBridgeMaker.register(function(data) {
      TMB.__receiveMessage(data.msg);
    }, usePort);
    var sendMessage = routerInfo.sendMessage;
    TMB.__sendMessage = function(msg) {
      logic(TMB, "send", { type: msg.type, msg });
      sendMessage(null, msg);
    };
    TMB.__sendMessage({
      type: "hello",
      config: universe2.exposeConfigForClient()
    });
  }
  var universe = null;
  var universePromise = null;
  var sendControl = registerSimple("control", async function(data, source) {
    var args = data.args;
    switch (data.cmd) {
      case "hello": {
        if (!universe) {
          universe = new MailUniverse({
            online: args[0],
            appExtensions: worker_extensions_default
          });
          universePromise = universe.init();
        }
        await universePromise;
        createBridgePair(universe, source);
        break;
      }
      case "online":
      case "offline":
        universe._onConnectionChange(args[0]);
        break;
      default:
        break;
    }
  });
  sendControl("hello");
})();
/*! http://mths.be/punycode v1.2.4 by @mathias */
