/// <reference path="types.d.ts" />
/*
 * DO NOT EDIT. THIS FILE IS AUTOMATICALLY GENERATED.
 */

declare namespace WebIDL {

  class CSS2Properties {
    alignContent: string;
    alignItems: string;
    alignSelf: string;
    backfaceVisibility: string;
    borderCollapse: string;
    borderImageRepeat: string;
    boxDecorationBreak: string;
    boxSizing: string;
    breakInside: string;
    captionSide: string;
    clear: string;
    colorAdjust: string;
    colorInterpolation: string;
    colorInterpolationFilters: string;
    columnCount: string;
    columnFill: string;
    columnSpan: string;
    contain: string;
    direction: string;
    display: string;
    dominantBaseline: string;
    emptyCells: string;
    flexDirection: string;
    flexWrap: string;
    cssFloat: string;
    fontKerning: string;
    fontOpticalSizing: string;
    fontSizeAdjust: string;
    fontStretch: string;
    fontStyle: string;
    fontSynthesis: string;
    fontVariantCaps: string;
    fontVariantEastAsian: string;
    fontVariantLigatures: string;
    fontVariantNumeric: string;
    fontVariantPosition: string;
    fontWeight: string;
    gridAutoFlow: string;
    hyphens: string;
    imageOrientation: string;
    imageRendering: string;
    imeMode: string;
    initialLetter: string;
    isolation: string;
    justifyContent: string;
    justifyItems: string;
    justifySelf: string;
    lineBreak: string;
    listStylePosition: string;
    maskType: string;
    mixBlendMode: string;
    MozAppearance: string;
    MozBoxAlign: string;
    MozBoxDirection: string;
    MozBoxOrient: string;
    MozBoxPack: string;
    MozFloatEdge: string;
    MozForceBrokenImageIcon: string;
    MozOrient: string;
    MozOsxFontSmoothing: string;
    MozTextSizeAdjust: string;
    MozUserFocus: string;
    MozUserInput: string;
    MozUserModify: string;
    MozWindowDragging: string;
    objectFit: string;
    offsetRotate: string;
    outlineStyle: string;
    overflowAnchor: string;
    overflowWrap: string;
    paintOrder: string;
    pointerEvents: string;
    position: string;
    resize: string;
    rubyAlign: string;
    rubyPosition: string;
    scrollBehavior: string;
    scrollSnapAlign: string;
    scrollSnapType: string;
    scrollbarWidth: string;
    shapeRendering: string;
    strokeLinecap: string;
    strokeLinejoin: string;
    tableLayout: string;
    textAlign: string;
    textAlignLast: string;
    textAnchor: string;
    textCombineUpright: string;
    textDecorationLine: string;
    textDecorationSkipInk: string;
    textDecorationStyle: string;
    textEmphasisPosition: string;
    textJustify: string;
    textOrientation: string;
    textRendering: string;
    textTransform: string;
    textUnderlinePosition: string;
    touchAction: string;
    transformBox: string;
    transformStyle: string;
    unicodeBidi: string;
    userSelect: string;
    vectorEffect: string;
    visibility: string;
    webkitLineClamp: string;
    whiteSpace: string;
    wordBreak: string;
    writingMode: string;
    zIndex: string;
    breakAfter: string;
    breakBefore: string;
    clipRule: string;
    fillRule: string;
    overflowClipBoxBlock: string;
    overflowClipBoxInline: string;
    fillOpacity: string;
    strokeOpacity: string;
    MozBoxOrdinalGroup: string;
    order: string;
    flexGrow: string;
    flexShrink: string;
    MozBoxFlex: string;
    strokeMiterlimit: string;
    overflowBlock: string;
    overflowInline: string;
    overflowX: string;
    overflowY: string;
    overscrollBehaviorBlock: string;
    overscrollBehaviorInline: string;
    overscrollBehaviorX: string;
    overscrollBehaviorY: string;
    floodOpacity: string;
    opacity: string;
    shapeImageThreshold: string;
    stopOpacity: string;
    borderBlockEndStyle: string;
    borderBlockStartStyle: string;
    borderBottomStyle: string;
    borderInlineEndStyle: string;
    borderInlineStartStyle: string;
    borderLeftStyle: string;
    borderRightStyle: string;
    borderTopStyle: string;
    columnRuleStyle: string;
    animationDelay: string;
    animationDirection: string;
    animationDuration: string;
    animationFillMode: string;
    animationIterationCount: string;
    animationName: string;
    animationPlayState: string;
    animationTimingFunction: string;
    backdropFilter: string;
    backgroundAttachment: string;
    backgroundBlendMode: string;
    backgroundClip: string;
    backgroundImage: string;
    backgroundOrigin: string;
    backgroundPositionX: string;
    backgroundPositionY: string;
    backgroundRepeat: string;
    backgroundSize: string;
    borderImageOutset: string;
    borderImageSlice: string;
    borderImageSource: string;
    borderImageWidth: string;
    borderSpacing: string;
    boxShadow: string;
    caretColor: string;
    clipPath: string;
    color: string;
    columnWidth: string;
    content: string;
    counterIncrement: string;
    cursor: string;
    filter: string;
    flexBasis: string;
    fontFamily: string;
    fontFeatureSettings: string;
    fontLanguageOverride: string;
    fontSize: string;
    fontVariantAlternates: string;
    fontVariationSettings: string;
    gridTemplateAreas: string;
    letterSpacing: string;
    lineHeight: string;
    listStyleImage: string;
    listStyleType: string;
    maskClip: string;
    maskComposite: string;
    maskImage: string;
    maskMode: string;
    maskOrigin: string;
    maskPositionX: string;
    maskPositionY: string;
    maskRepeat: string;
    maskSize: string;
    MozTabSize: string;
    offsetAnchor: string;
    offsetPath: string;
    perspective: string;
    quotes: string;
    rotate: string;
    scale: string;
    scrollbarColor: string;
    shapeOutside: string;
    strokeDasharray: string;
    strokeDashoffset: string;
    strokeWidth: string;
    textEmphasisStyle: string;
    textOverflow: string;
    textShadow: string;
    transitionDelay: string;
    transitionDuration: string;
    transitionProperty: string;
    transitionTimingFunction: string;
    translate: string;
    verticalAlign: string;
    willChange: string;
    wordSpacing: string;
    clip: string;
    MozImageRegion: string;
    objectPosition: string;
    perspectiveOrigin: string;
    fill: string;
    stroke: string;
    transformOrigin: string;
    counterReset: string;
    counterSet: string;
    gridTemplateColumns: string;
    gridTemplateRows: string;
    gridAutoColumns: string;
    gridAutoRows: string;
    textDecorationThickness: string;
    textUnderlineOffset: string;
    transform: string;
    columnGap: string;
    rowGap: string;
    markerEnd: string;
    markerMid: string;
    markerStart: string;
    gridColumnEnd: string;
    gridColumnStart: string;
    gridRowEnd: string;
    gridRowStart: string;
    maxBlockSize: string;
    maxHeight: string;
    maxInlineSize: string;
    maxWidth: string;
    cx: string;
    cy: string;
    offsetDistance: string;
    textIndent: string;
    x: string;
    y: string;
    blockSize: string;
    height: string;
    inlineSize: string;
    minBlockSize: string;
    minHeight: string;
    minInlineSize: string;
    minWidth: string;
    width: string;
    outlineOffset: string;
    scrollMarginBlockEnd: string;
    scrollMarginBlockStart: string;
    scrollMarginBottom: string;
    scrollMarginInlineEnd: string;
    scrollMarginInlineStart: string;
    scrollMarginLeft: string;
    scrollMarginRight: string;
    scrollMarginTop: string;
    paddingBlockEnd: string;
    paddingBlockStart: string;
    paddingBottom: string;
    paddingInlineEnd: string;
    paddingInlineStart: string;
    paddingLeft: string;
    paddingRight: string;
    paddingTop: string;
    r: string;
    shapeMargin: string;
    rx: string;
    ry: string;
    scrollPaddingBlockEnd: string;
    scrollPaddingBlockStart: string;
    scrollPaddingBottom: string;
    scrollPaddingInlineEnd: string;
    scrollPaddingInlineStart: string;
    scrollPaddingLeft: string;
    scrollPaddingRight: string;
    scrollPaddingTop: string;
    borderBlockEndWidth: string;
    borderBlockStartWidth: string;
    borderBottomWidth: string;
    borderInlineEndWidth: string;
    borderInlineStartWidth: string;
    borderLeftWidth: string;
    borderRightWidth: string;
    borderTopWidth: string;
    columnRuleWidth: string;
    outlineWidth: string;
    webkitTextStrokeWidth: string;
    borderBottomLeftRadius: string;
    borderBottomRightRadius: string;
    borderEndEndRadius: string;
    borderEndStartRadius: string;
    borderStartEndRadius: string;
    borderStartStartRadius: string;
    borderTopLeftRadius: string;
    borderTopRightRadius: string;
    MozOutlineRadiusBottomleft: string;
    MozOutlineRadiusBottomright: string;
    MozOutlineRadiusTopleft: string;
    MozOutlineRadiusTopright: string;
    bottom: string;
    insetBlockEnd: string;
    insetBlockStart: string;
    insetInlineEnd: string;
    insetInlineStart: string;
    left: string;
    marginBlockEnd: string;
    marginBlockStart: string;
    marginBottom: string;
    marginInlineEnd: string;
    marginInlineStart: string;
    marginLeft: string;
    marginRight: string;
    marginTop: string;
    right: string;
    top: string;
    backgroundColor: string;
    borderBlockEndColor: string;
    borderBlockStartColor: string;
    borderBottomColor: string;
    borderInlineEndColor: string;
    borderInlineStartColor: string;
    borderLeftColor: string;
    borderRightColor: string;
    borderTopColor: string;
    columnRuleColor: string;
    floodColor: string;
    lightingColor: string;
    outlineColor: string;
    stopColor: string;
    textDecorationColor: string;
    textEmphasisColor: string;
    webkitTextFillColor: string;
    webkitTextStrokeColor: string;
    background: string;
    backgroundPosition: string;
    borderColor: string;
    borderStyle: string;
    borderWidth: string;
    borderTop: string;
    borderRight: string;
    borderBottom: string;
    borderLeft: string;
    borderBlockStart: string;
    borderBlockEnd: string;
    borderInlineStart: string;
    borderInlineEnd: string;
    border: string;
    borderRadius: string;
    borderImage: string;
    borderBlockWidth: string;
    borderBlockStyle: string;
    borderBlockColor: string;
    borderInlineWidth: string;
    borderInlineStyle: string;
    borderInlineColor: string;
    borderBlock: string;
    borderInline: string;
    overflow: string;
    overflowClipBox: string;
    transition: string;
    animation: string;
    overscrollBehavior: string;
    pageBreakBefore: string;
    pageBreakAfter: string;
    offset: string;
    zoom: string;
    columns: string;
    columnRule: string;
    font: string;
    fontVariant: string;
    marker: string;
    textEmphasis: string;
    webkitTextStroke: string;
    listStyle: string;
    margin: string;
    marginBlock: string;
    marginInline: string;
    scrollMargin: string;
    scrollMarginBlock: string;
    scrollMarginInline: string;
    outline: string;
    MozOutlineRadius: string;
    padding: string;
    paddingBlock: string;
    paddingInline: string;
    scrollPadding: string;
    scrollPaddingBlock: string;
    scrollPaddingInline: string;
    flexFlow: string;
    flex: string;
    gap: string;
    gridRow: string;
    gridColumn: string;
    gridArea: string;
    gridTemplate: string;
    grid: string;
    placeContent: string;
    placeSelf: string;
    placeItems: string;
    inset: string;
    insetBlock: string;
    insetInline: string;
    mask: string;
    maskPosition: string;
    textDecoration: string;
    all: string;
    webkitBackgroundClip: string;
    webkitBackgroundOrigin: string;
    webkitBackgroundSize: string;
    MozBorderStartColor: string;
    MozBorderStartStyle: string;
    MozBorderStartWidth: string;
    MozBorderEndColor: string;
    MozBorderEndStyle: string;
    MozBorderEndWidth: string;
    webkitBorderTopLeftRadius: string;
    webkitBorderTopRightRadius: string;
    webkitBorderBottomRightRadius: string;
    webkitBorderBottomLeftRadius: string;
    MozTransitionDuration: string;
    webkitTransitionDuration: string;
    MozTransitionTimingFunction: string;
    webkitTransitionTimingFunction: string;
    MozTransitionProperty: string;
    webkitTransitionProperty: string;
    MozTransitionDelay: string;
    webkitTransitionDelay: string;
    MozAnimationName: string;
    webkitAnimationName: string;
    MozAnimationDuration: string;
    webkitAnimationDuration: string;
    MozAnimationTimingFunction: string;
    webkitAnimationTimingFunction: string;
    MozAnimationIterationCount: string;
    webkitAnimationIterationCount: string;
    MozAnimationDirection: string;
    webkitAnimationDirection: string;
    MozAnimationPlayState: string;
    webkitAnimationPlayState: string;
    MozAnimationFillMode: string;
    webkitAnimationFillMode: string;
    MozAnimationDelay: string;
    webkitAnimationDelay: string;
    MozTransform: string;
    webkitTransform: string;
    pageBreakInside: string;
    MozPerspective: string;
    webkitPerspective: string;
    MozPerspectiveOrigin: string;
    webkitPerspectiveOrigin: string;
    MozBackfaceVisibility: string;
    webkitBackfaceVisibility: string;
    MozTransformStyle: string;
    webkitTransformStyle: string;
    MozTransformOrigin: string;
    webkitTransformOrigin: string;
    webkitAppearance: string;
    MozColumnWidth: string;
    MozColumnCount: string;
    MozColumnFill: string;
    MozColumnRuleWidth: string;
    MozColumnRuleColor: string;
    MozColumnSpan: string;
    MozColumnRuleStyle: string;
    webkitBoxShadow: string;
    webkitFilter: string;
    MozFontFeatureSettings: string;
    MozFontLanguageOverride: string;
    MozHyphens: string;
    webkitTextSizeAdjust: string;
    wordWrap: string;
    MozMarginStart: string;
    MozMarginEnd: string;
    MozPaddingStart: string;
    MozPaddingEnd: string;
    offsetBlockStart: string;
    offsetBlockEnd: string;
    offsetInlineStart: string;
    offsetInlineEnd: string;
    webkitFlexDirection: string;
    webkitFlexWrap: string;
    webkitJustifyContent: string;
    webkitAlignContent: string;
    webkitAlignItems: string;
    webkitFlexGrow: string;
    webkitFlexShrink: string;
    webkitAlignSelf: string;
    webkitOrder: string;
    webkitFlexBasis: string;
    MozBoxSizing: string;
    webkitBoxSizing: string;
    gridColumnGap: string;
    MozColumnGap: string;
    gridRowGap: string;
    webkitMaskRepeat: string;
    webkitMaskPositionX: string;
    webkitMaskPositionY: string;
    webkitMaskClip: string;
    webkitMaskOrigin: string;
    webkitMaskSize: string;
    webkitMaskComposite: string;
    webkitMaskImage: string;
    MozUserSelect: string;
    webkitUserSelect: string;
    webkitBoxAlign: string;
    webkitBoxDirection: string;
    webkitBoxFlex: string;
    webkitBoxOrient: string;
    webkitBoxPack: string;
    webkitBoxOrdinalGroup: string;
    MozBorderStart: string;
    MozBorderEnd: string;
    webkitBorderRadius: string;
    MozBorderImage: string;
    webkitBorderImage: string;
    MozTransition: string;
    webkitTransition: string;
    MozAnimation: string;
    webkitAnimation: string;
    MozColumns: string;
    MozColumnRule: string;
    webkitFlexFlow: string;
    webkitFlex: string;
    gridGap: string;
    webkitMask: string;
    webkitMaskPosition: string;
  }
  class MozQueryInterface {
    __legacycaller(aIID: any): any;
  }
  enum WebIDLProcType {
    Web = "web",
    File = "file",
    Extension = "extension",
    Privilegedabout = "privilegedabout",
    WebLargeAllocation = "webLargeAllocation",
    Browser = "browser",
    Plugin = "plugin",
    IpdlUnitTest = "ipdlUnitTest",
    GmpPlugin = "gmpPlugin",
    Gpu = "gpu",
    Vr = "vr",
    Rdd = "rdd",
    Socket = "socket",
    RemoteSandboxBroker = "remoteSandboxBroker",
    Unknown = "unknown",
  }
  interface ThreadInfoDictionary {
    cpuKernel?: number
    cpuUser?: number
    name?: string
    tid?: number
  }
  interface ChildProcInfoDictionary {
    ChildID?: number
    cpuKernel?: number
    cpuUser?: number
    filename?: string
    pid?: number
    residentSetSize?: number
    threads?: ThreadInfoDictionary[]
    type?: WebIDLProcType
    virtualMemorySize?: number
  }
  interface ParentProcInfoDictionary {
    children?: ChildProcInfoDictionary[]
    cpuKernel?: number
    cpuUser?: number
    filename?: string
    pid?: number
    residentSetSize?: number
    threads?: ThreadInfoDictionary[]
    type?: WebIDLProcType
    virtualMemorySize?: number
  }
  interface MediaMemoryInfoDictionary {
    audioSize?: number
    resourcesSize?: number
    videoSize?: number
  }
  interface MemoryInfoDictionary {
    GCHeapUsage?: number
    domDom?: number
    domOther?: number
    domStyle?: number
    media: MediaMemoryInfoDictionary
  }
  interface CategoryDispatchDictionary {
    category?: number
    count?: number
  }
  interface PerformanceInfoDictionary {
    counterId?: number
    duration?: number
    host?: string
    isTopLevel?: boolean
    isWorker?: boolean
    items?: CategoryDispatchDictionary[]
    memoryInfo: MemoryInfoDictionary
    pid?: number
    windowId?: number
  }
  interface IOActivityDataDictionary {
    location?: string
    rx?: number
    tx?: number
  }
  interface OriginAttributesDictionary {
    firstPartyDomain?: string
    geckoViewSessionContextId?: string
    inIsolatedMozBrowser?: boolean
    privateBrowsingId?: number
    userContextId?: number
  }
  interface OriginAttributesPatternDictionary {
    firstPartyDomain?: string
    geckoViewSessionContextId?: string
    inIsolatedMozBrowser?: boolean
    privateBrowsingId?: number
    userContextId?: number
  }
  interface CompileScriptOptionsDictionary {
    charset?: string
    hasReturnValue?: boolean
    lazilyParse?: boolean
  }
  interface HeapSnapshotBoundaries {
    debugger?: object
    globals?: object[]
    runtime?: boolean
  }
  interface Base64URLEncodeOptions {
    pad: boolean
  }
  enum Base64URLDecodePadding {
    Require = "require",
    Ignore = "ignore",
    Reject = "reject",
  }
  interface Base64URLDecodeOptions {
    padding: Base64URLDecodePadding
  }
  enum PopupBlockerState {
    OpenAllowed = "openAllowed",
    OpenControlled = "openControlled",
    OpenBlocked = "openBlocked",
    OpenAbused = "openAbused",
    OpenOverridden = "openOverridden",
  }
  enum MediaControlKeysTestEvent {
    Play = "play",
    Pause = "pause",
    PlayPause = "playPause",
    PrevTrack = "prevTrack",
    NextTrack = "nextTrack",
    SeekBackward = "seekBackward",
    SeekForward = "seekForward",
    Stop = "stop",
  }
  class Node {
    readonly nodeType: number;
    readonly nodeName: string;
    readonly baseURI: string | null;
    readonly isConnected: boolean;
    readonly ownerDocument: Document | null;
    getRootNode(options?: GetRootNodeOptions): Node;
    readonly parentNode: Node | null;
    readonly parentElement: Element | null;
    hasChildNodes(): boolean;
    readonly childNodes: NodeList;
    readonly firstChild: Node | null;
    readonly lastChild: Node | null;
    readonly previousSibling: Node | null;
    readonly nextSibling: Node | null;
    nodeValue: string | null;
    textContent: string | null;
    insertBefore(node: Node, child: Node | null): Node;
    appendChild(node: Node): Node;
    replaceChild(node: Node, child: Node): Node;
    removeChild(child: Node): Node;
    normalize(): void;
    cloneNode(deep?: boolean): Node;
    isSameNode(node: Node | null): boolean;
    isEqualNode(node: Node | null): boolean;
    compareDocumentPosition(other: Node): number;
    contains(other: Node | null): boolean;
    lookupPrefix(namespace: string | null): string | null;
    lookupNamespaceURI(prefix: string | null): string | null;
    isDefaultNamespace(namespace: string | null): boolean;
    readonly nodePrincipal: Principal;
    readonly baseURIObject: URI | null;
    generateXPath(): string;
    readonly flattenedTreeParentNode: Node | null;
    readonly containingShadowRoot: ShadowRoot | null;
    readonly isNativeAnonymous: boolean;
    readonly parentFlexElement: Element | null;
    readonly accessibleNode: AccessibleNode | null;
  }
  interface GetRootNodeOptions {
    composed?: boolean
  }
  class TestRenamedInterface {
  }
  class TestCallbackInterface {
    readonly foo: number;
    bar: string;
    doSomething(): void;
    doSomethingElse(arg: string, otherArg: TestInterface): number;
    doSequenceLongArg(arg: number[]): void;
    doSequenceStringArg(arg: string[]): void;
    doRecordLongArg(arg: Record<string, number>): void;
    getSequenceOfLong(): number[];
    getSequenceOfInterfaces(): TestInterface[];
    getNullableSequenceOfInterfaces(): TestInterface[] | null;
    getSequenceOfNullableInterfaces(): TestInterface | null[];
    getNullableSequenceOfNullableInterfaces(): TestInterface | null[] | null;
    getSequenceOfCallbackInterfaces(): TestCallbackInterface[];
    getNullableSequenceOfCallbackInterfaces(): TestCallbackInterface[] | null;
    getSequenceOfNullableCallbackInterfaces(): TestCallbackInterface | null[];
    getNullableSequenceOfNullableCallbackInterfaces(): TestCallbackInterface | null[] | null;
    getRecordOfLong(): Record<string, number>;
    getDictionary(): Dict | null;
    passArrayBuffer(arg: ArrayBuffer): void;
    passNullableArrayBuffer(arg: ArrayBuffer | null): void;
    passOptionalArrayBuffer(arg?: ArrayBuffer): void;
    passOptionalNullableArrayBuffer(arg?: ArrayBuffer | null): void;
    passOptionalNullableArrayBufferWithDefaultValue(arg?: ArrayBuffer | null): void;
    passArrayBufferView(arg: ArrayBufferView): void;
    passInt8Array(arg: Int8Array): void;
    passInt16Array(arg: Int16Array): void;
    passInt32Array(arg: Int32Array): void;
    passUint8Array(arg: Uint8Array): void;
    passUint16Array(arg: Uint16Array): void;
    passUint32Array(arg: Uint32Array): void;
    passUint8ClampedArray(arg: Uint8ClampedArray): void;
    passFloat32Array(arg: Float32Array): void;
    passFloat64Array(arg: Float64Array): void;
    passSequenceOfArrayBuffers(arg: ArrayBuffer[]): void;
    passSequenceOfNullableArrayBuffers(arg: ArrayBuffer | null[]): void;
    passVariadicTypedArray(arg?: Float32Array): void;
    passVariadicNullableTypedArray(arg?: Float32Array | null): void;
    receiveUint8Array(): Uint8Array;
    uint8ArrayAttr: Uint8Array;
    receivePromise(): Promise<void>;
  }
  class TestSingleOperationCallbackInterface {
    doSomething(arg: number, anotherArg: number[]): TestInterface;
  }
  enum TestEnum {
    _ = "1",
    A = "a",
    B = "b",
    ___ = "1-2",
    _d_array = "2d-array",
  }
  function TestCallback(): void;
  function TestTreatAsNullCallback(): void;
  function TestIntegerReturn(): number;
  function TestNullableIntegerReturn(): number | null;
  function TestBooleanReturn(): boolean;
  function TestFloatReturn(): number;
  function TestStringReturn(arg: number): string;
  function TestEnumReturn(): TestEnum;
  function TestInterfaceReturn(): TestInterface;
  function TestNullableInterfaceReturn(): TestInterface | null;
  function TestExternalInterfaceReturn(): TestExternalInterface;
  function TestNullableExternalInterfaceReturn(): TestExternalInterface | null;
  function TestCallbackInterfaceReturn(): TestCallbackInterface;
  function TestNullableCallbackInterfaceReturn(): TestCallbackInterface | null;
  function TestCallbackReturn(): TestCallback;
  function TestNullableCallbackReturn(): TestCallback | null;
  function TestObjectReturn(): object;
  function TestNullableObjectReturn(): object | null;
  function TestTypedArrayReturn(): ArrayBuffer;
  function TestNullableTypedArrayReturn(): ArrayBuffer | null;
  function TestSequenceReturn(): boolean[];
  function TestNullableSequenceReturn(): boolean[] | null;
  function TestIntegerArguments(arg1: number, arg2: number | null, arg3: number[], arg4: number | null[] | null): number[];
  function TestInterfaceArguments(arg1: TestInterface, arg2: TestInterface | null, arg3: TestExternalInterface, arg4: TestExternalInterface | null, arg5: TestCallbackInterface, arg6: TestCallbackInterface | null, arg7: TestInterface[], arg8: TestInterface | null[] | null, arg9: TestExternalInterface[], arg10: TestExternalInterface | null[] | null, arg11: TestCallbackInterface[], arg12: TestCallbackInterface | null[] | null): void;
  function TestStringEnumArguments(myString: string, nullString: string | null, myEnum: TestEnum): void;
  function TestObjectArguments(anObj: object, anotherObj: object | null, buf: ArrayBuffer, buf2: ArrayBuffer | null): void;
  function TestOptionalArguments(aString?: string, something?: object, aSeq?: TestInterface[], anInterface?: TestInterface | null, anotherInterface?: TestInterface, aLong?: number): void;
  function TestVoidConstruction(arg: CustomEventInit): void;
  function TestIntegerConstruction(): number;
  function TestBooleanConstruction(arg1: any, arg2?: any): boolean;
  function TestFloatConstruction(arg1?: object, arg2?: CustomEventInit): number;
  function TestStringConstruction(arg: number | null): string;
  function TestEnumConstruction(arg?: any): TestEnum;
  function TestInterfaceConstruction(): TestInterface;
  function TestExternalInterfaceConstruction(): TestExternalInterface;
  function TestCallbackInterfaceConstruction(): TestCallbackInterface;
  function TestCallbackConstruction(): TestCallback;
  function TestObjectConstruction(): object;
  function TestTypedArrayConstruction(): ArrayBuffer;
  function TestSequenceConstruction(): boolean[];
  class OnlyForUseInConstructor {
  }
  class TestInterface {
    readonly readonlyByte: number;
    writableByte: number;
    passByte(arg: number): void;
    receiveByte(): number;
    passOptionalByte(arg?: number): void;
    passOptionalByteBeforeRequired(arg1?: number, arg2: number): void;
    passOptionalByteWithDefault(arg?: number): void;
    passOptionalByteWithDefaultBeforeRequired(arg1?: number, arg2: number): void;
    passNullableByte(arg: number | null): void;
    passOptionalNullableByte(arg?: number | null): void;
    passVariadicByte(arg?: number): void;
    readonly cachedByte: number;
    readonly cachedConstantByte: number;
    cachedWritableByte: number;
    sideEffectFreeByte: number;
    domDependentByte: number;
    readonly constantByte: number;
    readonly deviceStateDependentByte: number;
    returnByteSideEffectFree(): number;
    returnDOMDependentByte(): number;
    returnConstantByte(): number;
    returnDeviceStateDependentByte(): number;
    readonly readonlyShort: number;
    writableShort: number;
    passShort(arg: number): void;
    receiveShort(): number;
    passOptionalShort(arg?: number): void;
    passOptionalShortWithDefault(arg?: number): void;
    readonly readonlyLong: number;
    writableLong: number;
    passLong(arg: number): void;
    receiveLong(): number;
    passOptionalLong(arg?: number): void;
    passOptionalLongWithDefault(arg?: number): void;
    readonly readonlyLongLong: number;
    writableLongLong: number;
    passLongLong(arg: number): void;
    receiveLongLong(): number;
    passOptionalLongLong(arg?: number): void;
    passOptionalLongLongWithDefault(arg?: number): void;
    readonly readonlyOctet: number;
    writableOctet: number;
    passOctet(arg: number): void;
    receiveOctet(): number;
    passOptionalOctet(arg?: number): void;
    passOptionalOctetWithDefault(arg?: number): void;
    readonly readonlyUnsignedShort: number;
    writableUnsignedShort: number;
    passUnsignedShort(arg: number): void;
    receiveUnsignedShort(): number;
    passOptionalUnsignedShort(arg?: number): void;
    passOptionalUnsignedShortWithDefault(arg?: number): void;
    readonly readonlyUnsignedLong: number;
    writableUnsignedLong: number;
    passUnsignedLong(arg: number): void;
    receiveUnsignedLong(): number;
    passOptionalUnsignedLong(arg?: number): void;
    passOptionalUnsignedLongWithDefault(arg?: number): void;
    readonly readonlyUnsignedLongLong: number;
    writableUnsignedLongLong: number;
    passUnsignedLongLong(arg: number): void;
    receiveUnsignedLongLong(): number;
    passOptionalUnsignedLongLong(arg?: number): void;
    passOptionalUnsignedLongLongWithDefault(arg?: number): void;
    writableFloat: number;
    writableUnrestrictedFloat: number;
    writableNullableFloat: number | null;
    writableNullableUnrestrictedFloat: number | null;
    writableDouble: number;
    writableUnrestrictedDouble: number;
    writableNullableDouble: number | null;
    writableNullableUnrestrictedDouble: number | null;
    passFloat(arg1: number, arg2: number, arg3: number | null, arg4: number | null, arg5: number, arg6: number, arg7: number | null, arg8: number | null, arg9: number[], arg10: number[], arg11: number | null[], arg12: number | null[], arg13: number[], arg14: number[], arg15: number | null[], arg16: number | null[]): void;
    passLenientFloat(arg1: number, arg2: number, arg3: number | null, arg4: number | null, arg5: number, arg6: number, arg7: number | null, arg8: number | null, arg9: number[], arg10: number[], arg11: number | null[], arg12: number | null[], arg13: number[], arg14: number[], arg15: number | null[], arg16: number | null[]): void;
    lenientFloatAttr: number;
    lenientDoubleAttr: number;
    passUnrestricted(arg1?: number, arg2?: number, arg3?: number, arg4?: number, arg5?: number, arg6?: number, arg7?: number, arg8?: number): void;
    receiveSelf(): TestInterface;
    receiveNullableSelf(): TestInterface | null;
    receiveWeakSelf(): TestInterface;
    receiveWeakNullableSelf(): TestInterface | null;
    passSelf(arg: TestInterface): void;
    passNullableSelf(arg: TestInterface | null): void;
    nonNullSelf: TestInterface;
    nullableSelf: TestInterface | null;
    readonly cachedSelf: TestInterface;
    passOptionalSelf(arg?: TestInterface | null): void;
    passOptionalNonNullSelf(arg?: TestInterface): void;
    passOptionalSelfWithDefault(arg?: TestInterface | null): void;
    receiveNonWrapperCacheInterface(): TestNonWrapperCacheInterface;
    receiveNullableNonWrapperCacheInterface(): TestNonWrapperCacheInterface | null;
    receiveNonWrapperCacheInterfaceSequence(): TestNonWrapperCacheInterface[];
    receiveNullableNonWrapperCacheInterfaceSequence(): TestNonWrapperCacheInterface | null[];
    receiveNonWrapperCacheInterfaceNullableSequence(): TestNonWrapperCacheInterface[] | null;
    receiveNullableNonWrapperCacheInterfaceNullableSequence(): TestNonWrapperCacheInterface | null[] | null;
    receiveExternal(): TestExternalInterface;
    receiveNullableExternal(): TestExternalInterface | null;
    receiveWeakExternal(): TestExternalInterface;
    receiveWeakNullableExternal(): TestExternalInterface | null;
    passExternal(arg: TestExternalInterface): void;
    passNullableExternal(arg: TestExternalInterface | null): void;
    nonNullExternal: TestExternalInterface;
    nullableExternal: TestExternalInterface | null;
    passOptionalExternal(arg?: TestExternalInterface | null): void;
    passOptionalNonNullExternal(arg?: TestExternalInterface): void;
    passOptionalExternalWithDefault(arg?: TestExternalInterface | null): void;
    receiveCallbackInterface(): TestCallbackInterface;
    receiveNullableCallbackInterface(): TestCallbackInterface | null;
    receiveWeakCallbackInterface(): TestCallbackInterface;
    receiveWeakNullableCallbackInterface(): TestCallbackInterface | null;
    passCallbackInterface(arg: TestCallbackInterface): void;
    passNullableCallbackInterface(arg: TestCallbackInterface | null): void;
    nonNullCallbackInterface: TestCallbackInterface;
    nullableCallbackInterface: TestCallbackInterface | null;
    passOptionalCallbackInterface(arg?: TestCallbackInterface | null): void;
    passOptionalNonNullCallbackInterface(arg?: TestCallbackInterface): void;
    passOptionalCallbackInterfaceWithDefault(arg?: TestCallbackInterface | null): void;
    readonly readonlySequence: number[];
    readonly readonlySequenceOfDictionaries: Dict[];
    readonly readonlyNullableSequenceOfDictionaries: Dict[] | null;
    readonly readonlyFrozenSequence: Dict[];
    readonly readonlyFrozenNullableSequence: Dict[] | null;
    receiveSequence(): number[];
    receiveNullableSequence(): number[] | null;
    receiveSequenceOfNullableInts(): number | null[];
    receiveNullableSequenceOfNullableInts(): number | null[] | null;
    passSequence(arg: number[]): void;
    passNullableSequence(arg: number[] | null): void;
    passSequenceOfNullableInts(arg: number | null[]): void;
    passOptionalSequenceOfNullableInts(arg?: number | null[]): void;
    passOptionalNullableSequenceOfNullableInts(arg?: number | null[] | null): void;
    receiveCastableObjectSequence(): TestInterface[];
    receiveCallbackObjectSequence(): TestCallbackInterface[];
    receiveNullableCastableObjectSequence(): TestInterface | null[];
    receiveNullableCallbackObjectSequence(): TestCallbackInterface | null[];
    receiveCastableObjectNullableSequence(): TestInterface[] | null;
    receiveNullableCastableObjectNullableSequence(): TestInterface | null[] | null;
    receiveWeakCastableObjectSequence(): TestInterface[];
    receiveWeakNullableCastableObjectSequence(): TestInterface | null[];
    receiveWeakCastableObjectNullableSequence(): TestInterface[] | null;
    receiveWeakNullableCastableObjectNullableSequence(): TestInterface | null[] | null;
    passCastableObjectSequence(arg: TestInterface[]): void;
    passNullableCastableObjectSequence(arg: TestInterface | null[]): void;
    passCastableObjectNullableSequence(arg: TestInterface[] | null): void;
    passNullableCastableObjectNullableSequence(arg: TestInterface | null[] | null): void;
    passOptionalSequence(arg?: number[]): void;
    passOptionalSequenceWithDefaultValue(arg?: number[]): void;
    passOptionalNullableSequence(arg?: number[] | null): void;
    passOptionalNullableSequenceWithDefaultValue(arg?: number[] | null): void;
    passOptionalNullableSequenceWithDefaultValue2(arg?: number[] | null): void;
    passOptionalObjectSequence(arg?: TestInterface[]): void;
    passExternalInterfaceSequence(arg: TestExternalInterface[]): void;
    passNullableExternalInterfaceSequence(arg: TestExternalInterface | null[]): void;
    receiveStringSequence(): string[];
    passStringSequence(arg: string[]): void;
    receiveByteStringSequence(): string[];
    passByteStringSequence(arg: string[]): void;
    receiveUTF8StringSequence(): string[];
    passUTF8StringSequence(arg: string[]): void;
    receiveAnySequence(): any[];
    receiveNullableAnySequence(): any[] | null;
    receiveAnySequenceSequence(): any[][];
    receiveObjectSequence(): object[];
    receiveNullableObjectSequence(): object | null[];
    passSequenceOfSequences(arg: number[][]): void;
    passSequenceOfSequencesOfSequences(arg: number[][][]): void;
    receiveSequenceOfSequences(): number[][];
    receiveSequenceOfSequencesOfSequences(): number[][][];
    passRecord(arg: Record<string, number>): void;
    passNullableRecord(arg: Record<string, number> | null): void;
    passRecordOfNullableInts(arg: Record<string, number | null>): void;
    passOptionalRecordOfNullableInts(arg?: Record<string, number | null>): void;
    passOptionalNullableRecordOfNullableInts(arg?: Record<string, number | null> | null): void;
    passCastableObjectRecord(arg: Record<string, TestInterface>): void;
    passNullableCastableObjectRecord(arg: Record<string, TestInterface | null>): void;
    passCastableObjectNullableRecord(arg: Record<string, TestInterface> | null): void;
    passNullableCastableObjectNullableRecord(arg: Record<string, TestInterface | null> | null): void;
    passOptionalRecord(arg?: Record<string, number>): void;
    passOptionalNullableRecord(arg?: Record<string, number> | null): void;
    passOptionalNullableRecordWithDefaultValue(arg?: Record<string, number> | null): void;
    passOptionalObjectRecord(arg?: Record<string, TestInterface>): void;
    passExternalInterfaceRecord(arg: Record<string, TestExternalInterface>): void;
    passNullableExternalInterfaceRecord(arg: Record<string, TestExternalInterface | null>): void;
    passStringRecord(arg: Record<string, string>): void;
    passByteStringRecord(arg: Record<string, string>): void;
    passUTF8StringRecord(arg: Record<string, string>): void;
    passRecordOfRecords(arg: Record<string, Record<string, number>>): void;
    receiveRecord(): Record<string, number>;
    receiveNullableRecord(): Record<string, number> | null;
    receiveRecordOfNullableInts(): Record<string, number | null>;
    receiveNullableRecordOfNullableInts(): Record<string, number | null> | null;
    receiveRecordOfRecords(): Record<string, Record<string, number>>;
    receiveAnyRecord(): Record<string, any>;
    passArrayBuffer(arg: ArrayBuffer): void;
    passNullableArrayBuffer(arg: ArrayBuffer | null): void;
    passOptionalArrayBuffer(arg?: ArrayBuffer): void;
    passOptionalNullableArrayBuffer(arg?: ArrayBuffer | null): void;
    passOptionalNullableArrayBufferWithDefaultValue(arg?: ArrayBuffer | null): void;
    passArrayBufferView(arg: ArrayBufferView): void;
    passInt8Array(arg: Int8Array): void;
    passInt16Array(arg: Int16Array): void;
    passInt32Array(arg: Int32Array): void;
    passUint8Array(arg: Uint8Array): void;
    passUint16Array(arg: Uint16Array): void;
    passUint32Array(arg: Uint32Array): void;
    passUint8ClampedArray(arg: Uint8ClampedArray): void;
    passFloat32Array(arg: Float32Array): void;
    passFloat64Array(arg: Float64Array): void;
    passSequenceOfArrayBuffers(arg: ArrayBuffer[]): void;
    passSequenceOfNullableArrayBuffers(arg: ArrayBuffer | null[]): void;
    passRecordOfArrayBuffers(arg: Record<string, ArrayBuffer>): void;
    passRecordOfNullableArrayBuffers(arg: Record<string, ArrayBuffer | null>): void;
    passVariadicTypedArray(arg?: Float32Array): void;
    passVariadicNullableTypedArray(arg?: Float32Array | null): void;
    receiveUint8Array(): Uint8Array;
    uint8ArrayAttr: Uint8Array;
    passString(arg: string): void;
    passNullableString(arg: string | null): void;
    passOptionalString(arg?: string): void;
    passOptionalStringWithDefaultValue(arg?: string): void;
    passOptionalNullableString(arg?: string | null): void;
    passOptionalNullableStringWithDefaultValue(arg?: string | null): void;
    passVariadicString(arg?: string): void;
    receiveString(): string;
    passByteString(arg: string): void;
    passNullableByteString(arg: string | null): void;
    passOptionalByteString(arg?: string): void;
    passOptionalByteStringWithDefaultValue(arg?: string): void;
    passOptionalNullableByteString(arg?: string | null): void;
    passOptionalNullableByteStringWithDefaultValue(arg?: string | null): void;
    passVariadicByteString(arg?: string): void;
    passOptionalUnionByteString(arg?: string | number): void;
    passOptionalUnionByteStringWithDefaultValue(arg?: string | number): void;
    passUTF8String(arg: string): void;
    passNullableUTF8String(arg: string | null): void;
    passOptionalUTF8String(arg?: string): void;
    passOptionalUTF8StringWithDefaultValue(arg?: string): void;
    passOptionalNullableUTF8String(arg?: string | null): void;
    passOptionalNullableUTF8StringWithDefaultValue(arg?: string | null): void;
    passVariadicUTF8String(arg?: string): void;
    passOptionalUnionUTF8String(arg?: string | number): void;
    passOptionalUnionUTF8StringWithDefaultValue(arg?: string | number): void;
    passUSVS(arg: string): void;
    passNullableUSVS(arg: string | null): void;
    passOptionalUSVS(arg?: string): void;
    passOptionalUSVSWithDefaultValue(arg?: string): void;
    passOptionalNullableUSVS(arg?: string | null): void;
    passOptionalNullableUSVSWithDefaultValue(arg?: string | null): void;
    passVariadicUSVS(arg?: string): void;
    receiveUSVS(): string;
    passJSString(arg: string): void;
    passOptionalJSStringWithDefaultValue(arg?: string): void;
    receiveJSString(): string;
    readonly readonlyJSStringAttr: string;
    jsStringAttr: string;
    passEnum(arg: TestEnum): void;
    passNullableEnum(arg: TestEnum | null): void;
    passOptionalEnum(arg?: TestEnum): void;
    passEnumWithDefault(arg?: TestEnum): void;
    passOptionalNullableEnum(arg?: TestEnum | null): void;
    passOptionalNullableEnumWithDefaultValue(arg?: TestEnum | null): void;
    passOptionalNullableEnumWithDefaultValue2(arg?: TestEnum | null): void;
    receiveEnum(): TestEnum;
    receiveNullableEnum(): TestEnum | null;
    enumAttribute: TestEnum;
    readonly readonlyEnumAttribute: TestEnum;
    passCallback(arg: TestCallback): void;
    passNullableCallback(arg: TestCallback | null): void;
    passOptionalCallback(arg?: TestCallback): void;
    passOptionalNullableCallback(arg?: TestCallback | null): void;
    passOptionalNullableCallbackWithDefaultValue(arg?: TestCallback | null): void;
    receiveCallback(): TestCallback;
    receiveNullableCallback(): TestCallback | null;
    passNullableTreatAsNullCallback(arg: TestTreatAsNullCallback | null): void;
    passOptionalNullableTreatAsNullCallback(arg?: TestTreatAsNullCallback | null): void;
    passOptionalNullableTreatAsNullCallbackWithDefaultValue(arg?: TestTreatAsNullCallback | null): void;
    treatAsNullCallback: TestTreatAsNullCallback;
    nullableTreatAsNullCallback: TestTreatAsNullCallback | null;
    forceCallbackGeneration(arg1: TestIntegerReturn, arg2: TestNullableIntegerReturn, arg3: TestBooleanReturn, arg4: TestFloatReturn, arg5: TestStringReturn, arg6: TestEnumReturn, arg7: TestInterfaceReturn, arg8: TestNullableInterfaceReturn, arg9: TestExternalInterfaceReturn, arg10: TestNullableExternalInterfaceReturn, arg11: TestCallbackInterfaceReturn, arg12: TestNullableCallbackInterfaceReturn, arg13: TestCallbackReturn, arg14: TestNullableCallbackReturn, arg15: TestObjectReturn, arg16: TestNullableObjectReturn, arg17: TestTypedArrayReturn, arg18: TestNullableTypedArrayReturn, arg19: TestSequenceReturn, arg20: TestNullableSequenceReturn, arg21: TestIntegerArguments, arg22: TestInterfaceArguments, arg23: TestStringEnumArguments, arg24: TestObjectArguments, arg25: TestOptionalArguments, arg26: TestVoidConstruction, arg27: TestIntegerConstruction, arg28: TestBooleanConstruction, arg29: TestFloatConstruction, arg30: TestStringConstruction, arg31: TestEnumConstruction, arg32: TestInterfaceConstruction, arg33: TestExternalInterfaceConstruction, arg34: TestCallbackInterfaceConstruction, arg35: TestCallbackConstruction, arg36: TestObjectConstruction, arg37: TestTypedArrayConstruction, arg38: TestSequenceConstruction): void;
    passAny(arg: any): void;
    passVariadicAny(arg?: any): void;
    passOptionalAny(arg?: any): void;
    passAnyDefaultNull(arg?: any): void;
    passSequenceOfAny(arg: any[]): void;
    passNullableSequenceOfAny(arg: any[] | null): void;
    passOptionalSequenceOfAny(arg?: any[]): void;
    passOptionalNullableSequenceOfAny(arg?: any[] | null): void;
    passOptionalSequenceOfAnyWithDefaultValue(arg?: any[] | null): void;
    passSequenceOfSequenceOfAny(arg: any[][]): void;
    passSequenceOfNullableSequenceOfAny(arg: any[] | null[]): void;
    passNullableSequenceOfNullableSequenceOfAny(arg: any[] | null[] | null): void;
    passOptionalNullableSequenceOfNullableSequenceOfAny(arg?: any[] | null[] | null): void;
    passRecordOfAny(arg: Record<string, any>): void;
    passNullableRecordOfAny(arg: Record<string, any> | null): void;
    passOptionalRecordOfAny(arg?: Record<string, any>): void;
    passOptionalNullableRecordOfAny(arg?: Record<string, any> | null): void;
    passOptionalRecordOfAnyWithDefaultValue(arg?: Record<string, any> | null): void;
    passRecordOfRecordOfAny(arg: Record<string, Record<string, any>>): void;
    passRecordOfNullableRecordOfAny(arg: Record<string, Record<string, any> | null>): void;
    passNullableRecordOfNullableRecordOfAny(arg: Record<string, Record<string, any> | null> | null): void;
    passOptionalNullableRecordOfNullableRecordOfAny(arg?: Record<string, Record<string, any> | null> | null): void;
    passOptionalNullableRecordOfNullableSequenceOfAny(arg?: Record<string, any[] | null> | null): void;
    passOptionalNullableSequenceOfNullableRecordOfAny(arg?: Record<string, any> | null[] | null): void;
    receiveAny(): any;
    passObject(arg: object): void;
    passVariadicObject(arg?: object): void;
    passNullableObject(arg: object | null): void;
    passVariadicNullableObject(arg?: object): void;
    passOptionalObject(arg?: object): void;
    passOptionalNullableObject(arg?: object | null): void;
    passOptionalNullableObjectWithDefaultValue(arg?: object | null): void;
    passSequenceOfObject(arg: object[]): void;
    passSequenceOfNullableObject(arg: object | null[]): void;
    passNullableSequenceOfObject(arg: object[] | null): void;
    passOptionalNullableSequenceOfNullableSequenceOfObject(arg?: object[] | null[] | null): void;
    passOptionalNullableSequenceOfNullableSequenceOfNullableObject(arg?: object | null[] | null[] | null): void;
    passRecordOfObject(arg: Record<string, object>): void;
    receiveObject(): object;
    receiveNullableObject(): object | null;
    passUnion(arg: object | number): void;
    passUnionWithNullable(arg: object | null | number): void;
    passNullableUnion(arg: object | number | null): void;
    passOptionalUnion(arg?: object | number): void;
    passOptionalNullableUnion(arg?: object | number | null): void;
    passOptionalNullableUnionWithDefaultValue(arg?: object | number | null): void;
    passUnionWithArrayBuffer(arg: ArrayBuffer | number): void;
    passUnionWithString(arg: string | object): void;
    passUnionWithEnum(arg: SupportedType | object): void;
    passUnionWithObject(arg: object | number): void;
    passUnionWithDefaultValue1(arg?: number | string): void;
    passUnionWithDefaultValue2(arg?: number | string): void;
    passUnionWithDefaultValue3(arg?: number | string): void;
    passUnionWithDefaultValue4(arg?: number | string): void;
    passUnionWithDefaultValue5(arg?: number | string): void;
    passUnionWithDefaultValue6(arg?: number | string): void;
    passUnionWithDefaultValue7(arg?: number | string): void;
    passUnionWithDefaultValue8(arg?: number | string): void;
    passUnionWithDefaultValue9(arg?: number | string): void;
    passUnionWithDefaultValue10(arg?: number | string): void;
    passUnionWithDefaultValue11(arg?: number | string): void;
    passUnionWithDefaultValue12(arg?: number | string): void;
    passUnionWithDefaultValue13(arg?: number | string): void;
    passUnionWithDefaultValue14(arg?: number | string): void;
    passUnionWithDefaultValue15(arg?: number | string): void;
    passUnionWithDefaultValue16(arg?: number | string): void;
    passUnionWithDefaultValue17(arg?: number | SupportedType): void;
    passUnionWithDefaultValue18(arg?: number | SupportedType): void;
    passUnionWithDefaultValue19(arg?: number | SupportedType): void;
    passUnionWithDefaultValue20(arg?: number | string): void;
    passUnionWithDefaultValue21(arg?: number | string): void;
    passUnionWithDefaultValue22(arg?: number | string): void;
    passUnionWithDefaultValue23(arg?: number | string): void;
    passUnionWithDefaultValue24(arg?: number | string): void;
    passUnionWithDefaultValue25(arg?: number | string): void;
    passNullableUnionWithDefaultValue1(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue2(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue3(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue4(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue5(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue6(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue7(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue8(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue9(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue10(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue11(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue12(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue13(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue14(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue15(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue16(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue17(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue18(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue19(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue20(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue21(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue22(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue23(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue24(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue25(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue26(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue27(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue28(arg?: number | string | null): void;
    passSequenceOfUnions(arg: CanvasPattern | CanvasGradient[]): void;
    passSequenceOfUnions2(arg: object | number[]): void;
    passVariadicUnion(arg?: CanvasPattern | CanvasGradient): void;
    passSequenceOfNullableUnions(arg: CanvasPattern | CanvasGradient | null[]): void;
    passVariadicNullableUnion(arg?: CanvasPattern | CanvasGradient | null): void;
    passRecordOfUnions(arg: Record<string, CanvasPattern | CanvasGradient>): void;
    receiveUnion(): CanvasPattern | CanvasGradient;
    receiveUnion2(): object | number;
    receiveUnionContainingNull(): CanvasPattern | null | CanvasGradient;
    receiveNullableUnion(): CanvasPattern | CanvasGradient | null;
    receiveNullableUnion2(): object | number | null;
    writableUnion: CanvasPattern | CanvasGradient;
    writableUnionContainingNull: CanvasPattern | null | CanvasGradient;
    writableNullableUnion: CanvasPattern | CanvasGradient | null;
    passDate(arg: Date): void;
    passNullableDate(arg: Date | null): void;
    passOptionalDate(arg?: Date): void;
    passOptionalNullableDate(arg?: Date | null): void;
    passOptionalNullableDateWithDefaultValue(arg?: Date | null): void;
    passDateSequence(arg: Date[]): void;
    passNullableDateSequence(arg: Date | null[]): void;
    passDateRecord(arg: Record<string, Date>): void;
    receiveDate(): Date;
    receiveNullableDate(): Date | null;
    passPromise(arg: Promise<any>): void;
    passOptionalPromise(arg?: Promise<any>): void;
    passPromiseSequence(arg: Promise<any>[]): void;
    receivePromise(): Promise<any>;
    receiveAddrefedPromise(): Promise<any>;
    methodRenamedFrom(): void;
    methodRenamedFrom(argument: number): void;
    readonly attributeGetterRenamedFrom: number;
    attributeRenamedFrom: number;
    passDictionary(x?: Dict): void;
    passDictionary2(x: Dict): void;
    readonly readonlyDictionary: Dict;
    readonly readonlyNullableDictionary: Dict | null;
    writableDictionary: Dict;
    readonly readonlyFrozenDictionary: Dict;
    readonly readonlyFrozenNullableDictionary: Dict | null;
    writableFrozenDictionary: Dict;
    receiveDictionary(): Dict;
    receiveNullableDictionary(): Dict | null;
    passOtherDictionary(x?: GrandparentDict): void;
    passSequenceOfDictionaries(x: Dict[]): void;
    passRecordOfDictionaries(x: Record<string, GrandparentDict>): void;
    passDictionaryOrLong(x?: Dict): void;
    passDictionaryOrLong(x: number): void;
    passDictContainingDict(arg?: DictContainingDict): void;
    passDictContainingSequence(arg?: DictContainingSequence): void;
    receiveDictContainingSequence(): DictContainingSequence;
    passVariadicDictionary(arg?: Dict): void;
    dontEnforceRangeOrClamp(arg: number): void;
    doEnforceRange(arg: number): void;
    doEnforceRangeNullable(arg: number | null): void;
    doClamp(arg: number): void;
    doClampNullable(arg: number | null): void;
    enforcedByte: number;
    enforcedNullableByte: number | null;
    clampedByte: number;
    clampedNullableByte: number | null;
    exerciseTypedefInterfaces1(arg: TestInterface): void;
    exerciseTypedefInterfaces2(arg: TestInterface | null): TestInterface;
    exerciseTypedefInterfaces3(arg: TestInterface): void;
    deprecatedAttribute: number;
    deprecatedMethod(): number;
    deprecatedMethodWithContext(arg: any): number;
    static staticAttribute: boolean;
    staticMethod(arg: boolean): void;
    staticMethodWithContext(arg: any): void;
    assert(arg: boolean): void;
    static staticDeprecatedAttribute: number;
    staticDeprecatedMethod(): void;
    staticDeprecatedMethodWithContext(arg: any): void;
    overload1(arg: TestInterface): boolean;
    overload1(strs: string, arg: TestInterface): TestInterface;
    overload2(arg: TestInterface): void;
    overload2(arg?: Dict): void;
    overload2(arg: boolean): void;
    overload2(arg: string): void;
    overload2(arg: Date): void;
    overload3(arg: TestInterface): void;
    overload3(arg: TestCallback): void;
    overload3(arg: boolean): void;
    overload4(arg: TestInterface): void;
    overload4(arg: TestCallbackInterface): void;
    overload4(arg: string): void;
    overload5(arg: number): void;
    overload5(arg: TestEnum): void;
    overload6(arg: number): void;
    overload6(arg: boolean): void;
    overload7(arg: number): void;
    overload7(arg: boolean): void;
    overload7(arg: string): void;
    overload8(arg: number): void;
    overload8(arg: TestInterface): void;
    overload9(arg: number | null): void;
    overload9(arg: string): void;
    overload10(arg: number | null): void;
    overload10(arg: object): void;
    overload11(arg: number): void;
    overload11(arg: string | null): void;
    overload12(arg: number): void;
    overload12(arg: boolean | null): void;
    overload13(arg: number | null): void;
    overload13(arg: boolean): void;
    overload14(arg?: number): void;
    overload14(arg: TestInterface): void;
    overload15(arg: number): void;
    overload15(arg?: TestInterface): void;
    overload16(arg: number): void;
    overload16(arg?: TestInterface | null): void;
    overload17(arg: number[]): void;
    overload17(arg: Record<string, number>): void;
    overload18(arg: Record<string, string>): void;
    overload18(arg: string[]): void;
    overload19(arg: number[]): void;
    overload19(arg?: Dict): void;
    overload20(arg?: Dict): void;
    overload20(arg: number[]): void;
    passVariadicThirdArg(arg1: string, arg2: number, arg3?: TestInterface): void;
    readonly prefable1: boolean;
    readonly prefable2: boolean;
    readonly prefable3: boolean;
    readonly prefable4: boolean;
    readonly prefable5: boolean;
    readonly prefable6: boolean;
    readonly prefable7: boolean;
    readonly prefable8: boolean;
    readonly prefable9: boolean;
    prefable10(): void;
    prefable11(): void;
    readonly prefable12: boolean;
    prefable13(): void;
    readonly prefable14: boolean;
    readonly prefable15: boolean;
    readonly prefable16: boolean;
    prefable17(): void;
    prefable18(): void;
    prefable19(): void;
    prefable20(): void;
    readonly conditionalOnSecureContext1: boolean;
    readonly conditionalOnSecureContext2: boolean;
    readonly conditionalOnSecureContext3: boolean;
    readonly conditionalOnSecureContext4: boolean;
    conditionalOnSecureContext5(): void;
    conditionalOnSecureContext6(): void;
    conditionalOnSecureContext7(): void;
    conditionalOnSecureContext8(): void;
    attrWithLenientThis: number;
    readonly unforgeableAttr: number;
    readonly unforgeableAttr2: number;
    unforgeableMethod(): number;
    unforgeableMethod2(): number;
    __stringifier(): string;
    passRenamedInterface(arg: TestRenamedInterface): void;
    readonly putForwardsAttr: TestInterface;
    readonly putForwardsAttr2: TestInterface;
    readonly putForwardsAttr3: TestInterface;
    throwingMethod(): void;
    throwingAttr: boolean;
    throwingGetterAttr: boolean;
    throwingSetterAttr: boolean;
    canOOMMethod(): void;
    canOOMAttr: boolean;
    canOOMGetterAttr: boolean;
    canOOMSetterAttr: boolean;
    needsSubjectPrincipalMethod(): void;
    needsSubjectPrincipalAttr: boolean;
    needsCallerTypeMethod(): void;
    needsCallerTypeAttr: boolean;
    needsNonSystemSubjectPrincipalMethod(): void;
    needsNonSystemSubjectPrincipalAttr: boolean;
    ceReactionsMethod(): void;
    ceReactionsMethodOverload(): void;
    ceReactionsMethodOverload(bar: string): void;
    ceReactionsAttr: boolean;
    __legacycaller(arg1: number, arg2: TestInterface): number;
    passArgsWithDefaults(arg1?: number, arg2?: TestInterface | null, arg3?: Dict, arg4?: number, arg5?: number): void;
    toJSONShouldSkipThis: any;
    toJSONShouldSkipThis2: TestParentInterface;
    toJSONShouldSkipThis3: TestCallbackInterface;
    toJSON(): object;
    "dashed-attribute": number;
    "dashed-method"(): void;
    nonEnumerableAttr: boolean;
    nonEnumerableMethod(): void;
    mixedInMethod(): void;
    mixedInProperty: boolean;
  }
  class TestParentInterface {
  }
  class TestChildInterface {
  }
  class TestNonWrapperCacheInterface {
  }
  interface Dict {
    a?: number
    anotherAny?: any
    anotherObj?: object | null
    arrayBuffer?: ArrayBuffer
    b?: number
    byteStr?: string
    byteStringRecord?: Record<string, number>
    clampedUnsignedLong?: number
    customEventInit?: CustomEventInit
    "dashed-name"?: number
    dictionaryTypedef?: CustomEventInit
    empty?: string
    emptyByteStr?: string
    enforcedUnsignedLong?: number
    float64Array?: Float64Array | null
    floatOrString?: number | string
    infUrDouble?: number
    infUrFloat?: number
    nanUrDouble?: number
    nanUrFloat?: number
    negativeInfUrDouble?: number
    negativeInfUrFloat?: number
    nullableArrayBuffer?: ArrayBuffer | null
    nullableByteStringRecordWithDefault?: Record<string, number> | null
    nullableFloatOrString?: number | string | null
    nullableRecord?: Record<string, number> | null
    nullableRecordWithDefault?: Record<string, string> | null
    nullableUSVStringRecordWithDefault?: Record<string, number> | null
    nullableUTF8StringRecordWithDefault?: Record<string, number> | null
    objectOrLong?: object | number
    otherByteStr?: string
    otherEnum?: TestEnum
    otherStr?: string
    promise?: Promise<void>
    promiseSequence?: Promise<void>[]
    prototype?: boolean
    recordMember?: Record<string, number>
    requiredByteRecord: Record<string, TestInterface>
    requiredLong: number
    requiredObject: object
    requiredRecord: Record<string, TestInterface>
    requiredUSVRecord: Record<string, TestInterface>
    requiredUTF8Record: Record<string, TestInterface>
    seq1?: number[]
    seq2?: number[]
    seq3?: number[] | null
    seq4?: number[] | null
    seq5?: number[] | null
    someAny?: any
    someCallback?: TestCallback | null
    someEnum?: TestEnum
    someObj?: object
    str?: string
    template?: string
    uint8Array?: Uint8Array
    urDouble?: number
    urDouble2?: number
    urDouble3?: number
    urDouble4?: number | null
    urFloat?: number
    urFloat2?: number
    urFloat3?: number
    urFloat4?: number | null
    usvStringRecord?: Record<string, number>
    utf8StringRecord?: Record<string, number>
    x?: number
    yetAnotherStr?: string | null
    z?: number
  }
  interface ParentDict {
    c?: number
    parentAny?: any
    someExternalInterface?: TestExternalInterface
    someInterface?: TestInterface
    someNullableInterface?: TestInterface | null
  }
  interface DictContainingDict {
    memberDict?: Dict
  }
  interface DictContainingSequence {
    ourSequence?: number[]
    ourSequence10?: number | string[]
    ourSequence2?: TestInterface[]
    ourSequence3?: any[]
    ourSequence4?: object[]
    ourSequence5?: object | null[]
    ourSequence6?: object[] | null
    ourSequence7?: object | null[] | null
    ourSequence8?: object[] | null
    ourSequence9?: object | null[] | null
  }
  interface DictForConstructor {
    any1?: any
    dict?: Dict
    dict2?: DictContainingDict
    obj1?: object
    obj2?: object | null
    seq1?: Dict[]
    seq2?: Dict[][] | null
    seq3?: Dict[] | null[]
    seq4?: any[]
    seq5?: any[]
    seq6?: DictContainingSequence[]
  }
  interface DictWithConditionalMembers {
    chromeOnlyFuncAndPrefControlledMember?: number
    chromeOnlyFuncControlledMember?: number
    chromeOnlyMember?: number
    funcControlledMember?: number
    prefControlledMember?: number
  }
  class TestIndexedGetterInterface {
    item(idx: number): number;
    readonly length: number;
    __legacycaller(): void;
    readonly cachedAttr: number;
    readonly storeInSlotAttr: number;
  }
  class TestNamedGetterInterface {
    __namedgetter(name: string): string;
  }
  class TestIndexedGetterAndSetterAndNamedGetterInterface {
    __namedgetter(myName: string): string;
    __indexedgetter(index: number): number;
    __indexedsetter(index: number, arg: number): void;
    readonly length: number;
  }
  class TestIndexedAndNamedGetterInterface {
    __indexedgetter(index: number): number;
    namedItem(name: string): string;
    readonly length: number;
  }
  class TestIndexedSetterInterface {
    setItem(idx: number, item: string): void;
    __indexedgetter(idx: number): string;
    readonly length: number;
  }
  class TestNamedSetterInterface {
    __namedsetter(myName: string, item: TestIndexedSetterInterface): void;
    __namedgetter(name: string): TestIndexedSetterInterface;
  }
  class TestIndexedAndNamedSetterInterface {
    __indexedsetter(index: number, item: TestIndexedSetterInterface): void;
    __indexedgetter(index: number): TestIndexedSetterInterface;
    readonly length: number;
    setNamedItem(name: string, item: TestIndexedSetterInterface): void;
    __namedgetter(name: string): TestIndexedSetterInterface;
  }
  class TestIndexedAndNamedGetterAndSetterInterface {
    item(index: number): number;
    namedItem(name: string): string;
    __indexedsetter(index: number, item: number): void;
    __namedsetter(name: string, item: string): void;
    __stringifier(): string;
    readonly length: number;
  }
  class TestNamedDeleterInterface {
    __nameddeleter(name: string): void;
    __namedgetter(name: string): number;
  }
  class TestNamedDeleterWithRetvalInterface {
    delNamedItem(name: string): boolean;
    __namedgetter(name: string): number;
  }
  class TestCppKeywordNamedMethodsInterface {
    continue(): boolean;
    delete(): boolean;
    volatile(): number;
  }
  class TestDeprecatedInterface {
    alsoDeprecated(): void;
  }
  class TestInterfaceWithPromiseConstructorArg {
  }
  class TestSecureContextInterface {
    alsoSecureContext(): void;
  }
  class TestWorkerExposedInterface {
    needsSubjectPrincipalMethod(): void;
    needsSubjectPrincipalAttr: boolean;
    needsCallerTypeMethod(): void;
    needsCallerTypeAttr: boolean;
    needsNonSystemSubjectPrincipalMethod(): void;
    needsNonSystemSubjectPrincipalAttr: boolean;
  }
  class TestHTMLConstructorInterface {
  }
  class TestThrowingConstructorInterface {
  }
  class TestCEReactionsInterface {
    __indexedsetter(index: number, item: number): void;
    __namedsetter(name: string, item: string): void;
    __nameddeleter(name: string): void;
    item(index: number): number;
    __namedgetter(name: string): string;
    readonly length: number;
  }
  interface TestAttributesOnDictionaryMembers {
    a?: number
    b?: number
    c: number
    d?: number
  }
  class TestAttributesOnTypes {
    foo(thingy: number): void;
    bar(thingy: number): void;
    baz(thingy: string): void;
    someAttr: number;
    argWithAttr(arg0: number, arg1?: number): void;
  }
  class TestPrefConstructorForInterface {
  }
  class TestConstructorForPrefInterface {
  }
  class TestPrefConstructorForDifferentPrefInterface {
  }
  class TestConstructorForSCInterface {
  }
  class TestSCConstructorForInterface {
  }
  class TestConstructorForFuncInterface {
  }
  class TestFuncConstructorForInterface {
  }
  class TestFuncConstructorForDifferentFuncInterface {
  }
  class TestPrefChromeOnlySCFuncConstructorForInterface {
  }
  class TestExampleInterface {
    readonly readonlyByte: number;
    writableByte: number;
    passByte(arg: number): void;
    receiveByte(): number;
    passOptionalByte(arg?: number): void;
    passOptionalByteBeforeRequired(arg1?: number, arg2: number): void;
    passOptionalByteWithDefault(arg?: number): void;
    passOptionalByteWithDefaultBeforeRequired(arg1?: number, arg2: number): void;
    passNullableByte(arg: number | null): void;
    passOptionalNullableByte(arg?: number | null): void;
    passVariadicByte(arg?: number): void;
    readonly cachedByte: number;
    readonly cachedConstantByte: number;
    cachedWritableByte: number;
    sideEffectFreeByte: number;
    domDependentByte: number;
    readonly constantByte: number;
    readonly deviceStateDependentByte: number;
    returnByteSideEffectFree(): number;
    returnDOMDependentByte(): number;
    returnConstantByte(): number;
    returnDeviceStateDependentByte(): number;
    readonly readonlyShort: number;
    writableShort: number;
    passShort(arg: number): void;
    receiveShort(): number;
    passOptionalShort(arg?: number): void;
    passOptionalShortWithDefault(arg?: number): void;
    readonly readonlyLong: number;
    writableLong: number;
    passLong(arg: number): void;
    receiveLong(): number;
    passOptionalLong(arg?: number): void;
    passOptionalLongWithDefault(arg?: number): void;
    readonly readonlyLongLong: number;
    writableLongLong: number;
    passLongLong(arg: number): void;
    receiveLongLong(): number;
    passOptionalLongLong(arg?: number): void;
    passOptionalLongLongWithDefault(arg?: number): void;
    readonly readonlyOctet: number;
    writableOctet: number;
    passOctet(arg: number): void;
    receiveOctet(): number;
    passOptionalOctet(arg?: number): void;
    passOptionalOctetWithDefault(arg?: number): void;
    readonly readonlyUnsignedShort: number;
    writableUnsignedShort: number;
    passUnsignedShort(arg: number): void;
    receiveUnsignedShort(): number;
    passOptionalUnsignedShort(arg?: number): void;
    passOptionalUnsignedShortWithDefault(arg?: number): void;
    readonly readonlyUnsignedLong: number;
    writableUnsignedLong: number;
    passUnsignedLong(arg: number): void;
    receiveUnsignedLong(): number;
    passOptionalUnsignedLong(arg?: number): void;
    passOptionalUnsignedLongWithDefault(arg?: number): void;
    readonly readonlyUnsignedLongLong: number;
    writableUnsignedLongLong: number;
    passUnsignedLongLong(arg: number): void;
    receiveUnsignedLongLong(): number;
    passOptionalUnsignedLongLong(arg?: number): void;
    passOptionalUnsignedLongLongWithDefault(arg?: number): void;
    writableFloat: number;
    writableUnrestrictedFloat: number;
    writableNullableFloat: number | null;
    writableNullableUnrestrictedFloat: number | null;
    writableDouble: number;
    writableUnrestrictedDouble: number;
    writableNullableDouble: number | null;
    writableNullableUnrestrictedDouble: number | null;
    passFloat(arg1: number, arg2: number, arg3: number | null, arg4: number | null, arg5: number, arg6: number, arg7: number | null, arg8: number | null, arg9: number[], arg10: number[], arg11: number | null[], arg12: number | null[], arg13: number[], arg14: number[], arg15: number | null[], arg16: number | null[]): void;
    passLenientFloat(arg1: number, arg2: number, arg3: number | null, arg4: number | null, arg5: number, arg6: number, arg7: number | null, arg8: number | null, arg9: number[], arg10: number[], arg11: number | null[], arg12: number | null[], arg13: number[], arg14: number[], arg15: number | null[], arg16: number | null[]): void;
    lenientFloatAttr: number;
    lenientDoubleAttr: number;
    receiveSelf(): TestInterface;
    receiveNullableSelf(): TestInterface | null;
    receiveWeakSelf(): TestInterface;
    receiveWeakNullableSelf(): TestInterface | null;
    passSelf(arg: TestInterface): void;
    passNullableSelf(arg: TestInterface | null): void;
    nonNullSelf: TestInterface;
    nullableSelf: TestInterface | null;
    readonly cachedSelf: TestInterface;
    passOptionalSelf(arg?: TestInterface | null): void;
    passOptionalNonNullSelf(arg?: TestInterface): void;
    passOptionalSelfWithDefault(arg?: TestInterface | null): void;
    receiveNonWrapperCacheInterface(): TestNonWrapperCacheInterface;
    receiveNullableNonWrapperCacheInterface(): TestNonWrapperCacheInterface | null;
    receiveNonWrapperCacheInterfaceSequence(): TestNonWrapperCacheInterface[];
    receiveNullableNonWrapperCacheInterfaceSequence(): TestNonWrapperCacheInterface | null[];
    receiveNonWrapperCacheInterfaceNullableSequence(): TestNonWrapperCacheInterface[] | null;
    receiveNullableNonWrapperCacheInterfaceNullableSequence(): TestNonWrapperCacheInterface | null[] | null;
    receiveExternal(): TestExternalInterface;
    receiveNullableExternal(): TestExternalInterface | null;
    receiveWeakExternal(): TestExternalInterface;
    receiveWeakNullableExternal(): TestExternalInterface | null;
    passExternal(arg: TestExternalInterface): void;
    passNullableExternal(arg: TestExternalInterface | null): void;
    nonNullExternal: TestExternalInterface;
    nullableExternal: TestExternalInterface | null;
    passOptionalExternal(arg?: TestExternalInterface | null): void;
    passOptionalNonNullExternal(arg?: TestExternalInterface): void;
    passOptionalExternalWithDefault(arg?: TestExternalInterface | null): void;
    receiveCallbackInterface(): TestCallbackInterface;
    receiveNullableCallbackInterface(): TestCallbackInterface | null;
    receiveWeakCallbackInterface(): TestCallbackInterface;
    receiveWeakNullableCallbackInterface(): TestCallbackInterface | null;
    passCallbackInterface(arg: TestCallbackInterface): void;
    passNullableCallbackInterface(arg: TestCallbackInterface | null): void;
    nonNullCallbackInterface: TestCallbackInterface;
    nullableCallbackInterface: TestCallbackInterface | null;
    passOptionalCallbackInterface(arg?: TestCallbackInterface | null): void;
    passOptionalNonNullCallbackInterface(arg?: TestCallbackInterface): void;
    passOptionalCallbackInterfaceWithDefault(arg?: TestCallbackInterface | null): void;
    readonly readonlySequence: number[];
    readonly readonlySequenceOfDictionaries: Dict[];
    readonly readonlyNullableSequenceOfDictionaries: Dict[] | null;
    readonly readonlyFrozenSequence: number[];
    readonly readonlyFrozenNullableSequence: number[] | null;
    receiveSequence(): number[];
    receiveNullableSequence(): number[] | null;
    receiveSequenceOfNullableInts(): number | null[];
    receiveNullableSequenceOfNullableInts(): number | null[] | null;
    passSequence(arg: number[]): void;
    passNullableSequence(arg: number[] | null): void;
    passSequenceOfNullableInts(arg: number | null[]): void;
    passOptionalSequenceOfNullableInts(arg?: number | null[]): void;
    passOptionalNullableSequenceOfNullableInts(arg?: number | null[] | null): void;
    receiveCastableObjectSequence(): TestInterface[];
    receiveCallbackObjectSequence(): TestCallbackInterface[];
    receiveNullableCastableObjectSequence(): TestInterface | null[];
    receiveNullableCallbackObjectSequence(): TestCallbackInterface | null[];
    receiveCastableObjectNullableSequence(): TestInterface[] | null;
    receiveNullableCastableObjectNullableSequence(): TestInterface | null[] | null;
    receiveWeakCastableObjectSequence(): TestInterface[];
    receiveWeakNullableCastableObjectSequence(): TestInterface | null[];
    receiveWeakCastableObjectNullableSequence(): TestInterface[] | null;
    receiveWeakNullableCastableObjectNullableSequence(): TestInterface | null[] | null;
    passCastableObjectSequence(arg: TestInterface[]): void;
    passNullableCastableObjectSequence(arg: TestInterface | null[]): void;
    passCastableObjectNullableSequence(arg: TestInterface[] | null): void;
    passNullableCastableObjectNullableSequence(arg: TestInterface | null[] | null): void;
    passOptionalSequence(arg?: number[]): void;
    passOptionalSequenceWithDefaultValue(arg?: number[]): void;
    passOptionalNullableSequence(arg?: number[] | null): void;
    passOptionalNullableSequenceWithDefaultValue(arg?: number[] | null): void;
    passOptionalNullableSequenceWithDefaultValue2(arg?: number[] | null): void;
    passOptionalObjectSequence(arg?: TestInterface[]): void;
    passExternalInterfaceSequence(arg: TestExternalInterface[]): void;
    passNullableExternalInterfaceSequence(arg: TestExternalInterface | null[]): void;
    receiveStringSequence(): string[];
    passStringSequence(arg: string[]): void;
    receiveByteStringSequence(): string[];
    passByteStringSequence(arg: string[]): void;
    receiveUTF8StringSequence(): string[];
    passUTF8StringSequence(arg: string[]): void;
    receiveAnySequence(): any[];
    receiveNullableAnySequence(): any[] | null;
    receiveObjectSequence(): object[];
    receiveNullableObjectSequence(): object | null[];
    passSequenceOfSequences(arg: number[][]): void;
    passSequenceOfSequencesOfSequences(arg: number[][][]): void;
    passRecord(arg: Record<string, number>): void;
    passNullableRecord(arg: Record<string, number> | null): void;
    passRecordOfNullableInts(arg: Record<string, number | null>): void;
    passOptionalRecordOfNullableInts(arg?: Record<string, number | null>): void;
    passOptionalNullableRecordOfNullableInts(arg?: Record<string, number | null> | null): void;
    passCastableObjectRecord(arg: Record<string, TestInterface>): void;
    passNullableCastableObjectRecord(arg: Record<string, TestInterface | null>): void;
    passCastableObjectNullableRecord(arg: Record<string, TestInterface> | null): void;
    passNullableCastableObjectNullableRecord(arg: Record<string, TestInterface | null> | null): void;
    passOptionalRecord(arg?: Record<string, number>): void;
    passOptionalNullableRecord(arg?: Record<string, number> | null): void;
    passOptionalNullableRecordWithDefaultValue(arg?: Record<string, number> | null): void;
    passOptionalObjectRecord(arg?: Record<string, TestInterface>): void;
    passExternalInterfaceRecord(arg: Record<string, TestExternalInterface>): void;
    passNullableExternalInterfaceRecord(arg: Record<string, TestExternalInterface | null>): void;
    passStringRecord(arg: Record<string, string>): void;
    passByteStringRecord(arg: Record<string, string>): void;
    passUTF8StringRecord(arg: Record<string, string>): void;
    passRecordOfRecords(arg: Record<string, Record<string, number>>): void;
    receiveRecord(): Record<string, number>;
    receiveNullableRecord(): Record<string, number> | null;
    receiveRecordOfNullableInts(): Record<string, number | null>;
    receiveNullableRecordOfNullableInts(): Record<string, number | null> | null;
    receiveAnyRecord(): Record<string, any>;
    passArrayBuffer(arg: ArrayBuffer): void;
    passNullableArrayBuffer(arg: ArrayBuffer | null): void;
    passOptionalArrayBuffer(arg?: ArrayBuffer): void;
    passOptionalNullableArrayBuffer(arg?: ArrayBuffer | null): void;
    passOptionalNullableArrayBufferWithDefaultValue(arg?: ArrayBuffer | null): void;
    passArrayBufferView(arg: ArrayBufferView): void;
    passInt8Array(arg: Int8Array): void;
    passInt16Array(arg: Int16Array): void;
    passInt32Array(arg: Int32Array): void;
    passUint8Array(arg: Uint8Array): void;
    passUint16Array(arg: Uint16Array): void;
    passUint32Array(arg: Uint32Array): void;
    passUint8ClampedArray(arg: Uint8ClampedArray): void;
    passFloat32Array(arg: Float32Array): void;
    passFloat64Array(arg: Float64Array): void;
    passSequenceOfArrayBuffers(arg: ArrayBuffer[]): void;
    passSequenceOfNullableArrayBuffers(arg: ArrayBuffer | null[]): void;
    passRecordOfArrayBuffers(arg: Record<string, ArrayBuffer>): void;
    passRecordOfNullableArrayBuffers(arg: Record<string, ArrayBuffer | null>): void;
    passVariadicTypedArray(arg?: Float32Array): void;
    passVariadicNullableTypedArray(arg?: Float32Array | null): void;
    receiveUint8Array(): Uint8Array;
    uint8ArrayAttr: Uint8Array;
    passString(arg: string): void;
    passNullableString(arg: string | null): void;
    passOptionalString(arg?: string): void;
    passOptionalStringWithDefaultValue(arg?: string): void;
    passOptionalNullableString(arg?: string | null): void;
    passOptionalNullableStringWithDefaultValue(arg?: string | null): void;
    passVariadicString(arg?: string): void;
    passByteString(arg: string): void;
    passNullableByteString(arg: string | null): void;
    passOptionalByteString(arg?: string): void;
    passOptionalByteStringWithDefaultValue(arg?: string): void;
    passOptionalNullableByteString(arg?: string | null): void;
    passOptionalNullableByteStringWithDefaultValue(arg?: string | null): void;
    passVariadicByteString(arg?: string): void;
    passUnionByteString(arg: string | number): void;
    passOptionalUnionByteString(arg?: string | number): void;
    passOptionalUnionByteStringWithDefaultValue(arg?: string | number): void;
    passUTF8String(arg: string): void;
    passNullableUTF8String(arg: string | null): void;
    passOptionalUTF8String(arg?: string): void;
    passOptionalUTF8StringWithDefaultValue(arg?: string): void;
    passOptionalNullableUTF8String(arg?: string | null): void;
    passOptionalNullableUTF8StringWithDefaultValue(arg?: string | null): void;
    passVariadicUTF8String(arg?: string): void;
    passUnionUTF8String(arg: string | number): void;
    passOptionalUnionUTF8String(arg?: string | number): void;
    passOptionalUnionUTF8StringWithDefaultValue(arg?: string | number): void;
    passSVS(arg: string): void;
    passNullableSVS(arg: string | null): void;
    passOptionalSVS(arg?: string): void;
    passOptionalSVSWithDefaultValue(arg?: string): void;
    passOptionalNullableSVS(arg?: string | null): void;
    passOptionalNullableSVSWithDefaultValue(arg?: string | null): void;
    passVariadicSVS(arg?: string): void;
    receiveSVS(): string;
    passJSString(arg: string): void;
    passOptionalJSStringWithDefaultValue(arg?: string): void;
    receiveJSString(): string;
    readonly readonlyJSStringAttr: string;
    jsStringAttr: string;
    passEnum(arg: TestEnum): void;
    passNullableEnum(arg: TestEnum | null): void;
    passOptionalEnum(arg?: TestEnum): void;
    passEnumWithDefault(arg?: TestEnum): void;
    passOptionalNullableEnum(arg?: TestEnum | null): void;
    passOptionalNullableEnumWithDefaultValue(arg?: TestEnum | null): void;
    passOptionalNullableEnumWithDefaultValue2(arg?: TestEnum | null): void;
    receiveEnum(): TestEnum;
    receiveNullableEnum(): TestEnum | null;
    enumAttribute: TestEnum;
    readonly readonlyEnumAttribute: TestEnum;
    passCallback(arg: TestCallback): void;
    passNullableCallback(arg: TestCallback | null): void;
    passOptionalCallback(arg?: TestCallback): void;
    passOptionalNullableCallback(arg?: TestCallback | null): void;
    passOptionalNullableCallbackWithDefaultValue(arg?: TestCallback | null): void;
    receiveCallback(): TestCallback;
    receiveNullableCallback(): TestCallback | null;
    passNullableTreatAsNullCallback(arg: TestTreatAsNullCallback | null): void;
    passOptionalNullableTreatAsNullCallback(arg?: TestTreatAsNullCallback | null): void;
    passOptionalNullableTreatAsNullCallbackWithDefaultValue(arg?: TestTreatAsNullCallback | null): void;
    passAny(arg: any): void;
    passVariadicAny(arg?: any): void;
    passOptionalAny(arg?: any): void;
    passAnyDefaultNull(arg?: any): void;
    passSequenceOfAny(arg: any[]): void;
    passNullableSequenceOfAny(arg: any[] | null): void;
    passOptionalSequenceOfAny(arg?: any[]): void;
    passOptionalNullableSequenceOfAny(arg?: any[] | null): void;
    passOptionalSequenceOfAnyWithDefaultValue(arg?: any[] | null): void;
    passSequenceOfSequenceOfAny(arg: any[][]): void;
    passSequenceOfNullableSequenceOfAny(arg: any[] | null[]): void;
    passNullableSequenceOfNullableSequenceOfAny(arg: any[] | null[] | null): void;
    passOptionalNullableSequenceOfNullableSequenceOfAny(arg?: any[] | null[] | null): void;
    passRecordOfAny(arg: Record<string, any>): void;
    passNullableRecordOfAny(arg: Record<string, any> | null): void;
    passOptionalRecordOfAny(arg?: Record<string, any>): void;
    passOptionalNullableRecordOfAny(arg?: Record<string, any> | null): void;
    passOptionalRecordOfAnyWithDefaultValue(arg?: Record<string, any> | null): void;
    passRecordOfRecordOfAny(arg: Record<string, Record<string, any>>): void;
    passRecordOfNullableRecordOfAny(arg: Record<string, Record<string, any> | null>): void;
    passNullableRecordOfNullableRecordOfAny(arg: Record<string, Record<string, any> | null> | null): void;
    passOptionalNullableRecordOfNullableRecordOfAny(arg?: Record<string, Record<string, any> | null> | null): void;
    passOptionalNullableRecordOfNullableSequenceOfAny(arg?: Record<string, any[] | null> | null): void;
    passOptionalNullableSequenceOfNullableRecordOfAny(arg?: Record<string, any> | null[] | null): void;
    receiveAny(): any;
    passObject(arg: object): void;
    passVariadicObject(arg?: object): void;
    passNullableObject(arg: object | null): void;
    passVariadicNullableObject(arg?: object): void;
    passOptionalObject(arg?: object): void;
    passOptionalNullableObject(arg?: object | null): void;
    passOptionalNullableObjectWithDefaultValue(arg?: object | null): void;
    passSequenceOfObject(arg: object[]): void;
    passSequenceOfNullableObject(arg: object | null[]): void;
    passNullableSequenceOfObject(arg: object[] | null): void;
    passOptionalNullableSequenceOfNullableSequenceOfObject(arg?: object[] | null[] | null): void;
    passOptionalNullableSequenceOfNullableSequenceOfNullableObject(arg?: object | null[] | null[] | null): void;
    passRecordOfObject(arg: Record<string, object>): void;
    receiveObject(): object;
    receiveNullableObject(): object | null;
    passUnion(arg: object | number): void;
    passUnionWithNullable(arg: object | null | number): void;
    passNullableUnion(arg: object | number | null): void;
    passOptionalUnion(arg?: object | number): void;
    passOptionalNullableUnion(arg?: object | number | null): void;
    passOptionalNullableUnionWithDefaultValue(arg?: object | number | null): void;
    passUnionWithArrayBuffer(arg: ArrayBuffer | number): void;
    passUnionWithString(arg: string | object): void;
    passUnionWithEnum(arg: SupportedType | object): void;
    passUnionWithObject(arg: object | number): void;
    passUnionWithDefaultValue1(arg?: number | string): void;
    passUnionWithDefaultValue2(arg?: number | string): void;
    passUnionWithDefaultValue3(arg?: number | string): void;
    passUnionWithDefaultValue4(arg?: number | string): void;
    passUnionWithDefaultValue5(arg?: number | string): void;
    passUnionWithDefaultValue6(arg?: number | string): void;
    passUnionWithDefaultValue7(arg?: number | string): void;
    passUnionWithDefaultValue8(arg?: number | string): void;
    passUnionWithDefaultValue9(arg?: number | string): void;
    passUnionWithDefaultValue10(arg?: number | string): void;
    passUnionWithDefaultValue11(arg?: number | string): void;
    passUnionWithDefaultValue12(arg?: number | string): void;
    passUnionWithDefaultValue13(arg?: number | string): void;
    passUnionWithDefaultValue14(arg?: number | string): void;
    passUnionWithDefaultValue15(arg?: number | string): void;
    passUnionWithDefaultValue16(arg?: number | string): void;
    passUnionWithDefaultValue17(arg?: number | SupportedType): void;
    passUnionWithDefaultValue18(arg?: number | SupportedType): void;
    passUnionWithDefaultValue19(arg?: number | SupportedType): void;
    passUnionWithDefaultValue20(arg?: number | string): void;
    passUnionWithDefaultValue21(arg?: number | string): void;
    passUnionWithDefaultValue22(arg?: number | string): void;
    passUnionWithDefaultValue23(arg?: number | string): void;
    passUnionWithDefaultValue24(arg?: number | string): void;
    passUnionWithDefaultValue25(arg?: number | string): void;
    passNullableUnionWithDefaultValue1(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue2(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue3(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue4(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue5(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue6(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue7(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue8(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue9(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue10(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue11(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue12(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue13(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue14(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue15(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue16(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue17(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue18(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue19(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue20(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue21(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue22(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue23(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue24(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue25(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue26(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue27(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue28(arg?: number | string | null): void;
    passSequenceOfUnions(arg: CanvasPattern | CanvasGradient[]): void;
    passSequenceOfUnions2(arg: object | number[]): void;
    passVariadicUnion(arg?: CanvasPattern | CanvasGradient): void;
    passSequenceOfNullableUnions(arg: CanvasPattern | CanvasGradient | null[]): void;
    passVariadicNullableUnion(arg?: CanvasPattern | CanvasGradient | null): void;
    passRecordOfUnions(arg: Record<string, CanvasPattern | CanvasGradient>): void;
    receiveUnion(): CanvasPattern | CanvasGradient;
    receiveUnion2(): object | number;
    receiveUnionContainingNull(): CanvasPattern | null | CanvasGradient;
    receiveNullableUnion(): CanvasPattern | CanvasGradient | null;
    receiveNullableUnion2(): object | number | null;
    writableUnion: CanvasPattern | CanvasGradient;
    writableUnionContainingNull: CanvasPattern | null | CanvasGradient;
    writableNullableUnion: CanvasPattern | CanvasGradient | null;
    passDate(arg: Date): void;
    passNullableDate(arg: Date | null): void;
    passOptionalDate(arg?: Date): void;
    passOptionalNullableDate(arg?: Date | null): void;
    passOptionalNullableDateWithDefaultValue(arg?: Date | null): void;
    passDateSequence(arg: Date[]): void;
    passNullableDateSequence(arg: Date | null[]): void;
    passDateRecord(arg: Record<string, Date>): void;
    receiveDate(): Date;
    receiveNullableDate(): Date | null;
    passPromise(arg: Promise<any>): void;
    passOptionalPromise(arg?: Promise<any>): void;
    passPromiseSequence(arg: Promise<any>[]): void;
    receivePromise(): Promise<any>;
    receiveAddrefedPromise(): Promise<any>;
    methodRenamedFrom(): void;
    methodRenamedFrom(argument: number): void;
    readonly attributeGetterRenamedFrom: number;
    attributeRenamedFrom: number;
    passDictionary(x?: Dict): void;
    passDictionary2(x: Dict): void;
    readonly readonlyDictionary: Dict;
    readonly readonlyNullableDictionary: Dict | null;
    writableDictionary: Dict;
    readonly readonlyFrozenDictionary: Dict;
    readonly readonlyFrozenNullableDictionary: Dict | null;
    writableFrozenDictionary: Dict;
    receiveDictionary(): Dict;
    receiveNullableDictionary(): Dict | null;
    passOtherDictionary(x?: GrandparentDict): void;
    passSequenceOfDictionaries(x: Dict[]): void;
    passRecordOfDictionaries(x: Record<string, GrandparentDict>): void;
    passDictionaryOrLong(x?: Dict): void;
    passDictionaryOrLong(x: number): void;
    passDictContainingDict(arg?: DictContainingDict): void;
    passDictContainingSequence(arg?: DictContainingSequence): void;
    receiveDictContainingSequence(): DictContainingSequence;
    passVariadicDictionary(arg?: Dict): void;
    dontEnforceRangeOrClamp(arg: number): void;
    doEnforceRange(arg: number): void;
    doEnforceRangeNullable(arg: number | null): void;
    doClamp(arg: number): void;
    doClampNullable(arg: number | null): void;
    enforcedByte: number;
    enforcedByteNullable: number | null;
    clampedByte: number;
    clampedByteNullable: number | null;
    exerciseTypedefInterfaces1(arg: TestInterface): void;
    exerciseTypedefInterfaces2(arg: TestInterface | null): TestInterface;
    exerciseTypedefInterfaces3(arg: TestInterface): void;
    deprecatedAttribute: boolean;
    deprecatedMethod(arg: boolean): void;
    deprecatedMethodWithContext(arg: any): void;
    static staticAttribute: boolean;
    staticMethod(arg: boolean): void;
    staticMethodWithContext(arg: any): void;
    static staticDeprecatedAttribute: boolean;
    staticDeprecatedMethod(arg: boolean): void;
    staticDeprecatedMethodWithContext(arg: any): void;
    overload1(arg: TestInterface): boolean;
    overload1(strs: string, arg: TestInterface): TestInterface;
    overload2(arg: TestInterface): void;
    overload2(arg?: Dict): void;
    overload2(arg: boolean): void;
    overload2(arg: string): void;
    overload2(arg: Date): void;
    overload3(arg: TestInterface): void;
    overload3(arg: TestCallback): void;
    overload3(arg: boolean): void;
    overload4(arg: TestInterface): void;
    overload4(arg: TestCallbackInterface): void;
    overload4(arg: string): void;
    overload5(arg: number): void;
    overload5(arg: TestEnum): void;
    overload6(arg: number): void;
    overload6(arg: boolean): void;
    overload7(arg: number): void;
    overload7(arg: boolean): void;
    overload7(arg: string): void;
    overload8(arg: number): void;
    overload8(arg: TestInterface): void;
    overload9(arg: number | null): void;
    overload9(arg: string): void;
    overload10(arg: number | null): void;
    overload10(arg: object): void;
    overload11(arg: number): void;
    overload11(arg: string | null): void;
    overload12(arg: number): void;
    overload12(arg: boolean | null): void;
    overload13(arg: number | null): void;
    overload13(arg: boolean): void;
    overload14(arg?: number): void;
    overload14(arg: TestInterface): void;
    overload15(arg: number): void;
    overload15(arg?: TestInterface): void;
    overload16(arg: number): void;
    overload16(arg?: TestInterface | null): void;
    overload17(arg: number[]): void;
    overload17(arg: Record<string, number>): void;
    overload18(arg: Record<string, string>): void;
    overload18(arg: string[]): void;
    overload19(arg: number[]): void;
    overload19(arg?: Dict): void;
    overload20(arg?: Dict): void;
    overload20(arg: number[]): void;
    passVariadicThirdArg(arg1: string, arg2: number, arg3?: TestInterface): void;
    readonly prefable1: boolean;
    readonly prefable2: boolean;
    readonly prefable3: boolean;
    readonly prefable4: boolean;
    readonly prefable5: boolean;
    readonly prefable6: boolean;
    readonly prefable7: boolean;
    readonly prefable8: boolean;
    readonly prefable9: boolean;
    prefable10(): void;
    prefable11(): void;
    readonly prefable12: boolean;
    prefable13(): void;
    readonly prefable14: boolean;
    readonly prefable15: boolean;
    readonly prefable16: boolean;
    prefable17(): void;
    prefable18(): void;
    prefable19(): void;
    readonly conditionalOnSecureContext1: boolean;
    readonly conditionalOnSecureContext2: boolean;
    readonly conditionalOnSecureContext3: boolean;
    readonly conditionalOnSecureContext4: boolean;
    conditionalOnSecureContext5(): void;
    conditionalOnSecureContext6(): void;
    conditionalOnSecureContext7(): void;
    conditionalOnSecureContext8(): void;
    attrWithLenientThis: number;
    readonly unforgeableAttr: number;
    readonly unforgeableAttr2: number;
    unforgeableMethod(): number;
    unforgeableMethod2(): number;
    __stringifier(): string;
    passRenamedInterface(arg: TestRenamedInterface): void;
    readonly putForwardsAttr: TestExampleInterface;
    readonly putForwardsAttr2: TestExampleInterface;
    readonly putForwardsAttr3: TestExampleInterface;
    throwingMethod(): void;
    throwingAttr: boolean;
    throwingGetterAttr: boolean;
    throwingSetterAttr: boolean;
    canOOMMethod(): void;
    canOOMAttr: boolean;
    canOOMGetterAttr: boolean;
    canOOMSetterAttr: boolean;
    needsSubjectPrincipalMethod(): void;
    needsSubjectPrincipalAttr: boolean;
    needsNonSystemSubjectPrincipalMethod(): void;
    needsNonSystemSubjectPrincipalAttr: boolean;
    needsCallerTypeMethod(): void;
    needsCallerTypeAttr: boolean;
    ceReactionsMethod(): void;
    ceReactionsMethodOverload(): void;
    ceReactionsMethodOverload(bar: string): void;
    ceReactionsAttr: boolean;
    __legacycaller(arg1: number, arg2: TestInterface): number;
    passArgsWithDefaults(arg1?: number, arg2?: TestInterface | null, arg3?: Dict, arg4?: number, arg5?: number): void;
    toJSONShouldSkipThis: any;
    toJSONShouldSkipThis2: TestParentInterface;
    toJSONShouldSkipThis3: TestCallbackInterface;
    toJSON(): object;
    "dashed-attribute": number;
    "dashed-method"(): void;
    nonEnumerableAttr: boolean;
    nonEnumerableMethod(): void;
  }
  class TestExampleProxyInterface {
    longIndexedGetter(ix: number): number;
    longIndexedSetter(y: number, z: number): void;
    readonly length: number;
    myStringifier(): string;
    shortNameGetter(nom: string): number;
    __nameddeleter(nomnom: string): void;
    shortNamedSetter(me: string, value: number): void;
  }
  class TestExampleWorkerInterface {
    needsSubjectPrincipalMethod(): void;
    needsSubjectPrincipalAttr: boolean;
    needsCallerTypeMethod(): void;
    needsCallerTypeAttr: boolean;
    needsNonSystemSubjectPrincipalMethod(): void;
    needsNonSystemSubjectPrincipalAttr: boolean;
  }
  class TestExampleThrowingConstructorInterface {
  }
  function MyTestCallback(): void;
  enum MyTestEnum {
    A = "a",
    B = "b",
  }
  class TestJSImplInterface {
    readonly readonlyByte: number;
    writableByte: number;
    passByte(arg: number): void;
    receiveByte(): number;
    passOptionalByte(arg?: number): void;
    passOptionalByteBeforeRequired(arg1?: number, arg2: number): void;
    passOptionalByteWithDefault(arg?: number): void;
    passOptionalByteWithDefaultBeforeRequired(arg1?: number, arg2: number): void;
    passNullableByte(arg: number | null): void;
    passOptionalNullableByte(arg?: number | null): void;
    passVariadicByte(arg?: number): void;
    sideEffectFreeByte: number;
    domDependentByte: number;
    readonly constantByte: number;
    readonly deviceStateDependentByte: number;
    returnByteSideEffectFree(): number;
    returnDOMDependentByte(): number;
    returnConstantByte(): number;
    returnDeviceStateDependentByte(): number;
    readonly readonlyShort: number;
    writableShort: number;
    passShort(arg: number): void;
    receiveShort(): number;
    passOptionalShort(arg?: number): void;
    passOptionalShortWithDefault(arg?: number): void;
    readonly readonlyLong: number;
    writableLong: number;
    passLong(arg: number): void;
    receiveLong(): number;
    passOptionalLong(arg?: number): void;
    passOptionalLongWithDefault(arg?: number): void;
    readonly readonlyLongLong: number;
    writableLongLong: number;
    passLongLong(arg: number): void;
    receiveLongLong(): number;
    passOptionalLongLong(arg?: number): void;
    passOptionalLongLongWithDefault(arg?: number): void;
    readonly readonlyOctet: number;
    writableOctet: number;
    passOctet(arg: number): void;
    receiveOctet(): number;
    passOptionalOctet(arg?: number): void;
    passOptionalOctetWithDefault(arg?: number): void;
    readonly readonlyUnsignedShort: number;
    writableUnsignedShort: number;
    passUnsignedShort(arg: number): void;
    receiveUnsignedShort(): number;
    passOptionalUnsignedShort(arg?: number): void;
    passOptionalUnsignedShortWithDefault(arg?: number): void;
    readonly readonlyUnsignedLong: number;
    writableUnsignedLong: number;
    passUnsignedLong(arg: number): void;
    receiveUnsignedLong(): number;
    passOptionalUnsignedLong(arg?: number): void;
    passOptionalUnsignedLongWithDefault(arg?: number): void;
    readonly readonlyUnsignedLongLong: number;
    writableUnsignedLongLong: number;
    passUnsignedLongLong(arg: number): void;
    receiveUnsignedLongLong(): number;
    passOptionalUnsignedLongLong(arg?: number): void;
    passOptionalUnsignedLongLongWithDefault(arg?: number): void;
    writableFloat: number;
    writableUnrestrictedFloat: number;
    writableNullableFloat: number | null;
    writableNullableUnrestrictedFloat: number | null;
    writableDouble: number;
    writableUnrestrictedDouble: number;
    writableNullableDouble: number | null;
    writableNullableUnrestrictedDouble: number | null;
    passFloat(arg1: number, arg2: number, arg3: number | null, arg4: number | null, arg5: number, arg6: number, arg7: number | null, arg8: number | null, arg9: number[], arg10: number[], arg11: number | null[], arg12: number | null[], arg13: number[], arg14: number[], arg15: number | null[], arg16: number | null[]): void;
    passLenientFloat(arg1: number, arg2: number, arg3: number | null, arg4: number | null, arg5: number, arg6: number, arg7: number | null, arg8: number | null, arg9: number[], arg10: number[], arg11: number | null[], arg12: number | null[], arg13: number[], arg14: number[], arg15: number | null[], arg16: number | null[]): void;
    lenientFloatAttr: number;
    lenientDoubleAttr: number;
    receiveSelf(): TestJSImplInterface;
    receiveNullableSelf(): TestJSImplInterface | null;
    receiveWeakSelf(): TestJSImplInterface;
    receiveWeakNullableSelf(): TestJSImplInterface | null;
    passSelf(arg: TestJSImplInterface): void;
    passNullableSelf(arg: TestJSImplInterface | null): void;
    nonNullSelf: TestJSImplInterface;
    nullableSelf: TestJSImplInterface | null;
    passOptionalSelf(arg?: TestJSImplInterface | null): void;
    passOptionalNonNullSelf(arg?: TestJSImplInterface): void;
    passOptionalSelfWithDefault(arg?: TestJSImplInterface | null): void;
    receiveNonWrapperCacheInterface(): TestNonWrapperCacheInterface;
    receiveNullableNonWrapperCacheInterface(): TestNonWrapperCacheInterface | null;
    receiveNonWrapperCacheInterfaceSequence(): TestNonWrapperCacheInterface[];
    receiveNullableNonWrapperCacheInterfaceSequence(): TestNonWrapperCacheInterface | null[];
    receiveNonWrapperCacheInterfaceNullableSequence(): TestNonWrapperCacheInterface[] | null;
    receiveNullableNonWrapperCacheInterfaceNullableSequence(): TestNonWrapperCacheInterface | null[] | null;
    receiveExternal(): TestExternalInterface;
    receiveNullableExternal(): TestExternalInterface | null;
    receiveWeakExternal(): TestExternalInterface;
    receiveWeakNullableExternal(): TestExternalInterface | null;
    passExternal(arg: TestExternalInterface): void;
    passNullableExternal(arg: TestExternalInterface | null): void;
    nonNullExternal: TestExternalInterface;
    nullableExternal: TestExternalInterface | null;
    passOptionalExternal(arg?: TestExternalInterface | null): void;
    passOptionalNonNullExternal(arg?: TestExternalInterface): void;
    passOptionalExternalWithDefault(arg?: TestExternalInterface | null): void;
    receiveCallbackInterface(): TestCallbackInterface;
    receiveNullableCallbackInterface(): TestCallbackInterface | null;
    receiveWeakCallbackInterface(): TestCallbackInterface;
    receiveWeakNullableCallbackInterface(): TestCallbackInterface | null;
    passCallbackInterface(arg: TestCallbackInterface): void;
    passNullableCallbackInterface(arg: TestCallbackInterface | null): void;
    nonNullCallbackInterface: TestCallbackInterface;
    nullableCallbackInterface: TestCallbackInterface | null;
    passOptionalCallbackInterface(arg?: TestCallbackInterface | null): void;
    passOptionalNonNullCallbackInterface(arg?: TestCallbackInterface): void;
    passOptionalCallbackInterfaceWithDefault(arg?: TestCallbackInterface | null): void;
    receiveSequence(): number[];
    receiveNullableSequence(): number[] | null;
    receiveSequenceOfNullableInts(): number | null[];
    receiveNullableSequenceOfNullableInts(): number | null[] | null;
    passSequence(arg: number[]): void;
    passNullableSequence(arg: number[] | null): void;
    passSequenceOfNullableInts(arg: number | null[]): void;
    passOptionalSequenceOfNullableInts(arg?: number | null[]): void;
    passOptionalNullableSequenceOfNullableInts(arg?: number | null[] | null): void;
    receiveCastableObjectSequence(): TestJSImplInterface[];
    receiveCallbackObjectSequence(): TestCallbackInterface[];
    receiveNullableCastableObjectSequence(): TestJSImplInterface | null[];
    receiveNullableCallbackObjectSequence(): TestCallbackInterface | null[];
    receiveCastableObjectNullableSequence(): TestJSImplInterface[] | null;
    receiveNullableCastableObjectNullableSequence(): TestJSImplInterface | null[] | null;
    receiveWeakCastableObjectSequence(): TestJSImplInterface[];
    receiveWeakNullableCastableObjectSequence(): TestJSImplInterface | null[];
    receiveWeakCastableObjectNullableSequence(): TestJSImplInterface[] | null;
    receiveWeakNullableCastableObjectNullableSequence(): TestJSImplInterface | null[] | null;
    passCastableObjectSequence(arg: TestJSImplInterface[]): void;
    passNullableCastableObjectSequence(arg: TestJSImplInterface | null[]): void;
    passCastableObjectNullableSequence(arg: TestJSImplInterface[] | null): void;
    passNullableCastableObjectNullableSequence(arg: TestJSImplInterface | null[] | null): void;
    passOptionalSequence(arg?: number[]): void;
    passOptionalSequenceWithDefaultValue(arg?: number[]): void;
    passOptionalNullableSequence(arg?: number[] | null): void;
    passOptionalNullableSequenceWithDefaultValue(arg?: number[] | null): void;
    passOptionalNullableSequenceWithDefaultValue2(arg?: number[] | null): void;
    passOptionalObjectSequence(arg?: TestJSImplInterface[]): void;
    passExternalInterfaceSequence(arg: TestExternalInterface[]): void;
    passNullableExternalInterfaceSequence(arg: TestExternalInterface | null[]): void;
    receiveStringSequence(): string[];
    receiveByteStringSequence(): string[];
    receiveUTF8StringSequence(): string[];
    receiveAnySequence(): any[];
    receiveNullableAnySequence(): any[] | null;
    receiveObjectSequence(): object[];
    receiveNullableObjectSequence(): object | null[];
    passSequenceOfSequences(arg: number[][]): void;
    passSequenceOfSequencesOfSequences(arg: number[][][]): void;
    passRecord(arg: Record<string, number>): void;
    passNullableRecord(arg: Record<string, number> | null): void;
    passRecordOfNullableInts(arg: Record<string, number | null>): void;
    passOptionalRecordOfNullableInts(arg?: Record<string, number | null>): void;
    passOptionalNullableRecordOfNullableInts(arg?: Record<string, number | null> | null): void;
    passCastableObjectRecord(arg: Record<string, TestInterface>): void;
    passNullableCastableObjectRecord(arg: Record<string, TestInterface | null>): void;
    passCastableObjectNullableRecord(arg: Record<string, TestInterface> | null): void;
    passNullableCastableObjectNullableRecord(arg: Record<string, TestInterface | null> | null): void;
    passOptionalRecord(arg?: Record<string, number>): void;
    passOptionalNullableRecord(arg?: Record<string, number> | null): void;
    passOptionalNullableRecordWithDefaultValue(arg?: Record<string, number> | null): void;
    passOptionalObjectRecord(arg?: Record<string, TestInterface>): void;
    passExternalInterfaceRecord(arg: Record<string, TestExternalInterface>): void;
    passNullableExternalInterfaceRecord(arg: Record<string, TestExternalInterface | null>): void;
    passStringRecord(arg: Record<string, string>): void;
    passByteStringRecord(arg: Record<string, string>): void;
    passUTF8StringRecord(arg: Record<string, string>): void;
    passRecordOfRecords(arg: Record<string, Record<string, number>>): void;
    receiveRecord(): Record<string, number>;
    receiveNullableRecord(): Record<string, number> | null;
    receiveRecordOfNullableInts(): Record<string, number | null>;
    receiveNullableRecordOfNullableInts(): Record<string, number | null> | null;
    receiveAnyRecord(): Record<string, any>;
    passArrayBuffer(arg: ArrayBuffer): void;
    passNullableArrayBuffer(arg: ArrayBuffer | null): void;
    passOptionalArrayBuffer(arg?: ArrayBuffer): void;
    passOptionalNullableArrayBuffer(arg?: ArrayBuffer | null): void;
    passOptionalNullableArrayBufferWithDefaultValue(arg?: ArrayBuffer | null): void;
    passArrayBufferView(arg: ArrayBufferView): void;
    passInt8Array(arg: Int8Array): void;
    passInt16Array(arg: Int16Array): void;
    passInt32Array(arg: Int32Array): void;
    passUint8Array(arg: Uint8Array): void;
    passUint16Array(arg: Uint16Array): void;
    passUint32Array(arg: Uint32Array): void;
    passUint8ClampedArray(arg: Uint8ClampedArray): void;
    passFloat32Array(arg: Float32Array): void;
    passFloat64Array(arg: Float64Array): void;
    passSequenceOfArrayBuffers(arg: ArrayBuffer[]): void;
    passSequenceOfNullableArrayBuffers(arg: ArrayBuffer | null[]): void;
    passRecordOfArrayBuffers(arg: Record<string, ArrayBuffer>): void;
    passRecordOfNullableArrayBuffers(arg: Record<string, ArrayBuffer | null>): void;
    passVariadicTypedArray(arg?: Float32Array): void;
    passVariadicNullableTypedArray(arg?: Float32Array | null): void;
    receiveUint8Array(): Uint8Array;
    uint8ArrayAttr: Uint8Array;
    passString(arg: string): void;
    passNullableString(arg: string | null): void;
    passOptionalString(arg?: string): void;
    passOptionalStringWithDefaultValue(arg?: string): void;
    passOptionalNullableString(arg?: string | null): void;
    passOptionalNullableStringWithDefaultValue(arg?: string | null): void;
    passVariadicString(arg?: string): void;
    passByteString(arg: string): void;
    passNullableByteString(arg: string | null): void;
    passOptionalByteString(arg?: string): void;
    passOptionalByteStringWithDefaultValue(arg?: string): void;
    passOptionalNullableByteString(arg?: string | null): void;
    passOptionalNullableByteStringWithDefaultValue(arg?: string | null): void;
    passVariadicByteString(arg?: string): void;
    passUnionByteString(arg: string | number): void;
    passOptionalUnionByteString(arg?: string | number): void;
    passOptionalUnionByteStringWithDefaultValue(arg?: string | number): void;
    passUTF8String(arg: string): void;
    passNullableUTF8String(arg: string | null): void;
    passOptionalUTF8String(arg?: string): void;
    passOptionalUTF8StringWithDefaultValue(arg?: string): void;
    passOptionalNullableUTF8String(arg?: string | null): void;
    passOptionalNullableUTF8StringWithDefaultValue(arg?: string | null): void;
    passVariadicUTF8String(arg?: string): void;
    passUnionUTF8String(arg: string | number): void;
    passOptionalUnionUTF8String(arg?: string | number): void;
    passOptionalUnionUTF8StringWithDefaultValue(arg?: string | number): void;
    passSVS(arg: string): void;
    passNullableSVS(arg: string | null): void;
    passOptionalSVS(arg?: string): void;
    passOptionalSVSWithDefaultValue(arg?: string): void;
    passOptionalNullableSVS(arg?: string | null): void;
    passOptionalNullableSVSWithDefaultValue(arg?: string | null): void;
    passVariadicSVS(arg?: string): void;
    receiveSVS(): string;
    passJSString(arg: string): void;
    passOptionalJSStringWithDefaultValue(arg?: string): void;
    receiveJSString(): string;
    readonly readonlyJSStringAttr: string;
    jsStringAttr: string;
    passEnum(arg: MyTestEnum): void;
    passNullableEnum(arg: MyTestEnum | null): void;
    passOptionalEnum(arg?: MyTestEnum): void;
    passEnumWithDefault(arg?: MyTestEnum): void;
    passOptionalNullableEnum(arg?: MyTestEnum | null): void;
    passOptionalNullableEnumWithDefaultValue(arg?: MyTestEnum | null): void;
    passOptionalNullableEnumWithDefaultValue2(arg?: MyTestEnum | null): void;
    receiveEnum(): MyTestEnum;
    receiveNullableEnum(): MyTestEnum | null;
    enumAttribute: MyTestEnum;
    readonly readonlyEnumAttribute: MyTestEnum;
    passCallback(arg: MyTestCallback): void;
    passNullableCallback(arg: MyTestCallback | null): void;
    passOptionalCallback(arg?: MyTestCallback): void;
    passOptionalNullableCallback(arg?: MyTestCallback | null): void;
    passOptionalNullableCallbackWithDefaultValue(arg?: MyTestCallback | null): void;
    receiveCallback(): MyTestCallback;
    receiveNullableCallback(): MyTestCallback | null;
    passOptionalNullableTreatAsNullCallbackWithDefaultValue(arg?: TestTreatAsNullCallback | null): void;
    passAny(arg: any): void;
    passVariadicAny(arg?: any): void;
    passOptionalAny(arg?: any): void;
    passAnyDefaultNull(arg?: any): void;
    passSequenceOfAny(arg: any[]): void;
    passNullableSequenceOfAny(arg: any[] | null): void;
    passOptionalSequenceOfAny(arg?: any[]): void;
    passOptionalNullableSequenceOfAny(arg?: any[] | null): void;
    passOptionalSequenceOfAnyWithDefaultValue(arg?: any[] | null): void;
    passSequenceOfSequenceOfAny(arg: any[][]): void;
    passSequenceOfNullableSequenceOfAny(arg: any[] | null[]): void;
    passNullableSequenceOfNullableSequenceOfAny(arg: any[] | null[] | null): void;
    passOptionalNullableSequenceOfNullableSequenceOfAny(arg?: any[] | null[] | null): void;
    passRecordOfAny(arg: Record<string, any>): void;
    passNullableRecordOfAny(arg: Record<string, any> | null): void;
    passOptionalRecordOfAny(arg?: Record<string, any>): void;
    passOptionalNullableRecordOfAny(arg?: Record<string, any> | null): void;
    passOptionalRecordOfAnyWithDefaultValue(arg?: Record<string, any> | null): void;
    passRecordOfRecordOfAny(arg: Record<string, Record<string, any>>): void;
    passRecordOfNullableRecordOfAny(arg: Record<string, Record<string, any> | null>): void;
    passNullableRecordOfNullableRecordOfAny(arg: Record<string, Record<string, any> | null> | null): void;
    passOptionalNullableRecordOfNullableRecordOfAny(arg?: Record<string, Record<string, any> | null> | null): void;
    passOptionalNullableRecordOfNullableSequenceOfAny(arg?: Record<string, any[] | null> | null): void;
    passOptionalNullableSequenceOfNullableRecordOfAny(arg?: Record<string, any> | null[] | null): void;
    receiveAny(): any;
    passObject(arg: object): void;
    passVariadicObject(arg?: object): void;
    passNullableObject(arg: object | null): void;
    passVariadicNullableObject(arg?: object): void;
    passOptionalObject(arg?: object): void;
    passOptionalNullableObject(arg?: object | null): void;
    passOptionalNullableObjectWithDefaultValue(arg?: object | null): void;
    passSequenceOfObject(arg: object[]): void;
    passSequenceOfNullableObject(arg: object | null[]): void;
    passNullableSequenceOfObject(arg: object[] | null): void;
    passOptionalNullableSequenceOfNullableSequenceOfObject(arg?: object[] | null[] | null): void;
    passOptionalNullableSequenceOfNullableSequenceOfNullableObject(arg?: object | null[] | null[] | null): void;
    passRecordOfObject(arg: Record<string, object>): void;
    receiveObject(): object;
    receiveNullableObject(): object | null;
    passUnion(arg: object | number): void;
    passUnionWithNullable(arg: object | null | number): void;
    passNullableUnion(arg: object | number | null): void;
    passOptionalUnion(arg?: object | number): void;
    passOptionalNullableUnion(arg?: object | number | null): void;
    passOptionalNullableUnionWithDefaultValue(arg?: object | number | null): void;
    passUnionWithArrayBuffer(arg: ArrayBuffer | number): void;
    passUnionWithString(arg: string | object): void;
    passUnionWithEnum(arg: SupportedType | object): void;
    passUnionWithObject(arg: object | number): void;
    passUnionWithDefaultValue1(arg?: number | string): void;
    passUnionWithDefaultValue2(arg?: number | string): void;
    passUnionWithDefaultValue3(arg?: number | string): void;
    passUnionWithDefaultValue4(arg?: number | string): void;
    passUnionWithDefaultValue5(arg?: number | string): void;
    passUnionWithDefaultValue6(arg?: number | string): void;
    passUnionWithDefaultValue7(arg?: number | string): void;
    passUnionWithDefaultValue8(arg?: number | string): void;
    passUnionWithDefaultValue9(arg?: number | string): void;
    passUnionWithDefaultValue10(arg?: number | string): void;
    passUnionWithDefaultValue11(arg?: number | string): void;
    passUnionWithDefaultValue12(arg?: number | string): void;
    passUnionWithDefaultValue13(arg?: number | string): void;
    passUnionWithDefaultValue14(arg?: number | string): void;
    passUnionWithDefaultValue15(arg?: number | string): void;
    passUnionWithDefaultValue16(arg?: number | string): void;
    passUnionWithDefaultValue17(arg?: number | SupportedType): void;
    passUnionWithDefaultValue18(arg?: number | SupportedType): void;
    passUnionWithDefaultValue19(arg?: number | SupportedType): void;
    passUnionWithDefaultValue20(arg?: number | string): void;
    passUnionWithDefaultValue21(arg?: number | string): void;
    passUnionWithDefaultValue22(arg?: number | string): void;
    passUnionWithDefaultValue23(arg?: number | string): void;
    passUnionWithDefaultValue24(arg?: number | string): void;
    passUnionWithDefaultValue25(arg?: number | string): void;
    passNullableUnionWithDefaultValue1(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue2(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue3(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue4(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue5(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue6(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue7(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue8(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue9(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue10(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue11(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue12(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue13(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue14(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue15(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue16(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue17(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue18(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue19(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue20(arg?: number | SupportedType | null): void;
    passNullableUnionWithDefaultValue21(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue22(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue23(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue24(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue25(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue26(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue27(arg?: number | string | null): void;
    passNullableUnionWithDefaultValue28(arg?: number | string | null): void;
    passSequenceOfUnions(arg: CanvasPattern | CanvasGradient[]): void;
    passSequenceOfUnions2(arg: object | number[]): void;
    passVariadicUnion(arg?: CanvasPattern | CanvasGradient): void;
    passSequenceOfNullableUnions(arg: CanvasPattern | CanvasGradient | null[]): void;
    passVariadicNullableUnion(arg?: CanvasPattern | CanvasGradient | null): void;
    passRecordOfUnions(arg: Record<string, CanvasPattern | CanvasGradient>): void;
    receiveUnion(): CanvasPattern | CanvasGradient;
    receiveUnion2(): object | number;
    receiveUnionContainingNull(): CanvasPattern | null | CanvasGradient;
    receiveNullableUnion(): CanvasPattern | CanvasGradient | null;
    receiveNullableUnion2(): object | number | null;
    writableUnion: CanvasPattern | CanvasGradient;
    writableUnionContainingNull: CanvasPattern | null | CanvasGradient;
    writableNullableUnion: CanvasPattern | CanvasGradient | null;
    passDate(arg: Date): void;
    passNullableDate(arg: Date | null): void;
    passOptionalDate(arg?: Date): void;
    passOptionalNullableDate(arg?: Date | null): void;
    passOptionalNullableDateWithDefaultValue(arg?: Date | null): void;
    passDateSequence(arg: Date[]): void;
    passNullableDateSequence(arg: Date | null[]): void;
    passDateRecord(arg: Record<string, Date>): void;
    receiveDate(): Date;
    receiveNullableDate(): Date | null;
    passPromise(arg: Promise<any>): void;
    passOptionalPromise(arg?: Promise<any>): void;
    passPromiseSequence(arg: Promise<any>[]): void;
    receivePromise(): Promise<any>;
    receiveAddrefedPromise(): Promise<any>;
    methodRenamedFrom(): void;
    methodRenamedFrom(argument: number): void;
    readonly attributeGetterRenamedFrom: number;
    attributeRenamedFrom: number;
    passDictionary(x?: Dict): void;
    passDictionary2(x: Dict): void;
    receiveDictionary(): Dict;
    receiveNullableDictionary(): Dict | null;
    passOtherDictionary(x?: GrandparentDict): void;
    passSequenceOfDictionaries(x: Dict[]): void;
    passRecordOfDictionaries(x: Record<string, GrandparentDict>): void;
    passDictionaryOrLong(x?: Dict): void;
    passDictionaryOrLong(x: number): void;
    passDictContainingDict(arg?: DictContainingDict): void;
    passDictContainingSequence(arg?: DictContainingSequence): void;
    receiveDictContainingSequence(): DictContainingSequence;
    passVariadicDictionary(arg?: Dict): void;
    dontEnforceRangeOrClamp(arg: number): void;
    doEnforceRange(arg: number): void;
    doEnforceRangeNullable(arg: number | null): void;
    doClamp(arg: number): void;
    doClampNullable(arg: number | null): void;
    enforcedByte: number;
    enforcedByteNullable: number | null;
    clampedByte: number;
    clampedByteNullable: number | null;
    exerciseTypedefInterfaces1(arg: TestJSImplInterface): void;
    exerciseTypedefInterfaces2(arg: TestJSImplInterface | null): TestJSImplInterface;
    exerciseTypedefInterfaces3(arg: TestJSImplInterface): void;
    deprecatedAttribute: number;
    deprecatedMethod(): number;
    deprecatedMethodWithContext(arg: any): void;
    overload1(arg: TestJSImplInterface): boolean;
    overload1(strs: string, arg: TestJSImplInterface): TestJSImplInterface;
    overload2(arg: TestJSImplInterface): void;
    overload2(arg?: Dict): void;
    overload2(arg: boolean): void;
    overload2(arg: string): void;
    overload2(arg: Date): void;
    overload3(arg: TestJSImplInterface): void;
    overload3(arg: MyTestCallback): void;
    overload3(arg: boolean): void;
    overload4(arg: TestJSImplInterface): void;
    overload4(arg: TestCallbackInterface): void;
    overload4(arg: string): void;
    overload5(arg: number): void;
    overload5(arg: MyTestEnum): void;
    overload6(arg: number): void;
    overload6(arg: boolean): void;
    overload7(arg: number): void;
    overload7(arg: boolean): void;
    overload7(arg: string): void;
    overload8(arg: number): void;
    overload8(arg: TestJSImplInterface): void;
    overload9(arg: number | null): void;
    overload9(arg: string): void;
    overload10(arg: number | null): void;
    overload10(arg: object): void;
    overload11(arg: number): void;
    overload11(arg: string | null): void;
    overload12(arg: number): void;
    overload12(arg: boolean | null): void;
    overload13(arg: number | null): void;
    overload13(arg: boolean): void;
    overload14(arg?: number): void;
    overload14(arg: TestInterface): void;
    overload15(arg: number): void;
    overload15(arg?: TestInterface): void;
    overload16(arg: number): void;
    overload16(arg?: TestInterface | null): void;
    overload17(arg: number[]): void;
    overload17(arg: Record<string, number>): void;
    overload18(arg: Record<string, string>): void;
    overload18(arg: string[]): void;
    overload19(arg: number[]): void;
    overload19(arg?: Dict): void;
    overload20(arg?: Dict): void;
    overload20(arg: number[]): void;
    passVariadicThirdArg(arg1: string, arg2: number, arg3?: TestJSImplInterface): void;
    readonly prefable1: boolean;
    readonly prefable2: boolean;
    readonly prefable3: boolean;
    readonly prefable4: boolean;
    readonly prefable5: boolean;
    readonly prefable6: boolean;
    readonly prefable7: boolean;
    readonly prefable8: boolean;
    readonly prefable9: boolean;
    prefable10(): void;
    prefable11(): void;
    readonly prefable12: boolean;
    prefable13(): void;
    readonly prefable14: boolean;
    readonly prefable15: boolean;
    readonly prefable16: boolean;
    prefable17(): void;
    prefable18(): void;
    prefable19(): void;
    prefable20(): void;
    readonly conditionalOnSecureContext1: boolean;
    readonly conditionalOnSecureContext2: boolean;
    readonly conditionalOnSecureContext3: boolean;
    readonly conditionalOnSecureContext4: boolean;
    conditionalOnSecureContext5(): void;
    conditionalOnSecureContext6(): void;
    conditionalOnSecureContext7(): void;
    conditionalOnSecureContext8(): void;
    attrWithLenientThis: number;
    passRenamedInterface(arg: TestRenamedInterface): void;
    readonly putForwardsAttr: TestJSImplInterface;
    readonly putForwardsAttr2: TestJSImplInterface;
    readonly putForwardsAttr3: TestJSImplInterface;
    throwingMethod(): void;
    throwingAttr: boolean;
    throwingGetterAttr: boolean;
    throwingSetterAttr: boolean;
    canOOMMethod(): void;
    canOOMAttr: boolean;
    canOOMGetterAttr: boolean;
    canOOMSetterAttr: boolean;
    ceReactionsMethod(): void;
    ceReactionsMethodOverload(): void;
    ceReactionsMethodOverload(bar: string): void;
    ceReactionsAttr: boolean;
    passArgsWithDefaults(arg1?: number, arg2?: TestInterface | null, arg3?: Dict, arg4?: number, arg5?: number): void;
    toJSONShouldSkipThis: any;
    toJSONShouldSkipThis2: TestParentInterface;
    toJSONShouldSkipThis3: TestCallbackInterface;
    toJSON(): object;
    "dashed-attribute": number;
    "dashed-method"(): void;
    nonEnumerableAttr: boolean;
    nonEnumerableMethod(): void;
  }
  class TestCImplementedInterface {
  }
  class TestCImplementedInterface2 {
  }
  class TestJSImplNoInterfaceObject {
  }
  class Window {
    readonly window: WindowProxy;
    readonly self: WindowProxy;
    readonly document: Document | null;
    name: string;
    readonly location: Location;
    readonly history: History;
    readonly customElements: CustomElementRegistry;
    readonly locationbar: BarProp;
    readonly menubar: BarProp;
    readonly personalbar: BarProp;
    readonly scrollbars: BarProp;
    readonly statusbar: BarProp;
    readonly toolbar: BarProp;
    status: string;
    close(): void;
    readonly closed: boolean;
    stop(): void;
    focus(): void;
    blur(): void;
    readonly event: any;
    readonly frames: WindowProxy;
    readonly length: number;
    readonly top: WindowProxy | null;
    opener: any;
    readonly parent: WindowProxy | null;
    readonly frameElement: Element | null;
    open(url?: string, target?: string, features?: string): WindowProxy | null;
    __namedgetter(name: string): object;
    readonly navigator: Navigator;
    readonly external: External;
    readonly applicationCache: OfflineResourceList;
    alert(): void;
    alert(message: string): void;
    confirm(message?: string): boolean;
    prompt(message?: string, default?: string): string | null;
    print(): void;
    postMessage(message: any, targetOrigin: string, transfer?: object[]): void;
    postMessage(message: any, options?: WindowPostMessageOptions): void;
    onappinstalled: EventHandlerNonNull | null;
    captureEvents(): void;
    releaseEvents(): void;
    getSelection(): Selection | null;
    getComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration | null;
    matchMedia(query: string): MediaQueryList | null;
    readonly screen: Screen;
    moveTo(x: number, y: number): void;
    moveBy(x: number, y: number): void;
    resizeTo(x: number, y: number): void;
    resizeBy(x: number, y: number): void;
    innerWidth: any;
    innerHeight: any;
    scroll(x: number, y: number): void;
    scroll(options?: ScrollToOptions): void;
    scrollTo(x: number, y: number): void;
    scrollTo(options?: ScrollToOptions): void;
    scrollBy(x: number, y: number): void;
    scrollBy(options?: ScrollToOptions): void;
    mozScrollSnap(): void;
    readonly scrollX: number;
    readonly pageXOffset: number;
    readonly scrollY: number;
    readonly pageYOffset: number;
    readonly screenLeft: number;
    readonly screenTop: number;
    screenX: any;
    screenY: any;
    outerWidth: any;
    outerHeight: any;
    requestAnimationFrame(callback: FrameRequestCallback): number;
    cancelAnimationFrame(handle: number): void;
    readonly performance: Performance | null;
    getDefaultComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration | null;
    scrollByLines(numLines: number, options?: ScrollOptions): void;
    scrollByPages(numPages: number, options?: ScrollOptions): void;
    sizeToContent(): void;
    readonly controllers: XULControllers;
    readonly realFrameElement: Element | null;
    readonly docShell: nsIDocShell | null;
    readonly mozInnerScreenX: number;
    readonly mozInnerScreenY: number;
    readonly devicePixelRatio: number;
    readonly scrollMinX: number;
    readonly scrollMinY: number;
    readonly scrollMaxX: number;
    readonly scrollMaxY: number;
    fullScreen: boolean;
    updateCommands(action: string, sel?: Selection | null, reason?: number): void;
    find(str?: string, caseSensitive?: boolean, backwards?: boolean, wrapAround?: boolean, wholeWord?: boolean, searchInFrames?: boolean, showDialog?: boolean): boolean;
    readonly mozPaintCount: number;
    ondevicemotion: EventHandlerNonNull | null;
    ondeviceorientation: EventHandlerNonNull | null;
    onabsolutedeviceorientation: EventHandlerNonNull | null;
    ondeviceproximity: EventHandlerNonNull | null;
    onuserproximity: EventHandlerNonNull | null;
    ondevicelight: EventHandlerNonNull | null;
    dump(str: string): void;
    setResizable(resizable: boolean): void;
    openDialog(url?: string, name?: string, options?: string, extraArguments?: any): WindowProxy | null;
    readonly content: object | null;
    getInterface(iid: any): any;
    readonly windowRoot: WindowRoot | null;
    shouldReportForServiceWorkerScope(aScope: string): boolean;
    readonly InstallTrigger: InstallTriggerImpl | null;
    readonly windowUtils: nsIDOMWindowUtils;
    readonly hasOpenerForInitialContentBrowser: boolean;
    getWindowGlobalChild(): WindowGlobalChild | null;
    readonly sidebar: External | WindowProxy;
    readonly windowState: number;
    readonly isFullyOccluded: boolean;
    browserDOMWindow: nsIBrowserDOMWindow | null;
    getAttention(): void;
    getAttentionWithCycleCount(aCycleCount: number): void;
    setCursor(cursor: string): void;
    maximize(): void;
    minimize(): void;
    restore(): void;
    notifyDefaultButtonLoaded(defaultButton: Element): void;
    readonly messageManager: ChromeMessageBroadcaster;
    getGroupMessageManager(aGroup: string): ChromeMessageBroadcaster;
    promiseDocumentFlushed(callback: PromiseDocumentFlushedCallback): Promise<any>;
    readonly isChromeWindow: boolean;
    onvrdisplayconnect: EventHandlerNonNull | null;
    onvrdisplaydisconnect: EventHandlerNonNull | null;
    onvrdisplayactivate: EventHandlerNonNull | null;
    onvrdisplaydeactivate: EventHandlerNonNull | null;
    onvrdisplaypresentchange: EventHandlerNonNull | null;
    readonly paintWorklet: Worklet;
    requestIdleCallback(callback: IdleRequestCallback, options?: IdleRequestOptions): number;
    cancelIdleCallback(handle: number): void;
    getRegionalPrefsLocales(): string[];
    getWebExposedLocales(): string[];
    readonly intlUtils: IntlUtils;
    readonly visualViewport: VisualViewport;
    readonly crypto: Crypto;
    onabort: EventHandlerNonNull | null;
    onblur: EventHandlerNonNull | null;
    onfocus: EventHandlerNonNull | null;
    onauxclick: EventHandlerNonNull | null;
    oncanplay: EventHandlerNonNull | null;
    oncanplaythrough: EventHandlerNonNull | null;
    onchange: EventHandlerNonNull | null;
    onclick: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    oncontextmenu: EventHandlerNonNull | null;
    oncuechange: EventHandlerNonNull | null;
    ondblclick: EventHandlerNonNull | null;
    ondrag: EventHandlerNonNull | null;
    ondragend: EventHandlerNonNull | null;
    ondragenter: EventHandlerNonNull | null;
    ondragexit: EventHandlerNonNull | null;
    ondragleave: EventHandlerNonNull | null;
    ondragover: EventHandlerNonNull | null;
    ondragstart: EventHandlerNonNull | null;
    ondrop: EventHandlerNonNull | null;
    ondurationchange: EventHandlerNonNull | null;
    onemptied: EventHandlerNonNull | null;
    onended: EventHandlerNonNull | null;
    onformdata: EventHandlerNonNull | null;
    oninput: EventHandlerNonNull | null;
    oninvalid: EventHandlerNonNull | null;
    onkeydown: EventHandlerNonNull | null;
    onkeypress: EventHandlerNonNull | null;
    onkeyup: EventHandlerNonNull | null;
    onload: EventHandlerNonNull | null;
    onloadeddata: EventHandlerNonNull | null;
    onloadedmetadata: EventHandlerNonNull | null;
    onloadend: EventHandlerNonNull | null;
    onloadstart: EventHandlerNonNull | null;
    onmousedown: EventHandlerNonNull | null;
    onmouseenter: EventHandlerNonNull | null;
    onmouseleave: EventHandlerNonNull | null;
    onmousemove: EventHandlerNonNull | null;
    onmouseout: EventHandlerNonNull | null;
    onmouseover: EventHandlerNonNull | null;
    onmouseup: EventHandlerNonNull | null;
    onwheel: EventHandlerNonNull | null;
    onpause: EventHandlerNonNull | null;
    onplay: EventHandlerNonNull | null;
    onplaying: EventHandlerNonNull | null;
    onprogress: EventHandlerNonNull | null;
    onratechange: EventHandlerNonNull | null;
    onreset: EventHandlerNonNull | null;
    onresize: EventHandlerNonNull | null;
    onscroll: EventHandlerNonNull | null;
    onseeked: EventHandlerNonNull | null;
    onseeking: EventHandlerNonNull | null;
    onselect: EventHandlerNonNull | null;
    onshow: EventHandlerNonNull | null;
    onstalled: EventHandlerNonNull | null;
    onsubmit: EventHandlerNonNull | null;
    onsuspend: EventHandlerNonNull | null;
    ontimeupdate: EventHandlerNonNull | null;
    onvolumechange: EventHandlerNonNull | null;
    onwaiting: EventHandlerNonNull | null;
    onselectstart: EventHandlerNonNull | null;
    ontoggle: EventHandlerNonNull | null;
    onpointercancel: EventHandlerNonNull | null;
    onpointerdown: EventHandlerNonNull | null;
    onpointerup: EventHandlerNonNull | null;
    onpointermove: EventHandlerNonNull | null;
    onpointerout: EventHandlerNonNull | null;
    onpointerover: EventHandlerNonNull | null;
    onpointerenter: EventHandlerNonNull | null;
    onpointerleave: EventHandlerNonNull | null;
    ongotpointercapture: EventHandlerNonNull | null;
    onlostpointercapture: EventHandlerNonNull | null;
    onmozfullscreenchange: EventHandlerNonNull | null;
    onmozfullscreenerror: EventHandlerNonNull | null;
    onanimationcancel: EventHandlerNonNull | null;
    onanimationend: EventHandlerNonNull | null;
    onanimationiteration: EventHandlerNonNull | null;
    onanimationstart: EventHandlerNonNull | null;
    ontransitioncancel: EventHandlerNonNull | null;
    ontransitionend: EventHandlerNonNull | null;
    ontransitionrun: EventHandlerNonNull | null;
    ontransitionstart: EventHandlerNonNull | null;
    onwebkitanimationend: EventHandlerNonNull | null;
    onwebkitanimationiteration: EventHandlerNonNull | null;
    onwebkitanimationstart: EventHandlerNonNull | null;
    onwebkittransitionend: EventHandlerNonNull | null;
    readonly u2f: U2F;
    onerror: OnErrorEventHandlerNonNull | null;
    readonly speechSynthesis: SpeechSynthesis;
    ontouchstart: EventHandlerNonNull | null;
    ontouchend: EventHandlerNonNull | null;
    ontouchmove: EventHandlerNonNull | null;
    ontouchcancel: EventHandlerNonNull | null;
    onafterprint: EventHandlerNonNull | null;
    onbeforeprint: EventHandlerNonNull | null;
    onbeforeunload: OnBeforeUnloadEventHandlerNonNull | null;
    onhashchange: EventHandlerNonNull | null;
    onlanguagechange: EventHandlerNonNull | null;
    onmessage: EventHandlerNonNull | null;
    onmessageerror: EventHandlerNonNull | null;
    onoffline: EventHandlerNonNull | null;
    ononline: EventHandlerNonNull | null;
    onpagehide: EventHandlerNonNull | null;
    onpageshow: EventHandlerNonNull | null;
    onpopstate: EventHandlerNonNull | null;
    onrejectionhandled: EventHandlerNonNull | null;
    onstorage: EventHandlerNonNull | null;
    onunhandledrejection: EventHandlerNonNull | null;
    onunload: EventHandlerNonNull | null;
    readonly localStorage: Storage | null;
    readonly origin: string;
    readonly crossOriginIsolated: boolean;
    btoa(btoa: string): string;
    atob(atob: string): string;
    setTimeout(handler: Function, timeout?: number, arguments?: any): number;
    setTimeout(handler: string, timeout?: number, unused?: any): number;
    clearTimeout(handle?: number): void;
    setInterval(handler: Function, timeout?: number, arguments?: any): number;
    setInterval(handler: string, timeout?: number, unused?: any): number;
    clearInterval(handle?: number): void;
    queueMicrotask(callback: VoidFunction): void;
    createImageBitmap(aImage: HTMLImageElement | SVGImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap | Blob | CanvasRenderingContext2D | ImageData): Promise<ImageBitmap>;
    createImageBitmap(aImage: HTMLImageElement | SVGImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap | Blob | CanvasRenderingContext2D | ImageData, aSx: number, aSy: number, aSw: number, aSh: number): Promise<ImageBitmap>;
    fetch(input: Request | string, init?: RequestInit): Promise<Response>;
    readonly isSecureContext: boolean;
    readonly indexedDB: IDBFactory | null;
    readonly caches: CacheStorage;
    readonly sessionStorage: Storage | null;
  }
  enum ScrollBehavior {
    Auto = "auto",
    Instant = "instant",
    Smooth = "smooth",
  }
  interface ScrollOptions {
    behavior?: ScrollBehavior
  }
  interface ScrollToOptions {
    left?: number
    top?: number
  }
  function FrameRequestCallback(time: number): void;
  function PromiseDocumentFlushedCallback(): any;
  interface IdleRequestOptions {
    timeout?: number
  }
  function IdleRequestCallback(deadline: IdleDeadline): void;
  interface WindowPostMessageOptions {
    targetOrigin?: string
  }
  interface GrandparentDict {
    someNum?: number
  }
  class TestJSImplInterface2 {
  }
  class TestJSImplInterface3 {
  }
  class TestJSImplInterface5 {
  }
  class TestJSImplInterface6 {
  }
  class TestJSImplInterface4 {
  }
  class BrowsingContext {
    get(aId: number): BrowsingContext | null;
    getFromWindow(window: WindowProxy): BrowsingContext | null;
    findChildWithName(name: string, accessor: BrowsingContext): BrowsingContext | null;
    findWithName(name: string): BrowsingContext | null;
    readonly name: string;
    readonly parent: BrowsingContext | null;
    readonly top: BrowsingContext;
    getChildren(): BrowsingContext[];
    readonly docShell: nsIDocShell | null;
    readonly embedderElement: Element | null;
    readonly id: number;
    readonly opener: BrowsingContext | null;
    readonly group: BrowsingContextGroup;
    readonly window: WindowProxy | null;
    sandboxFlags: number;
    inRDMPane: boolean;
    setRDMPaneOrientation(type: OrientationType, rotationAngle: number): void;
  }
  class CanonicalBrowsingContext {
    getWindowGlobals(): WindowGlobalParent[];
    readonly currentWindowGlobal: WindowGlobalParent | null;
    readonly currentRemoteType: string | null;
    readonly embedderWindowGlobal: WindowGlobalParent | null;
    notifyStartDelayedAutoplayMedia(): void;
    notifyMediaMutedChanged(muted: boolean): void;
    countSiteOrigins(roots: BrowsingContext[]): number;
    loadURI(aURI: string, aOptions?: LoadURIOptions): void;
    changeFrameRemoteness(remoteType: string, pendingSwitchId: number): Promise<number>;
    readonly sessionHistory: nsISHistory | null;
  }
  class BrowsingContextGroup {
    getToplevels(): BrowsingContext[];
  }
  enum MozContentPolicyType {
    Main_frame = "main_frame",
    Sub_frame = "sub_frame",
    Stylesheet = "stylesheet",
    Script = "script",
    Image = "image",
    Object = "object",
    Object_subrequest = "object_subrequest",
    Xmlhttprequest = "xmlhttprequest",
    Fetch = "fetch",
    Xbl = "xbl",
    Xslt = "xslt",
    Ping = "ping",
    Beacon = "beacon",
    Xml_dtd = "xml_dtd",
    Font = "font",
    Media = "media",
    Websocket = "websocket",
    Csp_report = "csp_report",
    Imageset = "imageset",
    Web_manifest = "web_manifest",
    Speculative = "speculative",
    Other = "other",
  }
  enum MozUrlClassificationFlags {
    Fingerprinting = "fingerprinting",
    Fingerprinting_content = "fingerprinting_content",
    Cryptomining = "cryptomining",
    Cryptomining_content = "cryptomining_content",
    Tracking = "tracking",
    Tracking_ad = "tracking_ad",
    Tracking_analytics = "tracking_analytics",
    Tracking_social = "tracking_social",
    Tracking_content = "tracking_content",
    Socialtracking = "socialtracking",
    Socialtracking_facebook = "socialtracking_facebook",
    Socialtracking_linkedin = "socialtracking_linkedin",
    Socialtracking_twitter = "socialtracking_twitter",
    Any_basic_tracking = "any_basic_tracking",
    Any_strict_tracking = "any_strict_tracking",
    Any_social_tracking = "any_social_tracking",
  }
  class ChannelWrapper {
    get(channel: MozChannel): ChannelWrapper;
    getRegisteredChannel(aChannelId: number, extension: WebExtensionPolicy, remoteTab: RemoteTab | null): ChannelWrapper | null;
    readonly id: number;
    channel: MozChannel | null;
    cancel(result: number): void;
    redirectTo(url: URI): void;
    upgradeToSecure(): void;
    contentType: string;
    readonly method: string;
    readonly type: MozContentPolicyType;
    suspended: boolean;
    readonly finalURI: URI;
    readonly finalURL: string;
    matches(filter?: MozRequestFilter, extension?: WebExtensionPolicy | null, options?: MozRequestMatchOptions): boolean;
    registerTraceableChannel(extension: WebExtensionPolicy, remoteTab: RemoteTab | null): void;
    readonly statusCode: number;
    readonly statusLine: string;
    readonly errorString: string | null;
    onerror: EventHandlerNonNull | null;
    errorCheck(): void;
    onstart: EventHandlerNonNull | null;
    onstop: EventHandlerNonNull | null;
    readonly proxyInfo: MozProxyInfo | null;
    readonly remoteAddress: string | null;
    readonly loadInfo: LoadInfo | null;
    readonly isSystemLoad: boolean;
    readonly originURL: string | null;
    readonly documentURL: string | null;
    readonly originURI: URI | null;
    readonly documentURI: URI | null;
    readonly canModify: boolean;
    readonly windowId: number;
    readonly parentWindowId: number;
    readonly browserElement: nsISupports | null;
    readonly frameAncestors: MozFrameAncestorInfo[] | null;
    getRequestHeaders(): MozHTTPHeader[];
    getResponseHeaders(): MozHTTPHeader[];
    setRequestHeader(header: string, value: string, merge?: boolean): void;
    setResponseHeader(header: string, value: string, merge?: boolean): void;
    readonly urlClassification: MozUrlClassification | null;
    readonly thirdParty: boolean;
    readonly requestSize: number;
    readonly responseSize: number;
  }
  interface MozUrlClassification {
    firstParty: MozUrlClassificationFlags[]
    thirdParty: MozUrlClassificationFlags[]
  }
  interface MozProxyInfo {
    connectionIsolationKey?: string | null
    failoverTimeout?: number
    host: string
    port: number
    proxyAuthorizationHeader?: string | null
    proxyDNS: boolean
    type: string
    username?: string | null
  }
  interface MozFrameAncestorInfo {
    frameId: number
    url: string
  }
  interface MozHTTPHeader {
    name: string
    value: string
  }
  interface MozRequestFilter {
    incognito?: boolean | null
    types?: MozContentPolicyType[] | null
    urls?: MatchPatternSet | null
  }
  interface MozRequestMatchOptions {
    isProxy?: boolean
  }
  class ClonedErrorHolder {
  }
  interface DOMCollectedFrame {
    dataUri: string
    timeOffset: number
  }
  interface DOMCollectedFrames {
    frames: DOMCollectedFrame[]
    recordingStart: number
  }
  class DOMLocalization {
    connectRoot(aElement: Node): void;
    disconnectRoot(aElement: Node): void;
    pauseObserving(): void;
    resumeObserving(): void;
    setAttributes(aElement: Element, aId: string, aArgs?: object | null): void;
    getAttributes(aElement: Element): L10nKey;
    translateFragment(aNode: Node): Promise<any>;
    translateElements(aElements: Element[]): Promise<void>;
    translateRoots(): Promise<void>;
  }
  enum DebuggerNotificationType {
    SetTimeout = "setTimeout",
    ClearTimeout = "clearTimeout",
    SetInterval = "setInterval",
    ClearInterval = "clearInterval",
    RequestAnimationFrame = "requestAnimationFrame",
    CancelAnimationFrame = "cancelAnimationFrame",
    SetTimeoutCallback = "setTimeoutCallback",
    SetIntervalCallback = "setIntervalCallback",
    RequestAnimationFrameCallback = "requestAnimationFrameCallback",
    DomEvent = "domEvent",
  }
  class DebuggerNotification {
    readonly type: DebuggerNotificationType;
    readonly global: object;
  }
  enum CallbackDebuggerNotificationPhase {
    Pre = "pre",
    Post = "post",
  }
  class CallbackDebuggerNotification {
    readonly phase: CallbackDebuggerNotificationPhase;
  }
  enum EventCallbackDebuggerNotificationType {
    Global = "global",
    Node = "node",
    Xhr = "xhr",
    Worker = "worker",
  }
  class EventCallbackDebuggerNotification {
    readonly event: Event;
    readonly targetType: EventCallbackDebuggerNotificationType;
  }
  function DebuggerNotificationCallback(n: DebuggerNotification): void;
  class DebuggerNotificationObserver {
    connect(global: object): boolean;
    disconnect(global: object): boolean;
    addListener(handler: DebuggerNotificationCallback): boolean;
    removeListener(handler: DebuggerNotificationCallback): boolean;
  }
  interface HTMLContent {
    complete?: boolean
    contents?: string
    parserID?: string
    uri?: string
  }
  class DocumentL10n {
    readonly ready: Promise<any>;
  }
  class DominatorTree {
    readonly root: number;
    getRetainedSize(node: number): number | null;
    getImmediatelyDominated(node: number): number[] | null;
    getImmediateDominator(node: number): number | null;
  }
  enum FlexPhysicalDirection {
    Horizontal_lr = "horizontal-lr",
    Horizontal_rl = "horizontal-rl",
    Vertical_tb = "vertical-tb",
    Vertical_bt = "vertical-bt",
  }
  class Flex {
    getLines(): FlexLineValues[];
    readonly mainAxisDirection: FlexPhysicalDirection;
    readonly crossAxisDirection: FlexPhysicalDirection;
  }
  enum FlexLineGrowthState {
    Shrinking = "shrinking",
    Growing = "growing",
  }
  class FlexLineValues {
    readonly growthState: FlexLineGrowthState;
    readonly crossStart: number;
    readonly crossSize: number;
    readonly firstBaselineOffset: number;
    readonly lastBaselineOffset: number;
    getItems(): FlexItemValues[];
  }
  enum FlexItemClampState {
    Unclamped = "unclamped",
    Clamped_to_min = "clamped_to_min",
    Clamped_to_max = "clamped_to_max",
  }
  class FlexItemValues {
    readonly node: Node | null;
    readonly frameRect: DOMRectReadOnly;
    readonly mainBaseSize: number;
    readonly mainDeltaSize: number;
    readonly mainMinSize: number;
    readonly mainMaxSize: number;
    readonly crossMinSize: number;
    readonly crossMaxSize: number;
    readonly clampState: FlexItemClampState;
  }
  class HeapSnapshot {
    readonly creationTime: number | null;
    takeCensus(options: object | null): any;
    describeNode(breakdown: object, node: number): any;
    computeDominatorTree(): DominatorTree;
    computeShortestPaths(start: number, targets: number[], maxNumPaths: number): object;
  }
  interface PropertyNamesOptions {
    includeAliases?: boolean
    includeExperimentals?: boolean
    includeShorthands?: boolean
  }
  interface PropertyPref {
    name: string
    pref: string
  }
  interface InspectorRGBATuple {
    a?: number
    b?: number
    g?: number
    r?: number
  }
  enum InspectorPropertyType {
    Color = "color",
    Gradient = "gradient",
    Timing_function = "timing-function",
  }
  interface InspectorVariationAxis {
    defaultValue: number
    maxValue: number
    minValue: number
    name: string
    tag: string
  }
  interface InspectorVariationValue {
    axis: string
    value: number
  }
  interface InspectorVariationInstance {
    name: string
    values: InspectorVariationValue[]
  }
  interface InspectorFontFeature {
    languageSystem: string
    script: string
    tag: string
  }
  class InspectorFontFace {
    readonly fromFontGroup: boolean;
    readonly fromLanguagePrefs: boolean;
    readonly fromSystemFallback: boolean;
    readonly name: string;
    readonly CSSFamilyName: string;
    readonly CSSGeneric: string;
    getVariationAxes(): InspectorVariationAxis[];
    getVariationInstances(): InspectorVariationInstance[];
    getFeatures(): InspectorFontFeature[];
    readonly ranges: Range[];
    readonly rule: CSSFontFaceRule | null;
    readonly srcIndex: number;
    readonly URI: string;
    readonly localName: string;
    readonly format: string;
    readonly metadata: string;
  }
  interface IteratorResult {
    done: boolean
    value?: any
  }
  class JSWindowActorParent {
    readonly manager: WindowGlobalParent | null;
    readonly browsingContext: CanonicalBrowsingContext | null;
    sendAsyncMessage(messageName: string, obj?: any): void;
    sendQuery(messageName: string, obj?: any): Promise<any>;
  }
  class JSWindowActorChild {
    readonly manager: WindowGlobalChild | null;
    readonly document: Document | null;
    readonly browsingContext: BrowsingContext | null;
    readonly docShell: nsIDocShell | null;
    readonly contentWindow: WindowProxy | null;
    sendAsyncMessage(messageName: string, obj?: any): void;
    sendQuery(messageName: string, obj?: any): Promise<any>;
  }
  class MozObserverCallback {
    observe(subject: nsISupports, topic: string, data: string | null): void;
  }
  function MozJSWindowActorCallback(): void;
  interface MozJSWindowActorCallbacks {
    actorCreated?: MozJSWindowActorCallback
    didDestroy?: MozJSWindowActorCallback
    willDestroy?: MozJSWindowActorCallback
  }
  interface WindowActorOptions {
    allFrames?: boolean
    child?: WindowActorChildOptions
    includeChrome?: boolean
    matches?: string[]
    parent?: WindowActorSidedOptions
    remoteTypes?: string[]
  }
  interface WindowActorSidedOptions {
    moduleURI: string
  }
  interface WindowActorChildOptions {
    events?: Record<string, AddEventListenerOptions>
    observers?: string[]
  }
  interface L10nOverlaysError {
    code?: number
    l10nName?: string
    sourceElementName?: string
    translatedElementName?: string
  }
  interface L10nKey {
    args?: Record<string, string | number | null> | null
    id?: string | null
  }
  interface AttributeNameValue {
    name: string
    value: string
  }
  interface L10nMessage {
    attributes?: AttributeNameValue[] | null
    value?: string | null
  }
  function GenerateMessages(aResourceIds: string[]): Promise<any>;
  class Localization {
    addResourceIds(aResourceIds: string[], aEager?: boolean): number;
    removeResourceIds(aResourceIds: string[]): number;
    formatValue(aId: string, aArgs?: Record<string, string | number | null>): Promise<string>;
    formatValues(aKeys: L10nKey[]): Promise<string[]>;
    formatMessages(aKeys: L10nKey[]): Promise<L10nMessage[]>;
  }
  interface L10nArgsHelperDict {
    args: Record<string, string | number | null>
  }
  class MatchGlob {
    matches(string: string): boolean;
    readonly glob: string;
  }
  class MatchPattern {
    matches(uri: URI, explicit?: boolean): boolean;
    matches(url: string, explicit?: boolean): boolean;
    matchesCookie(cookie: Cookie): boolean;
    subsumes(pattern: MatchPattern): boolean;
    subsumesDomain(pattern: MatchPattern): boolean;
    overlaps(pattern: MatchPattern): boolean;
    readonly pattern: string;
  }
  class MatchPatternSet {
    matches(uri: URI, explicit?: boolean): boolean;
    matches(url: string, explicit?: boolean): boolean;
    matchesCookie(cookie: Cookie): boolean;
    subsumes(pattern: MatchPattern): boolean;
    subsumesDomain(pattern: MatchPattern): boolean;
    overlaps(pattern: MatchPattern): boolean;
    overlaps(patternSet: MatchPatternSet): boolean;
    overlapsAll(patternSet: MatchPatternSet): boolean;
    readonly patterns: MatchPattern[];
  }
  interface MatchPatternOptions {
    ignorePath?: boolean
    restrictSchemes?: boolean
  }
  interface ReceiveMessageArgument {
    data?: any
    json?: any
    name: string
    objects: object
    ports?: MessagePort[]
    principal: Principal | null
    sync: boolean
    target: nsISupports
    targetFrameLoader?: FrameLoader
  }
  class MessageListener {
    receiveMessage(argument: ReceiveMessageArgument): any;
  }
  class MessageListenerManager {
    addMessageListener(messageName: string, listener: MessageListener, listenWhenClosed?: boolean): void;
    removeMessageListener(messageName: string, listener: MessageListener): void;
    addWeakMessageListener(messageName: string, listener: MessageListener): void;
    removeWeakMessageListener(messageName: string, listener: MessageListener): void;
  }
  class MessageSender {
    sendAsyncMessage(messageName?: string | null, obj?: any, objects?: object | null, principal?: Principal | null, transfers?: any): void;
    readonly processMessageManager: MessageSender | null;
    readonly remoteType: string;
  }
  class SyncMessageSender {
    sendSyncMessage(messageName?: string | null, obj?: any, objects?: object | null, principal?: Principal | null): any[];
    sendRpcMessage(messageName?: string | null, obj?: any, objects?: object | null, principal?: Principal | null): any[];
  }
  class ChildProcessMessageManager {
  }
  class ContentFrameMessageManager {
    readonly content: WindowProxy | null;
    readonly docShell: nsIDocShell | null;
    readonly tabEventTarget: nsIEventTarget | null;
    readonly chromeOuterWindowID: number;
    addMessageListener(messageName: string, listener: MessageListener, listenWhenClosed?: boolean): void;
    removeMessageListener(messageName: string, listener: MessageListener): void;
    addWeakMessageListener(messageName: string, listener: MessageListener): void;
    removeWeakMessageListener(messageName: string, listener: MessageListener): void;
    dump(str: string): void;
    privateNoteIntentionalCrash(): void;
    atob(asciiString: string): string;
    btoa(base64Data: string): string;
    sendAsyncMessage(messageName?: string | null, obj?: any, objects?: object | null, principal?: Principal | null, transfers?: any): void;
    readonly processMessageManager: MessageSender | null;
    readonly remoteType: string;
    sendSyncMessage(messageName?: string | null, obj?: any, objects?: object | null, principal?: Principal | null): any[];
    sendRpcMessage(messageName?: string | null, obj?: any, objects?: object | null, principal?: Principal | null): any[];
  }
  class ContentProcessMessageManager {
    readonly initialProcessData: any;
    readonly sharedData: MozSharedMap;
    addMessageListener(messageName: string, listener: MessageListener, listenWhenClosed?: boolean): void;
    removeMessageListener(messageName: string, listener: MessageListener): void;
    addWeakMessageListener(messageName: string, listener: MessageListener): void;
    removeWeakMessageListener(messageName: string, listener: MessageListener): void;
    dump(str: string): void;
    privateNoteIntentionalCrash(): void;
    atob(asciiString: string): string;
    btoa(base64Data: string): string;
    sendAsyncMessage(messageName?: string | null, obj?: any, objects?: object | null, principal?: Principal | null, transfers?: any): void;
    readonly processMessageManager: MessageSender | null;
    readonly remoteType: string;
    sendSyncMessage(messageName?: string | null, obj?: any, objects?: object | null, principal?: Principal | null): any[];
    sendRpcMessage(messageName?: string | null, obj?: any, objects?: object | null, principal?: Principal | null): any[];
  }
  class MessageBroadcaster {
    broadcastAsyncMessage(messageName?: string | null, obj?: any, objects?: object | null): void;
    readonly childCount: number;
    getChildAt(aIndex: number): MessageListenerManager | null;
    releaseCachedProcesses(): void;
  }
  class ChromeMessageBroadcaster {
    loadFrameScript(url: string, allowDelayedLoad: boolean, runInGlobalScope?: boolean): void;
    removeDelayedFrameScript(url: string): void;
    getDelayedFrameScripts(): any[][];
  }
  class ParentProcessMessageManager {
    readonly initialProcessData: any;
    readonly sharedData: MozWritableSharedMap;
    loadProcessScript(url: string, allowDelayedLoad: boolean): void;
    removeDelayedProcessScript(url: string): void;
    getDelayedProcessScripts(): any[][];
  }
  class ChromeMessageSender {
    loadFrameScript(url: string, allowDelayedLoad: boolean, runInGlobalScope?: boolean): void;
    removeDelayedFrameScript(url: string): void;
    getDelayedFrameScripts(): any[][];
  }
  class ProcessMessageManager {
    readonly osPid: number;
    readonly isInProcess: boolean;
    loadProcessScript(url: string, allowDelayedLoad: boolean): void;
    removeDelayedProcessScript(url: string): void;
    getDelayedProcessScripts(): any[][];
  }
  class MozDocumentCallback {
    onNewDocument(matcher: MozDocumentMatcher, window: WindowProxy): void;
    onPreloadDocument(matcher: MozDocumentMatcher, loadInfo: LoadInfo): void;
  }
  class MozDocumentObserver {
    observe(matchers: MozDocumentMatcher[]): void;
    disconnect(): void;
  }
  class MozSharedMapChangeEvent {
    readonly changedKeys: string[];
    readonly isTrusted: boolean;
  }
  interface MozSharedMapChangeEventInit {
    changedKeys: string[]
  }
  class MozSharedMap {
    has(name: string): boolean;
    get(name: string): any;
    entries(): MozSharedMapIterator;
    keys(): MozSharedMapIterator;
    values(): MozSharedMapIterator;
    forEach(callback: object, thisArg?: any): void;
  }
  class MozWritableSharedMap {
    set(name: string, value: any): void;
    delete(name: string): void;
    flush(): void;
  }
  class MozStorageAsyncStatementParams {
    readonly length: number;
    __indexedgetter(index: number): any;
    __namedgetter(name: string): any;
    __indexedsetter(index: number, arg: any): void;
    __namedsetter(name: string, arg: any): void;
  }
  class MozStorageStatementParams {
    readonly length: number;
    __indexedgetter(index: number): any;
    __namedgetter(name: string): any;
    __indexedsetter(index: number, arg: any): void;
    __namedsetter(name: string, arg: any): void;
  }
  class MozStorageStatementRow {
    __namedgetter(name: string): any;
  }
  enum PlacesEventType {
    None = "none",
    Page_visited = "page-visited",
    Bookmark_added = "bookmark-added",
  }
  class PlacesEvent {
    readonly type: PlacesEventType;
  }
  class PlacesVisit {
    readonly url: string;
    readonly visitId: number;
    readonly visitTime: number;
    readonly referringVisitId: number;
    readonly transitionType: number;
    readonly pageGuid: string;
    readonly hidden: boolean;
    readonly visitCount: number;
    readonly typedCount: number;
    readonly lastKnownTitle: string | null;
  }
  class PlacesBookmark {
    readonly id: number;
    readonly parentId: number;
    readonly itemType: number;
    readonly url: string;
    readonly guid: string;
    readonly parentGuid: string;
    readonly source: number;
    readonly isTagging: boolean;
  }
  interface PlacesBookmarkAdditionInit {
    dateAdded: number
    guid: string
    id: number
    index: number
    isTagging: boolean
    itemType: number
    parentGuid: string
    parentId: number
    source: number
    title: string
    url: string
  }
  class PlacesBookmarkAddition {
    readonly index: number;
    readonly title: string;
    readonly dateAdded: number;
  }
  function PlacesEventCallback(events: PlacesEvent[]): void;
  class PlacesWeakCallbackWrapper {
  }
  class PrecompiledScript {
    executeInGlobal(global: object): any;
    readonly url: string;
    readonly hasReturnValue: boolean;
  }
  interface PrioParams {
    booleans: boolean[]
  }
  interface PrioEncodedData {
    a?: Uint8Array
    b?: Uint8Array
  }
  interface PromiseDebuggingStateHolder {
    reason?: any
    state?: PromiseDebuggingState
    value?: any
  }
  enum PromiseDebuggingState {
    Pending = "pending",
    Fulfilled = "fulfilled",
    Rejected = "rejected",
  }
  class UncaughtRejectionObserver {
    onLeftUncaught(p: object): boolean;
    onConsumed(p: object): void;
  }
  function SessionStoreUtilsFrameCallback(frame: WindowProxy, index: number): void;
  interface CollectedFileListValue {
    fileList: string[]
    type: string
  }
  interface CollectedNonMultipleSelectValue {
    selectedIndex: number
    value: string
  }
  interface CollectedData {
    children?: object | null[]
    id?: Record<string, string | boolean | object>
    innerHTML?: string
    scroll?: string
    url?: string
    xpath?: Record<string, string | boolean | object>
  }
  interface InputElementData {
    boolVal?: boolean[]
    id?: string[]
    selectVal?: string[]
    selectedIndex?: number[]
    strVal?: string[]
    type?: string[]
    valueIdx?: number[]
  }
  interface UpdateSessionStoreData {
    docShellCaps?: string
    id?: InputElementData
    innerHTML?: string[]
    inputDescendants?: number[]
    isFullStorage?: boolean
    isPrivate?: boolean
    numId?: number[]
    numXPath?: number[]
    positionDescendants?: number[]
    positions?: string[]
    storageKeys?: string[]
    storageOrigins?: string[]
    storageValues?: string[]
    url?: string[]
    xpath?: InputElementData
  }
  class StructuredCloneHolder {
    deserialize(global: object, keepData?: boolean): any;
  }
  interface TelemetryStopwatchOptions {
    inSeconds?: boolean
  }
  class MozDocumentMatcher {
    matchesURI(uri: URI): boolean;
    matchesLoadInfo(uri: URI, loadInfo: LoadInfo): boolean;
    matchesWindow(window: WindowProxy): boolean;
    readonly allFrames: boolean;
    readonly matchAboutBlank: boolean;
    readonly frameID: number | null;
    readonly matches: MatchPatternSet;
    readonly excludeMatches: MatchPatternSet | null;
    readonly includeGlobs: MatchGlob[] | null;
    readonly excludeGlobs: MatchGlob[] | null;
    readonly extension: WebExtensionPolicy | null;
  }
  interface MozDocumentMatcherInit {
    allFrames?: boolean
    excludeGlobs?: MatchGlob | string[] | null
    excludeMatches?: MatchPatternSet | string[] | null
    frameID?: number | null
    hasActiveTabPermission?: boolean
    includeGlobs?: MatchGlob | string[] | null
    matchAboutBlank?: boolean
    matches: MatchPatternSet | string[]
  }
  enum ContentScriptRunAt {
    Document_start = "document_start",
    Document_end = "document_end",
    Document_idle = "document_idle",
  }
  class WebExtensionContentScript {
    readonly runAt: ContentScriptRunAt;
    readonly cssPaths: string[];
    readonly jsPaths: string[];
  }
  interface WebExtensionContentScriptInit {
    cssPaths?: string[]
    jsPaths?: string[]
    runAt?: ContentScriptRunAt
  }
  function WebExtensionLocalizeCallback(unlocalizedText: string): string;
  class WebExtensionPolicy {
    readonly id: string;
    readonly mozExtensionHostname: string;
    readonly baseURL: string;
    readonly name: string;
    readonly isPrivileged: boolean;
    readonly extensionPageCSP: string;
    readonly contentScriptCSP: string;
    permissions: string[];
    allowedOrigins: MatchPatternSet;
    readonly contentScripts: WebExtensionContentScript[];
    active: boolean;
    static readonly useRemoteWebExtensions: boolean;
    static readonly isExtensionProcess: boolean;
    readonly privateBrowsingAllowed: boolean;
    canAccessWindow(window: WindowProxy): boolean;
    canAccessURI(uri: URI, explicit?: boolean): boolean;
    hasPermission(permission: string): boolean;
    isPathWebAccessible(pathname: string): boolean;
    localize(unlocalizedText: string): string;
    getURL(path?: string): string;
    registerContentScript(script: WebExtensionContentScript): void;
    unregisterContentScript(script: WebExtensionContentScript): void;
    injectContentScripts(): void;
    getActiveExtensions(): WebExtensionPolicy[];
    getByID(id: string): WebExtensionPolicy | null;
    getByHostname(hostname: string): WebExtensionPolicy | null;
    getByURI(uri: URI): WebExtensionPolicy | null;
    isRestrictedURI(uri: URI): boolean;
    readonly readyPromise: object | null;
  }
  interface WebExtensionInit {
    allowedOrigins: MatchPatternSet | string[]
    backgroundScripts?: string[] | null
    baseURL: string
    contentScriptCSP?: string | null
    contentScripts?: WebExtensionContentScriptInit[]
    extensionPageCSP?: string | null
    id: string
    isPrivileged?: boolean
    localizeCallback: WebExtensionLocalizeCallback
    mozExtensionHostname: string
    name?: string
    permissions?: string[]
    readyPromise?: Promise<WebExtensionPolicy>
    webAccessibleResources?: MatchGlob | string[]
  }
  class WindowGlobalParent {
    readonly isClosed: boolean;
    readonly isInProcess: boolean;
    readonly browsingContext: CanonicalBrowsingContext;
    readonly isCurrentGlobal: boolean;
    readonly innerWindowId: number;
    readonly outerWindowId: number;
    readonly contentParentId: number;
    readonly osPid: number;
    readonly isProcessRoot: boolean;
    readonly hasBeforeUnload: boolean;
    readonly isInitialDocument: boolean;
    readonly rootFrameLoader: FrameLoader | null;
    readonly childActor: WindowGlobalChild | null;
    readonly documentPrincipal: Principal;
    readonly documentURI: URI | null;
    getByInnerWindowId(innerWindowId: number): WindowGlobalParent | null;
    getActor(name: string): JSWindowActorParent;
    drawSnapshot(rect: DOMRect | null, scale: number, backgroundColor: string): Promise<ImageBitmap>;
    getSecurityInfo(): Promise<nsITransportSecurityInfo>;
  }
  class WindowGlobalChild {
    readonly isClosed: boolean;
    readonly isInProcess: boolean;
    readonly browsingContext: BrowsingContext;
    readonly isCurrentGlobal: boolean;
    readonly innerWindowId: number;
    readonly outerWindowId: number;
    readonly contentParentId: number;
    readonly isProcessRoot: boolean;
    readonly parentActor: WindowGlobalParent | null;
    getByInnerWindowId(innerWIndowId: number): WindowGlobalChild | null;
    getActor(name: string): JSWindowActorChild;
  }
  class XULFrameElement {
    readonly docShell: nsIDocShell | null;
    readonly webNavigation: nsIWebNavigation | null;
    readonly contentWindow: WindowProxy | null;
    readonly contentDocument: Document | null;
    readonly frameLoader: FrameLoader | null;
    readonly browsingContext: BrowsingContext | null;
    presetOpenerWindow(window: WindowProxy | null): void;
    swapFrameLoaders(aOtherLoaderOwner: XULFrameElement): void;
    swapFrameLoaders(aOtherLoaderOwner: HTMLIFrameElement): void;
    changeRemoteness(aOptions: RemotenessOptions): void;
  }
  class XULMenuElement {
    activeChild: Element | null;
    handleKeyPress(keyEvent: KeyboardEvent): boolean;
    readonly openedWithKey: boolean;
  }
  class XULTextElement {
    disabled: boolean;
    value: string;
    accessKey: string;
  }
  interface TreeCellInfo {
    childElt?: string
    col?: TreeColumn | null
    row?: number
  }
  class XULTreeElement {
    readonly columns: TreeColumns | null;
    view: MozTreeView | null;
    focused: boolean;
    readonly treeBody: Element | null;
    readonly rowHeight: number;
    readonly rowWidth: number;
    readonly horizontalPosition: number;
    getFirstVisibleRow(): number;
    getLastVisibleRow(): number;
    getPageLength(): number;
    ensureRowIsVisible(index: number): void;
    ensureCellIsVisible(row: number, col: TreeColumn | null): void;
    scrollToRow(index: number): void;
    scrollByLines(numLines: number): void;
    scrollByPages(numPages: number): void;
    invalidate(): void;
    invalidateColumn(col: TreeColumn | null): void;
    invalidateRow(index: number): void;
    invalidateCell(row: number, col: TreeColumn | null): void;
    invalidateRange(startIndex: number, endIndex: number): void;
    getRowAt(x: number, y: number): number;
    getCellAt(x: number, y: number): TreeCellInfo;
    getCoordsForCellItem(row: number, col: TreeColumn, element: string): DOMRect | null;
    isCellCropped(row: number, col: TreeColumn | null): boolean;
    rowCountChanged(index: number, count: number): void;
    beginUpdateBatch(): void;
    endUpdateBatch(): void;
    clearStyleAndImageCaches(): void;
    removeImageCacheEntry(row: number, col: TreeColumn): void;
  }
  interface ScrollFrameDataEntry {
    key?: string
    value?: string
  }
  interface ScrollFrameData {
    entries?: ScrollFrameDataEntry[]
    scrollId?: number
  }
  interface APZBucket {
    scrollFrames?: ScrollFrameData[]
    sequenceNumber?: number
  }
  interface APZHitResult {
    hitResult?: number
    layersId?: number
    screenX?: number
    screenY?: number
    scrollId?: number
  }
  interface AdditionalDataEntry {
    key?: string
    value?: string
  }
  interface APZTestData {
    additionalData?: AdditionalDataEntry[]
    hitResults?: APZHitResult[]
    paints?: APZBucket[]
    repaintRequests?: APZBucket[]
  }
  interface FrameUniformity {
    frameUniformity?: number
    layerAddress?: number
  }
  interface FrameUniformityResults {
    layerUniformities?: FrameUniformity[]
  }
  class AbortController {
    readonly signal: AbortSignal;
    abort(): void;
  }
  class AbortSignal {
    readonly aborted: boolean;
    onabort: EventHandlerNonNull | null;
  }
  class AbstractRange {
    readonly startContainer: Node;
    readonly startOffset: number;
    readonly endContainer: Node;
    readonly endOffset: number;
    readonly collapsed: boolean;
  }
  class AccessibleNode {
    readonly computedRole: string;
    readonly states: string[];
    readonly attributes: string[];
    readonly DOMNode: Node | null;
    is(states?: string): boolean;
    has(attributes?: string): boolean;
    get(attribute: string): any;
    role: string | null;
    roleDescription: string | null;
    label: string | null;
    current: string | null;
    autocomplete: string | null;
    keyShortcuts: string | null;
    modal: boolean | null;
    multiline: boolean | null;
    multiselectable: boolean | null;
    orientation: string | null;
    readOnly: boolean | null;
    required: boolean | null;
    sort: string | null;
    placeholder: string | null;
    valueMax: number | null;
    valueMin: number | null;
    valueNow: number | null;
    valueText: string | null;
    checked: string | null;
    disabled: boolean | null;
    expanded: boolean | null;
    hasPopUp: string | null;
    hidden: boolean | null;
    invalid: string | null;
    pressed: string | null;
    selected: boolean | null;
    atomic: boolean | null;
    busy: boolean | null;
    live: string | null;
    relevant: string | null;
    activeDescendant: AccessibleNode | null;
    details: AccessibleNode | null;
    errorMessage: AccessibleNode | null;
    colCount: number | null;
    colIndex: number | null;
    colSpan: number | null;
    level: number | null;
    posInSet: number | null;
    rowCount: number | null;
    rowIndex: number | null;
    rowSpan: number | null;
    setSize: number | null;
  }
  class AddonEvent {
    readonly id: string;
    readonly isTrusted: boolean;
  }
  interface AddonEventInit {
    id: string
  }
  class Addon {
    readonly id: string;
    readonly version: string;
    readonly type: string;
    readonly name: string;
    readonly description: string;
    readonly isEnabled: boolean;
    readonly isActive: boolean;
    readonly canUninstall: boolean;
    uninstall(): Promise<boolean>;
    setEnabled(value: boolean): Promise<void>;
  }
  class AddonInstall {
    readonly state: string;
    readonly error: string | null;
    readonly progress: number;
    readonly maxProgress: number;
    install(): Promise<void>;
    cancel(): Promise<void>;
  }
  interface addonInstallOptions {
    hash?: string | null
    url: string
  }
  class AddonManager {
    getAddonByID(id: string): Promise<Addon>;
    createInstall(options?: addonInstallOptions): Promise<AddonInstall>;
    reportAbuse(id: string): Promise<boolean>;
    readonly permissionPromptsEnabled: boolean;
    readonly abuseReportPanelEnabled: boolean;
  }
  interface AnalyserOptions {
    fftSize?: number
    maxDecibels?: number
    minDecibels?: number
    smoothingTimeConstant?: number
  }
  class AnalyserNode {
    getFloatFrequencyData(array: Float32Array): void;
    getByteFrequencyData(array: Uint8Array): void;
    getFloatTimeDomainData(array: Float32Array): void;
    getByteTimeDomainData(array: Uint8Array): void;
    fftSize: number;
    readonly frequencyBinCount: number;
    minDecibels: number;
    maxDecibels: number;
    smoothingTimeConstant: number;
    passThrough: boolean;
  }
  interface KeyframeAnimationOptions {
    id?: string
  }
  interface GetAnimationsOptions {
    subtree?: boolean
  }
  enum AnimationPlayState {
    Idle = "idle",
    Running = "running",
    Paused = "paused",
    Finished = "finished",
  }
  enum AnimationReplaceState {
    Active = "active",
    Removed = "removed",
    Persisted = "persisted",
  }
  class Animation {
    id: string;
    effect: AnimationEffect | null;
    timeline: AnimationTimeline | null;
    startTime: number | null;
    currentTime: number | null;
    playbackRate: number;
    readonly playState: AnimationPlayState;
    readonly pending: boolean;
    readonly replaceState: AnimationReplaceState;
    readonly ready: Promise<Animation>;
    readonly finished: Promise<Animation>;
    onfinish: EventHandlerNonNull | null;
    oncancel: EventHandlerNonNull | null;
    onremove: EventHandlerNonNull | null;
    cancel(): void;
    finish(): void;
    play(): void;
    pause(): void;
    updatePlaybackRate(playbackRate: number): void;
    reverse(): void;
    persist(): void;
    commitStyles(): void;
    readonly isRunningOnCompositor: boolean;
  }
  enum FillMode {
    None = "none",
    Forwards = "forwards",
    Backwards = "backwards",
    Both = "both",
    Auto = "auto",
  }
  enum PlaybackDirection {
    Normal = "normal",
    Reverse = "reverse",
    Alternate = "alternate",
    Alternate_reverse = "alternate-reverse",
  }
  interface EffectTiming {
    delay?: number
    direction?: PlaybackDirection
    duration?: number | string
    easing?: string
    endDelay?: number
    fill?: FillMode
    iterationStart?: number
    iterations?: number
  }
  interface OptionalEffectTiming {
    delay?: number
    direction?: PlaybackDirection
    duration?: number | string
    easing?: string
    endDelay?: number
    fill?: FillMode
    iterationStart?: number
    iterations?: number
  }
  interface ComputedEffectTiming {
    activeDuration?: number
    currentIteration?: number | null
    endTime?: number
    localTime?: number | null
    progress?: number | null
  }
  class AnimationEffect {
    getTiming(): EffectTiming;
    getComputedTiming(): ComputedEffectTiming;
    updateTiming(timing?: OptionalEffectTiming): void;
  }
  class AnimationEvent {
    readonly animationName: string;
    readonly elapsedTime: number;
    readonly pseudoElement: string;
    readonly isTrusted: boolean;
  }
  interface AnimationEventInit {
    animationName?: string
    elapsedTime?: number
    pseudoElement?: string
  }
  class AnimationPlaybackEvent {
    readonly currentTime: number | null;
    readonly timelineTime: number | null;
    readonly isTrusted: boolean;
  }
  interface AnimationPlaybackEventInit {
    currentTime?: number | null
    timelineTime?: number | null
  }
  class AnimationTimeline {
    readonly currentTime: number | null;
  }
  class AnonymousContent {
    getTextContentForElement(elementId: string): string;
    setTextContentForElement(elementId: string, text: string): void;
    getAttributeForElement(elementId: string, attributeName: string): string | null;
    setAttributeForElement(elementId: string, attributeName: string, value: string): void;
    removeAttributeForElement(elementId: string, attributeName: string): void;
    getCanvasContext(elementId: string, contextId: string): nsISupports | null;
    setAnimationForElement(elementId: string, keyframes: object | null, options?: number | KeyframeAnimationOptions): Animation;
    setCutoutRectsForElement(elementId: string, rects: DOMRect[]): void;
    getComputedStylePropertyValue(elementId: string, propertyName: string): string | null;
    getTargetIdForEvent(event: Event): string | null;
    setStyle(property: string, value: string): void;
  }
  interface AppInfo {
    isCoreApp?: boolean
    path?: string
  }
  interface AppNotificationServiceOptions {
    data?: string
    dbId?: string
    dir?: string
    id?: string
    lang?: string
    manifestURL?: string
    mozbehavior?: NotificationBehavior
    tag?: string
    textClickable?: boolean
  }
  class Attr {
    readonly localName: string;
    value: string;
    readonly name: string;
    readonly namespaceURI: string | null;
    readonly prefix: string | null;
    readonly specified: boolean;
    readonly ownerElement: Element | null;
  }
  interface AudioBufferOptions {
    length: number
    numberOfChannels?: number
    sampleRate: number
  }
  class AudioBuffer {
    readonly sampleRate: number;
    readonly length: number;
    readonly duration: number;
    readonly numberOfChannels: number;
    getChannelData(channel: number): Float32Array;
    copyFromChannel(destination: Float32Array, channelNumber: number, startInChannel?: number): void;
    copyToChannel(source: Float32Array, channelNumber: number, startInChannel?: number): void;
  }
  interface AudioBufferSourceOptions {
    buffer?: AudioBuffer | null
    detune?: number
    loop?: boolean
    loopEnd?: number
    loopStart?: number
    playbackRate?: number
  }
  class AudioBufferSourceNode {
    buffer: AudioBuffer | null;
    readonly playbackRate: AudioParam;
    readonly detune: AudioParam;
    loop: boolean;
    loopStart: number;
    loopEnd: number;
    start(when?: number, grainOffset?: number, grainDuration?: number): void;
    passThrough: boolean;
  }
  interface AudioContextOptions {
    sampleRate?: number
  }
  interface AudioTimestamp {
    contextTime?: number
    performanceTime?: number
  }
  class AudioContext {
    readonly baseLatency: number;
    readonly outputLatency: number;
    getOutputTimestamp(): AudioTimestamp;
    suspend(): Promise<void>;
    close(): Promise<void>;
    createMediaElementSource(mediaElement: HTMLMediaElement): MediaElementAudioSourceNode;
    createMediaStreamSource(mediaStream: MediaStream): MediaStreamAudioSourceNode;
    createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack): MediaStreamTrackAudioSourceNode;
    createMediaStreamDestination(): MediaStreamAudioDestinationNode;
  }
  class AudioDestinationNode {
    readonly maxChannelCount: number;
  }
  class AudioListener {
    setPosition(x: number, y: number, z: number): void;
    setOrientation(x: number, y: number, z: number, xUp: number, yUp: number, zUp: number): void;
  }
  enum ChannelCountMode {
    Max = "max",
    Clamped_max = "clamped-max",
    Explicit = "explicit",
  }
  enum ChannelInterpretation {
    Speakers = "speakers",
    Discrete = "discrete",
  }
  interface AudioNodeOptions {
    channelCount?: number
    channelCountMode?: ChannelCountMode
    channelInterpretation?: ChannelInterpretation
  }
  class AudioNode {
    connect(destination: AudioNode, output?: number, input?: number): AudioNode;
    connect(destination: AudioParam, output?: number): void;
    disconnect(): void;
    disconnect(output: number): void;
    disconnect(destination: AudioNode): void;
    disconnect(destination: AudioNode, output: number): void;
    disconnect(destination: AudioNode, output: number, input: number): void;
    disconnect(destination: AudioParam): void;
    disconnect(destination: AudioParam, output: number): void;
    readonly context: BaseAudioContext;
    readonly numberOfInputs: number;
    readonly numberOfOutputs: number;
    channelCount: number;
    channelCountMode: ChannelCountMode;
    channelInterpretation: ChannelInterpretation;
    readonly id: number;
  }
  enum AutomationRate {
    A_rate = "a-rate",
    K_rate = "k-rate",
  }
  class AudioParam {
    value: number;
    readonly defaultValue: number;
    readonly minValue: number;
    readonly maxValue: number;
    setValueAtTime(value: number, startTime: number): AudioParam;
    linearRampToValueAtTime(value: number, endTime: number): AudioParam;
    exponentialRampToValueAtTime(value: number, endTime: number): AudioParam;
    setTargetAtTime(target: number, startTime: number, timeConstant: number): AudioParam;
    setValueCurveAtTime(values: number[], startTime: number, duration: number): AudioParam;
    cancelScheduledValues(startTime: number): AudioParam;
    readonly parentNodeId: number;
    readonly name: string;
    readonly isTrackSuspended: boolean;
  }
  interface AudioParamDescriptor {
    defaultValue?: number
    maxValue?: number
    minValue?: number
    name: string
  }
  class AudioParamMap {
    readonly size: number;
    entries(): object;
    keys(): object;
    values(): object;
    forEach(callback: object, thisArg?: any): void;
    has(key: string): boolean;
    get(key: string): any;
  }
  class AudioProcessingEvent {
    readonly playbackTime: number;
    readonly inputBuffer: AudioBuffer;
    readonly outputBuffer: AudioBuffer;
    readonly isTrusted: boolean;
  }
  class AudioScheduledSourceNode {
    onended: EventHandlerNonNull | null;
    start(when?: number): void;
    stop(when?: number): void;
  }
  class AudioTrack {
    readonly id: string;
    readonly kind: string;
    readonly label: string;
    readonly language: string;
    enabled: boolean;
  }
  class AudioTrackList {
    readonly length: number;
    __indexedgetter(index: number): AudioTrack;
    getTrackById(id: string): AudioTrack | null;
    onchange: EventHandlerNonNull | null;
    onaddtrack: EventHandlerNonNull | null;
    onremovetrack: EventHandlerNonNull | null;
  }
  class AudioWorklet {
  }
  function AudioWorkletProcessorConstructor(options: object): AudioWorkletProcessor;
  class AudioWorkletGlobalScope {
    registerProcessor(name: string, processorCtor: AudioWorkletProcessorConstructor): void;
    readonly currentFrame: number;
    readonly currentTime: number;
    readonly sampleRate: number;
  }
  interface AudioWorkletNodeOptions {
    numberOfInputs?: number
    numberOfOutputs?: number
    outputChannelCount?: number[]
    parameterData?: Record<string, number>
    processorOptions?: object | null
  }
  class AudioWorkletNode {
    readonly parameters: AudioParamMap;
    readonly port: MessagePort;
    onprocessorerror: EventHandlerNonNull | null;
  }
  class AudioWorkletProcessor {
    readonly port: MessagePort;
  }
  interface AutocompleteInfo {
    addressType?: string
    canAutomaticallyPersist?: boolean
    contactType?: string
    fieldName?: string
    section?: string
  }
  class BarProp {
    visible: boolean;
  }
  function DecodeSuccessCallback(decodedData: AudioBuffer): void;
  function DecodeErrorCallback(error: DOMException): void;
  enum AudioContextState {
    Suspended = "suspended",
    Running = "running",
    Closed = "closed",
  }
  class BaseAudioContext {
    readonly destination: AudioDestinationNode;
    readonly sampleRate: number;
    readonly currentTime: number;
    readonly listener: AudioListener;
    readonly state: AudioContextState;
    readonly audioWorklet: AudioWorklet;
    resume(): Promise<void>;
    onstatechange: EventHandlerNonNull | null;
    createBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer;
    decodeAudioData(audioData: ArrayBuffer, successCallback?: DecodeSuccessCallback, errorCallback?: DecodeErrorCallback): Promise<AudioBuffer>;
    createBufferSource(): AudioBufferSourceNode;
    createConstantSource(): ConstantSourceNode;
    createScriptProcessor(bufferSize?: number, numberOfInputChannels?: number, numberOfOutputChannels?: number): ScriptProcessorNode;
    createAnalyser(): AnalyserNode;
    createGain(): GainNode;
    createDelay(maxDelayTime?: number): DelayNode;
    createBiquadFilter(): BiquadFilterNode;
    createIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode;
    createWaveShaper(): WaveShaperNode;
    createPanner(): PannerNode;
    createStereoPanner(): StereoPannerNode;
    createConvolver(): ConvolverNode;
    createChannelSplitter(numberOfOutputs?: number): ChannelSplitterNode;
    createChannelMerger(numberOfInputs?: number): ChannelMergerNode;
    createDynamicsCompressor(): DynamicsCompressorNode;
    createOscillator(): OscillatorNode;
    createPeriodicWave(real: Float32Array, imag: Float32Array, constraints?: PeriodicWaveConstraints): PeriodicWave;
  }
  enum CompositeOperation {
    Replace = "replace",
    Add = "add",
    Accumulate = "accumulate",
  }
  enum CompositeOperationOrAuto {
    Replace = "replace",
    Add = "add",
    Accumulate = "accumulate",
    Auto = "auto",
  }
  interface BasePropertyIndexedKeyframe {
    composite?: CompositeOperationOrAuto | CompositeOperationOrAuto[]
    easing?: string | string[]
    offset?: number | null | number | null[]
  }
  interface BaseKeyframe {
    composite?: CompositeOperationOrAuto
    easing?: string
    offset?: number | null
    simulateComputeValuesFailure?: boolean
  }
  interface BaseComputedKeyframe {
    computedOffset?: number
  }
  interface BasicCardRequest {
    requestSecurityCode?: boolean
    supportedNetworks?: string[]
  }
  interface BasicCardResponse {
    billingAddress?: PaymentAddress | null
    cardNumber: string
    cardSecurityCode?: string
    cardholderName?: string
    expiryMonth?: string
    expiryYear?: string
  }
  interface BasicCardChangeDetails {
    billingAddress?: PaymentAddress | null
  }
  interface BasicCardErrors {
    billingAddress?: AddressErrors
    cardNumber?: string
    cardSecurityCode?: string
    cardholderName?: string
    expiryMonth?: string
    expiryYear?: string
  }
  class BatteryManager {
    readonly charging: boolean;
    readonly chargingTime: number;
    readonly dischargingTime: number;
    readonly level: number;
    onchargingchange: EventHandlerNonNull | null;
    onchargingtimechange: EventHandlerNonNull | null;
    ondischargingtimechange: EventHandlerNonNull | null;
    onlevelchange: EventHandlerNonNull | null;
  }
  class BeforeUnloadEvent {
    returnValue: string;
    readonly isTrusted: boolean;
  }
  enum BiquadFilterType {
    Lowpass = "lowpass",
    Highpass = "highpass",
    Bandpass = "bandpass",
    Lowshelf = "lowshelf",
    Highshelf = "highshelf",
    Peaking = "peaking",
    Notch = "notch",
    Allpass = "allpass",
  }
  interface BiquadFilterOptions {
    Q?: number
    detune?: number
    frequency?: number
    gain?: number
    type?: BiquadFilterType
  }
  class BiquadFilterNode {
    type: BiquadFilterType;
    readonly frequency: AudioParam;
    readonly detune: AudioParam;
    readonly Q: AudioParam;
    readonly gain: AudioParam;
    getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;
    passThrough: boolean;
  }
  class Blob {
    readonly size: number;
    readonly type: string;
    slice(start?: number, end?: number, contentType?: string): Blob;
    stream(): ReadableStream;
    text(): Promise<string>;
    arrayBuffer(): Promise<ArrayBuffer>;
    readonly blobImplType: string;
  }
  enum EndingTypes {
    Transparent = "transparent",
    Native = "native",
  }
  interface BlobPropertyBag {
    endings?: EndingTypes
    type?: string
  }
  class BlobEvent {
    readonly data: Blob | null;
    readonly isTrusted: boolean;
  }
  interface BlobEventInit {
    data?: Blob | null
  }
  class BroadcastChannel {
    readonly name: string;
    postMessage(message: any): void;
    close(): void;
    onmessage: EventHandlerNonNull | null;
    onmessageerror: EventHandlerNonNull | null;
  }
  interface OpenWindowEventDetail {
    features?: string
    forceNoReferrer?: boolean
    frameElement?: Node | null
    name?: string
    url?: string
  }
  interface DOMWindowResizeEventDetail {
    height?: number
    width?: number
  }
  class CDATASection {
  }
  interface CSP {
    "base-uri"?: string[]
    "block-all-mixed-content"?: string[]
    "child-src"?: string[]
    "connect-src"?: string[]
    "default-src"?: string[]
    "font-src"?: string[]
    "form-action"?: string[]
    "frame-ancestors"?: string[]
    "frame-src"?: string[]
    "img-src"?: string[]
    "manifest-src"?: string[]
    "media-src"?: string[]
    "object-src"?: string[]
    referrer?: string[]
    "report-only"?: boolean
    "report-uri"?: string[]
    sandbox?: string[]
    "script-src"?: string[]
    "style-src"?: string[]
    "upgrade-insecure-requests"?: string[]
    "worker-src"?: string[]
  }
  interface CSPPolicies {
    "csp-policies"?: CSP[]
  }
  interface CSPReportProperties {
    "blocked-uri"?: string
    "column-number"?: number
    "document-uri"?: string
    "line-number"?: number
    "original-policy"?: string
    referrer?: string
    "script-sample"?: string
    "source-file"?: string
    "violated-directive"?: string
  }
  interface CSPReport {
    "csp-report"?: CSPReportProperties
  }
  class CSSAnimation {
    readonly animationName: string;
  }
  class CSSConditionRule {
    conditionText: string;
  }
  class CSSCounterStyleRule {
    name: string;
    system: string;
    symbols: string;
    additiveSymbols: string;
    negative: string;
    prefix: string;
    suffix: string;
    range: string;
    pad: string;
    speakAs: string;
    fallback: string;
  }
  class CSSFontFaceRule {
    readonly style: CSSStyleDeclaration;
  }
  class CSSFontFeatureValuesRule {
    fontFamily: string;
    valueText: string;
  }
  class CSSGroupingRule {
    readonly cssRules: CSSRuleList;
    insertRule(rule: string, index?: number): number;
    deleteRule(index: number): void;
  }
  class CSSImportRule {
    readonly href: string;
    readonly media: MediaList | null;
    readonly styleSheet: CSSStyleSheet | null;
  }
  class CSSKeyframeRule {
    keyText: string;
    readonly style: CSSStyleDeclaration;
  }
  class CSSKeyframesRule {
    name: string;
    readonly cssRules: CSSRuleList;
    appendRule(rule: string): void;
    deleteRule(select: string): void;
    findRule(select: string): CSSKeyframeRule | null;
  }
  class CSSMediaRule {
    readonly media: MediaList;
  }
  class CSSMozDocumentRule {
  }
  class CSSNamespaceRule {
    readonly namespaceURI: string;
    readonly prefix: string;
  }
  class CSSPageRule {
    readonly style: CSSStyleDeclaration;
  }
  class CSSPseudoElement {
    readonly type: string;
    readonly element: Element;
    animate(keyframes: object | null, options?: number | KeyframeAnimationOptions): Animation;
    getAnimations(options?: GetAnimationsOptions): Animation[];
  }
  class CSSRule {
    readonly type: number;
    cssText: string;
    readonly parentRule: CSSRule | null;
    readonly parentStyleSheet: CSSStyleSheet | null;
  }
  class CSSRuleList {
    readonly length: number;
    item(index: number): CSSRule | null;
  }
  class CSSStyleDeclaration {
    cssText: string;
    readonly length: number;
    item(index: number): string;
    getCSSImageURLs(property: string): string[];
    getPropertyValue(property: string): string;
    getPropertyPriority(property: string): string;
    setProperty(property: string, value: string, priority?: string): void;
    removeProperty(property: string): string;
    readonly parentRule: CSSRule | null;
  }
  class CSSStyleRule {
    selectorText: string;
    readonly style: CSSStyleDeclaration;
  }
  enum CSSStyleSheetParsingMode {
    Author = "author",
    User = "user",
    Agent = "agent",
  }
  interface CSSStyleSheetInit {
    alternate?: boolean
    disabled?: boolean
    media?: MediaList | string
    title?: string
  }
  class CSSStyleSheet {
    readonly ownerRule: CSSRule | null;
    readonly cssRules: CSSRuleList;
    readonly parsingMode: CSSStyleSheetParsingMode;
    insertRule(rule: string, index?: number): number;
    deleteRule(index: number): void;
    replace(text: string): Promise<CSSStyleSheet>;
    replaceSync(text: string): void;
    readonly rules: CSSRuleList;
    removeRule(index?: number): void;
    addRule(selector?: string, style?: string, index?: number): number;
  }
  class CSSSupportsRule {
  }
  class CSSTransition {
    readonly transitionProperty: string;
  }
  class Cache {
    match(request: Request | string, options?: CacheQueryOptions): Promise<Response>;
    matchAll(request?: Request | string, options?: CacheQueryOptions): Promise<Response[]>;
    add(request: Request | string): Promise<void>;
    addAll(requests: Request | string[]): Promise<void>;
    put(request: Request | string, response: Response): Promise<void>;
    delete(request: Request | string, options?: CacheQueryOptions): Promise<boolean>;
    keys(request?: Request | string, options?: CacheQueryOptions): Promise<Request[]>;
  }
  interface CacheQueryOptions {
    cacheName?: string
    ignoreMethod?: boolean
    ignoreSearch?: boolean
    ignoreVary?: boolean
  }
  interface CacheBatchOperation {
    options?: CacheQueryOptions
    request?: Request
    response?: Response
    type?: string
  }
  class CacheStorage {
    match(request: Request | string, options?: CacheQueryOptions): Promise<Response>;
    has(cacheName: string): Promise<boolean>;
    open(cacheName: string): Promise<Cache>;
    delete(cacheName: string): Promise<boolean>;
    keys(): Promise<string[]>;
  }
  enum CacheStorageNamespace {
    Content = "content",
    Chrome = "chrome",
  }
  interface CancelContentJSOptions {
    epoch?: number
    index?: number
    uri?: URI | null
  }
  class CanvasCaptureMediaStream {
    readonly canvas: HTMLCanvasElement;
    requestFrame(): void;
  }
  enum CanvasWindingRule {
    Nonzero = "nonzero",
    Evenodd = "evenodd",
  }
  interface ContextAttributes2D {
    alpha?: boolean
    willReadFrequently?: boolean
  }
  interface HitRegionOptions {
    control?: Element | null
    id?: string
    path?: Path2D | null
  }
  class CanvasRenderingContext2D {
    readonly canvas: HTMLCanvasElement | null;
    mozCurrentTransform: object;
    mozCurrentTransformInverse: object;
    mozTextStyle: string;
    mozImageSmoothingEnabled: boolean;
    drawWindow(window: Window, x: number, y: number, w: number, h: number, bgColor: string, flags?: number): void;
    demote(): void;
    globalAlpha: number;
    globalCompositeOperation: string;
    drawImage(image: HTMLImageElement | SVGImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dx: number, dy: number): void;
    drawImage(image: HTMLImageElement | SVGImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dx: number, dy: number, dw: number, dh: number): void;
    drawImage(image: HTMLImageElement | SVGImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
    beginPath(): void;
    fill(winding?: CanvasWindingRule): void;
    fill(path: Path2D, winding?: CanvasWindingRule): void;
    stroke(): void;
    stroke(path: Path2D): void;
    clip(winding?: CanvasWindingRule): void;
    clip(path: Path2D, winding?: CanvasWindingRule): void;
    isPointInPath(x: number, y: number, winding?: CanvasWindingRule): boolean;
    isPointInPath(path: Path2D, x: number, y: number, winding?: CanvasWindingRule): boolean;
    isPointInStroke(x: number, y: number): boolean;
    isPointInStroke(path: Path2D, x: number, y: number): boolean;
    strokeStyle: string | CanvasGradient | CanvasPattern;
    fillStyle: string | CanvasGradient | CanvasPattern;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
    createPattern(image: HTMLImageElement | SVGImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, repetition: string): CanvasPattern | null;
    filter: string;
    addHitRegion(options?: HitRegionOptions): void;
    removeHitRegion(id: string): void;
    clearHitRegions(): void;
    createImageData(sw: number, sh: number): ImageData;
    createImageData(imagedata: ImageData): ImageData;
    getImageData(sx: number, sy: number, sw: number, sh: number): ImageData;
    putImageData(imagedata: ImageData, dx: number, dy: number): void;
    putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void;
    imageSmoothingEnabled: boolean;
    lineWidth: number;
    lineCap: string;
    lineJoin: string;
    miterLimit: number;
    setLineDash(segments: number[]): void;
    getLineDash(): number[];
    lineDashOffset: number;
    closePath(): void;
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    rect(x: number, y: number, w: number, h: number): void;
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    clearRect(x: number, y: number, w: number, h: number): void;
    fillRect(x: number, y: number, w: number, h: number): void;
    strokeRect(x: number, y: number, w: number, h: number): void;
    shadowOffsetX: number;
    shadowOffsetY: number;
    shadowBlur: number;
    shadowColor: string;
    save(): void;
    restore(): void;
    fillText(text: string, x: number, y: number, maxWidth?: number): void;
    strokeText(text: string, x: number, y: number, maxWidth?: number): void;
    measureText(text: string): TextMetrics;
    font: string;
    textAlign: string;
    textBaseline: string;
    scale(x: number, y: number): void;
    rotate(angle: number): void;
    translate(x: number, y: number): void;
    transform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    getTransform(): DOMMatrix;
    setTransform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    setTransform(transform?: DOMMatrix2DInit): void;
    resetTransform(): void;
    drawFocusIfNeeded(element: Element): void;
  }
  class CanvasGradient {
    addColorStop(offset: number, color: string): void;
  }
  class CanvasPattern {
    setTransform(matrix: SVGMatrix): void;
  }
  class TextMetrics {
    readonly width: number;
  }
  class Path2D {
    addPath(path: Path2D, transform?: DOMMatrix2DInit): void;
    closePath(): void;
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    rect(x: number, y: number, w: number, h: number): void;
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
  }
  class CaretPosition {
    readonly offsetNode: Node | null;
    readonly offset: number;
    getClientRect(): DOMRect | null;
  }
  enum CaretChangedReason {
    Visibilitychange = "visibilitychange",
    Updateposition = "updateposition",
    Longpressonemptycontent = "longpressonemptycontent",
    Taponcaret = "taponcaret",
    Presscaret = "presscaret",
    Releasecaret = "releasecaret",
    Scroll = "scroll",
  }
  interface CaretStateChangedEventInit {
    boundingClientRect?: DOMRectReadOnly | null
    caretVisible?: boolean
    caretVisuallyVisible?: boolean
    collapsed?: boolean
    reason?: CaretChangedReason
    selectedTextContent?: string
    selectionEditable?: boolean
    selectionVisible?: boolean
  }
  class CaretStateChangedEvent {
    readonly collapsed: boolean;
    readonly boundingClientRect: DOMRectReadOnly | null;
    readonly reason: CaretChangedReason;
    readonly caretVisible: boolean;
    readonly caretVisuallyVisible: boolean;
    readonly selectionVisible: boolean;
    readonly selectionEditable: boolean;
    readonly selectedTextContent: string;
    readonly isTrusted: boolean;
  }
  interface ChannelMergerOptions {
    numberOfInputs?: number
  }
  class ChannelMergerNode {
  }
  interface ChannelSplitterOptions {
    numberOfOutputs?: number
  }
  class ChannelSplitterNode {
  }
  class CharacterData {
    data: string;
    readonly length: number;
    substringData(offset: number, count: number): string;
    appendData(data: string): void;
    insertData(offset: number, data: string): void;
    deleteData(offset: number, count: number): void;
    replaceData(offset: number, count: number, data: string): void;
    before(nodes?: Node | string): void;
    after(nodes?: Node | string): void;
    replaceWith(nodes?: Node | string): void;
    remove(): void;
    readonly previousElementSibling: Element | null;
    readonly nextElementSibling: Element | null;
  }
  enum CheckerboardReason {
    Severe = "severe",
    Recent = "recent",
  }
  interface CheckerboardReport {
    log?: string
    reason?: CheckerboardReason
    severity?: number
    timestamp?: number
  }
  class CheckerboardReportService {
    getReports(): CheckerboardReport[];
    isRecordingEnabled(): boolean;
    setRecordingEnabled(aEnabled: boolean): void;
    flushActiveReports(): void;
  }
  class ChildSHistory {
    readonly count: number;
    readonly index: number;
    canGo(aOffset: number): boolean;
    go(aOffset: number): void;
    reload(aReloadFlags: number): void;
    readonly legacySHistory: nsISHistory;
  }
  class ChromeNodeList {
    append(aNode: Node): void;
    remove(aNode: Node): void;
  }
  class Client {
    readonly url: string;
    readonly frameType: FrameType;
    readonly type: ClientType;
    readonly id: string;
    postMessage(message: any, transfer: object[]): void;
    postMessage(message: any, aOptions?: PostMessageOptions): void;
  }
  class WindowClient {
    readonly visibilityState: VisibilityState;
    readonly focused: boolean;
    focus(): Promise<WindowClient>;
    navigate(url: string): Promise<WindowClient>;
  }
  enum FrameType {
    Auxiliary = "auxiliary",
    Top_level = "top-level",
    Nested = "nested",
    None = "none",
  }
  class Clients {
    get(id: string): Promise<any>;
    matchAll(options?: ClientQueryOptions): Promise<Client[]>;
    openWindow(url: string): Promise<WindowClient | null>;
    claim(): Promise<void>;
  }
  interface ClientQueryOptions {
    includeUncontrolled?: boolean
    type?: ClientType
  }
  enum ClientType {
    Window = "window",
    Worker = "worker",
    Sharedworker = "sharedworker",
    Serviceworker = "serviceworker",
    All = "all",
  }
  class Clipboard {
    read(): Promise<DataTransfer>;
    readText(): Promise<string>;
    write(data: DataTransfer): Promise<void>;
    writeText(data: string): Promise<void>;
  }
  class ClipboardEvent {
    readonly clipboardData: DataTransfer | null;
    readonly isTrusted: boolean;
  }
  interface ClipboardEventInit {
    data?: string
    dataType?: string
  }
  class CloseEvent {
    readonly wasClean: boolean;
    readonly code: number;
    readonly reason: string;
    readonly isTrusted: boolean;
  }
  interface CloseEventInit {
    code?: number
    reason?: string
    wasClean?: boolean
  }
  class CommandEvent {
    readonly command: string | null;
    readonly isTrusted: boolean;
  }
  class Comment {
  }
  class CompositionEvent {
    readonly data: string | null;
    readonly locale: string;
    readonly ranges: TextClause[];
    initCompositionEvent(typeArg: string, canBubbleArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, dataArg?: string | null, localeArg?: string): void;
    readonly isTrusted: boolean;
  }
  interface CompositionEventInit {
    data?: string
  }
  interface ConsoleEvent {
    ID?: number | string
    addonId?: string
    arguments?: any[]
    chromeContext?: boolean
    columnNumber?: number
    consoleID?: string
    counter?: any
    filename?: string
    functionName?: string
    groupName?: string
    innerID?: number | string
    level?: string
    lineNumber?: number
    prefix?: string
    private?: boolean
    sourceId?: number
    styles?: string | null[]
    timeStamp?: number
    timer?: any
  }
  interface ConsoleProfileEvent {
    action?: string
    arguments?: any[]
    chromeContext?: boolean
  }
  interface ConsoleStackEntry {
    asyncCause?: string | null
    columnNumber?: number
    filename?: string
    functionName?: string
    lineNumber?: number
    sourceId?: number
  }
  interface ConsoleTimerStart {
    name?: string
  }
  interface ConsoleTimerLogOrEnd {
    duration?: number
    name?: string
  }
  interface ConsoleTimerError {
    error?: string
    name?: string
  }
  interface ConsoleCounter {
    count?: number
    label?: string
  }
  interface ConsoleCounterError {
    error?: string
    label?: string
  }
  class ConsoleInstance {
    assert(condition?: boolean, data?: any): void;
    clear(): void;
    count(label?: string): void;
    countReset(label?: string): void;
    debug(data?: any): void;
    error(data?: any): void;
    info(data?: any): void;
    log(data?: any): void;
    table(data?: any): void;
    trace(data?: any): void;
    warn(data?: any): void;
    dir(data?: any): void;
    dirxml(data?: any): void;
    group(data?: any): void;
    groupCollapsed(data?: any): void;
    groupEnd(): void;
    time(label?: string): void;
    timeLog(label?: string, data?: any): void;
    timeEnd(label?: string): void;
    exception(data?: any): void;
    timeStamp(data?: any): void;
    profile(data?: any): void;
    profileEnd(data?: any): void;
    reportForServiceWorkerScope(scope: string, message: string, filename: string, lineNumber: number, columnNumber: number, level: ConsoleLevel): void;
  }
  function ConsoleInstanceDumpCallback(message: string): void;
  enum ConsoleLogLevel {
    All = "All",
    Debug = "Debug",
    Log = "Log",
    Info = "Info",
    Clear = "Clear",
    Trace = "Trace",
    TimeLog = "TimeLog",
    TimeEnd = "TimeEnd",
    Time = "Time",
    Group = "Group",
    GroupEnd = "GroupEnd",
    Profile = "Profile",
    ProfileEnd = "ProfileEnd",
    Dir = "Dir",
    Dirxml = "Dirxml",
    Warn = "Warn",
    Error = "Error",
    Off = "Off",
  }
  interface ConsoleInstanceOptions {
    consoleID?: string
    dump?: ConsoleInstanceDumpCallback
    innerID?: string
    maxLogLevel?: ConsoleLogLevel
    maxLogLevelPref?: string
    prefix?: string
  }
  enum ConsoleLevel {
    Log = "log",
    Warning = "warning",
    Error = "error",
  }
  interface ConstantSourceOptions {
    offset?: number
  }
  class ConstantSourceNode {
    readonly offset: AudioParam;
  }
  interface ConvolverOptions {
    buffer?: AudioBuffer | null
    disableNormalization?: boolean
  }
  class ConvolverNode {
    buffer: AudioBuffer | null;
    normalize: boolean;
    passThrough: boolean;
  }
  class CreateOfferRequest {
    readonly windowID: number;
    readonly innerWindowID: number;
    readonly callID: string;
    readonly isSecure: boolean;
  }
  class Credential {
    readonly id: string;
    readonly type: string;
  }
  class CredentialsContainer {
    get(options?: CredentialRequestOptions): Promise<Credential | null>;
    create(options?: CredentialCreationOptions): Promise<Credential | null>;
    store(credential: Credential): Promise<Credential>;
    preventSilentAccess(): Promise<void>;
  }
  interface CredentialRequestOptions {
    publicKey?: PublicKeyCredentialRequestOptions
    signal?: AbortSignal
  }
  interface CredentialCreationOptions {
    publicKey?: PublicKeyCredentialCreationOptions
    signal?: AbortSignal
  }
  class Crypto {
    readonly subtle: SubtleCrypto;
    getRandomValues(array: ArrayBufferView): ArrayBufferView;
  }
  class CustomElementRegistry {
    define(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions): void;
    setElementCreationCallback(name: string, callback: CustomElementCreationCallback): void;
    get(name: string): any;
    whenDefined(name: string): Promise<void>;
    upgrade(root: Node): void;
  }
  interface ElementDefinitionOptions {
    extends?: string
  }
  function CustomElementConstructor(): any;
  function CustomElementCreationCallback(name: string): void;
  class CustomEvent {
    readonly detail: any;
    initCustomEvent(type: string, canBubble?: boolean, cancelable?: boolean, detail?: any): void;
    readonly isTrusted: boolean;
  }
  interface CustomEventInit {
    detail?: any
  }
  class Exception {
    readonly name: string;
    readonly message: string;
    __stringifier(): string;
    readonly result: number;
    readonly filename: string;
    readonly lineNumber: number;
    readonly columnNumber: number;
    readonly location: StackFrame | null;
    readonly data: nsISupports | null;
    readonly stack: string;
  }
  class DOMException {
    readonly name: string;
    readonly message: string;
    readonly code: number;
    readonly result: number;
    readonly filename: string;
    readonly lineNumber: number;
    readonly columnNumber: number;
    readonly location: StackFrame | null;
    readonly data: nsISupports | null;
    readonly stack: string;
  }
  class DOMImplementation {
    hasFeature(): boolean;
    createDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType;
    createDocument(namespace: string | null, qualifiedName: string, doctype?: DocumentType | null): Document;
    createHTMLDocument(title?: string): Document;
  }
  class DOMMatrixReadOnly {
    fromMatrix(other?: DOMMatrixInit): DOMMatrixReadOnly;
    fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly;
    fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly;
    readonly a: number;
    readonly b: number;
    readonly c: number;
    readonly d: number;
    readonly e: number;
    readonly f: number;
    readonly m11: number;
    readonly m12: number;
    readonly m13: number;
    readonly m14: number;
    readonly m21: number;
    readonly m22: number;
    readonly m23: number;
    readonly m24: number;
    readonly m31: number;
    readonly m32: number;
    readonly m33: number;
    readonly m34: number;
    readonly m41: number;
    readonly m42: number;
    readonly m43: number;
    readonly m44: number;
    translate(tx?: number, ty?: number, tz?: number): DOMMatrix;
    scale(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scaleNonUniform(scaleX?: number, scaleY?: number): DOMMatrix;
    scale3d(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    rotate(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;
    rotateFromVector(x?: number, y?: number): DOMMatrix;
    rotateAxisAngle(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;
    skewX(sx?: number): DOMMatrix;
    skewY(sy?: number): DOMMatrix;
    multiply(other?: DOMMatrixInit): DOMMatrix;
    flipX(): DOMMatrix;
    flipY(): DOMMatrix;
    inverse(): DOMMatrix;
    readonly is2D: boolean;
    readonly isIdentity: boolean;
    transformPoint(point?: DOMPointInit): DOMPoint;
    toFloat32Array(): Float32Array;
    toFloat64Array(): Float64Array;
    __stringifier(): string;
    toJSON(): object;
  }
  class DOMMatrix {
    fromMatrix(other?: DOMMatrixInit): DOMMatrix;
    fromFloat32Array(array32: Float32Array): DOMMatrix;
    fromFloat64Array(array64: Float64Array): DOMMatrix;
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    m11: number;
    m12: number;
    m13: number;
    m14: number;
    m21: number;
    m22: number;
    m23: number;
    m24: number;
    m31: number;
    m32: number;
    m33: number;
    m34: number;
    m41: number;
    m42: number;
    m43: number;
    m44: number;
    multiplySelf(other?: DOMMatrixInit): DOMMatrix;
    preMultiplySelf(other?: DOMMatrixInit): DOMMatrix;
    translateSelf(tx?: number, ty?: number, tz?: number): DOMMatrix;
    scaleSelf(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    scale3dSelf(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;
    rotateSelf(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;
    rotateFromVectorSelf(x?: number, y?: number): DOMMatrix;
    rotateAxisAngleSelf(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;
    skewXSelf(sx?: number): DOMMatrix;
    skewYSelf(sy?: number): DOMMatrix;
    invertSelf(): DOMMatrix;
    setMatrixValue(transformList: string): DOMMatrix;
  }
  interface DOMMatrix2DInit {
    a?: number
    b?: number
    c?: number
    d?: number
    e?: number
    f?: number
    m11?: number
    m12?: number
    m21?: number
    m22?: number
    m41?: number
    m42?: number
  }
  interface DOMMatrixInit {
    is2D?: boolean
    m13?: number
    m14?: number
    m23?: number
    m24?: number
    m31?: number
    m32?: number
    m33?: number
    m34?: number
    m43?: number
    m44?: number
  }
  enum SupportedType {
    Text_html = "text/html",
    Text_xml = "text/xml",
    Application_xml = "application/xml",
    Application_xhtml_xml = "application/xhtml+xml",
    Image_svg_xml = "image/svg+xml",
  }
  class DOMParser {
    parseFromString(str: string, type: SupportedType): Document;
    parseFromSafeString(str: string, type: SupportedType): Document;
    parseFromBuffer(buf: number[], type: SupportedType): Document;
    parseFromBuffer(buf: Uint8Array, type: SupportedType): Document;
    parseFromStream(stream: InputStream, charset: string | null, contentLength: number, type: SupportedType): Document;
    forceEnableXULXBL(): void;
    forceEnableDTD(): void;
  }
  class DOMPointReadOnly {
    fromPoint(other?: DOMPointInit): DOMPointReadOnly;
    readonly x: number;
    readonly y: number;
    readonly z: number;
    readonly w: number;
    matrixTransform(matrix?: DOMMatrixInit): DOMPoint;
    toJSON(): object;
  }
  class DOMPoint {
    fromPoint(other?: DOMPointInit): DOMPoint;
    x: number;
    y: number;
    z: number;
    w: number;
  }
  interface DOMPointInit {
    w?: number
    x?: number
    y?: number
    z?: number
  }
  class DOMQuad {
    fromRect(other?: DOMRectInit): DOMQuad;
    fromQuad(other?: DOMQuadInit): DOMQuad;
    readonly p1: DOMPoint;
    readonly p2: DOMPoint;
    readonly p3: DOMPoint;
    readonly p4: DOMPoint;
    getBounds(): DOMRectReadOnly;
    toJSON(): object;
  }
  interface DOMQuadInit {
    p1?: DOMPointInit
    p2?: DOMPointInit
    p3?: DOMPointInit
    p4?: DOMPointInit
  }
  class DOMRect {
    fromRect(other?: DOMRectInit): DOMRect;
    x: number;
    y: number;
    width: number;
    height: number;
  }
  class DOMRectReadOnly {
    fromRect(other?: DOMRectInit): DOMRectReadOnly;
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
    readonly top: number;
    readonly right: number;
    readonly bottom: number;
    readonly left: number;
    toJSON(): object;
  }
  interface DOMRectInit {
    height?: number
    width?: number
    x?: number
    y?: number
  }
  class DOMRectList {
    readonly length: number;
    item(index: number): DOMRect | null;
  }
  enum DOMRequestReadyState {
    Pending = "pending",
    Done = "done",
  }
  class DOMRequest {
    then(fulfillCallback?: AnyCallback | null, rejectCallback?: AnyCallback | null): any;
    fireDetailedError(aError: DOMException): void;
    readonly readyState: DOMRequestReadyState;
    readonly result: any;
    readonly error: DOMException | null;
    onsuccess: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
  }
  class DOMStringList {
    readonly length: number;
    item(index: number): string | null;
    contains(string: string): boolean;
  }
  class DOMStringMap {
    __namedgetter(name: string): string;
    __namedsetter(name: string, value: string): void;
    __nameddeleter(name: string): void;
  }
  class DOMTokenList {
    readonly length: number;
    item(index: number): string | null;
    contains(token: string): boolean;
    add(tokens?: string): void;
    remove(tokens?: string): void;
    replace(token: string, newToken: string): boolean;
    toggle(token: string, force?: boolean): boolean;
    supports(token: string): boolean;
    value: string;
    __stringifier(): string;
  }
  class DataTransfer {
    dropEffect: string;
    effectAllowed: string;
    readonly items: DataTransferItemList;
    setDragImage(image: Element, x: number, y: number): void;
    readonly types: string[];
    getData(format: string): string;
    setData(format: string, data: string): void;
    clearData(format?: string): void;
    readonly files: FileList | null;
    getFilesAndDirectories(): Promise<File | Directory[]>;
    getFiles(recursiveFlag?: boolean): Promise<File[]>;
    addElement(element: Element): void;
    readonly mozItemCount: number;
    mozCursor: string;
    mozTypesAt(index: number): DOMStringList;
    mozClearDataAt(format: string, index: number): void;
    mozSetDataAt(format: string, data: any, index: number): void;
    mozGetDataAt(format: string, index: number): any;
    updateDragImage(image: Element, x: number, y: number): void;
    readonly mozUserCancelled: boolean;
    readonly mozSourceNode: Node | null;
    readonly mozTriggeringPrincipalURISpec: string;
    readonly mozCSP: ContentSecurityPolicy | null;
    mozCloneForEvent(event: string): DataTransfer;
  }
  class DataTransferItem {
    readonly kind: string;
    readonly type: string;
    getAsString(callback: FunctionStringCallback | null): void;
    getAsFile(): File | null;
    webkitGetAsEntry(): FileSystemEntry | null;
  }
  function FunctionStringCallback(data: string): void;
  class DataTransferItemList {
    readonly length: number;
    __indexedgetter(index: number): DataTransferItem;
    add(data: string, type: string): DataTransferItem | null;
    add(data: File): DataTransferItem | null;
    remove(index: number): void;
    clear(): void;
  }
  enum DecoderDoctorNotificationType {
    Cannot_play = "cannot-play",
    Platform_decoder_not_found = "platform-decoder-not-found",
    Can_play_but_some_missing_decoders = "can-play-but-some-missing-decoders",
    Cannot_initialize_pulseaudio = "cannot-initialize-pulseaudio",
    Unsupported_libavcodec = "unsupported-libavcodec",
    Decode_error = "decode-error",
    Decode_warning = "decode-warning",
  }
  interface DecoderDoctorNotification {
    decodeIssue?: string
    decoderDoctorReportId: string
    docURL?: string
    formats?: string
    isSolved: boolean
    resourceURL?: string
    type: DecoderDoctorNotificationType
  }
  class DedicatedWorkerGlobalScope {
    readonly name: string;
    postMessage(message: any, transfer: object[]): void;
    postMessage(message: any, options?: PostMessageOptions): void;
    close(): void;
    onmessage: EventHandlerNonNull | null;
    onmessageerror: EventHandlerNonNull | null;
  }
  interface DelayOptions {
    delayTime?: number
    maxDelayTime?: number
  }
  class DelayNode {
    readonly delayTime: AudioParam;
    passThrough: boolean;
  }
  class DeviceLightEvent {
    readonly value: number;
    readonly isTrusted: boolean;
  }
  interface DeviceLightEventInit {
    value?: number
  }
  class DeviceAcceleration {
    readonly x: number | null;
    readonly y: number | null;
    readonly z: number | null;
  }
  class DeviceRotationRate {
    readonly alpha: number | null;
    readonly beta: number | null;
    readonly gamma: number | null;
  }
  class DeviceMotionEvent {
    readonly acceleration: DeviceAcceleration | null;
    readonly accelerationIncludingGravity: DeviceAcceleration | null;
    readonly rotationRate: DeviceRotationRate | null;
    readonly interval: number | null;
    initDeviceMotionEvent(type: string, canBubble?: boolean, cancelable?: boolean, acceleration?: DeviceAccelerationInit, accelerationIncludingGravity?: DeviceAccelerationInit, rotationRate?: DeviceRotationRateInit, interval?: number | null): void;
    readonly isTrusted: boolean;
  }
  interface DeviceAccelerationInit {
    x?: number | null
    y?: number | null
    z?: number | null
  }
  interface DeviceRotationRateInit {
    alpha?: number | null
    beta?: number | null
    gamma?: number | null
  }
  interface DeviceMotionEventInit {
    acceleration?: DeviceAccelerationInit
    accelerationIncludingGravity?: DeviceAccelerationInit
    interval?: number | null
    rotationRate?: DeviceRotationRateInit
  }
  class DeviceOrientationEvent {
    readonly alpha: number | null;
    readonly beta: number | null;
    readonly gamma: number | null;
    readonly absolute: boolean;
    initDeviceOrientationEvent(type: string, canBubble?: boolean, cancelable?: boolean, alpha?: number | null, beta?: number | null, gamma?: number | null, absolute?: boolean): void;
    readonly isTrusted: boolean;
  }
  interface DeviceOrientationEventInit {
    absolute?: boolean
    alpha?: number | null
    beta?: number | null
    gamma?: number | null
  }
  class DeviceProximityEvent {
    readonly value: number;
    readonly min: number;
    readonly max: number;
    readonly isTrusted: boolean;
  }
  interface DeviceProximityEventInit {
    max?: number
    min?: number
    value?: number
  }
  class Directory {
    readonly name: string;
    readonly path: string;
    getFilesAndDirectories(): Promise<File | Directory[]>;
    getFiles(recursiveFlag?: boolean): Promise<File[]>;
  }
  enum VisibilityState {
    Hidden = "hidden",
    Visible = "visible",
  }
  interface ElementCreationOptions {
    is?: string
    pseudo?: string
  }
  class Document {
    readonly implementation: DOMImplementation;
    readonly URL: string;
    readonly documentURI: string;
    readonly compatMode: string;
    readonly characterSet: string;
    readonly charset: string;
    readonly inputEncoding: string;
    readonly contentType: string;
    readonly doctype: DocumentType | null;
    readonly documentElement: Element | null;
    getElementsByTagName(localName: string): HTMLCollection;
    getElementsByTagNameNS(namespace: string | null, localName: string): HTMLCollection;
    getElementsByClassName(classNames: string): HTMLCollection;
    getElementById(elementId: string): Element | null;
    createElement(localName: string, options?: ElementCreationOptions | string): Element;
    createElementNS(namespace: string | null, qualifiedName: string, options?: ElementCreationOptions | string): Element;
    createDocumentFragment(): DocumentFragment;
    createTextNode(data: string): Text;
    createComment(data: string): Comment;
    createProcessingInstruction(target: string, data: string): ProcessingInstruction;
    importNode(node: Node, deep?: boolean): Node;
    adoptNode(node: Node): Node;
    createEvent(interface: string): Event;
    createRange(): Range;
    createNodeIterator(root: Node, whatToShow?: number, filter?: NodeFilter | null): NodeIterator;
    createTreeWalker(root: Node, whatToShow?: number, filter?: NodeFilter | null): TreeWalker;
    createCDATASection(data: string): CDATASection;
    createAttribute(name: string): Attr;
    createAttributeNS(namespace: string | null, name: string): Attr;
    readonly location: Location | null;
    domain: string;
    readonly referrer: string;
    cookie: string;
    readonly lastModified: string;
    readonly readyState: string;
    title: string;
    dir: string;
    body: HTMLElement | null;
    readonly head: HTMLHeadElement | null;
    readonly images: HTMLCollection;
    readonly embeds: HTMLCollection;
    readonly plugins: HTMLCollection;
    readonly links: HTMLCollection;
    readonly forms: HTMLCollection;
    readonly scripts: HTMLCollection;
    getElementsByName(elementName: string): NodeList;
    open(unused1?: string, unused2?: string): Document;
    open(url: string, name: string, features: string): WindowProxy | null;
    close(): void;
    write(text?: string): void;
    writeln(text?: string): void;
    readonly defaultView: WindowProxy | null;
    hasFocus(): boolean;
    designMode: string;
    execCommand(commandId: string, showUI?: boolean, value?: string): boolean;
    queryCommandEnabled(commandId: string): boolean;
    queryCommandIndeterm(commandId: string): boolean;
    queryCommandState(commandId: string): boolean;
    queryCommandSupported(commandId: string): boolean;
    queryCommandValue(commandId: string): string;
    onreadystatechange: EventHandlerNonNull | null;
    onbeforescriptexecute: EventHandlerNonNull | null;
    onafterscriptexecute: EventHandlerNonNull | null;
    onselectionchange: EventHandlerNonNull | null;
    readonly mozSyntheticDocument: boolean;
    readonly currentScript: Element | null;
    releaseCapture(): void;
    mozSetImageElement(aImageElementId: string, aImageElement: Element | null): void;
    readonly documentURIObject: URI | null;
    readonly referrerPolicy: ReferrerPolicy;
    readonly referrerInfo: nsIReferrerInfo;
    fgColor: string;
    linkColor: string;
    vlinkColor: string;
    alinkColor: string;
    bgColor: string;
    readonly anchors: HTMLCollection;
    readonly applets: HTMLCollection;
    clear(): void;
    captureEvents(): void;
    releaseEvents(): void;
    readonly all: HTMLAllCollection;
    readonly fullscreen: boolean;
    readonly mozFullScreen: boolean;
    readonly fullscreenEnabled: boolean;
    readonly mozFullScreenEnabled: boolean;
    exitFullscreen(): Promise<void>;
    mozCancelFullScreen(): Promise<void>;
    onfullscreenchange: EventHandlerNonNull | null;
    onfullscreenerror: EventHandlerNonNull | null;
    exitPointerLock(): void;
    onpointerlockchange: EventHandlerNonNull | null;
    onpointerlockerror: EventHandlerNonNull | null;
    addCertException(isTemporary: boolean): Promise<any>;
    getFailedCertSecurityInfo(): FailedCertSecurityInfo;
    getNetErrorInfo(): NetErrorInfo;
    readonly hidden: boolean;
    readonly visibilityState: VisibilityState;
    onvisibilitychange: EventHandlerNonNull | null;
    selectedStyleSheetSet: string | null;
    readonly lastStyleSheetSet: string | null;
    readonly preferredStyleSheetSet: string | null;
    readonly styleSheetSets: DOMStringList;
    enableStyleSheetsForSet(name: string | null): void;
    caretPositionFromPoint(x: number, y: number): CaretPosition | null;
    readonly scrollingElement: Element | null;
    querySelector(selectors: string): Element | null;
    querySelectorAll(selectors: string): NodeList;
    readonly timeline: DocumentTimeline;
    readonly rootElement: SVGSVGElement | null;
    createXULElement(localName: string, options?: ElementCreationOptions | string): Element;
    readonly loadedFromPrototype: boolean;
    readonly effectiveStoragePrincipal: Principal;
    readonly contentBlockingAllowListPrincipal: Principal | null;
    createTouch(view?: Window | null, target?: EventTarget | null, identifier?: number, pageX?: number, pageY?: number, screenX?: number, screenY?: number, clientX?: number, clientY?: number, radiusX?: number, radiusY?: number, rotationAngle?: number, force?: number): Touch;
    createTouchList(touch: Touch, touches?: Touch): TouchList;
    createTouchList(): TouchList;
    createTouchList(touches: Touch[]): TouchList;
    styleSheetChangeEventsEnabled: boolean;
    readonly contentLanguage: string;
    readonly documentLoadGroup: nsILoadGroup | null;
    blockParsing(promise: Promise<any>, options?: BlockParsingOptions): Promise<any>;
    readonly mozDocumentURIIfNotForErrorPages: URI | null;
    readonly documentReadyForIdle: Promise<Document>;
    readonly commandDispatcher: XULCommandDispatcher | null;
    popupNode: Node | null;
    dontWarnAboutMutationEventsAndAllowSlowDOMMutations: boolean;
    readonly popupRangeParent: Node | null;
    readonly popupRangeOffset: number;
    tooltipNode: Node | null;
    readonly isSrcdocDocument: boolean;
    readonly sandboxFlagsAsString: string | null;
    insertAnonymousContent(aElement: Element): AnonymousContent;
    removeAnonymousContent(aContent: AnonymousContent): void;
    getSelection(): Selection | null;
    hasStorageAccess(): Promise<boolean>;
    requestStorageAccess(): Promise<void>;
    readonly autoplayPolicy: DocumentAutoplayPolicy;
    readonly userHasInteracted: boolean;
    notifyUserGestureActivation(): void;
    clearUserGestureActivation(): void;
    readonly hasBeenUserGestureActivated: boolean;
    readonly hasValidTransientUserGestureActivation: boolean;
    consumeTransientUserGestureActivation(): boolean;
    setSuppressedEventListener(aListener: EventListener | null): void;
    readonly hasScriptsBlockedBySandbox: boolean;
    readonly inlineScriptAllowedByCSP: boolean;
    readonly csp: ContentSecurityPolicy | null;
    readonly cspJSON: string;
    readonly documentFlashClassification: FlashClassification;
    readonly l10n: DocumentL10n | null;
    readonly featurePolicy: FeaturePolicy;
    setKeyPressEventModel(aKeyPressEventModel: number): void;
    readonly blockedNodeByClassifierCount: number;
    readonly blockedNodesByClassifier: NodeList;
    userInteractionForTesting(): void;
    readonly permDelegateHandler: nsIPermissionDelegateHandler;
    oncopy: EventHandlerNonNull | null;
    oncut: EventHandlerNonNull | null;
    onpaste: EventHandlerNonNull | null;
    elementFromPoint(x: number, y: number): Element | null;
    elementsFromPoint(x: number, y: number): Element[];
    nodeFromPoint(x: number, y: number): Node | null;
    nodesFromPoint(x: number, y: number): Node[];
    readonly activeElement: Element | null;
    readonly styleSheets: StyleSheetList;
    readonly pointerLockElement: Element | null;
    readonly fullscreenElement: Element | null;
    readonly mozFullScreenElement: Element | null;
    getAnimations(): Animation[];
    readonly fonts: FontFaceSet;
    getBoxQuads(options?: BoxQuadOptions): DOMQuad[];
    convertQuadFromNode(quad: DOMQuad, from: Text | Element | Document, options?: ConvertCoordinateOptions): DOMQuad;
    convertRectFromNode(rect: DOMRectReadOnly, from: Text | Element | Document, options?: ConvertCoordinateOptions): DOMQuad;
    convertPointFromNode(point: DOMPointInit, from: Text | Element | Document, options?: ConvertCoordinateOptions): DOMPoint;
    onabort: EventHandlerNonNull | null;
    onblur: EventHandlerNonNull | null;
    onfocus: EventHandlerNonNull | null;
    onauxclick: EventHandlerNonNull | null;
    oncanplay: EventHandlerNonNull | null;
    oncanplaythrough: EventHandlerNonNull | null;
    onchange: EventHandlerNonNull | null;
    onclick: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    oncontextmenu: EventHandlerNonNull | null;
    oncuechange: EventHandlerNonNull | null;
    ondblclick: EventHandlerNonNull | null;
    ondrag: EventHandlerNonNull | null;
    ondragend: EventHandlerNonNull | null;
    ondragenter: EventHandlerNonNull | null;
    ondragexit: EventHandlerNonNull | null;
    ondragleave: EventHandlerNonNull | null;
    ondragover: EventHandlerNonNull | null;
    ondragstart: EventHandlerNonNull | null;
    ondrop: EventHandlerNonNull | null;
    ondurationchange: EventHandlerNonNull | null;
    onemptied: EventHandlerNonNull | null;
    onended: EventHandlerNonNull | null;
    onformdata: EventHandlerNonNull | null;
    oninput: EventHandlerNonNull | null;
    oninvalid: EventHandlerNonNull | null;
    onkeydown: EventHandlerNonNull | null;
    onkeypress: EventHandlerNonNull | null;
    onkeyup: EventHandlerNonNull | null;
    onload: EventHandlerNonNull | null;
    onloadeddata: EventHandlerNonNull | null;
    onloadedmetadata: EventHandlerNonNull | null;
    onloadend: EventHandlerNonNull | null;
    onloadstart: EventHandlerNonNull | null;
    onmousedown: EventHandlerNonNull | null;
    onmouseenter: EventHandlerNonNull | null;
    onmouseleave: EventHandlerNonNull | null;
    onmousemove: EventHandlerNonNull | null;
    onmouseout: EventHandlerNonNull | null;
    onmouseover: EventHandlerNonNull | null;
    onmouseup: EventHandlerNonNull | null;
    onwheel: EventHandlerNonNull | null;
    onpause: EventHandlerNonNull | null;
    onplay: EventHandlerNonNull | null;
    onplaying: EventHandlerNonNull | null;
    onprogress: EventHandlerNonNull | null;
    onratechange: EventHandlerNonNull | null;
    onreset: EventHandlerNonNull | null;
    onresize: EventHandlerNonNull | null;
    onscroll: EventHandlerNonNull | null;
    onseeked: EventHandlerNonNull | null;
    onseeking: EventHandlerNonNull | null;
    onselect: EventHandlerNonNull | null;
    onshow: EventHandlerNonNull | null;
    onstalled: EventHandlerNonNull | null;
    onsubmit: EventHandlerNonNull | null;
    onsuspend: EventHandlerNonNull | null;
    ontimeupdate: EventHandlerNonNull | null;
    onvolumechange: EventHandlerNonNull | null;
    onwaiting: EventHandlerNonNull | null;
    onselectstart: EventHandlerNonNull | null;
    ontoggle: EventHandlerNonNull | null;
    onpointercancel: EventHandlerNonNull | null;
    onpointerdown: EventHandlerNonNull | null;
    onpointerup: EventHandlerNonNull | null;
    onpointermove: EventHandlerNonNull | null;
    onpointerout: EventHandlerNonNull | null;
    onpointerover: EventHandlerNonNull | null;
    onpointerenter: EventHandlerNonNull | null;
    onpointerleave: EventHandlerNonNull | null;
    ongotpointercapture: EventHandlerNonNull | null;
    onlostpointercapture: EventHandlerNonNull | null;
    onmozfullscreenchange: EventHandlerNonNull | null;
    onmozfullscreenerror: EventHandlerNonNull | null;
    onanimationcancel: EventHandlerNonNull | null;
    onanimationend: EventHandlerNonNull | null;
    onanimationiteration: EventHandlerNonNull | null;
    onanimationstart: EventHandlerNonNull | null;
    ontransitioncancel: EventHandlerNonNull | null;
    ontransitionend: EventHandlerNonNull | null;
    ontransitionrun: EventHandlerNonNull | null;
    ontransitionstart: EventHandlerNonNull | null;
    onwebkitanimationend: EventHandlerNonNull | null;
    onwebkitanimationiteration: EventHandlerNonNull | null;
    onwebkitanimationstart: EventHandlerNonNull | null;
    onwebkittransitionend: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    readonly children: HTMLCollection;
    readonly firstElementChild: Element | null;
    readonly lastElementChild: Element | null;
    readonly childElementCount: number;
    getElementsByAttribute(name: string, value: string): HTMLCollection;
    getElementsByAttributeNS(namespaceURI: string | null, name: string, value: string): HTMLCollection;
    prepend(nodes?: Node | string): void;
    append(nodes?: Node | string): void;
    ontouchstart: EventHandlerNonNull | null;
    ontouchend: EventHandlerNonNull | null;
    ontouchmove: EventHandlerNonNull | null;
    ontouchcancel: EventHandlerNonNull | null;
    createExpression(expression: string, resolver?: XPathNSResolver | null): XPathExpression;
    createNSResolver(nodeResolver: Node): Node;
    evaluate(expression: string, contextNode: Node, resolver?: XPathNSResolver | null, type?: number, result?: object | null): XPathResult;
  }
  interface BlockParsingOptions {
    blockScriptCreated?: boolean
  }
  enum DocumentAutoplayPolicy {
    Allowed = "allowed",
    Allowed_muted = "allowed-muted",
    Disallowed = "disallowed",
  }
  enum FlashClassification {
    Unknown = "unknown",
    Allowed = "allowed",
    Denied = "denied",
  }
  class DocumentFragment {
    getElementById(elementId: string): Element | null;
    querySelector(selectors: string): Element | null;
    querySelectorAll(selectors: string): NodeList;
    readonly children: HTMLCollection;
    readonly firstElementChild: Element | null;
    readonly lastElementChild: Element | null;
    readonly childElementCount: number;
    getElementsByAttribute(name: string, value: string): HTMLCollection;
    getElementsByAttributeNS(namespaceURI: string | null, name: string, value: string): HTMLCollection;
    prepend(nodes?: Node | string): void;
    append(nodes?: Node | string): void;
  }
  interface DocumentTimelineOptions {
    originTime?: number
  }
  class DocumentTimeline {
  }
  class DocumentType {
    readonly name: string;
    readonly publicId: string;
    readonly systemId: string;
    before(nodes?: Node | string): void;
    after(nodes?: Node | string): void;
    replaceWith(nodes?: Node | string): void;
    remove(): void;
  }
  class DragEvent {
    readonly dataTransfer: DataTransfer | null;
    initDragEvent(type: string, canBubble?: boolean, cancelable?: boolean, aView?: Window | null, aDetail?: number, aScreenX?: number, aScreenY?: number, aClientX?: number, aClientY?: number, aCtrlKey?: boolean, aAltKey?: boolean, aShiftKey?: boolean, aMetaKey?: boolean, aButton?: number, aRelatedTarget?: EventTarget | null, aDataTransfer?: DataTransfer | null): void;
    readonly isTrusted: boolean;
  }
  interface DragEventInit {
    dataTransfer?: DataTransfer | null
  }
  interface DynamicsCompressorOptions {
    attack?: number
    knee?: number
    ratio?: number
    release?: number
    threshold?: number
  }
  class DynamicsCompressorNode {
    readonly threshold: AudioParam;
    readonly knee: AudioParam;
    readonly ratio: AudioParam;
    readonly reduction: number;
    readonly attack: AudioParam;
    readonly release: AudioParam;
    passThrough: boolean;
  }
  class Element {
    readonly namespaceURI: string | null;
    readonly prefix: string | null;
    readonly localName: string;
    readonly tagName: string;
    id: string;
    className: string;
    readonly classList: DOMTokenList;
    readonly part: DOMTokenList;
    readonly attributes: NamedNodeMap;
    getAttributeNames(): string[];
    getAttribute(name: string): string | null;
    getAttributeNS(namespace: string | null, localName: string): string | null;
    toggleAttribute(name: string, force?: boolean): boolean;
    setAttribute(name: string, value: string): void;
    setAttributeNS(namespace: string | null, name: string, value: string): void;
    removeAttribute(name: string): void;
    removeAttributeNS(namespace: string | null, localName: string): void;
    hasAttribute(name: string): boolean;
    hasAttributeNS(namespace: string | null, localName: string): boolean;
    hasAttributes(): boolean;
    closest(selector: string): Element | null;
    matches(selector: string): boolean;
    webkitMatchesSelector(selector: string): boolean;
    getElementsByTagName(localName: string): HTMLCollection;
    getElementsByTagNameNS(namespace: string | null, localName: string): HTMLCollection;
    getElementsByClassName(classNames: string): HTMLCollection;
    insertAdjacentElement(where: string, element: Element): Element | null;
    insertAdjacentText(where: string, data: string): void;
    readonly fontSizeInflation: number;
    mozMatchesSelector(selector: string): boolean;
    setPointerCapture(pointerId: number): void;
    releasePointerCapture(pointerId: number): void;
    hasPointerCapture(pointerId: number): boolean;
    setCapture(retargetToElement?: boolean): void;
    releaseCapture(): void;
    setCaptureAlways(retargetToElement?: boolean): void;
    getAttributeNode(name: string): Attr | null;
    setAttributeNode(newAttr: Attr): Attr | null;
    removeAttributeNode(oldAttr: Attr): Attr | null;
    getAttributeNodeNS(namespaceURI: string | null, localName: string): Attr | null;
    setAttributeNodeNS(newAttr: Attr): Attr | null;
    getTransformToAncestor(ancestor: Element): DOMMatrixReadOnly;
    getTransformToParent(): DOMMatrixReadOnly;
    getTransformToViewport(): DOMMatrixReadOnly;
    getClientRects(): DOMRectList;
    getBoundingClientRect(): DOMRect;
    scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
    scrollTop: number;
    scrollLeft: number;
    readonly scrollWidth: number;
    readonly scrollHeight: number;
    scroll(x: number, y: number): void;
    scroll(options?: ScrollToOptions): void;
    scrollTo(x: number, y: number): void;
    scrollTo(options?: ScrollToOptions): void;
    scrollBy(x: number, y: number): void;
    scrollBy(options?: ScrollToOptions): void;
    mozScrollSnap(): void;
    readonly clientTop: number;
    readonly clientLeft: number;
    readonly clientWidth: number;
    readonly clientHeight: number;
    readonly scrollTopMin: number;
    readonly scrollTopMax: number;
    readonly scrollLeftMin: number;
    readonly scrollLeftMax: number;
    innerHTML: string;
    outerHTML: string;
    insertAdjacentHTML(position: string, text: string): void;
    querySelector(selectors: string): Element | null;
    querySelectorAll(selectors: string): NodeList;
    attachShadow(shadowRootInitDict: ShadowRootInit): ShadowRoot;
    readonly shadowRoot: ShadowRoot | null;
    readonly openOrClosedShadowRoot: ShadowRoot | null;
    readonly assignedSlot: HTMLSlotElement | null;
    readonly openOrClosedAssignedSlot: HTMLSlotElement | null;
    slot: string;
    requestFullscreen(): Promise<void>;
    mozRequestFullScreen(): Promise<void>;
    onfullscreenchange: EventHandlerNonNull | null;
    onfullscreenerror: EventHandlerNonNull | null;
    requestPointerLock(): void;
    getAsFlexContainer(): Flex | null;
    getGridFragments(): Grid[];
    getElementsWithGrid(): Element[];
    setAttributeDevtools(name: string, value: string): void;
    setAttributeDevtoolsNS(namespace: string | null, name: string, value: string): void;
    readonly clientHeightDouble: number;
    readonly clientWidthDouble: number;
    readonly firstLineBoxBSize: number;
    animate(keyframes: object | null, options?: number | KeyframeAnimationOptions): Animation;
    getAnimations(options?: GetAnimationsOptions): Animation[];
    before(nodes?: Node | string): void;
    after(nodes?: Node | string): void;
    replaceWith(nodes?: Node | string): void;
    remove(): void;
    getBoxQuads(options?: BoxQuadOptions): DOMQuad[];
    convertQuadFromNode(quad: DOMQuad, from: Text | Element | Document, options?: ConvertCoordinateOptions): DOMQuad;
    convertRectFromNode(rect: DOMRectReadOnly, from: Text | Element | Document, options?: ConvertCoordinateOptions): DOMQuad;
    convertPointFromNode(point: DOMPointInit, from: Text | Element | Document, options?: ConvertCoordinateOptions): DOMPoint;
    readonly previousElementSibling: Element | null;
    readonly nextElementSibling: Element | null;
    readonly children: HTMLCollection;
    readonly firstElementChild: Element | null;
    readonly lastElementChild: Element | null;
    readonly childElementCount: number;
    getElementsByAttribute(name: string, value: string): HTMLCollection;
    getElementsByAttributeNS(namespaceURI: string | null, name: string, value: string): HTMLCollection;
    prepend(nodes?: Node | string): void;
    append(nodes?: Node | string): void;
  }
  interface FocusOptions {
    preventScroll?: boolean
  }
  enum ScrollLogicalPosition {
    Start = "start",
    Center = "center",
    End = "end",
    Nearest = "nearest",
  }
  interface ScrollIntoViewOptions {
    block?: ScrollLogicalPosition
    inline?: ScrollLogicalPosition
  }
  interface ShadowRootInit {
    mode: ShadowRootMode
  }
  class ElementInternals {
  }
  class ErrorEvent {
    readonly message: string;
    readonly filename: string;
    readonly lineno: number;
    readonly colno: number;
    readonly error: any;
    readonly isTrusted: boolean;
  }
  interface ErrorEventInit {
    colno?: number
    error?: any
    filename?: string
    lineno?: number
    message?: string
  }
  class Event {
    readonly type: string;
    readonly target: EventTarget | null;
    readonly currentTarget: EventTarget | null;
    composedPath(): EventTarget[];
    readonly eventPhase: number;
    stopPropagation(): void;
    stopImmediatePropagation(): void;
    readonly bubbles: boolean;
    readonly cancelable: boolean;
    returnValue: boolean;
    preventDefault(): void;
    readonly defaultPrevented: boolean;
    readonly defaultPreventedByChrome: boolean;
    readonly defaultPreventedByContent: boolean;
    readonly composed: boolean;
    readonly isTrusted: boolean;
    readonly timeStamp: number;
    initEvent(type: string, bubbles?: boolean, cancelable?: boolean): void;
    cancelBubble: boolean;
    readonly originalTarget: EventTarget | null;
    readonly explicitOriginalTarget: EventTarget | null;
    readonly composedTarget: EventTarget | null;
    preventMultipleActions(): void;
    readonly multipleActionsPrevented: boolean;
    readonly isSynthesized: boolean;
  }
  interface EventInit {
    bubbles?: boolean
    cancelable?: boolean
    composed?: boolean
  }
  function EventHandlerNonNull(event: Event): any;
  function OnBeforeUnloadEventHandlerNonNull(event: Event): string | null;
  function OnErrorEventHandlerNonNull(event: Event | string, source?: string, lineno?: number, column?: number, error?: any): any;
  class EventListener {
    handleEvent(event: Event): void;
  }
  class EventSource {
    readonly url: string;
    readonly withCredentials: boolean;
    readonly readyState: number;
    onopen: EventHandlerNonNull | null;
    onmessage: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    close(): void;
  }
  interface EventSourceInit {
    withCredentials?: boolean
  }
  interface EventListenerOptions {
    capture?: boolean
    mozSystemGroup?: boolean
  }
  interface AddEventListenerOptions {
    once?: boolean
    passive?: boolean
    wantUntrusted?: boolean
  }
  class EventTarget {
    addEventListener(type: string, listener: EventListener | null, options?: AddEventListenerOptions | boolean, wantsUntrusted?: boolean | null): void;
    removeEventListener(type: string, listener: EventListener | null, options?: EventListenerOptions | boolean): void;
    dispatchEvent(event: Event): boolean;
    setEventHandler(type: string, handler: EventHandlerNonNull | null): void;
    getEventHandler(type: string): EventHandlerNonNull | null;
    readonly ownerGlobal: WindowProxy | null;
  }
  class ExtendableEvent {
    waitUntil(p: Promise<any>): void;
    readonly isTrusted: boolean;
  }
  interface ExtendableEventInit {
  }
  class ExtendableMessageEvent {
    readonly data: any;
    readonly origin: string;
    readonly lastEventId: string;
    readonly source: Client | ServiceWorker | MessagePort | null;
    readonly ports: MessagePort[];
    readonly isTrusted: boolean;
  }
  interface ExtendableMessageEventInit {
    data?: any
    lastEventId?: string
    origin?: string
    ports?: MessagePort[]
    source?: Client | ServiceWorker | MessagePort | null
  }
  class External {
    AddSearchProvider(aDescriptionURL: string): void;
    IsSearchProviderInstalled(): void;
  }
  interface FailedCertSecurityInfo {
    certChainStrings?: string[]
    certValidityRangeNotAfter?: number
    certValidityRangeNotBefore?: number
    errorCodeString?: string
    errorMessage?: string
    hasHPKP?: boolean
    hasHSTS?: boolean
    isDomainMismatch?: boolean
    isNotValidAtThisTime?: boolean
    isUntrusted?: boolean
    issuerCommonName?: string
    subjectAltNames?: string
    validNotAfter?: number
    validNotBefore?: number
  }
  interface FakePluginTagInit {
    description?: string
    fileName?: string
    fullPath?: string
    handlerURI: string
    mimeEntries: FakePluginMimeEntry[]
    name?: string
    niceName?: string
    sandboxScript?: string
    version?: string
  }
  interface FakePluginMimeEntry {
    description?: string
    extension?: string
    type: string
  }
  class FeaturePolicy {
    allowsFeature(feature: string, origin?: string): boolean;
    features(): string[];
    allowedFeatures(): string[];
    getAllowlistForFeature(feature: string): string[];
  }
  class FeaturePolicyViolationReportBody {
    readonly featureId: string;
    readonly sourceFile: string | null;
    readonly lineNumber: number | null;
    readonly columnNumber: number | null;
    readonly disposition: string;
  }
  interface FetchReadableStreamReadDataDone {
    done?: boolean
  }
  interface FetchReadableStreamReadDataArray {
    value?: Uint8Array
  }
  class FetchEvent {
    readonly request: Request;
    readonly clientId: string;
    readonly resultingClientId: string;
    readonly isReload: boolean;
    respondWith(r: Promise<Response>): void;
    readonly isTrusted: boolean;
  }
  interface FetchEventInit {
    clientId?: string
    isReload?: boolean
    request: Request
    resultingClientId?: string
  }
  class ObserverCallback {
    handleEvent(observer: FetchObserver): void;
  }
  enum FetchState {
    Requesting = "requesting",
    Responding = "responding",
    Aborted = "aborted",
    Errored = "errored",
    Complete = "complete",
  }
  class FetchObserver {
    readonly state: FetchState;
    onstatechange: EventHandlerNonNull | null;
    onrequestprogress: EventHandlerNonNull | null;
    onresponseprogress: EventHandlerNonNull | null;
  }
  class File {
    readonly name: string;
    readonly lastModified: number;
    readonly webkitRelativePath: string;
    readonly mozFullPath: string;
    createFromNsIFile(file: nsIFile, options?: ChromeFilePropertyBag): Promise<File>;
    createFromFileName(fileName: string, options?: ChromeFilePropertyBag): Promise<File>;
  }
  interface FilePropertyBag {
    lastModified?: number
  }
  interface ChromeFilePropertyBag {
    existenceCheck?: boolean
    name?: string
  }
  class FileList {
    item(index: number): File | null;
    readonly length: number;
  }
  enum FileMode {
    Readonly = "readonly",
    Readwrite = "readwrite",
  }
  class FileReader {
    readAsArrayBuffer(blob: Blob): void;
    readAsBinaryString(filedata: Blob): void;
    readAsText(blob: Blob, label?: string): void;
    readAsDataURL(blob: Blob): void;
    abort(): void;
    readonly readyState: number;
    readonly result: string | ArrayBuffer | null;
    readonly error: DOMException | null;
    onloadstart: EventHandlerNonNull | null;
    onprogress: EventHandlerNonNull | null;
    onload: EventHandlerNonNull | null;
    onabort: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onloadend: EventHandlerNonNull | null;
  }
  class FileReaderSync {
    readAsArrayBuffer(blob: Blob): ArrayBuffer;
    readAsBinaryString(blob: Blob): string;
    readAsText(blob: Blob, encoding?: string): string;
    readAsDataURL(blob: Blob): string;
  }
  interface FileSystemFlags {
    create?: boolean
    exclusive?: boolean
  }
  function FileSystemEntryCallback(entry: FileSystemEntry): void;
  function ErrorCallback(err: DOMException): void;
  class FileSystem {
    readonly name: string;
    readonly root: FileSystemDirectoryEntry;
  }
  class FileSystemDirectoryEntry {
    createReader(): FileSystemDirectoryReader;
    getFile(path?: string | null, options?: FileSystemFlags, successCallback?: FileSystemEntryCallback, errorCallback?: ErrorCallback): void;
    getDirectory(path?: string | null, options?: FileSystemFlags, successCallback?: FileSystemEntryCallback, errorCallback?: ErrorCallback): void;
  }
  function FileSystemEntriesCallback(entries: FileSystemEntry[]): void;
  class FileSystemDirectoryReader {
    readEntries(successCallback: FileSystemEntriesCallback, errorCallback?: ErrorCallback): void;
  }
  class FileSystemEntry {
    readonly isFile: boolean;
    readonly isDirectory: boolean;
    readonly name: string;
    readonly fullPath: string;
    readonly filesystem: FileSystem;
    getParent(successCallback?: FileSystemEntryCallback, errorCallback?: ErrorCallback): void;
  }
  function FileCallback(file: File): void;
  class FileSystemFileEntry {
    file(successCallback: FileCallback, errorCallback?: ErrorCallback): void;
  }
  class FocusEvent {
    readonly relatedTarget: EventTarget | null;
    readonly isTrusted: boolean;
  }
  interface FocusEventInit {
    relatedTarget?: EventTarget | null
  }
  interface FontFaceDescriptors {
    display?: string
    featureSettings?: string
    stretch?: string
    style?: string
    unicodeRange?: string
    variant?: string
    variationSettings?: string
    weight?: string
  }
  enum FontFaceLoadStatus {
    Unloaded = "unloaded",
    Loading = "loading",
    Loaded = "loaded",
    Error = "error",
  }
  class FontFace {
    family: string;
    style: string;
    weight: string;
    stretch: string;
    unicodeRange: string;
    variant: string;
    featureSettings: string;
    variationSettings: string;
    display: string;
    readonly status: FontFaceLoadStatus;
    load(): Promise<FontFace>;
    readonly loaded: Promise<FontFace>;
  }
  interface FontFaceSetIteratorResult {
    done: boolean
    value: any
  }
  class FontFaceSetIterator {
    next(): FontFaceSetIteratorResult;
  }
  function FontFaceSetForEachCallback(value: FontFace, key: FontFace, set: FontFaceSet): void;
  enum FontFaceSetLoadStatus {
    Loading = "loading",
    Loaded = "loaded",
  }
  class FontFaceSet {
    readonly size: number;
    add(font: FontFace): void;
    has(font: FontFace): boolean;
    delete(font: FontFace): boolean;
    clear(): void;
    entries(): FontFaceSetIterator;
    values(): FontFaceSetIterator;
    forEach(cb: FontFaceSetForEachCallback, thisArg?: any): void;
    onloading: EventHandlerNonNull | null;
    onloadingdone: EventHandlerNonNull | null;
    onloadingerror: EventHandlerNonNull | null;
    load(font: string, text?: string): Promise<FontFace[]>;
    check(font: string, text?: string): boolean;
    readonly ready: Promise<void>;
    readonly status: FontFaceSetLoadStatus;
  }
  interface FontFaceSetLoadEventInit {
    fontfaces?: FontFace[]
  }
  class FontFaceSetLoadEvent {
    readonly fontfaces: FontFace[];
    readonly isTrusted: boolean;
  }
  class FormData {
    append(name: string, value: Blob, filename?: string): void;
    append(name: string, value: string): void;
    delete(name: string): void;
    get(name: string): Blob | Directory | string | null;
    getAll(name: string): Blob | Directory | string[];
    has(name: string): boolean;
    set(name: string, value: Blob, filename?: string): void;
    set(name: string, value: string): void;
    entries(): FormDataIterator;
    keys(): FormDataIterator;
    values(): FormDataIterator;
    forEach(callback: object, thisArg?: any): void;
  }
  class FormDataEvent {
    readonly formData: FormData;
    readonly isTrusted: boolean;
  }
  interface FormDataEventInit {
    formData: FormData
  }
  class FrameCrashedEvent {
    readonly browsingContextId: number;
    readonly isTopFrame: boolean;
    readonly isTrusted: boolean;
  }
  interface FrameCrashedEventInit {
    browsingContextId?: number
    isTopFrame?: boolean
  }
  class FrameLoader {
    readonly docShell: nsIDocShell | null;
    readonly remoteTab: RemoteTab | null;
    readonly loadContext: LoadContext;
    readonly browsingContext: BrowsingContext | null;
    readonly depthTooGreat: boolean;
    readonly isRemoteFrame: boolean;
    activateRemoteFrame(): void;
    deactivateRemoteFrame(): void;
    sendCrossProcessMouseEvent(aType: string, aX: number, aY: number, aButton: number, aClickCount: number, aModifiers: number, aIgnoreRootScrollFrame?: boolean): void;
    activateFrameEvent(aType: string, capture: boolean): void;
    readonly messageManager: MessageSender | null;
    requestNotifyAfterRemotePaint(): void;
    requestUpdatePosition(): void;
    requestTabStateFlush(aFlushId: number): boolean;
    requestEpochUpdate(aEpoch: number): void;
    print(aOuterWindowID: number, aPrintSettings: nsIPrintSettings, aProgressListener?: nsIWebProgressListener | null): void;
    readonly ownerElement: Element | null;
    readonly childID: number;
    readonly ownerIsMozBrowserFrame: boolean;
    readonly lazyWidth: number;
    readonly lazyHeight: number;
    readonly isDead: boolean;
    startPersistence(aOuterWindowID: number, aRecv: nsIWebBrowserPersistDocumentReceiver): void;
  }
  function Function(arguments?: any): any;
  function VoidFunction(): void;
  class GPUUncapturedErrorEvent {
    readonly error: GPUOutOfMemoryError | GPUValidationError;
    readonly isTrusted: boolean;
  }
  interface GPUUncapturedErrorEventInit {
    error: GPUOutOfMemoryError | GPUValidationError
  }
  interface GainOptions {
    gain?: number
  }
  class GainNode {
    readonly gain: AudioParam;
    passThrough: boolean;
  }
  class GamepadButton {
    readonly pressed: boolean;
    readonly touched: boolean;
    readonly value: number;
  }
  enum GamepadHand {
    _empty = "",
    Left = "left",
    Right = "right",
  }
  enum GamepadMappingType {
    _empty = "",
    Standard = "standard",
    Xr_standard = "xr-standard",
  }
  class Gamepad {
    readonly id: string;
    readonly index: number;
    readonly mapping: GamepadMappingType;
    readonly hand: GamepadHand;
    readonly displayId: number;
    readonly connected: boolean;
    readonly buttons: GamepadButton[];
    readonly axes: number[];
    readonly timestamp: number;
    readonly pose: GamepadPose | null;
    readonly hapticActuators: GamepadHapticActuator[];
    readonly lightIndicators: GamepadLightIndicator[];
    readonly touchEvents: GamepadTouch[];
  }
  class GamepadAxisMoveEvent {
    readonly axis: number;
    readonly value: number;
    readonly isTrusted: boolean;
  }
  interface GamepadAxisMoveEventInit {
    axis?: number
    value?: number
  }
  class GamepadButtonEvent {
    readonly button: number;
    readonly isTrusted: boolean;
  }
  interface GamepadButtonEventInit {
    button?: number
  }
  class GamepadEvent {
    readonly gamepad: Gamepad | null;
    readonly isTrusted: boolean;
  }
  interface GamepadEventInit {
    gamepad?: Gamepad | null
  }
  enum GamepadHapticActuatorType {
    Vibration = "vibration",
  }
  class GamepadHapticActuator {
    readonly type: GamepadHapticActuatorType;
    pulse(value: number, duration: number): Promise<boolean>;
  }
  enum GamepadLightIndicatorType {
    On_off = "on-off",
    Rgb = "rgb",
  }
  interface GamepadLightColor {
    blue: number
    green: number
    red: number
  }
  class GamepadLightIndicator {
    readonly type: GamepadLightIndicatorType;
    setColor(color: GamepadLightColor): Promise<boolean>;
  }
  class GamepadPose {
    readonly hasOrientation: boolean;
    readonly hasPosition: boolean;
    readonly position: Float32Array | null;
    readonly linearVelocity: Float32Array | null;
    readonly linearAcceleration: Float32Array | null;
    readonly orientation: Float32Array | null;
    readonly angularVelocity: Float32Array | null;
    readonly angularAcceleration: Float32Array | null;
  }
  class GamepadServiceTest {
    readonly noMapping: GamepadMappingType;
    readonly standardMapping: GamepadMappingType;
    readonly noHand: GamepadHand;
    readonly leftHand: GamepadHand;
    readonly rightHand: GamepadHand;
    addGamepad(id: string, mapping: GamepadMappingType, hand: GamepadHand, numButtons: number, numAxes: number, numHaptics: number, numLightIndicator: number, numTouchEvents: number): Promise<number>;
    removeGamepad(index: number): void;
    newButtonEvent(index: number, button: number, pressed: boolean, touched: boolean): void;
    newButtonValueEvent(index: number, button: number, pressed: boolean, touched: boolean, value: number): void;
    newAxisMoveEvent(index: number, axis: number, value: number): void;
    newPoseMove(index: number, orient: Float32Array | null, pos: Float32Array | null, angVelocity: Float32Array | null, angAcceleration: Float32Array | null, linVelocity: Float32Array | null, linAcceleration: Float32Array | null): void;
    newTouch(index: number, aTouchArrayIndex: number, touchId: number, surfaceId: number, position: Float32Array, surfaceDimension: Float32Array | null): void;
  }
  class GamepadTouch {
    readonly touchId: number;
    readonly surfaceId: number;
    readonly position: Float32Array;
    readonly surfaceDimensions: Uint32Array | null;
  }
  interface PositionOptions {
    enableHighAccuracy?: boolean
    maximumAge?: number
    timeout?: number
  }
  class Geolocation {
    getCurrentPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback | null, options?: PositionOptions): void;
    watchPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback | null, options?: PositionOptions): number;
    clearWatch(watchId: number): void;
  }
  function PositionCallback(position: GeolocationPosition): void;
  function PositionErrorCallback(positionError: GeolocationPositionError): void;
  class GeolocationCoordinates {
    readonly latitude: number;
    readonly longitude: number;
    readonly altitude: number | null;
    readonly accuracy: number;
    readonly altitudeAccuracy: number | null;
    readonly heading: number | null;
    readonly speed: number | null;
  }
  class GeolocationPosition {
    readonly coords: GeolocationCoordinates;
    readonly timestamp: number;
  }
  class GeolocationPositionError {
    readonly code: number;
    readonly message: string;
  }
  enum CSSBoxType {
    Margin = "margin",
    Border = "border",
    Padding = "padding",
    Content = "content",
  }
  interface BoxQuadOptions {
    box?: CSSBoxType
    createFramesForSuppressedWhitespace?: boolean
    relativeTo?: Text | Element | Document
  }
  interface ConvertCoordinateOptions {
    fromBox?: CSSBoxType
    toBox?: CSSBoxType
  }
  class GetUserMediaRequest {
    readonly windowID: number;
    readonly innerWindowID: number;
    readonly callID: string;
    readonly rawID: string;
    readonly mediaSource: string;
    getConstraints(): MediaStreamConstraints;
    readonly isSecure: boolean;
    readonly isHandlingUserInput: boolean;
  }
  enum GridDeclaration {
    Explicit = "explicit",
    Implicit = "implicit",
  }
  enum GridTrackState {
    Static = "static",
    Repeat = "repeat",
    Removed = "removed",
  }
  class Grid {
    readonly rows: GridDimension;
    readonly cols: GridDimension;
    readonly areas: GridArea[];
  }
  class GridDimension {
    readonly lines: GridLines;
    readonly tracks: GridTracks;
  }
  class GridLines {
    readonly length: number;
    item(index: number): GridLine | null;
  }
  class GridLine {
    readonly names: string[];
    readonly start: number;
    readonly breadth: number;
    readonly type: GridDeclaration;
    readonly number: number;
    readonly negativeNumber: number;
  }
  class GridTracks {
    readonly length: number;
    item(index: number): GridTrack | null;
  }
  class GridTrack {
    readonly start: number;
    readonly breadth: number;
    readonly type: GridDeclaration;
    readonly state: GridTrackState;
  }
  class GridArea {
    readonly name: string;
    readonly type: GridDeclaration;
    readonly rowStart: number;
    readonly rowEnd: number;
    readonly columnStart: number;
    readonly columnEnd: number;
  }
  class HTMLAllCollection {
    readonly length: number;
    __indexedgetter(index: number): Element;
    namedItem(name: string): HTMLCollection | Element | null;
    item(nameOrIndex?: string): HTMLCollection | Element | null;
    __legacycaller(nameOrIndex?: string): HTMLCollection | Element | null;
  }
  class HTMLAnchorElement {
    target: string;
    download: string;
    ping: string;
    rel: string;
    referrerPolicy: string;
    readonly relList: DOMTokenList;
    hreflang: string;
    type: string;
    text: string;
    coords: string;
    charset: string;
    name: string;
    rev: string;
    shape: string;
    href: string;
    readonly origin: string;
    protocol: string;
    username: string;
    password: string;
    host: string;
    hostname: string;
    port: string;
    pathname: string;
    search: string;
    hash: string;
    __stringifier(): string;
  }
  class HTMLAreaElement {
    alt: string;
    coords: string;
    shape: string;
    target: string;
    download: string;
    ping: string;
    rel: string;
    referrerPolicy: string;
    readonly relList: DOMTokenList;
    noHref: boolean;
    href: string;
    readonly origin: string;
    protocol: string;
    username: string;
    password: string;
    host: string;
    hostname: string;
    port: string;
    pathname: string;
    search: string;
    hash: string;
    __stringifier(): string;
  }
  class HTMLAudioElement {
  }
  class HTMLBRElement {
    clear: string;
    readonly isPaddingForEmptyEditor: boolean;
    readonly isPaddingForEmptyLastLine: boolean;
  }
  class HTMLBaseElement {
    href: string;
    target: string;
  }
  class HTMLBodyElement {
    text: string;
    link: string;
    vLink: string;
    aLink: string;
    bgColor: string;
    background: string;
    onafterprint: EventHandlerNonNull | null;
    onbeforeprint: EventHandlerNonNull | null;
    onbeforeunload: OnBeforeUnloadEventHandlerNonNull | null;
    onhashchange: EventHandlerNonNull | null;
    onlanguagechange: EventHandlerNonNull | null;
    onmessage: EventHandlerNonNull | null;
    onmessageerror: EventHandlerNonNull | null;
    onoffline: EventHandlerNonNull | null;
    ononline: EventHandlerNonNull | null;
    onpagehide: EventHandlerNonNull | null;
    onpageshow: EventHandlerNonNull | null;
    onpopstate: EventHandlerNonNull | null;
    onrejectionhandled: EventHandlerNonNull | null;
    onstorage: EventHandlerNonNull | null;
    onunhandledrejection: EventHandlerNonNull | null;
    onunload: EventHandlerNonNull | null;
  }
  class HTMLButtonElement {
    autofocus: boolean;
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    formAction: string;
    formEnctype: string;
    formMethod: string;
    formNoValidate: boolean;
    formTarget: string;
    name: string;
    type: string;
    value: string;
    readonly willValidate: boolean;
    readonly validity: ValidityState;
    readonly validationMessage: string;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    readonly labels: NodeList;
  }
  class HTMLCanvasElement {
    width: number;
    height: number;
    getContext(contextId: string, contextOptions?: any): nsISupports | null;
    toDataURL(type?: string, encoderOptions?: any): string;
    toBlob(callback: BlobCallback, type?: string, encoderOptions?: any): void;
    mozOpaque: boolean;
    mozGetAsFile(name: string, type?: string | null): File;
    MozGetIPCContext(contextId: string): nsISupports | null;
    mozPrintCallback: PrintCallback | null;
    captureStream(frameRate?: number): CanvasCaptureMediaStream;
    transferControlToOffscreen(): OffscreenCanvas;
  }
  class MozCanvasPrintState {
    readonly context: nsISupports;
    done(): void;
  }
  function PrintCallback(ctx: MozCanvasPrintState): void;
  function BlobCallback(blob: Blob | null): void;
  class HTMLCollection {
    readonly length: number;
    item(index: number): Element | null;
    namedItem(name: string): Element | null;
  }
  class HTMLDListElement {
    compact: boolean;
  }
  class HTMLDataElement {
    value: string;
  }
  class HTMLDataListElement {
    readonly options: HTMLCollection;
  }
  class HTMLDetailsElement {
    open: boolean;
  }
  class HTMLDialogElement {
    open: boolean;
    returnValue: string;
    show(): void;
    showModal(): void;
    close(returnValue?: string): void;
  }
  class HTMLDirectoryElement {
    compact: boolean;
  }
  class HTMLDivElement {
    align: string;
  }
  class HTMLDocument {
    __namedgetter(name: string): object;
    readonly location: Location | null;
  }
  class HTMLElement {
    title: string;
    lang: string;
    dir: string;
    innerText: string;
    hidden: boolean;
    click(): void;
    accessKey: string;
    readonly accessKeyLabel: string;
    draggable: boolean;
    contentEditable: string;
    readonly isContentEditable: boolean;
    readonly contextMenu: HTMLMenuElement | null;
    spellcheck: boolean;
    attachInternals(): ElementInternals;
    readonly offsetParent: Element | null;
    readonly offsetTop: number;
    readonly offsetLeft: number;
    readonly offsetWidth: number;
    readonly offsetHeight: number;
    oncopy: EventHandlerNonNull | null;
    oncut: EventHandlerNonNull | null;
    onpaste: EventHandlerNonNull | null;
    readonly style: CSSStyleDeclaration;
    onabort: EventHandlerNonNull | null;
    onblur: EventHandlerNonNull | null;
    onfocus: EventHandlerNonNull | null;
    onauxclick: EventHandlerNonNull | null;
    oncanplay: EventHandlerNonNull | null;
    oncanplaythrough: EventHandlerNonNull | null;
    onchange: EventHandlerNonNull | null;
    onclick: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    oncontextmenu: EventHandlerNonNull | null;
    oncuechange: EventHandlerNonNull | null;
    ondblclick: EventHandlerNonNull | null;
    ondrag: EventHandlerNonNull | null;
    ondragend: EventHandlerNonNull | null;
    ondragenter: EventHandlerNonNull | null;
    ondragexit: EventHandlerNonNull | null;
    ondragleave: EventHandlerNonNull | null;
    ondragover: EventHandlerNonNull | null;
    ondragstart: EventHandlerNonNull | null;
    ondrop: EventHandlerNonNull | null;
    ondurationchange: EventHandlerNonNull | null;
    onemptied: EventHandlerNonNull | null;
    onended: EventHandlerNonNull | null;
    onformdata: EventHandlerNonNull | null;
    oninput: EventHandlerNonNull | null;
    oninvalid: EventHandlerNonNull | null;
    onkeydown: EventHandlerNonNull | null;
    onkeypress: EventHandlerNonNull | null;
    onkeyup: EventHandlerNonNull | null;
    onload: EventHandlerNonNull | null;
    onloadeddata: EventHandlerNonNull | null;
    onloadedmetadata: EventHandlerNonNull | null;
    onloadend: EventHandlerNonNull | null;
    onloadstart: EventHandlerNonNull | null;
    onmousedown: EventHandlerNonNull | null;
    onmouseenter: EventHandlerNonNull | null;
    onmouseleave: EventHandlerNonNull | null;
    onmousemove: EventHandlerNonNull | null;
    onmouseout: EventHandlerNonNull | null;
    onmouseover: EventHandlerNonNull | null;
    onmouseup: EventHandlerNonNull | null;
    onwheel: EventHandlerNonNull | null;
    onpause: EventHandlerNonNull | null;
    onplay: EventHandlerNonNull | null;
    onplaying: EventHandlerNonNull | null;
    onprogress: EventHandlerNonNull | null;
    onratechange: EventHandlerNonNull | null;
    onreset: EventHandlerNonNull | null;
    onresize: EventHandlerNonNull | null;
    onscroll: EventHandlerNonNull | null;
    onseeked: EventHandlerNonNull | null;
    onseeking: EventHandlerNonNull | null;
    onselect: EventHandlerNonNull | null;
    onshow: EventHandlerNonNull | null;
    onstalled: EventHandlerNonNull | null;
    onsubmit: EventHandlerNonNull | null;
    onsuspend: EventHandlerNonNull | null;
    ontimeupdate: EventHandlerNonNull | null;
    onvolumechange: EventHandlerNonNull | null;
    onwaiting: EventHandlerNonNull | null;
    onselectstart: EventHandlerNonNull | null;
    ontoggle: EventHandlerNonNull | null;
    onpointercancel: EventHandlerNonNull | null;
    onpointerdown: EventHandlerNonNull | null;
    onpointerup: EventHandlerNonNull | null;
    onpointermove: EventHandlerNonNull | null;
    onpointerout: EventHandlerNonNull | null;
    onpointerover: EventHandlerNonNull | null;
    onpointerenter: EventHandlerNonNull | null;
    onpointerleave: EventHandlerNonNull | null;
    ongotpointercapture: EventHandlerNonNull | null;
    onlostpointercapture: EventHandlerNonNull | null;
    onmozfullscreenchange: EventHandlerNonNull | null;
    onmozfullscreenerror: EventHandlerNonNull | null;
    onanimationcancel: EventHandlerNonNull | null;
    onanimationend: EventHandlerNonNull | null;
    onanimationiteration: EventHandlerNonNull | null;
    onanimationstart: EventHandlerNonNull | null;
    ontransitioncancel: EventHandlerNonNull | null;
    ontransitionend: EventHandlerNonNull | null;
    ontransitionrun: EventHandlerNonNull | null;
    ontransitionstart: EventHandlerNonNull | null;
    onwebkitanimationend: EventHandlerNonNull | null;
    onwebkitanimationiteration: EventHandlerNonNull | null;
    onwebkitanimationstart: EventHandlerNonNull | null;
    onwebkittransitionend: EventHandlerNonNull | null;
    readonly dataset: DOMStringMap;
    tabIndex: number;
    focus(options?: FocusOptions): void;
    blur(): void;
    onerror: EventHandlerNonNull | null;
    ontouchstart: EventHandlerNonNull | null;
    ontouchend: EventHandlerNonNull | null;
    ontouchmove: EventHandlerNonNull | null;
    ontouchcancel: EventHandlerNonNull | null;
  }
  class HTMLUnknownElement {
  }
  class HTMLEmbedElement {
    src: string;
    type: string;
    width: string;
    height: string;
    align: string;
    name: string;
    getSVGDocument(): Document | null;
    readonly frameLoader: FrameLoader | null;
    readonly browsingContext: BrowsingContext | null;
    presetOpenerWindow(window: WindowProxy | null): void;
    swapFrameLoaders(aOtherLoaderOwner: XULFrameElement): void;
    swapFrameLoaders(aOtherLoaderOwner: HTMLIFrameElement): void;
    changeRemoteness(aOptions: RemotenessOptions): void;
    loadingEnabled: boolean;
    readonly imageBlockingStatus: number;
    addObserver(aObserver: imgINotificationObserver): void;
    removeObserver(aObserver: imgINotificationObserver): void;
    getRequest(aRequestType: number): imgIRequest | null;
    getRequestType(aRequest: imgIRequest): number;
    readonly currentURI: URI | null;
    readonly currentRequestFinalURI: URI | null;
    forceReload(aNotify?: boolean): void;
    forceImageState(aForce: boolean, aState: number): void;
    readonly actualType: string;
    readonly displayedType: number;
    getContentTypeForMIMEType(aMimeType: string): number;
    getPluginAttributes(): MozPluginParameter[];
    getPluginParameters(): MozPluginParameter[];
    playPlugin(): void;
    reload(aClearActivation: boolean): void;
    readonly activated: boolean;
    readonly srcURI: URI | null;
    readonly defaultFallbackType: number;
    readonly pluginFallbackType: number;
    readonly hasRunningPlugin: boolean;
    skipFakePlugins(): void;
    readonly runID: number;
  }
  class HTMLFieldSetElement {
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    name: string;
    readonly type: string;
    readonly elements: HTMLCollection;
    readonly willValidate: boolean;
    readonly validity: ValidityState;
    readonly validationMessage: string;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
  }
  class HTMLFontElement {
    color: string;
    face: string;
    size: string;
  }
  class HTMLFormControlsCollection {
    namedItem(name: string): RadioNodeList | Element | null;
  }
  class HTMLFormElement {
    acceptCharset: string;
    action: string;
    autocomplete: string;
    enctype: string;
    encoding: string;
    method: string;
    name: string;
    noValidate: boolean;
    target: string;
    readonly elements: HTMLCollection;
    readonly length: number;
    __indexedgetter(index: number): Element;
    __namedgetter(name: string): nsISupports;
    submit(): void;
    requestSubmit(submitter?: HTMLElement | null): void;
    reset(): void;
    checkValidity(): boolean;
    reportValidity(): boolean;
  }
  class HTMLFrameElement {
    name: string;
    scrolling: string;
    src: string;
    frameBorder: string;
    longDesc: string;
    noResize: boolean;
    readonly contentDocument: Document | null;
    readonly contentWindow: WindowProxy | null;
    marginHeight: string;
    marginWidth: string;
    readonly frameLoader: FrameLoader | null;
    readonly browsingContext: BrowsingContext | null;
    presetOpenerWindow(window: WindowProxy | null): void;
    swapFrameLoaders(aOtherLoaderOwner: XULFrameElement): void;
    swapFrameLoaders(aOtherLoaderOwner: HTMLIFrameElement): void;
    changeRemoteness(aOptions: RemotenessOptions): void;
  }
  class HTMLFrameSetElement {
    cols: string;
    rows: string;
    onafterprint: EventHandlerNonNull | null;
    onbeforeprint: EventHandlerNonNull | null;
    onbeforeunload: OnBeforeUnloadEventHandlerNonNull | null;
    onhashchange: EventHandlerNonNull | null;
    onlanguagechange: EventHandlerNonNull | null;
    onmessage: EventHandlerNonNull | null;
    onmessageerror: EventHandlerNonNull | null;
    onoffline: EventHandlerNonNull | null;
    ononline: EventHandlerNonNull | null;
    onpagehide: EventHandlerNonNull | null;
    onpageshow: EventHandlerNonNull | null;
    onpopstate: EventHandlerNonNull | null;
    onrejectionhandled: EventHandlerNonNull | null;
    onstorage: EventHandlerNonNull | null;
    onunhandledrejection: EventHandlerNonNull | null;
    onunload: EventHandlerNonNull | null;
  }
  class HTMLHRElement {
    align: string;
    color: string;
    noShade: boolean;
    size: string;
    width: string;
  }
  class HTMLHeadElement {
  }
  class HTMLHeadingElement {
    align: string;
  }
  class HTMLHtmlElement {
    version: string;
  }
  class HTMLIFrameElement {
    src: string;
    srcdoc: string;
    name: string;
    readonly sandbox: DOMTokenList;
    allowFullscreen: boolean;
    allowPaymentRequest: boolean;
    width: string;
    height: string;
    referrerPolicy: string;
    readonly contentDocument: Document | null;
    readonly contentWindow: WindowProxy | null;
    align: string;
    scrolling: string;
    frameBorder: string;
    longDesc: string;
    marginHeight: string;
    marginWidth: string;
    getSVGDocument(): Document | null;
    mozbrowser: boolean;
    readonly featurePolicy: FeaturePolicy;
    allow: string;
    sendMouseEvent(type: string, x: number, y: number, button: number, clickCount: number, modifiers: number): void;
    goBack(): void;
    goForward(): void;
    reload(hardReload?: boolean): void;
    stop(): void;
    getCanGoBack(): Promise<boolean>;
    getCanGoForward(): Promise<boolean>;
    readonly frameLoader: FrameLoader | null;
    readonly browsingContext: BrowsingContext | null;
    presetOpenerWindow(window: WindowProxy | null): void;
    swapFrameLoaders(aOtherLoaderOwner: XULFrameElement): void;
    swapFrameLoaders(aOtherLoaderOwner: HTMLIFrameElement): void;
    changeRemoteness(aOptions: RemotenessOptions): void;
  }
  class HTMLImageElement {
    alt: string;
    src: string;
    srcset: string;
    crossOrigin: string | null;
    useMap: string;
    referrerPolicy: string;
    isMap: boolean;
    width: number;
    height: number;
    decoding: string;
    readonly naturalWidth: number;
    readonly naturalHeight: number;
    readonly complete: boolean;
    decode(): Promise<void>;
    name: string;
    align: string;
    hspace: number;
    vspace: number;
    longDesc: string;
    border: string;
    sizes: string;
    readonly currentSrc: string;
    lowsrc: string;
    readonly x: number;
    readonly y: number;
    loadingEnabled: boolean;
    readonly imageBlockingStatus: number;
    addObserver(aObserver: imgINotificationObserver): void;
    removeObserver(aObserver: imgINotificationObserver): void;
    getRequest(aRequestType: number): imgIRequest | null;
    getRequestType(aRequest: imgIRequest): number;
    readonly currentURI: URI | null;
    readonly currentRequestFinalURI: URI | null;
    forceReload(aNotify?: boolean): void;
    forceImageState(aForce: boolean, aState: number): void;
  }
  enum SelectionMode {
    Select = "select",
    Start = "start",
    End = "end",
    Preserve = "preserve",
  }
  class HTMLInputElement {
    accept: string;
    alt: string;
    autocomplete: string;
    autofocus: boolean;
    capture: string;
    defaultChecked: boolean;
    checked: boolean;
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    files: FileList | null;
    formAction: string;
    formEnctype: string;
    formMethod: string;
    formNoValidate: boolean;
    formTarget: string;
    height: number;
    indeterminate: boolean;
    inputMode: string;
    readonly list: HTMLElement | null;
    max: string;
    maxLength: number;
    min: string;
    minLength: number;
    multiple: boolean;
    name: string;
    pattern: string;
    placeholder: string;
    readOnly: boolean;
    required: boolean;
    size: number;
    src: string;
    step: string;
    type: string;
    defaultValue: string;
    value: string;
    valueAsDate: Date | null;
    valueAsNumber: number;
    width: number;
    stepUp(n?: number): void;
    stepDown(n?: number): void;
    readonly willValidate: boolean;
    readonly validity: ValidityState;
    readonly validationMessage: string;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    readonly labels: NodeList | null;
    select(): void;
    selectionStart: number | null;
    selectionEnd: number | null;
    selectionDirection: string | null;
    setRangeText(replacement: string): void;
    setRangeText(replacement: string, start: number, end: number, selectionMode?: SelectionMode): void;
    setSelectionRange(start: number, end: number, direction?: string): void;
    align: string;
    useMap: string;
    readonly controllers: XULControllers;
    readonly textLength: number;
    mozGetFileNameArray(): string[];
    mozSetFileNameArray(fileNames: string[]): void;
    mozSetFileArray(files: File[]): void;
    mozSetDirectory(directoryPath: string): void;
    mozSetDndFilesAndDirectories(list: File | Directory[]): void;
    readonly ownerNumberControl: HTMLInputElement | null;
    mozIsTextField(aExcludePassword: boolean): boolean;
    readonly hasBeenTypePassword: boolean;
    previewValue: string;
    getAutocompleteInfo(): AutocompleteInfo | null;
    allowdirs: boolean;
    readonly isFilesAndDirectoriesSupported: boolean;
    getFilesAndDirectories(): Promise<File | Directory[]>;
    getFiles(recursiveFlag?: boolean): Promise<File[]>;
    chooseDirectory(): void;
    readonly webkitEntries: FileSystemEntry[];
    webkitdirectory: boolean;
    getDateTimeInputBoxValue(): DateTimeValue;
    readonly dateTimeBoxElement: Element | null;
    getMinimum(): number;
    getMaximum(): number;
    openDateTimePicker(initialValue?: DateTimeValue): void;
    updateDateTimePicker(value?: DateTimeValue): void;
    closeDateTimePicker(): void;
    setFocusState(aIsFocused: boolean): void;
    updateValidityState(): void;
    getStep(): number;
    getStepBase(): number;
    readonly editor: nsIEditor | null;
    readonly isInputEventTarget: boolean;
    setUserInput(input: string): void;
    loadingEnabled: boolean;
    readonly imageBlockingStatus: number;
    addObserver(aObserver: imgINotificationObserver): void;
    removeObserver(aObserver: imgINotificationObserver): void;
    getRequest(aRequestType: number): imgIRequest | null;
    getRequestType(aRequest: imgIRequest): number;
    readonly currentURI: URI | null;
    readonly currentRequestFinalURI: URI | null;
    forceReload(aNotify?: boolean): void;
    forceImageState(aForce: boolean, aState: number): void;
  }
  interface DateTimeValue {
    day?: number
    hour?: number
    minute?: number
    month?: number
    year?: number
  }
  class HTMLLIElement {
    value: number;
    type: string;
  }
  class HTMLLabelElement {
    readonly form: HTMLFormElement | null;
    htmlFor: string;
    readonly control: HTMLElement | null;
  }
  class HTMLLegendElement {
    readonly form: HTMLFormElement | null;
    align: string;
  }
  class HTMLLinkElement {
    disabled: boolean;
    href: string;
    crossOrigin: string | null;
    rel: string;
    readonly relList: DOMTokenList;
    media: string;
    hreflang: string;
    type: string;
    referrerPolicy: string;
    readonly sizes: DOMTokenList;
    charset: string;
    rev: string;
    target: string;
    integrity: string;
    as: string;
    readonly sheet: StyleSheet | null;
  }
  class HTMLMapElement {
    name: string;
    readonly areas: HTMLCollection;
  }
  class HTMLMarqueeElement {
    behavior: string;
    bgColor: string;
    direction: string;
    height: string;
    hspace: number;
    loop: number;
    scrollAmount: number;
    scrollDelay: number;
    trueSpeed: boolean;
    vspace: number;
    width: string;
    onbounce: EventHandlerNonNull | null;
    onfinish: EventHandlerNonNull | null;
    onstart: EventHandlerNonNull | null;
    start(): void;
    stop(): void;
  }
  class HTMLMediaElement {
    readonly error: MediaError | null;
    src: string;
    readonly currentSrc: string;
    crossOrigin: string | null;
    readonly networkState: number;
    preload: string;
    readonly buffered: TimeRanges;
    load(): void;
    canPlayType(type: string): string;
    readonly readyState: number;
    readonly seeking: boolean;
    currentTime: number;
    fastSeek(time: number): void;
    readonly duration: number;
    readonly isEncrypted: boolean;
    readonly paused: boolean;
    defaultPlaybackRate: number;
    playbackRate: number;
    readonly played: TimeRanges;
    readonly seekable: TimeRanges;
    readonly ended: boolean;
    autoplay: boolean;
    loop: boolean;
    play(): Promise<void>;
    pause(): void;
    controls: boolean;
    volume: number;
    muted: boolean;
    defaultMuted: boolean;
    readonly audioTracks: AudioTrackList;
    readonly videoTracks: VideoTrackList;
    readonly textTracks: TextTrackList | null;
    addTextTrack(kind: TextTrackKind, label?: string, language?: string): TextTrack;
    readonly mozMediaSourceObject: MediaSource | null;
    mozRequestDebugInfo(): Promise<HTMLMediaElementDebugInfo>;
    mozEnableDebugLog(): void;
    mozRequestDebugLog(): Promise<string>;
    srcObject: MediaStream | null;
    mozPreservesPitch: boolean;
    mozAllowCasting: boolean;
    mozIsCasting: boolean;
    mozCaptureStream(): MediaStream;
    mozCaptureStreamUntilEnded(): MediaStream;
    readonly mozAudioCaptured: boolean;
    mozGetMetadata(): object | null;
    readonly mozFragmentEnd: number;
    reportCanPlayTelemetry(): void;
    readonly mediaKeys: MediaKeys | null;
    setMediaKeys(mediaKeys: MediaKeys | null): Promise<void>;
    onencrypted: EventHandlerNonNull | null;
    onwaitingforkey: EventHandlerNonNull | null;
    readonly computedVolume: number;
    readonly computedMuted: boolean;
    readonly computedSuspended: number;
    seekToNextFrame(): Promise<void>;
    setVisible(aVisible: boolean): void;
    hasSuspendTaint(): boolean;
    readonly isVisible: boolean;
    readonly isVideoDecodingSuspended: boolean;
    readonly sinkId: string;
    setSinkId(sinkId: string): Promise<void>;
    readonly allowedToPlay: boolean;
  }
  class HTMLMenuElement {
    type: string;
    label: string;
    compact: boolean;
    sendShowEvent(): void;
    createBuilder(): MenuBuilder | null;
    build(aBuilder: MenuBuilder): void;
  }
  class HTMLMenuItemElement {
    type: string;
    label: string;
    icon: string;
    disabled: boolean;
    checked: boolean;
    radiogroup: string;
    defaultChecked: boolean;
  }
  class HTMLMetaElement {
    name: string;
    httpEquiv: string;
    content: string;
    scheme: string;
  }
  class HTMLMeterElement {
    value: number;
    min: number;
    max: number;
    low: number;
    high: number;
    optimum: number;
    readonly labels: NodeList;
  }
  class HTMLModElement {
    cite: string;
    dateTime: string;
  }
  class HTMLOListElement {
    reversed: boolean;
    start: number;
    type: string;
    compact: boolean;
  }
  class HTMLObjectElement {
    data: string;
    type: string;
    name: string;
    useMap: string;
    readonly form: HTMLFormElement | null;
    width: string;
    height: string;
    readonly contentDocument: Document | null;
    readonly contentWindow: WindowProxy | null;
    readonly willValidate: boolean;
    readonly validity: ValidityState;
    readonly validationMessage: string;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    align: string;
    archive: string;
    code: string;
    declare: boolean;
    hspace: number;
    standby: string;
    vspace: number;
    codeBase: string;
    codeType: string;
    border: string;
    getSVGDocument(): Document | null;
    readonly frameLoader: FrameLoader | null;
    readonly browsingContext: BrowsingContext | null;
    presetOpenerWindow(window: WindowProxy | null): void;
    swapFrameLoaders(aOtherLoaderOwner: XULFrameElement): void;
    swapFrameLoaders(aOtherLoaderOwner: HTMLIFrameElement): void;
    changeRemoteness(aOptions: RemotenessOptions): void;
    loadingEnabled: boolean;
    readonly imageBlockingStatus: number;
    addObserver(aObserver: imgINotificationObserver): void;
    removeObserver(aObserver: imgINotificationObserver): void;
    getRequest(aRequestType: number): imgIRequest | null;
    getRequestType(aRequest: imgIRequest): number;
    readonly currentURI: URI | null;
    readonly currentRequestFinalURI: URI | null;
    forceReload(aNotify?: boolean): void;
    forceImageState(aForce: boolean, aState: number): void;
    readonly actualType: string;
    readonly displayedType: number;
    getContentTypeForMIMEType(aMimeType: string): number;
    getPluginAttributes(): MozPluginParameter[];
    getPluginParameters(): MozPluginParameter[];
    playPlugin(): void;
    reload(aClearActivation: boolean): void;
    readonly activated: boolean;
    readonly srcURI: URI | null;
    readonly defaultFallbackType: number;
    readonly pluginFallbackType: number;
    readonly hasRunningPlugin: boolean;
    skipFakePlugins(): void;
    readonly runID: number;
  }
  interface MozPluginParameter {
    name?: string
    value?: string
  }
  class HTMLOptGroupElement {
    disabled: boolean;
    label: string;
  }
  class HTMLOptionElement {
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    label: string;
    defaultSelected: boolean;
    selected: boolean;
    value: string;
    text: string;
    readonly index: number;
  }
  class HTMLOptionsCollection {
    length: number;
    __indexedsetter(index: number, option: HTMLOptionElement | null): void;
    add(element: HTMLOptionElement | HTMLOptGroupElement, before?: HTMLElement | number | null): void;
    remove(index: number): void;
    selectedIndex: number;
  }
  class HTMLOutputElement {
    readonly htmlFor: DOMTokenList;
    readonly form: HTMLFormElement | null;
    name: string;
    readonly type: string;
    defaultValue: string;
    value: string;
    readonly willValidate: boolean;
    readonly validity: ValidityState;
    readonly validationMessage: string;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    readonly labels: NodeList;
  }
  class HTMLParagraphElement {
    align: string;
  }
  class HTMLParamElement {
    name: string;
    value: string;
    type: string;
    valueType: string;
  }
  class HTMLPictureElement {
  }
  class HTMLPreElement {
    width: number;
  }
  class HTMLProgressElement {
    value: number;
    max: number;
    readonly position: number;
    readonly labels: NodeList;
  }
  class HTMLQuoteElement {
    cite: string;
  }
  class HTMLScriptElement {
    src: string;
    type: string;
    noModule: boolean;
    charset: string;
    async: boolean;
    defer: boolean;
    crossOrigin: string | null;
    referrerPolicy: string;
    text: string;
    event: string;
    htmlFor: string;
    integrity: string;
  }
  class HTMLSelectElement {
    autofocus: boolean;
    autocomplete: string;
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    multiple: boolean;
    name: string;
    required: boolean;
    size: number;
    readonly type: string;
    readonly options: HTMLOptionsCollection;
    length: number;
    item(index: number): Element | null;
    namedItem(name: string): HTMLOptionElement | null;
    add(element: HTMLOptionElement | HTMLOptGroupElement, before?: HTMLElement | number | null): void;
    remove(index: number): void;
    remove(): void;
    __indexedsetter(index: number, option: HTMLOptionElement | null): void;
    readonly selectedOptions: HTMLCollection;
    selectedIndex: number;
    value: string;
    readonly willValidate: boolean;
    readonly validity: ValidityState;
    readonly validationMessage: string;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    readonly labels: NodeList;
    openInParentProcess: boolean;
    getAutocompleteInfo(): AutocompleteInfo;
    previewValue: string;
  }
  class HTMLSlotElement {
    name: string;
    assignedNodes(options?: AssignedNodesOptions): Node[];
    assignedElements(options?: AssignedNodesOptions): Element[];
  }
  interface AssignedNodesOptions {
    flatten?: boolean
  }
  class HTMLSourceElement {
    src: string;
    type: string;
    srcset: string;
    sizes: string;
    media: string;
  }
  class HTMLSpanElement {
  }
  class HTMLStyleElement {
    disabled: boolean;
    media: string;
    type: string;
    readonly sheet: StyleSheet | null;
  }
  class HTMLTableCaptionElement {
    align: string;
  }
  class HTMLTableCellElement {
    colSpan: number;
    rowSpan: number;
    headers: string;
    readonly cellIndex: number;
    abbr: string;
    scope: string;
    align: string;
    axis: string;
    height: string;
    width: string;
    ch: string;
    chOff: string;
    noWrap: boolean;
    vAlign: string;
    bgColor: string;
  }
  class HTMLTableColElement {
    span: number;
    align: string;
    ch: string;
    chOff: string;
    vAlign: string;
    width: string;
  }
  class HTMLTableElement {
    caption: HTMLTableCaptionElement | null;
    createCaption(): HTMLElement;
    deleteCaption(): void;
    tHead: HTMLTableSectionElement | null;
    createTHead(): HTMLElement;
    deleteTHead(): void;
    tFoot: HTMLTableSectionElement | null;
    createTFoot(): HTMLElement;
    deleteTFoot(): void;
    readonly tBodies: HTMLCollection;
    createTBody(): HTMLElement;
    readonly rows: HTMLCollection;
    insertRow(index?: number): HTMLElement;
    deleteRow(index: number): void;
    align: string;
    border: string;
    frame: string;
    rules: string;
    summary: string;
    width: string;
    bgColor: string;
    cellPadding: string;
    cellSpacing: string;
  }
  class HTMLTableRowElement {
    readonly rowIndex: number;
    readonly sectionRowIndex: number;
    readonly cells: HTMLCollection;
    insertCell(index?: number): HTMLElement;
    deleteCell(index: number): void;
    align: string;
    ch: string;
    chOff: string;
    vAlign: string;
    bgColor: string;
  }
  class HTMLTableSectionElement {
    readonly rows: HTMLCollection;
    insertRow(index?: number): HTMLElement;
    deleteRow(index: number): void;
    align: string;
    ch: string;
    chOff: string;
    vAlign: string;
  }
  class HTMLTemplateElement {
    readonly content: DocumentFragment;
  }
  class HTMLTextAreaElement {
    autocomplete: string;
    autofocus: boolean;
    cols: number;
    disabled: boolean;
    readonly form: HTMLFormElement | null;
    maxLength: number;
    minLength: number;
    name: string;
    placeholder: string;
    readOnly: boolean;
    required: boolean;
    rows: number;
    wrap: string;
    readonly type: string;
    defaultValue: string;
    value: string;
    readonly textLength: number;
    readonly willValidate: boolean;
    readonly validity: ValidityState;
    readonly validationMessage: string;
    checkValidity(): boolean;
    reportValidity(): boolean;
    setCustomValidity(error: string): void;
    readonly labels: NodeList;
    select(): void;
    selectionStart: number | null;
    selectionEnd: number | null;
    selectionDirection: string | null;
    setRangeText(replacement: string): void;
    setRangeText(replacement: string, start: number, end: number, selectionMode?: SelectionMode): void;
    setSelectionRange(start: number, end: number, direction?: string): void;
    readonly controllers: XULControllers;
    previewValue: string;
    readonly editor: nsIEditor | null;
    readonly isInputEventTarget: boolean;
    setUserInput(input: string): void;
  }
  class HTMLTimeElement {
    dateTime: string;
  }
  class HTMLTitleElement {
    text: string;
  }
  class HTMLTrackElement {
    kind: string;
    src: string;
    srclang: string;
    label: string;
    default: boolean;
    readonly readyState: number;
    readonly track: TextTrack | null;
  }
  class HTMLUListElement {
    compact: boolean;
    type: string;
  }
  class HTMLVideoElement {
    width: number;
    height: number;
    readonly videoWidth: number;
    readonly videoHeight: number;
    poster: string;
    readonly mozParsedFrames: number;
    readonly mozDecodedFrames: number;
    readonly mozPresentedFrames: number;
    readonly mozPaintedFrames: number;
    readonly mozFrameDelay: number;
    readonly mozHasAudio: boolean;
    readonly mozOrientationLockEnabled: boolean;
    mozIsOrientationLocked: boolean;
    cloneElementVisually(target: HTMLVideoElement): Promise<void>;
    stopCloningElementVisually(): void;
    readonly isCloningElementVisually: boolean;
    getVideoPlaybackQuality(): VideoPlaybackQuality;
  }
  class HashChangeEvent {
    readonly oldURL: string;
    readonly newURL: string;
    initHashChangeEvent(typeArg: string, canBubbleArg?: boolean, cancelableArg?: boolean, oldURLArg?: string, newURLArg?: string): void;
    readonly isTrusted: boolean;
  }
  interface HashChangeEventInit {
    newURL?: string
    oldURL?: string
  }
  enum HeadersGuardEnum {
    None = "none",
    Request = "request",
    Request_no_cors = "request-no-cors",
    Response = "response",
    Immutable = "immutable",
  }
  class Headers {
    append(name: string, value: string): void;
    delete(name: string): void;
    get(name: string): string | null;
    has(name: string): boolean;
    set(name: string, value: string): void;
    guard: HeadersGuardEnum;
    entries(): HeadersIterator;
    keys(): HeadersIterator;
    values(): HeadersIterator;
    forEach(callback: object, thisArg?: any): void;
  }
  class HiddenPluginEvent {
    readonly tag: PluginTag | null;
    readonly isTrusted: boolean;
  }
  interface HiddenPluginEventInit {
    tag?: PluginTag | null
  }
  enum ScrollRestoration {
    Auto = "auto",
    Manual = "manual",
  }
  class History {
    readonly length: number;
    scrollRestoration: ScrollRestoration;
    readonly state: any;
    go(delta?: number): void;
    back(): void;
    forward(): void;
    pushState(data: any, title: string, url?: string | null): void;
    replaceState(data: any, title: string, url?: string | null): void;
  }
  enum IDBCursorDirection {
    Next = "next",
    Nextunique = "nextunique",
    Prev = "prev",
    Prevunique = "prevunique",
  }
  class IDBCursor {
    readonly source: IDBObjectStore | IDBIndex;
    readonly direction: IDBCursorDirection;
    readonly key: any;
    readonly primaryKey: any;
    update(value: any): IDBRequest;
    advance(count: number): void;
    continue(key?: any): void;
    continuePrimaryKey(key: any, primaryKey: any): void;
    delete(): IDBRequest;
  }
  class IDBCursorWithValue {
    readonly value: any;
  }
  class IDBDatabase {
    readonly name: string;
    readonly version: number;
    readonly objectStoreNames: DOMStringList;
    createObjectStore(name: string, optionalParameters?: IDBObjectStoreParameters): IDBObjectStore;
    deleteObjectStore(name: string): void;
    transaction(storeNames: string | string[], mode?: IDBTransactionMode): IDBTransaction;
    close(): void;
    onabort: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onversionchange: EventHandlerNonNull | null;
    readonly storage: StorageType;
    createMutableFile(name: string, type?: string): IDBRequest;
    mozCreateFileHandle(name: string, type?: string): IDBRequest;
  }
  interface IDBOpenDBOptions {
    storage?: StorageType
    version?: number
  }
  class IDBFactory {
    open(name: string, version: number): IDBOpenDBRequest;
    open(name: string, options?: IDBOpenDBOptions): IDBOpenDBRequest;
    deleteDatabase(name: string, options?: IDBOpenDBOptions): IDBOpenDBRequest;
    cmp(first: any, second: any): number;
    openForPrincipal(principal: Principal, name: string, version: number): IDBOpenDBRequest;
    openForPrincipal(principal: Principal, name: string, options?: IDBOpenDBOptions): IDBOpenDBRequest;
    deleteForPrincipal(principal: Principal, name: string, options?: IDBOpenDBOptions): IDBOpenDBRequest;
  }
  interface IDBFileMetadataParameters {
    lastModified?: boolean
    size?: boolean
  }
  class IDBFileHandle {
    readonly mutableFile: IDBMutableFile | null;
    readonly fileHandle: IDBMutableFile | null;
    readonly mode: FileMode;
    readonly active: boolean;
    location: number | null;
    getMetadata(parameters?: IDBFileMetadataParameters): IDBFileRequest | null;
    readAsArrayBuffer(size: number): IDBFileRequest | null;
    readAsText(size: number, encoding?: string | null): IDBFileRequest | null;
    write(value: string | ArrayBuffer | ArrayBufferView | Blob): IDBFileRequest | null;
    append(value: string | ArrayBuffer | ArrayBufferView | Blob): IDBFileRequest | null;
    truncate(size?: number): IDBFileRequest | null;
    flush(): IDBFileRequest | null;
    abort(): void;
    oncomplete: EventHandlerNonNull | null;
    onabort: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
  }
  class IDBFileRequest {
    readonly fileHandle: IDBFileHandle | null;
    readonly lockedFile: IDBFileHandle | null;
    onprogress: EventHandlerNonNull | null;
  }
  interface IDBIndexParameters {
    locale?: string | null
    multiEntry?: boolean
    unique?: boolean
  }
  class IDBIndex {
    name: string;
    readonly objectStore: IDBObjectStore;
    readonly keyPath: any;
    readonly multiEntry: boolean;
    readonly unique: boolean;
    readonly locale: string | null;
    readonly isAutoLocale: boolean;
    openCursor(range?: any, direction?: IDBCursorDirection): IDBRequest;
    openKeyCursor(range?: any, direction?: IDBCursorDirection): IDBRequest;
    get(key: any): IDBRequest;
    getKey(key: any): IDBRequest;
    count(key?: any): IDBRequest;
    getAll(key?: any, limit?: number): IDBRequest;
    getAllKeys(key?: any, limit?: number): IDBRequest;
  }
  class IDBKeyRange {
    readonly lower: any;
    readonly upper: any;
    readonly lowerOpen: boolean;
    readonly upperOpen: boolean;
    includes(key: any): boolean;
    only(value: any): IDBKeyRange;
    lowerBound(lower: any, open?: boolean): IDBKeyRange;
    upperBound(upper: any, open?: boolean): IDBKeyRange;
    bound(lower: any, upper: any, lowerOpen?: boolean, upperOpen?: boolean): IDBKeyRange;
  }
  class IDBLocaleAwareKeyRange {
    bound(lower: any, upper: any, lowerOpen?: boolean, upperOpen?: boolean): IDBLocaleAwareKeyRange;
  }
  class IDBMutableFile {
    readonly name: string;
    readonly type: string;
    readonly database: IDBDatabase;
    open(mode?: FileMode): IDBFileHandle;
    getFile(): DOMRequest;
    onabort: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
  }
  interface IDBObjectStoreParameters {
    autoIncrement?: boolean
    keyPath?: string | string[] | null
  }
  class IDBObjectStore {
    name: string;
    readonly keyPath: any;
    readonly indexNames: DOMStringList;
    readonly transaction: IDBTransaction;
    readonly autoIncrement: boolean;
    put(value: any, key?: any): IDBRequest;
    add(value: any, key?: any): IDBRequest;
    delete(key: any): IDBRequest;
    get(key: any): IDBRequest;
    getKey(key: any): IDBRequest;
    clear(): IDBRequest;
    openCursor(range?: any, direction?: IDBCursorDirection): IDBRequest;
    createIndex(name: string, keyPath: string | string[], optionalParameters?: IDBIndexParameters): IDBIndex;
    index(name: string): IDBIndex;
    deleteIndex(indexName: string): void;
    count(key?: any): IDBRequest;
    getAll(key?: any, limit?: number): IDBRequest;
    getAllKeys(key?: any, limit?: number): IDBRequest;
    openKeyCursor(range?: any, direction?: IDBCursorDirection): IDBRequest;
  }
  class IDBOpenDBRequest {
    onblocked: EventHandlerNonNull | null;
    onupgradeneeded: EventHandlerNonNull | null;
  }
  enum IDBRequestReadyState {
    Pending = "pending",
    Done = "done",
  }
  class IDBRequest {
    readonly result: any;
    readonly error: DOMException | null;
    readonly source: IDBObjectStore | IDBIndex | IDBCursor | null;
    readonly transaction: IDBTransaction | null;
    readonly readyState: IDBRequestReadyState;
    onsuccess: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
  }
  enum IDBTransactionMode {
    Readonly = "readonly",
    Readwrite = "readwrite",
    Readwriteflush = "readwriteflush",
    Cleanup = "cleanup",
    Versionchange = "versionchange",
  }
  class IDBTransaction {
    readonly mode: IDBTransactionMode;
    readonly db: IDBDatabase;
    readonly error: DOMException | null;
    objectStore(name: string): IDBObjectStore;
    commit(): void;
    abort(): void;
    onabort: EventHandlerNonNull | null;
    oncomplete: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    readonly objectStoreNames: DOMStringList;
  }
  interface IDBVersionChangeEventInit {
    newVersion?: number | null
    oldVersion?: number
  }
  class IDBVersionChangeEvent {
    readonly oldVersion: number;
    readonly newVersion: number | null;
    readonly isTrusted: boolean;
  }
  interface IIRFilterOptions {
    feedback: number[]
    feedforward: number[]
  }
  class IIRFilterNode {
    getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;
    passThrough: boolean;
  }
  class IdleDeadline {
    timeRemaining(): number;
    readonly didTimeout: boolean;
  }
  class ImageBitmap {
    readonly width: number;
    readonly height: number;
    close(): void;
  }
  enum ImageBitmapFormat {
    RGBA__ = "RGBA32",
    BGRA__ = "BGRA32",
    RGB__ = "RGB24",
    BGR__ = "BGR24",
    GRAY_ = "GRAY8",
    YUV___P = "YUV444P",
    YUV___P = "YUV422P",
    YUV___P = "YUV420P",
    YUV___SP_NV__ = "YUV420SP_NV12",
    YUV___SP_NV__ = "YUV420SP_NV21",
    HSV = "HSV",
    Lab = "Lab",
    DEPTH = "DEPTH",
  }
  enum ChannelPixelLayoutDataType {
    Uint_ = "uint8",
    Int_ = "int8",
    Uint__ = "uint16",
    Int__ = "int16",
    Uint__ = "uint32",
    Int__ = "int32",
    Float__ = "float32",
    Float__ = "float64",
  }
  interface ChannelPixelLayout {
    dataType: ChannelPixelLayoutDataType
    height: number
    offset: number
    skip: number
    stride: number
    width: number
  }
  class ImageBitmapRenderingContext {
    transferFromImageBitmap(bitmap: ImageBitmap): void;
    transferImageBitmap(bitmap: ImageBitmap): void;
  }
  class ImageCapture {
    readonly videoStreamTrack: MediaStreamTrack;
    onphoto: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    takePhoto(): void;
  }
  class ImageCaptureErrorEvent {
    readonly imageCaptureError: ImageCaptureError | null;
    readonly isTrusted: boolean;
  }
  interface ImageCaptureErrorEventInit {
    imageCaptureError?: ImageCaptureError | null
  }
  class ImageCaptureError {
    readonly code: number;
    readonly message: string;
  }
  class ImageData {
    readonly width: number;
    readonly height: number;
    readonly data: Uint8ClampedArray;
  }
  class ImageDocument {
    readonly imageIsOverflowing: boolean;
    readonly imageIsResized: boolean;
    readonly imageRequest: imgIRequest | null;
    shrinkToFit(): void;
    restoreImage(): void;
    restoreImageTo(x: number, y: number): void;
    toggleImageSize(): void;
    readonly location: Location | null;
  }
  class InputEvent {
    readonly isComposing: boolean;
    readonly inputType: string;
    readonly data: string | null;
    readonly dataTransfer: DataTransfer | null;
    readonly isTrusted: boolean;
  }
  interface InputEventInit {
    data?: string | null
    dataTransfer?: DataTransfer | null
    inputType?: string
    isComposing?: boolean
  }
  function InstallTriggerCallback(url: string, status: number): void;
  interface InstallTriggerData {
    Hash?: string | null
    IconURL?: string | null
    URL?: string
  }
  class InstallTriggerImpl {
    enabled(): boolean;
    updateEnabled(): boolean;
    install(installs: Record<string, string | InstallTriggerData>, callback?: InstallTriggerCallback): boolean;
    installChrome(type: number, url: string, skin: string): boolean;
    startSoftwareUpdate(url: string, flags?: number): boolean;
  }
  class IntersectionObserverEntry {
    readonly time: number;
    readonly rootBounds: DOMRectReadOnly | null;
    readonly boundingClientRect: DOMRectReadOnly;
    readonly intersectionRect: DOMRectReadOnly;
    readonly isIntersecting: boolean;
    readonly intersectionRatio: number;
    readonly target: Element;
  }
  class IntersectionObserver {
    readonly root: Element | null;
    readonly rootMargin: string;
    readonly thresholds: number[];
    observe(target: Element): void;
    unobserve(target: Element): void;
    disconnect(): void;
    takeRecords(): IntersectionObserverEntry[];
    readonly intersectionCallback: IntersectionCallback;
  }
  function IntersectionCallback(entries: IntersectionObserverEntry[], observer: IntersectionObserver): void;
  interface IntersectionObserverEntryInit {
    boundingClientRect: DOMRectInit
    intersectionRect: DOMRectInit
    rootBounds: DOMRectInit
    target: Element
    time: number
  }
  interface IntersectionObserverInit {
    root?: Element | null
    rootMargin?: string
    threshold?: number | number[]
  }
  interface DisplayNameOptions {
    keys?: string[]
    style?: string
  }
  interface DisplayNameResult {
    locale?: string
    style?: string
    values?: Record<string, string>
  }
  interface LocaleInfo {
    direction?: string
    locale?: string
  }
  class IntlUtils {
    getDisplayNames(locales: string[], options?: DisplayNameOptions): DisplayNameResult;
    getLocaleInfo(locales: string[]): LocaleInfo;
  }
  interface IterableKeyOrValueResult {
    done?: boolean
    value?: any
  }
  interface IterableKeyAndValueResult {
    done?: boolean
    value?: any[]
  }
  interface KeyAlgorithm {
    name: string
  }
  interface AesKeyAlgorithm {
    length: number
  }
  interface EcKeyAlgorithm {
    namedCurve: string
  }
  interface HmacKeyAlgorithm {
    hash: KeyAlgorithm
    length: number
  }
  interface RsaHashedKeyAlgorithm {
    hash: KeyAlgorithm
    modulusLength: number
    publicExponent: Uint8Array
  }
  interface DhKeyAlgorithm {
    generator: Uint8Array
    prime: Uint8Array
  }
  class KeyEvent {
    initKeyEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean, keyCode?: number, charCode?: number): void;
  }
  interface KeyIdsInitData {
    kids: string[]
  }
  class KeyboardEvent {
    readonly charCode: number;
    readonly keyCode: number;
    readonly altKey: boolean;
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly metaKey: boolean;
    getModifierState(key: string): boolean;
    readonly location: number;
    readonly repeat: boolean;
    readonly isComposing: boolean;
    readonly key: string;
    readonly code: string;
    initKeyboardEvent(typeArg: string, bubblesArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, keyArg?: string, locationArg?: number, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean): void;
    readonly initDict: KeyboardEventInit;
    initKeyEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean, keyCode?: number, charCode?: number): void;
    readonly isTrusted: boolean;
  }
  interface KeyboardEventInit {
    charCode?: number
    code?: string
    isComposing?: boolean
    key?: string
    keyCode?: number
    location?: number
    repeat?: boolean
    which?: number
  }
  enum IterationCompositeOperation {
    Replace = "replace",
    Accumulate = "accumulate",
  }
  interface KeyframeEffectOptions {
    composite?: CompositeOperation
    iterationComposite?: IterationCompositeOperation
  }
  class KeyframeEffect {
    target: Element | CSSPseudoElement | null;
    iterationComposite: IterationCompositeOperation;
    composite: CompositeOperation;
    getKeyframes(): object[];
    setKeyframes(keyframes: object | null): void;
    getProperties(): AnimationPropertyDetails[];
  }
  interface AnimationPropertyValueDetails {
    composite: CompositeOperation
    easing?: string
    offset: number
    value?: string
  }
  interface AnimationPropertyDetails {
    property: string
    runningOnCompositor: boolean
    values: AnimationPropertyValueDetails[]
    warning?: string
  }
  interface LoadURIOptions {
    baseURI?: URI | null
    cancelContentJSEpoch?: number
    csp?: ContentSecurityPolicy | null
    headers?: InputStream | null
    loadFlags?: number
    postData?: InputStream | null
    referrerInfo?: ReferrerInfo | null
    triggeringPrincipal?: Principal | null
  }
  class Location {
    href: string;
    readonly origin: string;
    protocol: string;
    host: string;
    hostname: string;
    port: string;
    pathname: string;
    search: string;
    hash: string;
    assign(url: string): void;
    replace(url: string): void;
    reload(forceget?: boolean): void;
    __stringifier(): string;
  }
  class MIDIAccess {
    readonly inputs: MIDIInputMap;
    readonly outputs: MIDIOutputMap;
    onstatechange: EventHandlerNonNull | null;
    readonly sysexEnabled: boolean;
  }
  class MIDIConnectionEvent {
    readonly port: MIDIPort | null;
    readonly isTrusted: boolean;
  }
  interface MIDIConnectionEventInit {
    port?: MIDIPort | null
  }
  class MIDIInput {
    onmidimessage: EventHandlerNonNull | null;
  }
  class MIDIInputMap {
    readonly size: number;
    entries(): object;
    keys(): object;
    values(): object;
    forEach(callback: object, thisArg?: any): void;
    has(key: string): boolean;
    get(key: string): any;
  }
  class MIDIMessageEvent {
    readonly data: Uint8Array;
    readonly isTrusted: boolean;
  }
  interface MIDIMessageEventInit {
    data?: Uint8Array
  }
  interface MIDIOptions {
    software?: boolean
    sysex?: boolean
  }
  class MIDIOutput {
    send(data: number[], timestamp?: number): void;
    clear(): void;
  }
  class MIDIOutputMap {
    readonly size: number;
    entries(): object;
    keys(): object;
    values(): object;
    forEach(callback: object, thisArg?: any): void;
    has(key: string): boolean;
    get(key: string): any;
  }
  enum MIDIPortType {
    Input = "input",
    Output = "output",
  }
  enum MIDIPortDeviceState {
    Disconnected = "disconnected",
    Connected = "connected",
  }
  enum MIDIPortConnectionState {
    Open = "open",
    Closed = "closed",
    Pending = "pending",
  }
  class MIDIPort {
    readonly id: string;
    readonly manufacturer: string | null;
    readonly name: string | null;
    readonly version: string | null;
    readonly type: MIDIPortType;
    readonly state: MIDIPortDeviceState;
    readonly connection: MIDIPortConnectionState;
    onstatechange: EventHandlerNonNull | null;
    open(): Promise<MIDIPort>;
    close(): Promise<MIDIPort>;
  }
  class MathMLElement {
    oncopy: EventHandlerNonNull | null;
    oncut: EventHandlerNonNull | null;
    onpaste: EventHandlerNonNull | null;
    readonly style: CSSStyleDeclaration;
    onabort: EventHandlerNonNull | null;
    onblur: EventHandlerNonNull | null;
    onfocus: EventHandlerNonNull | null;
    onauxclick: EventHandlerNonNull | null;
    oncanplay: EventHandlerNonNull | null;
    oncanplaythrough: EventHandlerNonNull | null;
    onchange: EventHandlerNonNull | null;
    onclick: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    oncontextmenu: EventHandlerNonNull | null;
    oncuechange: EventHandlerNonNull | null;
    ondblclick: EventHandlerNonNull | null;
    ondrag: EventHandlerNonNull | null;
    ondragend: EventHandlerNonNull | null;
    ondragenter: EventHandlerNonNull | null;
    ondragexit: EventHandlerNonNull | null;
    ondragleave: EventHandlerNonNull | null;
    ondragover: EventHandlerNonNull | null;
    ondragstart: EventHandlerNonNull | null;
    ondrop: EventHandlerNonNull | null;
    ondurationchange: EventHandlerNonNull | null;
    onemptied: EventHandlerNonNull | null;
    onended: EventHandlerNonNull | null;
    onformdata: EventHandlerNonNull | null;
    oninput: EventHandlerNonNull | null;
    oninvalid: EventHandlerNonNull | null;
    onkeydown: EventHandlerNonNull | null;
    onkeypress: EventHandlerNonNull | null;
    onkeyup: EventHandlerNonNull | null;
    onload: EventHandlerNonNull | null;
    onloadeddata: EventHandlerNonNull | null;
    onloadedmetadata: EventHandlerNonNull | null;
    onloadend: EventHandlerNonNull | null;
    onloadstart: EventHandlerNonNull | null;
    onmousedown: EventHandlerNonNull | null;
    onmouseenter: EventHandlerNonNull | null;
    onmouseleave: EventHandlerNonNull | null;
    onmousemove: EventHandlerNonNull | null;
    onmouseout: EventHandlerNonNull | null;
    onmouseover: EventHandlerNonNull | null;
    onmouseup: EventHandlerNonNull | null;
    onwheel: EventHandlerNonNull | null;
    onpause: EventHandlerNonNull | null;
    onplay: EventHandlerNonNull | null;
    onplaying: EventHandlerNonNull | null;
    onprogress: EventHandlerNonNull | null;
    onratechange: EventHandlerNonNull | null;
    onreset: EventHandlerNonNull | null;
    onresize: EventHandlerNonNull | null;
    onscroll: EventHandlerNonNull | null;
    onseeked: EventHandlerNonNull | null;
    onseeking: EventHandlerNonNull | null;
    onselect: EventHandlerNonNull | null;
    onshow: EventHandlerNonNull | null;
    onstalled: EventHandlerNonNull | null;
    onsubmit: EventHandlerNonNull | null;
    onsuspend: EventHandlerNonNull | null;
    ontimeupdate: EventHandlerNonNull | null;
    onvolumechange: EventHandlerNonNull | null;
    onwaiting: EventHandlerNonNull | null;
    onselectstart: EventHandlerNonNull | null;
    ontoggle: EventHandlerNonNull | null;
    onpointercancel: EventHandlerNonNull | null;
    onpointerdown: EventHandlerNonNull | null;
    onpointerup: EventHandlerNonNull | null;
    onpointermove: EventHandlerNonNull | null;
    onpointerout: EventHandlerNonNull | null;
    onpointerover: EventHandlerNonNull | null;
    onpointerenter: EventHandlerNonNull | null;
    onpointerleave: EventHandlerNonNull | null;
    ongotpointercapture: EventHandlerNonNull | null;
    onlostpointercapture: EventHandlerNonNull | null;
    onmozfullscreenchange: EventHandlerNonNull | null;
    onmozfullscreenerror: EventHandlerNonNull | null;
    onanimationcancel: EventHandlerNonNull | null;
    onanimationend: EventHandlerNonNull | null;
    onanimationiteration: EventHandlerNonNull | null;
    onanimationstart: EventHandlerNonNull | null;
    ontransitioncancel: EventHandlerNonNull | null;
    ontransitionend: EventHandlerNonNull | null;
    ontransitionrun: EventHandlerNonNull | null;
    ontransitionstart: EventHandlerNonNull | null;
    onwebkitanimationend: EventHandlerNonNull | null;
    onwebkitanimationiteration: EventHandlerNonNull | null;
    onwebkitanimationstart: EventHandlerNonNull | null;
    onwebkittransitionend: EventHandlerNonNull | null;
    readonly dataset: DOMStringMap;
    tabIndex: number;
    focus(options?: FocusOptions): void;
    blur(): void;
    onerror: EventHandlerNonNull | null;
    ontouchstart: EventHandlerNonNull | null;
    ontouchend: EventHandlerNonNull | null;
    ontouchmove: EventHandlerNonNull | null;
    ontouchcancel: EventHandlerNonNull | null;
  }
  interface MediaConfiguration {
    audio?: AudioConfiguration
    video?: VideoConfiguration
  }
  interface MediaDecodingConfiguration {
    type: MediaDecodingType
  }
  interface MediaEncodingConfiguration {
    type: MediaEncodingType
  }
  enum MediaDecodingType {
    File = "file",
    Media_source = "media-source",
  }
  enum MediaEncodingType {
    Record = "record",
    Transmission = "transmission",
  }
  interface VideoConfiguration {
    bitrate: number
    contentType: string
    framerate: string
    height: number
    width: number
  }
  interface AudioConfiguration {
    bitrate?: number
    channels?: string
    contentType: string
    samplerate?: number
  }
  class MediaCapabilitiesInfo {
    readonly supported: boolean;
    readonly smooth: boolean;
    readonly powerEfficient: boolean;
  }
  class MediaCapabilities {
    decodingInfo(configuration: MediaDecodingConfiguration): Promise<MediaCapabilitiesInfo>;
    encodingInfo(configuration: MediaEncodingConfiguration): Promise<MediaCapabilitiesInfo>;
  }
  interface MediaCacheStreamDebugInfo {
    cacheSuspended?: boolean
    channelEnded?: boolean
    channelOffset?: number
    loadID?: number
    streamLength?: number
  }
  interface MediaResourceDebugInfo {
    cacheStream?: MediaCacheStreamDebugInfo
  }
  interface MediaDecoderDebugInfo {
    PlayState?: string
    channels?: number
    containerType?: string
    hasAudio?: boolean
    hasVideo?: boolean
    instance?: string
    rate?: number
    reader?: MediaFormatReaderDebugInfo
    resource?: MediaResourceDebugInfo
    stateMachine?: MediaDecoderStateMachineDebugInfo
  }
  interface AudioSinkDebugInfo {
    audioEnded?: boolean
    hasErrored?: boolean
    isPlaying?: boolean
    isStarted?: boolean
    lastGoodPosition?: number
    outputRate?: number
    playbackComplete?: boolean
    startTime?: number
    written?: number
  }
  interface AudioSinkWrapperDebugInfo {
    audioEnded?: boolean
    audioSink?: AudioSinkDebugInfo
    isPlaying?: boolean
    isStarted?: boolean
  }
  interface VideoSinkDebugInfo {
    endPromiseHolderIsEmpty?: boolean
    finished?: boolean
    hasVideo?: boolean
    isPlaying?: boolean
    isStarted?: boolean
    size?: number
    videoFrameEndTime?: number
    videoSinkEndRequestExists?: boolean
  }
  interface DecodedStreamDataDebugInfo {
    audioFramesWritten?: number
    haveSentFinishAudio?: boolean
    haveSentFinishVideo?: boolean
    instance?: string
    lastVideoEndTime?: number
    lastVideoStartTime?: number
    nextAudioTime?: number
    streamAudioWritten?: number
    streamVideoWritten?: number
  }
  interface DecodedStreamDebugInfo {
    audioQueueFinished?: boolean
    audioQueueSize?: number
    data?: DecodedStreamDataDebugInfo
    instance?: string
    lastAudio?: number
    lastOutputTime?: number
    playing?: number
    startTime?: number
  }
  interface MediaSinkDebugInfo {
    audioSinkWrapper?: AudioSinkWrapperDebugInfo
    decodedStream?: DecodedStreamDebugInfo
    videoSink?: VideoSinkDebugInfo
  }
  interface MediaDecoderStateMachineDecodingStateDebugInfo {
    isPrerolling?: boolean
  }
  interface MediaDecoderStateMachineDebugInfo {
    audioCompleted?: boolean
    audioRequestStatus?: string
    clock?: number
    decodedAudioEndTime?: number
    decodedVideoEndTime?: number
    duration?: number
    isPlaying?: boolean
    mediaSink?: MediaSinkDebugInfo
    mediaTime?: number
    playState?: number
    sentFirstFrameLoadedEvent?: boolean
    state?: string
    stateObj?: MediaDecoderStateMachineDecodingStateDebugInfo
    videoCompleted?: boolean
    videoRequestStatus?: string
  }
  interface MediaStateDebugInfo {
    demuxEOS?: number
    demuxQueueSize?: number
    drainState?: number
    hasDecoder?: boolean
    hasDemuxRequest?: boolean
    hasPromise?: boolean
    lastStreamSourceID?: number
    needInput?: boolean
    numSamplesInput?: number
    numSamplesOutput?: number
    pending?: number
    queueSize?: number
    timeTreshold?: number
    timeTresholdHasSeeked?: boolean
    waitingForData?: boolean
    waitingForKey?: boolean
    waitingPromise?: boolean
  }
  interface MediaFrameStats {
    droppedCompositorFrames?: number
    droppedDecodedFrames?: number
    droppedSinkFrames?: number
  }
  interface MediaFormatReaderDebugInfo {
    audioChannels?: number
    audioDecoderName?: string
    audioFramesDecoded?: number
    audioRate?: number
    audioState?: MediaStateDebugInfo
    audioType?: string
    frameStats?: MediaFrameStats
    videoDecoderName?: string
    videoHardwareAccelerated?: boolean
    videoHeight?: number
    videoNumSamplesOutputTotal?: number
    videoNumSamplesSkippedTotal?: number
    videoRate?: number
    videoState?: MediaStateDebugInfo
    videoType?: string
    videoWidth?: number
  }
  interface BufferRange {
    end?: number
    start?: number
  }
  interface TrackBuffersManagerDebugInfo {
    bufferSize?: number
    evictable?: number
    nextGetSampleIndex?: number
    nextInsertionIndex?: number
    nextSampleTime?: number
    numSamples?: number
    ranges?: BufferRange[]
    type?: string
  }
  interface MediaSourceDemuxerDebugInfo {
    audioTrack?: TrackBuffersManagerDebugInfo
    videoTrack?: TrackBuffersManagerDebugInfo
  }
  interface MediaSourceDecoderDebugInfo {
    demuxer?: MediaSourceDemuxerDebugInfo
    reader?: MediaFormatReaderDebugInfo
  }
  interface EMEDebugInfo {
    keySystem?: string
    sessionsInfo?: string
  }
  interface HTMLMediaElementDebugInfo {
    EMEInfo?: EMEDebugInfo
    compositorDroppedFrames?: number
    decoder?: MediaDecoderDebugInfo
  }
  enum MediaDeviceKind {
    Audioinput = "audioinput",
    Audiooutput = "audiooutput",
    Videoinput = "videoinput",
  }
  class MediaDeviceInfo {
    readonly deviceId: string;
    readonly kind: MediaDeviceKind;
    readonly label: string;
    readonly groupId: string;
    toJSON(): object;
  }
  class MediaDevices {
    ondevicechange: EventHandlerNonNull | null;
    getSupportedConstraints(): MediaTrackSupportedConstraints;
    enumerateDevices(): Promise<MediaDeviceInfo[]>;
    getUserMedia(constraints?: MediaStreamConstraints): Promise<MediaStream>;
    getDisplayMedia(constraints?: DisplayMediaStreamConstraints): Promise<MediaStream>;
  }
  interface MediaElementAudioSourceOptions {
    mediaElement: HTMLMediaElement
  }
  class MediaElementAudioSourceNode {
    readonly mediaElement: HTMLMediaElement;
    passThrough: boolean;
  }
  class MediaEncryptedEvent {
    readonly initDataType: string;
    readonly initData: ArrayBuffer | null;
    readonly isTrusted: boolean;
  }
  interface MediaKeyNeededEventInit {
    initData?: ArrayBuffer | null
    initDataType?: string
  }
  class MediaError {
    readonly code: number;
    readonly message: string;
  }
  class MediaKeyError {
    readonly systemCode: number;
    readonly isTrusted: boolean;
  }
  enum MediaKeyMessageType {
    License_request = "license-request",
    License_renewal = "license-renewal",
    License_release = "license-release",
    Individualization_request = "individualization-request",
  }
  class MediaKeyMessageEvent {
    readonly messageType: MediaKeyMessageType;
    readonly message: ArrayBuffer;
    readonly isTrusted: boolean;
  }
  interface MediaKeyMessageEventInit {
    message: ArrayBuffer
    messageType: MediaKeyMessageType
  }
  class MediaKeySession {
    readonly error: MediaKeyError | null;
    readonly sessionId: string;
    readonly expiration: number;
    readonly closed: Promise<void>;
    readonly keyStatuses: MediaKeyStatusMap;
    onkeystatuseschange: EventHandlerNonNull | null;
    onmessage: EventHandlerNonNull | null;
    generateRequest(initDataType: string, initData: ArrayBufferView | ArrayBuffer): Promise<void>;
    load(sessionId: string): Promise<boolean>;
    update(response: ArrayBufferView | ArrayBuffer): Promise<void>;
    close(): Promise<void>;
    remove(): Promise<void>;
  }
  enum MediaKeyStatus {
    Usable = "usable",
    Expired = "expired",
    Released = "released",
    Output_restricted = "output-restricted",
    Output_downscaled = "output-downscaled",
    Status_pending = "status-pending",
    Internal_error = "internal-error",
  }
  class MediaKeyStatusMap {
    readonly size: number;
    has(keyId: ArrayBufferView | ArrayBuffer): boolean;
    get(keyId: ArrayBufferView | ArrayBuffer): any;
    entries(): MediaKeyStatusMapIterator;
    keys(): MediaKeyStatusMapIterator;
    values(): MediaKeyStatusMapIterator;
    forEach(callback: object, thisArg?: any): void;
  }
  enum MediaKeysRequirement {
    Required = "required",
    Optional = "optional",
    Not_allowed = "not-allowed",
  }
  interface MediaKeySystemMediaCapability {
    contentType?: string
    encryptionScheme?: string | null
    robustness?: string
  }
  interface MediaKeySystemConfiguration {
    audioCapabilities?: MediaKeySystemMediaCapability[]
    distinctiveIdentifier?: MediaKeysRequirement
    initDataTypes?: string[]
    label?: string
    persistentState?: MediaKeysRequirement
    sessionTypes?: string[]
    videoCapabilities?: MediaKeySystemMediaCapability[]
  }
  class MediaKeySystemAccess {
    readonly keySystem: string;
    getConfiguration(): MediaKeySystemConfiguration;
    createMediaKeys(): Promise<MediaKeys>;
  }
  enum MediaKeySessionType {
    Temporary = "temporary",
    Persistent_license = "persistent-license",
  }
  interface MediaKeysPolicy {
    minHdcpVersion?: string
  }
  class MediaKeys {
    readonly keySystem: string;
    createSession(sessionType?: MediaKeySessionType): MediaKeySession;
    setServerCertificate(serverCertificate: ArrayBufferView | ArrayBuffer): Promise<void>;
    getStatusForPolicy(policy?: MediaKeysPolicy): Promise<MediaKeyStatus>;
  }
  enum MediaKeySystemStatus {
    Available = "available",
    Api_disabled = "api-disabled",
    Cdm_disabled = "cdm-disabled",
    Cdm_not_supported = "cdm-not-supported",
    Cdm_not_installed = "cdm-not-installed",
    Cdm_created = "cdm-created",
  }
  interface RequestMediaKeySystemAccessNotification {
    keySystem: string
    status: MediaKeySystemStatus
  }
  class MediaList {
    mediaText: string;
    readonly length: number;
    item(index: number): string | null;
    deleteMedium(oldMedium: string): void;
    appendMedium(newMedium: string): void;
    __stringifier(): string;
  }
  class MediaQueryList {
    readonly media: string;
    readonly matches: boolean;
    addListener(listener: EventListener | null): void;
    removeListener(listener: EventListener | null): void;
    onchange: EventHandlerNonNull | null;
  }
  class MediaQueryListEvent {
    readonly media: string;
    readonly matches: boolean;
    readonly isTrusted: boolean;
  }
  interface MediaQueryListEventInit {
    matches?: boolean
    media?: string
  }
  enum RecordingState {
    Inactive = "inactive",
    Recording = "recording",
    Paused = "paused",
  }
  class MediaRecorder {
    readonly stream: MediaStream;
    readonly mimeType: string;
    readonly state: RecordingState;
    onstart: EventHandlerNonNull | null;
    onstop: EventHandlerNonNull | null;
    ondataavailable: EventHandlerNonNull | null;
    onpause: EventHandlerNonNull | null;
    onresume: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    readonly videoBitsPerSecond: number;
    readonly audioBitsPerSecond: number;
    start(timeslice?: number): void;
    stop(): void;
    pause(): void;
    resume(): void;
    requestData(): void;
    isTypeSupported(type: string): boolean;
  }
  interface MediaRecorderOptions {
    audioBitsPerSecond?: number
    bitsPerSecond?: number
    mimeType?: string
    videoBitsPerSecond?: number
  }
  interface MediaRecorderErrorEventInit {
    error: DOMException
  }
  class MediaRecorderErrorEvent {
    readonly error: DOMException;
    readonly isTrusted: boolean;
  }
  enum MediaSessionAction {
    Play = "play",
    Pause = "pause",
    Previoustrack = "previoustrack",
    Nexttrack = "nexttrack",
    Stop = "stop",
  }
  function MediaSessionActionHandler(details: MediaSessionActionDetails): void;
  class MediaSession {
    metadata: MediaMetadata | null;
    setActionHandler(action: MediaSessionAction, handler: MediaSessionActionHandler | null): void;
    notifyHandler(details: MediaSessionActionDetails): void;
  }
  class MediaMetadata {
    title: string;
    artist: string;
    album: string;
    artwork: object[];
  }
  interface MediaMetadataInit {
    album?: string
    artist?: string
    artwork?: MediaImage[]
    title?: string
  }
  interface MediaImage {
    sizes?: string
    src: string
    type?: string
  }
  interface MediaSessionActionDetails {
    action: MediaSessionAction
  }
  enum MediaSourceReadyState {
    Closed = "closed",
    Open = "open",
    Ended = "ended",
  }
  enum MediaSourceEndOfStreamError {
    Network = "network",
    Decode = "decode",
  }
  class MediaSource {
    readonly sourceBuffers: SourceBufferList;
    readonly activeSourceBuffers: SourceBufferList;
    readonly readyState: MediaSourceReadyState;
    duration: number;
    onsourceopen: EventHandlerNonNull | null;
    onsourceended: EventHandlerNonNull | null;
    onsourceclosed: EventHandlerNonNull | null;
    addSourceBuffer(type: string): SourceBuffer;
    removeSourceBuffer(sourceBuffer: SourceBuffer): void;
    endOfStream(error?: MediaSourceEndOfStreamError): void;
    setLiveSeekableRange(start: number, end: number): void;
    clearLiveSeekableRange(): void;
    isTypeSupported(type: string): boolean;
    mozDebugReaderData(): Promise<MediaSourceDecoderDebugInfo>;
  }
  interface MediaStreamConstraints {
    audio?: boolean | MediaTrackConstraints
    fake?: boolean
    peerIdentity?: string | null
    picture?: boolean
    video?: boolean | MediaTrackConstraints
  }
  interface DisplayMediaStreamConstraints {
    audio?: boolean | MediaTrackConstraints
    video?: boolean | MediaTrackConstraints
  }
  class MediaStream {
    readonly id: string;
    getAudioTracks(): MediaStreamTrack[];
    getVideoTracks(): MediaStreamTrack[];
    getTracks(): MediaStreamTrack[];
    getTrackById(trackId: string): MediaStreamTrack | null;
    addTrack(track: MediaStreamTrack): void;
    removeTrack(track: MediaStreamTrack): void;
    clone(): MediaStream;
    readonly active: boolean;
    onaddtrack: EventHandlerNonNull | null;
    onremovetrack: EventHandlerNonNull | null;
    countUnderlyingStreams(): Promise<number>;
    assignId(id: string): void;
  }
  class MediaStreamAudioDestinationNode {
    readonly stream: MediaStream;
  }
  interface MediaStreamAudioSourceOptions {
    mediaStream: MediaStream
  }
  class MediaStreamAudioSourceNode {
    readonly mediaStream: MediaStream;
    passThrough: boolean;
  }
  class MediaStreamError {
    readonly name: string;
    readonly message: string | null;
    readonly constraint: string | null;
  }
  interface MediaStreamEventInit {
    stream?: MediaStream | null
  }
  class MediaStreamEvent {
    readonly stream: MediaStream | null;
    readonly isTrusted: boolean;
  }
  enum VideoFacingModeEnum {
    User = "user",
    Environment = "environment",
    Left = "left",
    Right = "right",
  }
  enum MediaSourceEnum {
    Camera = "camera",
    Screen = "screen",
    Application = "application",
    Window = "window",
    Browser = "browser",
    Microphone = "microphone",
    AudioCapture = "audioCapture",
    Other = "other",
  }
  interface ConstrainLongRange {
    exact?: number
    ideal?: number
    max?: number
    min?: number
  }
  interface ConstrainDoubleRange {
    exact?: number
    ideal?: number
    max?: number
    min?: number
  }
  interface ConstrainBooleanParameters {
    exact?: boolean
    ideal?: boolean
  }
  interface ConstrainDOMStringParameters {
    exact?: string | string[]
    ideal?: string | string[]
  }
  interface MediaTrackConstraintSet {
    autoGainControl?: boolean | ConstrainBooleanParameters
    browserWindow?: number
    channelCount?: number | ConstrainLongRange
    deviceId?: string | string[] | ConstrainDOMStringParameters
    echoCancellation?: boolean | ConstrainBooleanParameters
    facingMode?: string | string[] | ConstrainDOMStringParameters
    frameRate?: number | ConstrainDoubleRange
    groupId?: string | string[] | ConstrainDOMStringParameters
    height?: number | ConstrainLongRange
    mediaSource?: string
    noiseSuppression?: boolean | ConstrainBooleanParameters
    scrollWithPage?: boolean
    viewportHeight?: number | ConstrainLongRange
    viewportOffsetX?: number | ConstrainLongRange
    viewportOffsetY?: number | ConstrainLongRange
    viewportWidth?: number | ConstrainLongRange
    width?: number | ConstrainLongRange
  }
  interface MediaTrackConstraints {
    advanced?: MediaTrackConstraintSet[]
  }
  enum MediaStreamTrackState {
    Live = "live",
    Ended = "ended",
  }
  class MediaStreamTrack {
    readonly kind: string;
    readonly id: string;
    readonly label: string;
    enabled: boolean;
    readonly muted: boolean;
    onmute: EventHandlerNonNull | null;
    onunmute: EventHandlerNonNull | null;
    readonly readyState: MediaStreamTrackState;
    onended: EventHandlerNonNull | null;
    clone(): MediaStreamTrack;
    stop(): void;
    getConstraints(): MediaTrackConstraints;
    getSettings(): MediaTrackSettings;
    applyConstraints(constraints?: MediaTrackConstraints): Promise<void>;
  }
  interface MediaStreamTrackAudioSourceOptions {
    mediaStreamTrack: MediaStreamTrack
  }
  class MediaStreamTrackAudioSourceNode {
    passThrough: boolean;
  }
  interface MediaStreamTrackEventInit {
    track: MediaStreamTrack
  }
  class MediaStreamTrackEvent {
    readonly track: MediaStreamTrack;
    readonly isTrusted: boolean;
  }
  interface MediaTrackSettings {
    autoGainControl?: boolean
    browserWindow?: number
    channelCount?: number
    deviceId?: string
    echoCancellation?: boolean
    facingMode?: string
    frameRate?: number
    groupId?: string
    height?: number
    mediaSource?: string
    noiseSuppression?: boolean
    scrollWithPage?: boolean
    viewportHeight?: number
    viewportOffsetX?: number
    viewportOffsetY?: number
    viewportWidth?: number
    width?: number
  }
  interface MediaTrackSupportedConstraints {
    aspectRatio?: boolean
    autoGainControl?: boolean
    browserWindow?: boolean
    channelCount?: boolean
    deviceId?: boolean
    echoCancellation?: boolean
    facingMode?: boolean
    frameRate?: boolean
    groupId?: boolean
    height?: boolean
    latency?: boolean
    mediaSource?: boolean
    noiseSuppression?: boolean
    sampleRate?: boolean
    sampleSize?: boolean
    scrollWithPage?: boolean
    viewportHeight?: boolean
    viewportOffsetX?: boolean
    viewportOffsetY?: boolean
    viewportWidth?: boolean
    volume?: boolean
    width?: boolean
  }
  class MerchantValidationEvent {
    readonly methodName: string;
    readonly validationURL: string;
    complete(merchantSessionPromise: Promise<any>): void;
    readonly isTrusted: boolean;
  }
  interface MerchantValidationEventInit {
    methodName?: string
    validationURL?: string
  }
  class MessageChannel {
    readonly port1: MessagePort;
    readonly port2: MessagePort;
  }
  class MessageEvent {
    readonly data: any;
    readonly origin: string;
    readonly lastEventId: string;
    readonly source: WindowProxy | MessagePort | ServiceWorker | null;
    readonly ports: MessagePort[];
    initMessageEvent(type: string, bubbles?: boolean, cancelable?: boolean, data?: any, origin?: string, lastEventId?: string, source?: WindowProxy | MessagePort | ServiceWorker | null, ports?: MessagePort[]): void;
    readonly isTrusted: boolean;
  }
  interface MessageEventInit {
    data?: any
    lastEventId?: string
    origin?: string
    ports?: MessagePort[]
    source?: WindowProxy | MessagePort | ServiceWorker | null
  }
  class MessagePort {
    postMessage(message: any, transferable: object[]): void;
    postMessage(message: any, options?: PostMessageOptions): void;
    start(): void;
    close(): void;
    onmessage: EventHandlerNonNull | null;
    onmessageerror: EventHandlerNonNull | null;
  }
  interface PostMessageOptions {
    transfer?: object[]
  }
  class MimeType {
    readonly description: string;
    readonly enabledPlugin: Plugin | null;
    readonly suffixes: string;
    readonly type: string;
  }
  class MimeTypeArray {
    readonly length: number;
    item(index: number): MimeType | null;
    namedItem(name: string): MimeType | null;
  }
  class MouseEvent {
    readonly screenX: number;
    readonly screenY: number;
    readonly pageX: number;
    readonly pageY: number;
    readonly clientX: number;
    readonly clientY: number;
    readonly x: number;
    readonly y: number;
    readonly offsetX: number;
    readonly offsetY: number;
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly altKey: boolean;
    readonly metaKey: boolean;
    readonly button: number;
    readonly buttons: number;
    readonly relatedTarget: EventTarget | null;
    readonly region: string | null;
    readonly movementX: number;
    readonly movementY: number;
    initMouseEvent(typeArg: string, canBubbleArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, detailArg?: number, screenXArg?: number, screenYArg?: number, clientXArg?: number, clientYArg?: number, ctrlKeyArg?: boolean, altKeyArg?: boolean, shiftKeyArg?: boolean, metaKeyArg?: boolean, buttonArg?: number, relatedTargetArg?: EventTarget | null): void;
    getModifierState(keyArg: string): boolean;
    readonly mozPressure: number;
    readonly mozInputSource: number;
    initNSMouseEvent(typeArg: string, canBubbleArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, detailArg?: number, screenXArg?: number, screenYArg?: number, clientXArg?: number, clientYArg?: number, ctrlKeyArg?: boolean, altKeyArg?: boolean, shiftKeyArg?: boolean, metaKeyArg?: boolean, buttonArg?: number, relatedTargetArg?: EventTarget | null, pressure?: number, inputSourceArg?: number): void;
    readonly hitCluster: boolean;
    readonly isTrusted: boolean;
  }
  interface MouseEventInit {
    button?: number
    buttons?: number
    clientX?: number
    clientY?: number
    movementX?: number
    movementY?: number
    relatedTarget?: EventTarget | null
    screenX?: number
    screenY?: number
  }
  class MouseScrollEvent {
    readonly axis: number;
    initMouseScrollEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, detail?: number, screenX?: number, screenY?: number, clientX?: number, clientY?: number, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean, button?: number, relatedTarget?: EventTarget | null, axis?: number): void;
    readonly isTrusted: boolean;
  }
  interface RemotenessOptions {
    error?: number
    pendingSwitchID?: number
    remoteType: string | null
    replaceBrowsingContext?: boolean
  }
  class MutationEvent {
    readonly relatedNode: Node | null;
    readonly prevValue: string;
    readonly newValue: string;
    readonly attrName: string;
    readonly attrChange: number;
    initMutationEvent(type: string, canBubble?: boolean, cancelable?: boolean, relatedNode?: Node | null, prevValue?: string, newValue?: string, attrName?: string, attrChange?: number): void;
    readonly isTrusted: boolean;
  }
  class MutationRecord {
    readonly type: string;
    readonly target: Node | null;
    readonly addedNodes: NodeList;
    readonly removedNodes: NodeList;
    readonly previousSibling: Node | null;
    readonly nextSibling: Node | null;
    readonly attributeName: string | null;
    readonly attributeNamespace: string | null;
    readonly oldValue: string | null;
    readonly addedAnimations: Animation[];
    readonly changedAnimations: Animation[];
    readonly removedAnimations: Animation[];
  }
  class MutationObserver {
    observe(target: Node, options?: MutationObserverInit): void;
    disconnect(): void;
    takeRecords(): MutationRecord[];
    getObservingInfo(): MutationObservingInfo | null[];
    readonly mutationCallback: MutationCallback;
    mergeAttributeRecords: boolean;
  }
  function MutationCallback(mutations: MutationRecord[], observer: MutationObserver): void;
  interface MutationObserverInit {
    animations?: boolean
    attributeFilter?: string[]
    attributeOldValue?: boolean
    attributes?: boolean
    characterData?: boolean
    characterDataOldValue?: boolean
    childList?: boolean
    nativeAnonymousChildList?: boolean
    subtree?: boolean
  }
  interface MutationObservingInfo {
    observedNode?: Node | null
  }
  class NamedNodeMap {
    getNamedItem(name: string): Attr | null;
    setNamedItem(arg: Attr): Attr | null;
    removeNamedItem(name: string): Attr;
    item(index: number): Attr | null;
    readonly length: number;
    getNamedItemNS(namespaceURI: string | null, localName: string): Attr | null;
    setNamedItemNS(arg: Attr): Attr | null;
    removeNamedItemNS(namespaceURI: string | null, localName: string): Attr;
  }
  interface NativeOSFileReadOptions {
    bytes?: number | null
    encoding?: string | null
  }
  interface NativeOSFileWriteAtomicOptions {
    backupTo?: string | null
    bytes?: number | null
    flush?: boolean
    noOverwrite?: boolean
    tmpPath?: string | null
  }
  class Navigator {
    readonly permissions: Permissions;
    readonly mimeTypes: MimeTypeArray;
    readonly plugins: PluginArray;
    readonly doNotTrack: string;
    getBattery(): Promise<BatteryManager>;
    vibrate(duration: number): boolean;
    vibrate(pattern: number[]): boolean;
    readonly maxTouchPoints: number;
    readonly mediaCapabilities: MediaCapabilities;
    setVibrationPermission(permitted: boolean, persistent?: boolean): void;
    readonly oscpu: string;
    readonly vendor: string;
    readonly vendorSub: string;
    readonly productSub: string;
    readonly cookieEnabled: boolean;
    readonly buildID: string;
    javaEnabled(): boolean;
    readonly mozAddonManager: AddonManager;
    readonly connection: NetworkInformation;
    getGamepads(): Gamepad | null[];
    requestGamepadServiceTest(): GamepadServiceTest;
    getVRDisplays(): Promise<VRDisplay[]>;
    readonly activeVRDisplays: VRDisplay[];
    readonly isWebVRContentDetected: boolean;
    readonly isWebVRContentPresenting: boolean;
    requestVRPresentation(display: VRDisplay): void;
    requestVRServiceTest(): VRServiceTest;
    requestMIDIAccess(options?: MIDIOptions): Promise<MIDIAccess>;
    readonly mediaDevices: MediaDevices;
    mozGetUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;
    mozGetUserMediaDevices(constraints: MediaStreamConstraints, onsuccess: MozGetUserMediaDevicesSuccessCallback, onerror: NavigatorUserMediaErrorCallback, innerWindowID?: number, callID?: string): void;
    readonly serviceWorker: ServiceWorkerContainer;
    sendBeacon(url: string, data?: Blob | ArrayBufferView | ArrayBuffer | FormData | URLSearchParams | string | null): boolean;
    readonly presentation: Presentation | null;
    readonly mozTCPSocket: LegacyMozTCPSocket;
    requestMediaKeySystemAccess(keySystem: string, supportedConfigurations: MediaKeySystemConfiguration[]): Promise<MediaKeySystemAccess>;
    readonly credentials: CredentialsContainer;
    readonly clipboard: Clipboard;
    share(data?: ShareData): Promise<void>;
    readonly mediaSession: MediaSession;
    readonly gpu: GPU;
    readonly webdriver: boolean;
    readonly hardwareConcurrency: number;
    checkProtocolHandlerAllowed(scheme: string, handlerURI: URI, documentURI: URI): void;
    registerProtocolHandler(scheme: string, url: string, title: string): void;
    registerContentHandler(mimeType: string, url: string, title: string): void;
    readonly geolocation: Geolocation;
    readonly appCodeName: string;
    readonly appName: string;
    readonly appVersion: string;
    readonly platform: string;
    readonly userAgent: string;
    readonly product: string;
    taintEnabled(): boolean;
    readonly language: string | null;
    readonly languages: string[];
    readonly onLine: boolean;
    readonly storage: StorageManager;
  }
  function NavigatorUserMediaSuccessCallback(stream: MediaStream): void;
  function NavigatorUserMediaErrorCallback(error: MediaStreamError): void;
  function MozGetUserMediaDevicesSuccessCallback(devices: nsIVariant | null): void;
  interface ShareData {
    text?: string
    title?: string
    url?: string
  }
  interface SocketElement {
    active?: boolean
    host?: string
    port?: number
    received?: number
    sent?: number
    tcp?: boolean
  }
  interface SocketsDict {
    received?: number
    sent?: number
    sockets?: SocketElement[]
  }
  interface HttpConnInfo {
    protocolVersion?: string
    rtt?: number
    ttl?: number
  }
  interface HalfOpenInfoDict {
    speculative?: boolean
  }
  interface HttpConnectionElement {
    active?: HttpConnInfo[]
    halfOpens?: HalfOpenInfoDict[]
    host?: string
    httpVersion?: string
    idle?: HttpConnInfo[]
    port?: number
    ssl?: boolean
  }
  interface HttpConnDict {
    connections?: HttpConnectionElement[]
  }
  interface WebSocketElement {
    encrypted?: boolean
    hostport?: string
    msgreceived?: number
    msgsent?: number
    receivedsize?: number
    sentsize?: number
  }
  interface WebSocketDict {
    websockets?: WebSocketElement[]
  }
  interface DnsCacheEntry {
    expiration?: number
    family?: string
    hostaddr?: string[]
    hostname?: string
    trr?: boolean
  }
  interface DNSCacheDict {
    entries?: DnsCacheEntry[]
  }
  interface DNSLookupDict {
    address?: string[]
    answer?: boolean
    error?: string
  }
  interface ConnStatusDict {
    status?: string
  }
  interface RcwnPerfStats {
    avgLong?: number
    avgShort?: number
    stddevLong?: number
  }
  interface RcwnStatus {
    cacheNotSlowCount?: number
    cacheSlowCount?: number
    perfStats?: RcwnPerfStats[]
    rcwnCacheWonCount?: number
    rcwnNetWonCount?: number
    totalNetworkRequests?: number
  }
  interface NetErrorInfo {
    errorCodeString?: string
  }
  enum ConnectionType {
    Cellular = "cellular",
    Bluetooth = "bluetooth",
    Ethernet = "ethernet",
    Wifi = "wifi",
    Other = "other",
    None = "none",
    Unknown = "unknown",
  }
  class NetworkInformation {
    readonly type: ConnectionType;
    ontypechange: EventHandlerNonNull | null;
  }
  interface NetworkCommandOptions {
    cmd?: string
    curExternalIfname?: string
    curInternalIfname?: string
    dns1?: string
    dns1_long?: number
    dns2?: string
    dns2_long?: number
    dnses?: string[]
    domain?: string
    enable?: boolean
    enabled?: boolean
    endIp?: string
    externalIfname?: string
    gateway?: string
    gateway_long?: number
    gateways?: string[]
    id?: number
    ifname?: string
    interfaceList?: string[]
    internalIfname?: string
    ip?: string
    ipaddr?: number
    key?: string
    link?: string
    mask?: number
    maskLength?: string
    mode?: string
    mtu?: number
    preExternalIfname?: string
    preInternalIfname?: string
    prefix?: string
    prefixLength?: number
    report?: boolean
    security?: string
    serverIp?: string
    ssid?: string
    startIp?: string
    threshold?: number
    usbEndIp?: string
    usbStartIp?: string
    wifiEndIp?: string
    wifiStartIp?: string
    wifictrlinterfacename?: string
  }
  interface NetworkResultOptions {
    broadcast?: boolean
    curExternalIfname?: string
    curInternalIfname?: string
    dns1?: number
    dns1_str?: string
    dns2?: number
    dns2_str?: string
    enable?: boolean
    error?: boolean
    flag?: string
    gateway?: number
    gateway_str?: string
    id?: number
    interfaceList?: string[]
    ipAddr?: string
    ipaddr?: number
    ipaddr_str?: string
    lease?: number
    macAddr?: string
    mask?: number
    mask_str?: string
    netId?: string
    prefixLength?: number
    reason?: string
    reply?: string
    result?: boolean
    resultCode?: number
    resultReason?: string
    ret?: boolean
    route?: string
    server?: number
    server_str?: string
    success?: boolean
    topic?: string
    vendor_str?: string
  }
  class NodeFilter {
    acceptNode(node: Node): number;
  }
  class NodeIterator {
    readonly root: Node;
    readonly referenceNode: Node | null;
    readonly pointerBeforeReferenceNode: boolean;
    readonly whatToShow: number;
    readonly filter: NodeFilter | null;
    nextNode(): Node | null;
    previousNode(): Node | null;
    detach(): void;
  }
  class NodeList {
    item(index: number): Node | null;
    readonly length: number;
  }
  class Notification {
    static readonly permission: NotificationPermission;
    requestPermission(permissionCallback?: NotificationPermissionCallback): Promise<NotificationPermission>;
    get(filter?: GetNotificationOptions): Promise<Notification[]>;
    onclick: EventHandlerNonNull | null;
    onshow: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    readonly title: string;
    readonly dir: NotificationDirection;
    readonly lang: string | null;
    readonly body: string | null;
    readonly tag: string | null;
    readonly icon: string | null;
    readonly requireInteraction: boolean;
    readonly data: any;
    close(): void;
  }
  interface NotificationOptions {
    body?: string
    data?: any
    dir?: NotificationDirection
    icon?: string
    lang?: string
    mozbehavior?: NotificationBehavior
    requireInteraction?: boolean
    tag?: string
  }
  interface GetNotificationOptions {
    tag?: string
  }
  interface NotificationBehavior {
    noclear?: boolean
    noscreen?: boolean
    showOnlyOnce?: boolean
    soundFile?: string
    vibrationPattern?: number[]
  }
  enum NotificationPermission {
    Default = "default",
    Denied = "denied",
    Granted = "granted",
  }
  function NotificationPermissionCallback(permission: NotificationPermission): void;
  enum NotificationDirection {
    Auto = "auto",
    Ltr = "ltr",
    Rtl = "rtl",
  }
  class NotificationEvent {
    readonly notification: Notification;
    readonly isTrusted: boolean;
  }
  interface NotificationEventInit {
    notification: Notification
  }
  class NotifyPaintEvent {
    readonly clientRects: DOMRectList;
    readonly boundingClientRect: DOMRect;
    readonly paintRequests: PaintRequestList;
    readonly transactionId: number;
    readonly paintTimeStamp: number;
    readonly isTrusted: boolean;
  }
  interface OfflineAudioCompletionEventInit {
    renderedBuffer: AudioBuffer
  }
  class OfflineAudioCompletionEvent {
    readonly renderedBuffer: AudioBuffer;
    readonly isTrusted: boolean;
  }
  interface OfflineAudioContextOptions {
    length: number
    numberOfChannels?: number
    sampleRate: number
  }
  class OfflineAudioContext {
    startRendering(): Promise<AudioBuffer>;
    readonly length: number;
    oncomplete: EventHandlerNonNull | null;
  }
  class OfflineResourceList {
    readonly status: number;
    update(): void;
    swapCache(): void;
    onchecking: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onnoupdate: EventHandlerNonNull | null;
    ondownloading: EventHandlerNonNull | null;
    onprogress: EventHandlerNonNull | null;
    onupdateready: EventHandlerNonNull | null;
    oncached: EventHandlerNonNull | null;
    onobsolete: EventHandlerNonNull | null;
    readonly mozItems: DOMStringList;
    mozHasItem(uri: string): boolean;
    readonly mozLength: number;
    mozItem(index: number): string;
    readonly length: number;
    mozAdd(uri: string): void;
    mozRemove(uri: string): void;
  }
  class OffscreenCanvas {
    width: number;
    height: number;
    getContext(contextId: string, contextOptions?: any): nsISupports | null;
    transferToImageBitmap(): ImageBitmap;
    toBlob(type?: string, encoderOptions?: any): Promise<Blob>;
  }
  enum OscillatorType {
    Sine = "sine",
    Square = "square",
    Sawtooth = "sawtooth",
    Triangle = "triangle",
    Custom = "custom",
  }
  interface OscillatorOptions {
    detune?: number
    frequency?: number
    periodicWave?: PeriodicWave
    type?: OscillatorType
  }
  class OscillatorNode {
    type: OscillatorType;
    readonly frequency: AudioParam;
    readonly detune: AudioParam;
    setPeriodicWave(periodicWave: PeriodicWave): void;
    passThrough: boolean;
  }
  class PageTransitionEvent {
    readonly persisted: boolean;
    readonly inFrameSwap: boolean;
    readonly isTrusted: boolean;
  }
  interface PageTransitionEventInit {
    inFrameSwap?: boolean
    persisted?: boolean
  }
  class PaintRequest {
    readonly clientRect: DOMRect;
    readonly reason: string;
  }
  class PaintRequestList {
    readonly length: number;
    item(index: number): PaintRequest | null;
  }
  class PaintWorkletGlobalScope {
    registerPaint(name: string, paintCtor: VoidFunction): void;
  }
  enum PanningModelType {
    Equalpower = "equalpower",
    HRTF = "HRTF",
  }
  enum DistanceModelType {
    Linear = "linear",
    Inverse = "inverse",
    Exponential = "exponential",
  }
  interface PannerOptions {
    coneInnerAngle?: number
    coneOuterAngle?: number
    coneOuterGain?: number
    distanceModel?: DistanceModelType
    maxDistance?: number
    orientationX?: number
    orientationY?: number
    orientationZ?: number
    panningModel?: PanningModelType
    positionX?: number
    positionY?: number
    positionZ?: number
    refDistance?: number
    rolloffFactor?: number
  }
  class PannerNode {
    panningModel: PanningModelType;
    setPosition(x: number, y: number, z: number): void;
    setOrientation(x: number, y: number, z: number): void;
    readonly positionX: AudioParam;
    readonly positionY: AudioParam;
    readonly positionZ: AudioParam;
    readonly orientationX: AudioParam;
    readonly orientationY: AudioParam;
    readonly orientationZ: AudioParam;
    distanceModel: DistanceModelType;
    refDistance: number;
    maxDistance: number;
    rolloffFactor: number;
    coneInnerAngle: number;
    coneOuterAngle: number;
    coneOuterGain: number;
    passThrough: boolean;
  }
  class PaymentAddress {
    toJSON(): object;
    readonly country: string;
    readonly addressLine: string[];
    readonly region: string;
    readonly regionCode: string;
    readonly city: string;
    readonly dependentLocality: string;
    readonly postalCode: string;
    readonly sortingCode: string;
    readonly organization: string;
    readonly recipient: string;
    readonly phone: string;
  }
  class PaymentMethodChangeEvent {
    readonly methodName: string;
    readonly methodDetails: object | null;
    readonly isTrusted: boolean;
  }
  interface PaymentMethodChangeEventInit {
    methodDetails?: object | null
    methodName?: string
  }
  interface PaymentMethodData {
    data?: object
    supportedMethods: string
  }
  interface PaymentCurrencyAmount {
    currency: string
    value: string
  }
  interface PaymentItem {
    amount: PaymentCurrencyAmount
    label: string
    pending?: boolean
  }
  interface PaymentShippingOption {
    amount: PaymentCurrencyAmount
    id: string
    label: string
    selected?: boolean
  }
  interface PaymentDetailsModifier {
    additionalDisplayItems?: PaymentItem[]
    data?: object
    supportedMethods: string
    total?: PaymentItem
  }
  interface PaymentDetailsBase {
    displayItems?: PaymentItem[]
    modifiers?: PaymentDetailsModifier[]
    shippingOptions?: PaymentShippingOption[]
  }
  interface PaymentDetailsInit {
    id?: string
    total: PaymentItem
  }
  interface AddressErrors {
    addressLine?: string
    city?: string
    country?: string
    dependentLocality?: string
    organization?: string
    phone?: string
    postalCode?: string
    recipient?: string
    region?: string
    regionCode?: string
    sortingCode?: string
  }
  interface PaymentValidationErrors {
    error?: string
    payer?: PayerErrors
    paymentMethod?: object
    shippingAddress?: AddressErrors
  }
  interface PayerErrors {
    email?: string
    name?: string
    phone?: string
  }
  interface PaymentDetailsUpdate {
    error?: string
    payerErrors?: PayerErrors
    paymentMethodErrors?: object
    shippingAddressErrors?: AddressErrors
    total?: PaymentItem
  }
  enum PaymentShippingType {
    Shipping = "shipping",
    Delivery = "delivery",
    Pickup = "pickup",
  }
  interface PaymentOptions {
    requestBillingAddress?: boolean
    requestPayerEmail?: boolean
    requestPayerName?: boolean
    requestPayerPhone?: boolean
    requestShipping?: boolean
    shippingType?: PaymentShippingType
  }
  class PaymentRequest {
    show(detailsPromise?: Promise<PaymentDetailsUpdate>): Promise<PaymentResponse>;
    abort(): Promise<void>;
    canMakePayment(): Promise<boolean>;
    readonly id: string;
    readonly shippingAddress: PaymentAddress | null;
    readonly shippingOption: string | null;
    readonly shippingType: PaymentShippingType | null;
    onmerchantvalidation: EventHandlerNonNull | null;
    onshippingaddresschange: EventHandlerNonNull | null;
    onshippingoptionchange: EventHandlerNonNull | null;
    onpaymentmethodchange: EventHandlerNonNull | null;
  }
  class PaymentRequestUpdateEvent {
    updateWith(detailsPromise: Promise<PaymentDetailsUpdate>): void;
    readonly isTrusted: boolean;
  }
  interface PaymentRequestUpdateEventInit {
  }
  enum PaymentComplete {
    Success = "success",
    Fail = "fail",
    Unknown = "unknown",
  }
  class PaymentResponse {
    toJSON(): object;
    readonly requestId: string;
    readonly methodName: string;
    readonly details: object;
    readonly shippingAddress: PaymentAddress | null;
    readonly shippingOption: string | null;
    readonly payerName: string | null;
    readonly payerEmail: string | null;
    readonly payerPhone: string | null;
    complete(result?: PaymentComplete): Promise<void>;
    retry(errorFields?: PaymentValidationErrors): Promise<void>;
    onpayerdetailchange: EventHandlerNonNull | null;
  }
  class PeerConnectionImpl {
    initialize(observer: PeerConnectionObserver, window: Window, iceServers: RTCConfiguration, thread: nsISupports): void;
    createOffer(options?: RTCOfferOptions): void;
    createAnswer(): void;
    setLocalDescription(action: number, sdp: string): void;
    setRemoteDescription(action: number, sdp: string): void;
    getStats(selector: MediaStreamTrack | null): Promise<RTCStatsReport>;
    createTransceiverImpl(kind: string, track: MediaStreamTrack | null): TransceiverImpl;
    checkNegotiationNeeded(): boolean;
    insertDTMF(transceiver: TransceiverImpl, tones: string, duration?: number, interToneGap?: number): void;
    getDTMFToneBuffer(sender: RTCRtpSender): string;
    getRtpSources(track: MediaStreamTrack, rtpSourceNow: number): RTCRtpSourceEntry[];
    getNowInRtpSourceReferenceTime(): number;
    replaceTrackNoRenegotiation(transceiverImpl: TransceiverImpl, withTrack: MediaStreamTrack | null): void;
    closeStreams(): void;
    addRIDExtension(recvTrack: MediaStreamTrack, extensionId: number): void;
    addRIDFilter(recvTrack: MediaStreamTrack, rid: string): void;
    insertAudioLevelForContributingSource(recvTrack: MediaStreamTrack, source: number, timestamp: number, rtpTimestamp: number, hasLevel: boolean, level: number): void;
    enablePacketDump(level: number, type: mozPacketDumpType, sending: boolean): void;
    disablePacketDump(level: number, type: mozPacketDumpType, sending: boolean): void;
    addIceCandidate(candidate: string, mid: string, ufrag: string, level: number | null): void;
    close(): void;
    pluginCrash(pluginId: number, name: string): boolean;
    certificate: RTCCertificate;
    readonly fingerprint: string;
    readonly currentLocalDescription: string;
    readonly pendingLocalDescription: string;
    readonly currentRemoteDescription: string;
    readonly pendingRemoteDescription: string;
    readonly iceConnectionState: RTCIceConnectionState;
    readonly iceGatheringState: RTCIceGatheringState;
    readonly signalingState: RTCSignalingState;
    id: string;
    peerIdentity: string;
    readonly privacyRequested: boolean;
    createDataChannel(label: string, protocol: string, type: number, ordered: boolean, maxTime: number, maxNum: number, externalNegotiated: boolean, stream: number): RTCDataChannel;
  }
  interface PCErrorData {
    message: string
    name: PCError
  }
  class PeerConnectionObserver {
    onCreateOfferSuccess(offer: string): void;
    onCreateOfferError(error: PCErrorData): void;
    onCreateAnswerSuccess(answer: string): void;
    onCreateAnswerError(error: PCErrorData): void;
    onSetLocalDescriptionSuccess(): void;
    onSetRemoteDescriptionSuccess(): void;
    onSetLocalDescriptionError(error: PCErrorData): void;
    onSetRemoteDescriptionError(error: PCErrorData): void;
    onAddIceCandidateSuccess(): void;
    onAddIceCandidateError(error: PCErrorData): void;
    onIceCandidate(level: number, mid: string, candidate: string, ufrag: string): void;
    notifyDataChannel(channel: RTCDataChannel): void;
    onStateChange(state: PCObserverStateType): void;
    onTransceiverNeeded(kind: string, transceiverImpl: TransceiverImpl): void;
    onDTMFToneChange(track: MediaStreamTrack, tone: string): void;
    onPacket(level: number, type: mozPacketDumpType, sending: boolean, packet: ArrayBuffer): void;
    syncTransceivers(): void;
  }
  enum PCObserverStateType {
    None = "None",
    IceConnectionState = "IceConnectionState",
    IceGatheringState = "IceGatheringState",
    SignalingState = "SignalingState",
  }
  enum PCError {
    UnknownError = "UnknownError",
    InvalidAccessError = "InvalidAccessError",
    InvalidStateError = "InvalidStateError",
    InvalidModificationError = "InvalidModificationError",
    OperationError = "OperationError",
    NotSupportedError = "NotSupportedError",
    SyntaxError = "SyntaxError",
    NotReadableError = "NotReadableError",
    TypeError = "TypeError",
    RangeError = "RangeError",
    InvalidCharacterError = "InvalidCharacterError",
  }
  class Performance {
    now(): number;
    readonly timeOrigin: number;
    toJSON(): object;
    readonly timing: PerformanceTiming;
    readonly navigation: PerformanceNavigation;
    getEntries(): PerformanceEntry[];
    getEntriesByType(entryType: string): PerformanceEntry[];
    getEntriesByName(name: string, entryType?: string): PerformanceEntry[];
    clearResourceTimings(): void;
    setResourceTimingBufferSize(maxSize: number): void;
    onresourcetimingbufferfull: EventHandlerNonNull | null;
    readonly mozMemory: object;
    mark(markName: string): void;
    clearMarks(markName?: string): void;
    measure(measureName: string, startMark?: string, endMark?: string): void;
    clearMeasures(measureName?: string): void;
  }
  class PerformanceEntry {
    readonly name: string;
    readonly entryType: string;
    readonly startTime: number;
    readonly duration: number;
    toJSON(): object;
  }
  interface PerformanceEntryEventInit {
    duration?: number
    entryType?: string
    epoch?: number
    name?: string
    origin?: string
    startTime?: number
  }
  class PerformanceEntryEvent {
    readonly name: string;
    readonly entryType: string;
    readonly startTime: number;
    readonly duration: number;
    readonly epoch: number;
    readonly origin: string;
    readonly isTrusted: boolean;
  }
  class PerformanceMark {
  }
  class PerformanceMeasure {
  }
  class PerformanceNavigation {
    readonly type: number;
    readonly redirectCount: number;
    toJSON(): object;
  }
  enum NavigationType {
    Navigate = "navigate",
    Reload = "reload",
    Back_forward = "back_forward",
    Prerender = "prerender",
  }
  class PerformanceNavigationTiming {
    readonly unloadEventStart: number;
    readonly unloadEventEnd: number;
    readonly domInteractive: number;
    readonly domContentLoadedEventStart: number;
    readonly domContentLoadedEventEnd: number;
    readonly domComplete: number;
    readonly loadEventStart: number;
    readonly loadEventEnd: number;
    readonly type: NavigationType;
    readonly redirectCount: number;
    toJSON(): object;
  }
  interface PerformanceObserverInit {
    buffered?: boolean
    entryTypes?: string[]
    type?: string
  }
  function PerformanceObserverCallback(entries: PerformanceObserverEntryList, observer: PerformanceObserver): void;
  class PerformanceObserver {
    observe(options?: PerformanceObserverInit): void;
    disconnect(): void;
    takeRecords(): PerformanceEntry[];
    static readonly supportedEntryTypes: object;
  }
  interface PerformanceEntryFilterOptions {
    entryType?: string
    initiatorType?: string
    name?: string
  }
  class PerformanceObserverEntryList {
    getEntries(filter?: PerformanceEntryFilterOptions): PerformanceEntry[];
    getEntriesByType(entryType: string): PerformanceEntry[];
    getEntriesByName(name: string, entryType?: string): PerformanceEntry[];
  }
  class PerformanceResourceTiming {
    readonly initiatorType: string;
    readonly nextHopProtocol: string;
    readonly workerStart: number;
    readonly redirectStart: number;
    readonly redirectEnd: number;
    readonly fetchStart: number;
    readonly domainLookupStart: number;
    readonly domainLookupEnd: number;
    readonly connectStart: number;
    readonly connectEnd: number;
    readonly secureConnectionStart: number;
    readonly requestStart: number;
    readonly responseStart: number;
    readonly responseEnd: number;
    readonly transferSize: number;
    readonly encodedBodySize: number;
    readonly decodedBodySize: number;
    readonly serverTiming: PerformanceServerTiming[];
    toJSON(): object;
  }
  class PerformanceServerTiming {
    readonly name: string;
    readonly duration: number;
    readonly description: string;
    toJSON(): object;
  }
  class PerformanceTiming {
    readonly navigationStart: number;
    readonly unloadEventStart: number;
    readonly unloadEventEnd: number;
    readonly redirectStart: number;
    readonly redirectEnd: number;
    readonly fetchStart: number;
    readonly domainLookupStart: number;
    readonly domainLookupEnd: number;
    readonly connectStart: number;
    readonly connectEnd: number;
    readonly secureConnectionStart: number;
    readonly requestStart: number;
    readonly responseStart: number;
    readonly responseEnd: number;
    readonly domLoading: number;
    readonly domInteractive: number;
    readonly domContentLoadedEventStart: number;
    readonly domContentLoadedEventEnd: number;
    readonly domComplete: number;
    readonly loadEventStart: number;
    readonly loadEventEnd: number;
    readonly timeToNonBlankPaint: number;
    readonly timeToContentfulPaint: number;
    readonly timeToDOMContentFlushed: number;
    readonly timeToFirstInteractive: number;
    toJSON(): object;
  }
  interface PeriodicWaveConstraints {
    disableNormalization?: boolean
  }
  interface PeriodicWaveOptions {
    imag?: number[]
    real?: number[]
  }
  class PeriodicWave {
  }
  enum PermissionState {
    Granted = "granted",
    Denied = "denied",
    Prompt = "prompt",
  }
  class PermissionStatus {
    readonly state: PermissionState;
    onchange: EventHandlerNonNull | null;
  }
  enum PermissionName {
    Geolocation = "geolocation",
    Notifications = "notifications",
    Push = "push",
    Persistent_storage = "persistent-storage",
  }
  interface PermissionDescriptor {
    name: PermissionName
  }
  class Permissions {
    query(permission: object): Promise<PermissionStatus>;
    revoke(permission: object): Promise<PermissionStatus>;
  }
  class Plugin {
    readonly description: string;
    readonly filename: string;
    readonly version: string;
    readonly name: string;
    readonly length: number;
    item(index: number): MimeType | null;
    namedItem(name: string): MimeType | null;
  }
  class PluginArray {
    readonly length: number;
    item(index: number): Plugin | null;
    namedItem(name: string): Plugin | null;
    refresh(reloadDocuments?: boolean): void;
  }
  class PluginCrashedEvent {
    readonly pluginID: number;
    readonly pluginDumpID: string;
    readonly pluginName: string;
    readonly pluginFilename: string | null;
    readonly submittedCrashReport: boolean;
    readonly gmpPlugin: boolean;
    readonly isTrusted: boolean;
  }
  interface PluginCrashedEventInit {
    gmpPlugin?: boolean
    pluginDumpID?: string
    pluginFilename?: string | null
    pluginID?: number
    pluginName?: string
    submittedCrashReport?: boolean
  }
  class PointerEvent {
    readonly pointerId: number;
    readonly width: number;
    readonly height: number;
    readonly pressure: number;
    readonly tangentialPressure: number;
    readonly tiltX: number;
    readonly tiltY: number;
    readonly twist: number;
    readonly pointerType: string;
    readonly isPrimary: boolean;
    getCoalescedEvents(): PointerEvent[];
    readonly isTrusted: boolean;
  }
  interface PointerEventInit {
    coalescedEvents?: PointerEvent[]
    height?: number
    isPrimary?: boolean
    pointerId?: number
    pointerType?: string
    pressure?: number
    tangentialPressure?: number
    tiltX?: number
    tiltY?: number
    twist?: number
    width?: number
  }
  class PopStateEvent {
    readonly state: any;
    readonly isTrusted: boolean;
  }
  interface PopStateEventInit {
    state?: any
  }
  class PopupBlockedEvent {
    readonly requestingWindow: Window | null;
    readonly popupWindowURI: URI | null;
    readonly popupWindowName: string | null;
    readonly popupWindowFeatures: string | null;
    readonly isTrusted: boolean;
  }
  interface PopupBlockedEventInit {
    popupWindowFeatures?: string
    popupWindowName?: string
    popupWindowURI?: URI | null
    requestingWindow?: Window | null
  }
  class Presentation {
    defaultRequest: PresentationRequest | null;
    readonly receiver: PresentationReceiver | null;
  }
  class PresentationAvailability {
    readonly value: boolean;
    onchange: EventHandlerNonNull | null;
  }
  enum PresentationConnectionState {
    Connecting = "connecting",
    Connected = "connected",
    Closed = "closed",
    Terminated = "terminated",
  }
  enum PresentationConnectionBinaryType {
    Blob = "blob",
    Arraybuffer = "arraybuffer",
  }
  class PresentationConnection {
    readonly id: string;
    readonly url: string;
    readonly state: PresentationConnectionState;
    onconnect: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    onterminate: EventHandlerNonNull | null;
    binaryType: PresentationConnectionBinaryType;
    send(data: string): void;
    send(data: Blob): void;
    send(data: ArrayBuffer): void;
    send(data: ArrayBufferView): void;
    onmessage: EventHandlerNonNull | null;
    close(): void;
    terminate(): void;
  }
  class PresentationConnectionAvailableEvent {
    readonly connection: PresentationConnection;
    readonly isTrusted: boolean;
  }
  interface PresentationConnectionAvailableEventInit {
    connection: PresentationConnection
  }
  enum PresentationConnectionClosedReason {
    Error = "error",
    Closed = "closed",
    Wentaway = "wentaway",
  }
  class PresentationConnectionCloseEvent {
    readonly reason: PresentationConnectionClosedReason;
    readonly message: string;
    readonly isTrusted: boolean;
  }
  interface PresentationConnectionCloseEventInit {
    message?: string
    reason: PresentationConnectionClosedReason
  }
  class PresentationConnectionList {
    readonly connections: PresentationConnection[];
    onconnectionavailable: EventHandlerNonNull | null;
  }
  class PresentationReceiver {
    readonly connectionList: Promise<PresentationConnectionList>;
  }
  class PresentationRequest {
    start(): Promise<PresentationConnection>;
    reconnect(presentationId: string): Promise<PresentationConnection>;
    getAvailability(): Promise<PresentationAvailability>;
    onconnectionavailable: EventHandlerNonNull | null;
    startWithDevice(deviceId: string): Promise<PresentationConnection>;
  }
  class ProcessingInstruction {
    readonly target: string;
    readonly sheet: StyleSheet | null;
  }
  interface ProfileTimelineStackFrame {
    asyncCause?: string
    asyncParent?: object | null
    column?: number
    functionDisplayName?: string
    line?: number
    parent?: object | null
    source?: string
  }
  interface ProfileTimelineLayerRect {
    height?: number
    width?: number
    x?: number
    y?: number
  }
  enum ProfileTimelineMessagePortOperationType {
    SerializeData = "serializeData",
    DeserializeData = "deserializeData",
  }
  enum ProfileTimelineWorkerOperationType {
    SerializeDataOffMainThread = "serializeDataOffMainThread",
    SerializeDataOnMainThread = "serializeDataOnMainThread",
    DeserializeDataOffMainThread = "deserializeDataOffMainThread",
    DeserializeDataOnMainThread = "deserializeDataOnMainThread",
  }
  interface ProfileTimelineMarker {
    causeName?: string
    end?: number
    endStack?: object | null
    eventPhase?: number
    isAnimationOnly?: boolean
    isOffMainThread?: boolean
    messagePortOperation?: ProfileTimelineMessagePortOperationType
    name?: string
    processType?: number
    rectangles?: ProfileTimelineLayerRect[]
    stack?: object | null
    start?: number
    type?: string
    unixTime?: number
    workerOperation?: ProfileTimelineWorkerOperationType
  }
  class ProgressEvent {
    readonly lengthComputable: boolean;
    readonly loaded: number;
    readonly total: number;
    readonly isTrusted: boolean;
  }
  interface ProgressEventInit {
    lengthComputable?: boolean
    loaded?: number
    total?: number
  }
  function PromiseJobCallback(): void;
  function AnyCallback(value: any): any;
  class PromiseNativeHandler {
  }
  class PromiseRejectionEvent {
    readonly promise: Promise<any>;
    readonly reason: any;
    readonly isTrusted: boolean;
  }
  interface PromiseRejectionEventInit {
    promise: Promise<any>
    reason?: any
  }
  class PushEvent {
    readonly data: PushMessageData | null;
    readonly isTrusted: boolean;
  }
  interface PushEventInit {
    data?: ArrayBufferView | ArrayBuffer | string
  }
  interface PushSubscriptionOptionsInit {
    applicationServerKey?: ArrayBufferView | ArrayBuffer | string | null
  }
  class PushManagerImpl {
    subscribe(options?: PushSubscriptionOptionsInit): Promise<PushSubscription>;
    getSubscription(): Promise<PushSubscription | null>;
    permissionState(options?: PushSubscriptionOptionsInit): Promise<PushPermissionState>;
  }
  class PushManager {
    subscribe(options?: PushSubscriptionOptionsInit): Promise<PushSubscription>;
    getSubscription(): Promise<PushSubscription | null>;
    permissionState(options?: PushSubscriptionOptionsInit): Promise<PushPermissionState>;
  }
  enum PushPermissionState {
    Granted = "granted",
    Denied = "denied",
    Prompt = "prompt",
  }
  class PushMessageData {
    arrayBuffer(): ArrayBuffer;
    blob(): Blob;
    json(): any;
    text(): string;
  }
  enum PushEncryptionKeyName {
    P___dh = "p256dh",
    Auth = "auth",
  }
  interface PushSubscriptionKeys {
    auth?: string
    p256dh?: string
  }
  interface PushSubscriptionJSON {
    endpoint?: string
    keys?: PushSubscriptionKeys
  }
  interface PushSubscriptionInit {
    appServerKey?: ArrayBufferView | ArrayBuffer | null
    authSecret?: ArrayBuffer | null
    endpoint: string
    p256dhKey?: ArrayBuffer | null
    scope: string
  }
  class PushSubscription {
    readonly endpoint: string;
    readonly options: PushSubscriptionOptions;
    getKey(name: PushEncryptionKeyName): ArrayBuffer | null;
    unsubscribe(): Promise<boolean>;
    toJSON(): PushSubscriptionJSON;
  }
  class PushSubscriptionOptions {
    readonly applicationServerKey: ArrayBuffer | null;
  }
  interface RTCCertificateExpiration {
    expires?: number
  }
  class RTCCertificate {
    readonly expires: number;
  }
  enum RTCIceCredentialType {
    Password = "password",
  }
  interface RTCIceServer {
    credential?: string
    credentialType?: RTCIceCredentialType
    url?: string
    urls?: string | string[]
    username?: string
  }
  enum RTCIceTransportPolicy {
    Relay = "relay",
    All = "all",
  }
  enum RTCBundlePolicy {
    Balanced = "balanced",
    Max_compat = "max-compat",
    Max_bundle = "max-bundle",
  }
  interface RTCConfiguration {
    bundlePolicy?: RTCBundlePolicy
    certificates?: RTCCertificate[]
    iceServers?: RTCIceServer[]
    iceTransportPolicy?: RTCIceTransportPolicy
    peerIdentity?: string | null
  }
  class RTCDTMFSender {
    insertDTMF(tones: string, duration?: number, interToneGap?: number): void;
    ontonechange: EventHandlerNonNull | null;
    readonly toneBuffer: string;
  }
  class RTCDTMFToneChangeEvent {
    readonly tone: string;
    readonly isTrusted: boolean;
  }
  interface RTCDTMFToneChangeEventInit {
    tone?: string
  }
  enum RTCDataChannelState {
    Connecting = "connecting",
    Open = "open",
    Closing = "closing",
    Closed = "closed",
  }
  enum RTCDataChannelType {
    Arraybuffer = "arraybuffer",
    Blob = "blob",
  }
  class RTCDataChannel {
    readonly label: string;
    readonly negotiated: boolean;
    readonly ordered: boolean;
    readonly reliable: boolean;
    readonly maxPacketLifeTime: number | null;
    readonly maxRetransmits: number | null;
    readonly protocol: string;
    readonly id: number | null;
    readonly readyState: RTCDataChannelState;
    readonly bufferedAmount: number;
    bufferedAmountLowThreshold: number;
    onopen: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    close(): void;
    onmessage: EventHandlerNonNull | null;
    onbufferedamountlow: EventHandlerNonNull | null;
    binaryType: RTCDataChannelType;
    send(data: string): void;
    send(data: Blob): void;
    send(data: ArrayBuffer): void;
    send(data: ArrayBufferView): void;
  }
  interface RTCDataChannelEventInit {
    channel: RTCDataChannel
  }
  class RTCDataChannelEvent {
    readonly channel: RTCDataChannel;
    readonly isTrusted: boolean;
  }
  interface RTCIceCandidateInit {
    candidate?: string
    sdpMLineIndex?: number | null
    sdpMid?: string | null
    usernameFragment?: string | null
  }
  class RTCIceCandidate {
    candidate: string;
    sdpMid: string | null;
    sdpMLineIndex: number | null;
    usernameFragment: string | null;
    toJSON(): object;
  }
  interface RTCIdentityAssertion {
    idp?: string
    name?: string
  }
  class RTCIdentityProviderRegistrar {
    register(idp: RTCIdentityProvider): void;
    readonly hasIdp: boolean;
    generateAssertion(contents: string, origin: string, options?: RTCIdentityProviderOptions): Promise<RTCIdentityAssertionResult>;
    validateAssertion(assertion: string, origin: string): Promise<RTCIdentityValidationResult>;
  }
  interface RTCIdentityProvider {
    generateAssertion: GenerateAssertionCallback
    validateAssertion: ValidateAssertionCallback
  }
  function GenerateAssertionCallback(contents: string, origin: string, options: RTCIdentityProviderOptions): Promise<RTCIdentityAssertionResult>;
  function ValidateAssertionCallback(assertion: string, origin: string): Promise<RTCIdentityValidationResult>;
  interface RTCIdentityAssertionResult {
    assertion: string
    idp: RTCIdentityProviderDetails
  }
  interface RTCIdentityProviderDetails {
    domain: string
    protocol?: string
  }
  interface RTCIdentityValidationResult {
    contents: string
    identity: string
  }
  interface RTCIdentityProviderOptions {
    peerIdentity?: string
    protocol?: string
    usernameHint?: string
  }
  function RTCSessionDescriptionCallback(description: RTCSessionDescriptionInit): void;
  function RTCPeerConnectionErrorCallback(error: DOMException): void;
  function RTCStatsCallback(report: RTCStatsReport): void;
  enum RTCSignalingState {
    Stable = "stable",
    Have_local_offer = "have-local-offer",
    Have_remote_offer = "have-remote-offer",
    Have_local_pranswer = "have-local-pranswer",
    Have_remote_pranswer = "have-remote-pranswer",
    Closed = "closed",
  }
  enum RTCIceGatheringState {
    New = "new",
    Gathering = "gathering",
    Complete = "complete",
  }
  enum RTCIceConnectionState {
    New = "new",
    Checking = "checking",
    Connected = "connected",
    Completed = "completed",
    Failed = "failed",
    Disconnected = "disconnected",
    Closed = "closed",
  }
  enum mozPacketDumpType {
    Rtp = "rtp",
    Srtp = "srtp",
    Rtcp = "rtcp",
    Srtcp = "srtcp",
  }
  function mozPacketCallback(level: number, type: mozPacketDumpType, sending: boolean, packet: ArrayBuffer): void;
  interface RTCDataChannelInit {
    id?: number
    maxPacketLifeTime?: number
    maxRetransmitTime?: number
    maxRetransmits?: number
    negotiated?: boolean
    ordered?: boolean
    protocol?: string
  }
  interface RTCOfferAnswerOptions {
  }
  interface RTCAnswerOptions {
  }
  interface RTCOfferOptions {
    iceRestart?: boolean
    offerToReceiveAudio?: boolean
    offerToReceiveVideo?: boolean
  }
  class RTCPeerConnection {
    generateCertificate(keygenAlgorithm: object | string): Promise<RTCCertificate>;
    setIdentityProvider(provider: string, options?: RTCIdentityProviderOptions): void;
    getIdentityAssertion(): Promise<string>;
    createOffer(options?: RTCOfferOptions): Promise<RTCSessionDescriptionInit>;
    createOffer(successCallback: RTCSessionDescriptionCallback, failureCallback: RTCPeerConnectionErrorCallback, options?: RTCOfferOptions): Promise<void>;
    createAnswer(options?: RTCAnswerOptions): Promise<RTCSessionDescriptionInit>;
    createAnswer(successCallback: RTCSessionDescriptionCallback, failureCallback: RTCPeerConnectionErrorCallback): Promise<void>;
    setLocalDescription(description: RTCSessionDescriptionInit): Promise<void>;
    setLocalDescription(description: RTCSessionDescriptionInit, successCallback: VoidFunction, failureCallback: RTCPeerConnectionErrorCallback): Promise<void>;
    setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void>;
    setRemoteDescription(description: RTCSessionDescriptionInit, successCallback: VoidFunction, failureCallback: RTCPeerConnectionErrorCallback): Promise<void>;
    readonly localDescription: RTCSessionDescription | null;
    readonly currentLocalDescription: RTCSessionDescription | null;
    readonly pendingLocalDescription: RTCSessionDescription | null;
    readonly remoteDescription: RTCSessionDescription | null;
    readonly currentRemoteDescription: RTCSessionDescription | null;
    readonly pendingRemoteDescription: RTCSessionDescription | null;
    readonly signalingState: RTCSignalingState;
    addIceCandidate(candidate?: RTCIceCandidateInit | RTCIceCandidate): Promise<void>;
    addIceCandidate(candidate: RTCIceCandidate, successCallback: VoidFunction, failureCallback: RTCPeerConnectionErrorCallback): Promise<void>;
    readonly canTrickleIceCandidates: boolean | null;
    readonly iceGatheringState: RTCIceGatheringState;
    readonly iceConnectionState: RTCIceConnectionState;
    restartIce(): void;
    readonly peerIdentity: Promise<RTCIdentityAssertion>;
    readonly idpLoginUrl: string | null;
    id: string;
    getConfiguration(): RTCConfiguration;
    getLocalStreams(): MediaStream[];
    getRemoteStreams(): MediaStream[];
    addStream(stream: MediaStream): void;
    addTrack(track: MediaStreamTrack, streams?: MediaStream): RTCRtpSender;
    removeTrack(sender: RTCRtpSender): void;
    addTransceiver(trackOrKind: MediaStreamTrack | string, init?: RTCRtpTransceiverInit): RTCRtpTransceiver;
    getSenders(): RTCRtpSender[];
    getReceivers(): RTCRtpReceiver[];
    getTransceivers(): RTCRtpTransceiver[];
    mozGetNowInRtpSourceReferenceTime(): number;
    mozInsertAudioLevelForContributingSource(receiver: RTCRtpReceiver, source: number, timestamp: number, rtpTimestamp: number, hasLevel: boolean, level: number): void;
    mozAddRIDExtension(receiver: RTCRtpReceiver, extensionId: number): void;
    mozAddRIDFilter(receiver: RTCRtpReceiver, rid: string): void;
    mozSetPacketCallback(callback: mozPacketCallback): void;
    mozEnablePacketDump(level: number, type: mozPacketDumpType, sending: boolean): void;
    mozDisablePacketDump(level: number, type: mozPacketDumpType, sending: boolean): void;
    close(): void;
    onnegotiationneeded: EventHandlerNonNull | null;
    onicecandidate: EventHandlerNonNull | null;
    onsignalingstatechange: EventHandlerNonNull | null;
    onaddstream: EventHandlerNonNull | null;
    onaddtrack: EventHandlerNonNull | null;
    ontrack: EventHandlerNonNull | null;
    oniceconnectionstatechange: EventHandlerNonNull | null;
    onicegatheringstatechange: EventHandlerNonNull | null;
    getStats(selector?: MediaStreamTrack | null): Promise<RTCStatsReport>;
    createDataChannel(label: string, dataChannelDict?: RTCDataChannelInit): RTCDataChannel;
    ondatachannel: EventHandlerNonNull | null;
  }
  interface RTCPeerConnectionIceEventInit {
    candidate?: RTCIceCandidate | null
  }
  class RTCPeerConnectionIceEvent {
    readonly candidate: RTCIceCandidate | null;
    readonly isTrusted: boolean;
  }
  enum RTCLifecycleEvent {
    Initialized = "initialized",
    Icegatheringstatechange = "icegatheringstatechange",
    Iceconnectionstatechange = "iceconnectionstatechange",
  }
  function PeerConnectionLifecycleCallback(pc: RTCPeerConnection, windowId: number, eventType: RTCLifecycleEvent): void;
  class RTCPeerConnectionStatic {
    registerPeerConnectionLifecycleCallback(cb: PeerConnectionLifecycleCallback): void;
  }
  class RTCRtpReceiver {
    readonly track: MediaStreamTrack;
    getStats(): Promise<RTCStatsReport>;
    getContributingSources(): RTCRtpContributingSource[];
    getSynchronizationSources(): RTCRtpSynchronizationSource[];
    setStreamIds(streamIds: string[]): void;
    setRecvBit(recvBit: boolean): void;
    processTrackAdditionsAndRemovals(transceiver: RTCRtpTransceiver, postProcessing: object): void;
  }
  enum RTCPriorityType {
    Very_low = "very-low",
    Low = "low",
    Medium = "medium",
    High = "high",
  }
  enum RTCDegradationPreference {
    Maintain_framerate = "maintain-framerate",
    Maintain_resolution = "maintain-resolution",
    Balanced = "balanced",
  }
  interface RTCRtxParameters {
    ssrc?: number
  }
  interface RTCFecParameters {
    ssrc?: number
  }
  interface RTCRtpEncodingParameters {
    active?: boolean
    degradationPreference?: RTCDegradationPreference
    fec?: RTCFecParameters
    maxBitrate?: number
    priority?: RTCPriorityType
    rid?: string
    rtx?: RTCRtxParameters
    scaleResolutionDownBy?: number
    ssrc?: number
  }
  interface RTCRtpHeaderExtensionParameters {
    encrypted?: boolean
    id?: number
    uri?: string
  }
  interface RTCRtcpParameters {
    cname?: string
    reducedSize?: boolean
  }
  interface RTCRtpCodecParameters {
    channels?: number
    clockRate?: number
    mimeType?: string
    payloadType?: number
    sdpFmtpLine?: string
  }
  interface RTCRtpParameters {
    codecs?: RTCRtpCodecParameters[]
    encodings?: RTCRtpEncodingParameters[]
    headerExtensions?: RTCRtpHeaderExtensionParameters[]
    rtcp?: RTCRtcpParameters
  }
  class RTCRtpSender {
    readonly track: MediaStreamTrack | null;
    setParameters(parameters?: RTCRtpParameters): Promise<void>;
    getParameters(): RTCRtpParameters;
    replaceTrack(withTrack: MediaStreamTrack | null): Promise<void>;
    getStats(): Promise<RTCStatsReport>;
    readonly dtmf: RTCDTMFSender | null;
    getStreams(): MediaStream[];
    setStreams(streams: MediaStream[]): void;
    setTrack(track: MediaStreamTrack | null): void;
    checkWasCreatedByPc(pc: RTCPeerConnection): void;
  }
  interface RTCRtpContributingSource {
    audioLevel?: number
    rtpTimestamp: number
    source: number
    timestamp: number
  }
  interface RTCRtpSynchronizationSource {
    voiceActivityFlag?: boolean | null
  }
  enum RTCRtpSourceEntryType {
    Contributing = "contributing",
    Synchronization = "synchronization",
  }
  interface RTCRtpSourceEntry {
    sourceType: RTCRtpSourceEntryType
  }
  enum RTCRtpTransceiverDirection {
    Sendrecv = "sendrecv",
    Sendonly = "sendonly",
    Recvonly = "recvonly",
    Inactive = "inactive",
  }
  interface RTCRtpTransceiverInit {
    direction?: RTCRtpTransceiverDirection
    streams?: MediaStream[]
  }
  class RTCRtpTransceiver {
    readonly mid: string | null;
    readonly sender: RTCRtpSender;
    readonly receiver: RTCRtpReceiver;
    readonly stopped: boolean;
    direction: RTCRtpTransceiverDirection;
    readonly currentDirection: RTCRtpTransceiverDirection | null;
    stop(): void;
    setAddTrackMagic(): void;
    readonly addTrackMagic: boolean;
    shouldRemove: boolean;
    setCurrentDirection(direction: RTCRtpTransceiverDirection): void;
    setDirectionInternal(direction: RTCRtpTransceiverDirection): void;
    setMid(mid: string): void;
    unsetMid(): void;
    setStopped(): void;
    getKind(): string;
    hasBeenUsedToSend(): boolean;
    sync(): void;
    insertDTMF(tones: string, duration?: number, interToneGap?: number): void;
  }
  enum RTCSdpType {
    Offer = "offer",
    Pranswer = "pranswer",
    Answer = "answer",
    Rollback = "rollback",
  }
  interface RTCSessionDescriptionInit {
    sdp?: string
    type: RTCSdpType
  }
  class RTCSessionDescription {
    type: RTCSdpType;
    sdp: string;
    toJSON(): object;
  }
  enum RTCStatsType {
    Inbound_rtp = "inbound-rtp",
    Outbound_rtp = "outbound-rtp",
    Remote_inbound_rtp = "remote-inbound-rtp",
    Remote_outbound_rtp = "remote-outbound-rtp",
    Csrc = "csrc",
    Session = "session",
    Track = "track",
    Transport = "transport",
    Candidate_pair = "candidate-pair",
    Local_candidate = "local-candidate",
    Remote_candidate = "remote-candidate",
  }
  interface RTCStats {
    id?: string
    timestamp?: number
    type?: RTCStatsType
  }
  interface RTCRtpStreamStats {
    kind?: string
    mediaType?: string
    ssrc?: number
    transportId?: string
  }
  interface RTCReceivedRtpStreamStats {
    discardedPackets?: number
    jitter?: number
    packetsDiscarded?: number
    packetsLost?: number
    packetsReceived?: number
  }
  interface RTCInboundRtpStreamStats {
    bitrateMean?: number
    bitrateStdDev?: number
    bytesReceived?: number
    firCount?: number
    framerateMean?: number
    framerateStdDev?: number
    framesDecoded?: number
    nackCount?: number
    pliCount?: number
    remoteId?: string
  }
  interface RTCRemoteInboundRtpStreamStats {
    bytesReceived?: number
    localId?: string
    roundTripTime?: number
  }
  interface RTCSentRtpStreamStats {
    bytesSent?: number
    packetsSent?: number
  }
  interface RTCOutboundRtpStreamStats {
    bitrateMean?: number
    bitrateStdDev?: number
    droppedFrames?: number
    firCount?: number
    framerateMean?: number
    framerateStdDev?: number
    framesEncoded?: number
    nackCount?: number
    pliCount?: number
    qpSum?: number
    remoteId?: string
  }
  interface RTCRemoteOutboundRtpStreamStats {
    localId?: string
  }
  interface RTCRTPContributingSourceStats {
    contributorSsrc?: number
    inboundRtpStreamId?: string
  }
  enum RTCStatsIceCandidatePairState {
    Frozen = "frozen",
    Waiting = "waiting",
    Inprogress = "inprogress",
    Failed = "failed",
    Succeeded = "succeeded",
    Cancelled = "cancelled",
  }
  interface RTCIceCandidatePairStats {
    bytesReceived?: number
    bytesSent?: number
    componentId?: number
    lastPacketReceivedTimestamp?: number
    lastPacketSentTimestamp?: number
    localCandidateId?: string
    nominated?: boolean
    priority?: number
    readable?: boolean
    remoteCandidateId?: string
    selected?: boolean
    state?: RTCStatsIceCandidatePairState
    transportId?: string
    writable?: boolean
  }
  enum RTCIceCandidateType {
    Host = "host",
    Srflx = "srflx",
    Prflx = "prflx",
    Relay = "relay",
  }
  interface RTCIceCandidateStats {
    address?: string
    candidateType?: RTCIceCandidateType
    port?: number
    priority?: number
    protocol?: string
    proxied?: string
    relayProtocol?: string
    transportId?: string
  }
  interface RTCStatsCollection {
    iceCandidatePairStats?: RTCIceCandidatePairStats[]
    iceCandidateStats?: RTCIceCandidateStats[]
    inboundRtpStreamStats?: RTCInboundRtpStreamStats[]
    outboundRtpStreamStats?: RTCOutboundRtpStreamStats[]
    rawLocalCandidates?: string[]
    rawRemoteCandidates?: string[]
    remoteInboundRtpStreamStats?: RTCRemoteInboundRtpStreamStats[]
    remoteOutboundRtpStreamStats?: RTCRemoteOutboundRtpStreamStats[]
    rtpContributingSourceStats?: RTCRTPContributingSourceStats[]
    trickledIceCandidateStats?: RTCIceCandidateStats[]
  }
  interface RTCStatsReportInternal {
    callDurationMs?: number
    closed: boolean
    iceRestarts: number
    iceRollbacks: number
    localSdp?: string
    offerer?: boolean
    pcid: string
    remoteSdp?: string
    timestamp: number
  }
  class RTCStatsReport {
    readonly size: number;
    entries(): object;
    keys(): object;
    values(): object;
    forEach(callback: object, thisArg?: any): void;
    has(key: string): boolean;
    get(key: string): any;
  }
  interface RTCTrackEventInit {
    receiver: RTCRtpReceiver
    streams?: MediaStream[]
    track: MediaStreamTrack
    transceiver: RTCRtpTransceiver
  }
  class RTCTrackEvent {
    readonly receiver: RTCRtpReceiver;
    readonly track: MediaStreamTrack;
    readonly streams: MediaStream[];
    readonly transceiver: RTCRtpTransceiver;
    readonly isTrusted: boolean;
  }
  class RadioNodeList {
    value: string;
  }
  class Range {
    readonly commonAncestorContainer: Node;
    setStart(refNode: Node, offset: number): void;
    setEnd(refNode: Node, offset: number): void;
    setStartBefore(refNode: Node): void;
    setStartAfter(refNode: Node): void;
    setEndBefore(refNode: Node): void;
    setEndAfter(refNode: Node): void;
    collapse(toStart?: boolean): void;
    selectNode(refNode: Node): void;
    selectNodeContents(refNode: Node): void;
    compareBoundaryPoints(how: number, sourceRange: Range): number;
    deleteContents(): void;
    extractContents(): DocumentFragment;
    cloneContents(): DocumentFragment;
    insertNode(node: Node): void;
    surroundContents(newParent: Node): void;
    cloneRange(): Range;
    detach(): void;
    isPointInRange(node: Node, offset: number): boolean;
    comparePoint(node: Node, offset: number): number;
    intersectsNode(node: Node): boolean;
    __stringifier(): string;
    createContextualFragment(fragment: string): DocumentFragment;
    getClientRects(): DOMRectList | null;
    getBoundingClientRect(): DOMRect;
    getClientRectsAndTexts(): ClientRectsAndTexts;
  }
  interface ClientRectsAndTexts {
    rectList: DOMRectList
    textList: string[]
  }
  enum ReferrerPolicy {
    _empty = "",
    No_referrer = "no-referrer",
    No_referrer_when_downgrade = "no-referrer-when-downgrade",
    Origin = "origin",
    Origin_when_cross_origin = "origin-when-cross-origin",
    Unsafe_url = "unsafe-url",
    Same_origin = "same-origin",
    Strict_origin = "strict-origin",
    Strict_origin_when_cross_origin = "strict-origin-when-cross-origin",
  }
  class ReportBody {
  }
  class Report {
    readonly type: string;
    readonly url: string;
    readonly body: ReportBody | null;
  }
  class ReportingObserver {
    observe(): void;
    disconnect(): void;
    takeRecords(): Report[];
  }
  function ReportingObserverCallback(reports: Report[], observer: ReportingObserver): void;
  interface ReportingObserverOptions {
    buffered?: boolean
    types?: string[]
  }
  class DeprecationReportBody {
    readonly id: string;
    readonly anticipatedRemoval: Date | null;
    readonly message: string;
    readonly sourceFile: string | null;
    readonly lineNumber: number | null;
    readonly columnNumber: number | null;
  }
  class TestingDeprecatedInterface {
    deprecatedMethod(): void;
    readonly deprecatedAttribute: boolean;
  }
  interface ReportingHeaderValue {
    items?: ReportingItem[]
  }
  interface ReportingItem {
    endpoints?: any
    group?: any
    include_subdomains?: boolean
    max_age?: any
  }
  interface ReportingEndpoint {
    priority?: any
    url?: any
    weight?: any
  }
  class Request {
    readonly method: string;
    readonly url: string;
    readonly headers: Headers;
    readonly destination: RequestDestination;
    readonly referrer: string;
    readonly referrerPolicy: ReferrerPolicy;
    readonly mode: RequestMode;
    readonly credentials: RequestCredentials;
    readonly cache: RequestCache;
    readonly redirect: RequestRedirect;
    readonly integrity: string;
    readonly mozErrors: boolean;
    readonly signal: AbortSignal;
    clone(): Request;
    overrideContentPolicyType(context: number): void;
    readonly bodyUsed: boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
    formData(): Promise<FormData>;
    json(): Promise<object>;
    text(): Promise<string>;
  }
  interface RequestInit {
    body?: Blob | ArrayBufferView | ArrayBuffer | FormData | URLSearchParams | string | null
    cache?: RequestCache
    credentials?: RequestCredentials
    headers?: Headers | string[][] | Record<string, string>
    integrity?: string
    method?: string
    mode?: RequestMode
    mozErrors?: boolean
    observe?: ObserverCallback
    redirect?: RequestRedirect
    referrer?: string
    referrerPolicy?: ReferrerPolicy
    signal?: AbortSignal | null
  }
  enum RequestDestination {
    _empty = "",
    Audio = "audio",
    Audioworklet = "audioworklet",
    Document = "document",
    Embed = "embed",
    Font = "font",
    Image = "image",
    Manifest = "manifest",
    Object = "object",
    Paintworklet = "paintworklet",
    Report = "report",
    Script = "script",
    Sharedworker = "sharedworker",
    Style = "style",
    Track = "track",
    Video = "video",
    Worker = "worker",
    Xslt = "xslt",
  }
  enum RequestMode {
    Same_origin = "same-origin",
    No_cors = "no-cors",
    Cors = "cors",
    Navigate = "navigate",
  }
  enum RequestCredentials {
    Omit = "omit",
    Same_origin = "same-origin",
    Include = "include",
  }
  enum RequestCache {
    Default = "default",
    No_store = "no-store",
    Reload = "reload",
    No_cache = "no-cache",
    Force_cache = "force-cache",
    Only_if_cached = "only-if-cached",
  }
  enum RequestRedirect {
    Follow = "follow",
    Error = "error",
    Manual = "manual",
  }
  enum ResizeObserverBoxOptions {
    Border_box = "border-box",
    Content_box = "content-box",
  }
  interface ResizeObserverOptions {
    box?: ResizeObserverBoxOptions
  }
  class ResizeObserver {
    observe(target: Element, options?: ResizeObserverOptions): void;
    unobserve(target: Element): void;
    disconnect(): void;
  }
  function ResizeObserverCallback(entries: ResizeObserverEntry[], observer: ResizeObserver): void;
  class ResizeObserverEntry {
    readonly target: Element;
    readonly contentRect: DOMRectReadOnly;
    readonly borderBoxSize: ResizeObserverSize;
    readonly contentBoxSize: ResizeObserverSize;
  }
  class ResizeObserverSize {
    readonly inlineSize: number;
    readonly blockSize: number;
  }
  class Response {
    error(): Response;
    redirect(url: string, status?: number): Response;
    readonly type: ResponseType;
    readonly url: string;
    readonly redirected: boolean;
    readonly status: number;
    readonly ok: boolean;
    readonly statusText: string;
    readonly headers: Headers;
    clone(): Response;
    cloneUnfiltered(): Response;
    readonly hasCacheInfoChannel: boolean;
    readonly body: ReadableStream | null;
    readonly bodyUsed: boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
    formData(): Promise<FormData>;
    json(): Promise<object>;
    text(): Promise<string>;
  }
  interface ResponseInit {
    headers?: Headers | string[][] | Record<string, string>
    status?: number
    statusText?: string
  }
  enum ResponseType {
    Basic = "basic",
    Cors = "cors",
    Default = "default",
    Error = "error",
    Opaque = "opaque",
    Opaqueredirect = "opaqueredirect",
  }
  class SVGAElement {
    readonly target: SVGAnimatedString;
    download: string;
    ping: string;
    rel: string;
    referrerPolicy: string;
    readonly relList: DOMTokenList;
    hreflang: string;
    type: string;
    text: string;
    readonly href: SVGAnimatedString;
  }
  class SVGAngle {
    readonly unitType: number;
    value: number;
    valueInSpecifiedUnits: number;
    valueAsString: string;
    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;
    convertToSpecifiedUnits(unitType: number): void;
  }
  class SVGAnimateElement {
  }
  class SVGAnimateMotionElement {
  }
  class SVGAnimateTransformElement {
  }
  class SVGAnimatedAngle {
    readonly baseVal: SVGAngle;
    readonly animVal: SVGAngle;
  }
  class SVGAnimatedBoolean {
    baseVal: boolean;
    readonly animVal: boolean;
  }
  class SVGAnimatedEnumeration {
    baseVal: number;
    readonly animVal: number;
  }
  class SVGAnimatedInteger {
    baseVal: number;
    readonly animVal: number;
  }
  class SVGAnimatedLength {
    readonly baseVal: SVGLength;
    readonly animVal: SVGLength;
  }
  class SVGAnimatedLengthList {
    readonly baseVal: SVGLengthList;
    readonly animVal: SVGLengthList;
  }
  class SVGAnimatedNumber {
    baseVal: number;
    readonly animVal: number;
  }
  class SVGAnimatedNumberList {
    readonly baseVal: SVGNumberList;
    readonly animVal: SVGNumberList;
  }
  class SVGAnimatedPreserveAspectRatio {
    readonly baseVal: SVGPreserveAspectRatio;
    readonly animVal: SVGPreserveAspectRatio;
  }
  class SVGAnimatedRect {
    readonly baseVal: SVGRect | null;
    readonly animVal: SVGRect | null;
  }
  class SVGAnimatedString {
    baseVal: string;
    readonly animVal: string;
  }
  class SVGAnimatedTransformList {
    readonly baseVal: SVGTransformList;
    readonly animVal: SVGTransformList;
  }
  class SVGAnimationElement {
    readonly targetElement: SVGElement | null;
    getStartTime(): number;
    getCurrentTime(): number;
    getSimpleDuration(): number;
    beginElement(): void;
    beginElementAt(offset: number): void;
    endElement(): void;
    endElementAt(offset: number): void;
    readonly requiredExtensions: SVGStringList;
    readonly systemLanguage: SVGStringList;
  }
  class SVGCircleElement {
    readonly cx: SVGAnimatedLength;
    readonly cy: SVGAnimatedLength;
    readonly r: SVGAnimatedLength;
  }
  class SVGClipPathElement {
    readonly clipPathUnits: SVGAnimatedEnumeration;
    readonly transform: SVGAnimatedTransformList;
  }
  class SVGComponentTransferFunctionElement {
    readonly type: SVGAnimatedEnumeration;
    readonly tableValues: SVGAnimatedNumberList;
    readonly slope: SVGAnimatedNumber;
    readonly intercept: SVGAnimatedNumber;
    readonly amplitude: SVGAnimatedNumber;
    readonly exponent: SVGAnimatedNumber;
    readonly offset: SVGAnimatedNumber;
  }
  class SVGDefsElement {
  }
  class SVGDescElement {
  }
  class SVGElement {
    id: string;
    readonly className: SVGAnimatedString;
    readonly ownerSVGElement: SVGSVGElement | null;
    readonly viewportElement: SVGElement | null;
    oncopy: EventHandlerNonNull | null;
    oncut: EventHandlerNonNull | null;
    onpaste: EventHandlerNonNull | null;
    readonly style: CSSStyleDeclaration;
    onabort: EventHandlerNonNull | null;
    onblur: EventHandlerNonNull | null;
    onfocus: EventHandlerNonNull | null;
    onauxclick: EventHandlerNonNull | null;
    oncanplay: EventHandlerNonNull | null;
    oncanplaythrough: EventHandlerNonNull | null;
    onchange: EventHandlerNonNull | null;
    onclick: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    oncontextmenu: EventHandlerNonNull | null;
    oncuechange: EventHandlerNonNull | null;
    ondblclick: EventHandlerNonNull | null;
    ondrag: EventHandlerNonNull | null;
    ondragend: EventHandlerNonNull | null;
    ondragenter: EventHandlerNonNull | null;
    ondragexit: EventHandlerNonNull | null;
    ondragleave: EventHandlerNonNull | null;
    ondragover: EventHandlerNonNull | null;
    ondragstart: EventHandlerNonNull | null;
    ondrop: EventHandlerNonNull | null;
    ondurationchange: EventHandlerNonNull | null;
    onemptied: EventHandlerNonNull | null;
    onended: EventHandlerNonNull | null;
    onformdata: EventHandlerNonNull | null;
    oninput: EventHandlerNonNull | null;
    oninvalid: EventHandlerNonNull | null;
    onkeydown: EventHandlerNonNull | null;
    onkeypress: EventHandlerNonNull | null;
    onkeyup: EventHandlerNonNull | null;
    onload: EventHandlerNonNull | null;
    onloadeddata: EventHandlerNonNull | null;
    onloadedmetadata: EventHandlerNonNull | null;
    onloadend: EventHandlerNonNull | null;
    onloadstart: EventHandlerNonNull | null;
    onmousedown: EventHandlerNonNull | null;
    onmouseenter: EventHandlerNonNull | null;
    onmouseleave: EventHandlerNonNull | null;
    onmousemove: EventHandlerNonNull | null;
    onmouseout: EventHandlerNonNull | null;
    onmouseover: EventHandlerNonNull | null;
    onmouseup: EventHandlerNonNull | null;
    onwheel: EventHandlerNonNull | null;
    onpause: EventHandlerNonNull | null;
    onplay: EventHandlerNonNull | null;
    onplaying: EventHandlerNonNull | null;
    onprogress: EventHandlerNonNull | null;
    onratechange: EventHandlerNonNull | null;
    onreset: EventHandlerNonNull | null;
    onresize: EventHandlerNonNull | null;
    onscroll: EventHandlerNonNull | null;
    onseeked: EventHandlerNonNull | null;
    onseeking: EventHandlerNonNull | null;
    onselect: EventHandlerNonNull | null;
    onshow: EventHandlerNonNull | null;
    onstalled: EventHandlerNonNull | null;
    onsubmit: EventHandlerNonNull | null;
    onsuspend: EventHandlerNonNull | null;
    ontimeupdate: EventHandlerNonNull | null;
    onvolumechange: EventHandlerNonNull | null;
    onwaiting: EventHandlerNonNull | null;
    onselectstart: EventHandlerNonNull | null;
    ontoggle: EventHandlerNonNull | null;
    onpointercancel: EventHandlerNonNull | null;
    onpointerdown: EventHandlerNonNull | null;
    onpointerup: EventHandlerNonNull | null;
    onpointermove: EventHandlerNonNull | null;
    onpointerout: EventHandlerNonNull | null;
    onpointerover: EventHandlerNonNull | null;
    onpointerenter: EventHandlerNonNull | null;
    onpointerleave: EventHandlerNonNull | null;
    ongotpointercapture: EventHandlerNonNull | null;
    onlostpointercapture: EventHandlerNonNull | null;
    onmozfullscreenchange: EventHandlerNonNull | null;
    onmozfullscreenerror: EventHandlerNonNull | null;
    onanimationcancel: EventHandlerNonNull | null;
    onanimationend: EventHandlerNonNull | null;
    onanimationiteration: EventHandlerNonNull | null;
    onanimationstart: EventHandlerNonNull | null;
    ontransitioncancel: EventHandlerNonNull | null;
    ontransitionend: EventHandlerNonNull | null;
    ontransitionrun: EventHandlerNonNull | null;
    ontransitionstart: EventHandlerNonNull | null;
    onwebkitanimationend: EventHandlerNonNull | null;
    onwebkitanimationiteration: EventHandlerNonNull | null;
    onwebkitanimationstart: EventHandlerNonNull | null;
    onwebkittransitionend: EventHandlerNonNull | null;
    readonly dataset: DOMStringMap;
    tabIndex: number;
    focus(options?: FocusOptions): void;
    blur(): void;
    onerror: EventHandlerNonNull | null;
    ontouchstart: EventHandlerNonNull | null;
    ontouchend: EventHandlerNonNull | null;
    ontouchmove: EventHandlerNonNull | null;
    ontouchcancel: EventHandlerNonNull | null;
  }
  class SVGEllipseElement {
    readonly cx: SVGAnimatedLength;
    readonly cy: SVGAnimatedLength;
    readonly rx: SVGAnimatedLength;
    readonly ry: SVGAnimatedLength;
  }
  class SVGFEBlendElement {
    readonly in1: SVGAnimatedString;
    readonly in2: SVGAnimatedString;
    readonly mode: SVGAnimatedEnumeration;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEColorMatrixElement {
    readonly in1: SVGAnimatedString;
    readonly type: SVGAnimatedEnumeration;
    readonly values: SVGAnimatedNumberList;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEComponentTransferElement {
    readonly in1: SVGAnimatedString;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFECompositeElement {
    readonly in1: SVGAnimatedString;
    readonly in2: SVGAnimatedString;
    readonly operator: SVGAnimatedEnumeration;
    readonly k1: SVGAnimatedNumber;
    readonly k2: SVGAnimatedNumber;
    readonly k3: SVGAnimatedNumber;
    readonly k4: SVGAnimatedNumber;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEConvolveMatrixElement {
    readonly in1: SVGAnimatedString;
    readonly orderX: SVGAnimatedInteger;
    readonly orderY: SVGAnimatedInteger;
    readonly kernelMatrix: SVGAnimatedNumberList;
    readonly divisor: SVGAnimatedNumber;
    readonly bias: SVGAnimatedNumber;
    readonly targetX: SVGAnimatedInteger;
    readonly targetY: SVGAnimatedInteger;
    readonly edgeMode: SVGAnimatedEnumeration;
    readonly kernelUnitLengthX: SVGAnimatedNumber;
    readonly kernelUnitLengthY: SVGAnimatedNumber;
    readonly preserveAlpha: SVGAnimatedBoolean;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEDiffuseLightingElement {
    readonly in1: SVGAnimatedString;
    readonly surfaceScale: SVGAnimatedNumber;
    readonly diffuseConstant: SVGAnimatedNumber;
    readonly kernelUnitLengthX: SVGAnimatedNumber;
    readonly kernelUnitLengthY: SVGAnimatedNumber;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEDisplacementMapElement {
    readonly in1: SVGAnimatedString;
    readonly in2: SVGAnimatedString;
    readonly scale: SVGAnimatedNumber;
    readonly xChannelSelector: SVGAnimatedEnumeration;
    readonly yChannelSelector: SVGAnimatedEnumeration;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEDistantLightElement {
    readonly azimuth: SVGAnimatedNumber;
    readonly elevation: SVGAnimatedNumber;
  }
  class SVGFEDropShadowElement {
    readonly in1: SVGAnimatedString;
    readonly dx: SVGAnimatedNumber;
    readonly dy: SVGAnimatedNumber;
    readonly stdDeviationX: SVGAnimatedNumber;
    readonly stdDeviationY: SVGAnimatedNumber;
    setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEFloodElement {
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEFuncAElement {
  }
  class SVGFEFuncBElement {
  }
  class SVGFEFuncGElement {
  }
  class SVGFEFuncRElement {
  }
  class SVGFEGaussianBlurElement {
    readonly in1: SVGAnimatedString;
    readonly stdDeviationX: SVGAnimatedNumber;
    readonly stdDeviationY: SVGAnimatedNumber;
    setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEImageElement {
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
    readonly href: SVGAnimatedString;
  }
  class SVGFEMergeElement {
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEMergeNodeElement {
    readonly in1: SVGAnimatedString;
  }
  class SVGFEMorphologyElement {
    readonly in1: SVGAnimatedString;
    readonly operator: SVGAnimatedEnumeration;
    readonly radiusX: SVGAnimatedNumber;
    readonly radiusY: SVGAnimatedNumber;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEOffsetElement {
    readonly in1: SVGAnimatedString;
    readonly dx: SVGAnimatedNumber;
    readonly dy: SVGAnimatedNumber;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFEPointLightElement {
    readonly x: SVGAnimatedNumber;
    readonly y: SVGAnimatedNumber;
    readonly z: SVGAnimatedNumber;
  }
  class SVGFESpecularLightingElement {
    readonly in1: SVGAnimatedString;
    readonly surfaceScale: SVGAnimatedNumber;
    readonly specularConstant: SVGAnimatedNumber;
    readonly specularExponent: SVGAnimatedNumber;
    readonly kernelUnitLengthX: SVGAnimatedNumber;
    readonly kernelUnitLengthY: SVGAnimatedNumber;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFESpotLightElement {
    readonly x: SVGAnimatedNumber;
    readonly y: SVGAnimatedNumber;
    readonly z: SVGAnimatedNumber;
    readonly pointsAtX: SVGAnimatedNumber;
    readonly pointsAtY: SVGAnimatedNumber;
    readonly pointsAtZ: SVGAnimatedNumber;
    readonly specularExponent: SVGAnimatedNumber;
    readonly limitingConeAngle: SVGAnimatedNumber;
  }
  class SVGFETileElement {
    readonly in1: SVGAnimatedString;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFETurbulenceElement {
    readonly baseFrequencyX: SVGAnimatedNumber;
    readonly baseFrequencyY: SVGAnimatedNumber;
    readonly numOctaves: SVGAnimatedInteger;
    readonly seed: SVGAnimatedNumber;
    readonly stitchTiles: SVGAnimatedEnumeration;
    readonly type: SVGAnimatedEnumeration;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly result: SVGAnimatedString;
  }
  class SVGFilterElement {
    readonly filterUnits: SVGAnimatedEnumeration;
    readonly primitiveUnits: SVGAnimatedEnumeration;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly href: SVGAnimatedString;
  }
  class SVGForeignObjectElement {
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
  }
  class SVGGElement {
  }
  class SVGGeometryElement {
    readonly pathLength: SVGAnimatedNumber;
    isPointInFill(point?: DOMPointInit): boolean;
    isPointInStroke(point?: DOMPointInit): boolean;
    getTotalLength(): number;
    getPointAtLength(distance: number): SVGPoint;
  }
  class SVGGradientElement {
    readonly gradientUnits: SVGAnimatedEnumeration;
    readonly gradientTransform: SVGAnimatedTransformList;
    readonly spreadMethod: SVGAnimatedEnumeration;
    readonly href: SVGAnimatedString;
  }
  interface SVGBoundingBoxOptions {
    clipped?: boolean
    fill?: boolean
    markers?: boolean
    stroke?: boolean
  }
  class SVGGraphicsElement {
    readonly transform: SVGAnimatedTransformList;
    readonly nearestViewportElement: SVGElement | null;
    readonly farthestViewportElement: SVGElement | null;
    getBBox(aOptions?: SVGBoundingBoxOptions): SVGRect;
    getCTM(): SVGMatrix | null;
    getScreenCTM(): SVGMatrix | null;
    getTransformToElement(element: SVGGraphicsElement): SVGMatrix;
    readonly requiredExtensions: SVGStringList;
    readonly systemLanguage: SVGStringList;
  }
  class SVGImageElement {
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
    decoding: string;
    decode(): Promise<void>;
    loadingEnabled: boolean;
    readonly imageBlockingStatus: number;
    addObserver(aObserver: imgINotificationObserver): void;
    removeObserver(aObserver: imgINotificationObserver): void;
    getRequest(aRequestType: number): imgIRequest | null;
    getRequestType(aRequest: imgIRequest): number;
    readonly currentURI: URI | null;
    readonly currentRequestFinalURI: URI | null;
    forceReload(aNotify?: boolean): void;
    forceImageState(aForce: boolean, aState: number): void;
    readonly href: SVGAnimatedString;
  }
  class SVGLength {
    readonly unitType: number;
    value: number;
    valueInSpecifiedUnits: number;
    valueAsString: string;
    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;
    convertToSpecifiedUnits(unitType: number): void;
  }
  class SVGLengthList {
    readonly numberOfItems: number;
    clear(): void;
    initialize(newItem: SVGLength): SVGLength;
    getItem(index: number): SVGLength;
    insertItemBefore(newItem: SVGLength, index: number): SVGLength;
    replaceItem(newItem: SVGLength, index: number): SVGLength;
    removeItem(index: number): SVGLength;
    appendItem(newItem: SVGLength): SVGLength;
    readonly length: number;
  }
  class SVGLineElement {
    readonly x1: SVGAnimatedLength;
    readonly y1: SVGAnimatedLength;
    readonly x2: SVGAnimatedLength;
    readonly y2: SVGAnimatedLength;
  }
  class SVGLinearGradientElement {
    readonly x1: SVGAnimatedLength;
    readonly y1: SVGAnimatedLength;
    readonly x2: SVGAnimatedLength;
    readonly y2: SVGAnimatedLength;
  }
  class SVGMPathElement {
    readonly href: SVGAnimatedString;
  }
  class SVGMarkerElement {
    readonly refX: SVGAnimatedLength;
    readonly refY: SVGAnimatedLength;
    readonly markerUnits: SVGAnimatedEnumeration;
    readonly markerWidth: SVGAnimatedLength;
    readonly markerHeight: SVGAnimatedLength;
    readonly orientType: SVGAnimatedEnumeration;
    readonly orientAngle: SVGAnimatedAngle;
    setOrientToAuto(): void;
    setOrientToAngle(angle: SVGAngle): void;
    readonly viewBox: SVGAnimatedRect;
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
  }
  class SVGMaskElement {
    readonly maskUnits: SVGAnimatedEnumeration;
    readonly maskContentUnits: SVGAnimatedEnumeration;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
  }
  class SVGMatrix {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    multiply(secondMatrix: SVGMatrix): SVGMatrix;
    inverse(): SVGMatrix;
    translate(x: number, y: number): SVGMatrix;
    scale(scaleFactor: number): SVGMatrix;
    scaleNonUniform(scaleFactorX: number, scaleFactorY: number): SVGMatrix;
    rotate(angle: number): SVGMatrix;
    rotateFromVector(x: number, y: number): SVGMatrix;
    flipX(): SVGMatrix;
    flipY(): SVGMatrix;
    skewX(angle: number): SVGMatrix;
    skewY(angle: number): SVGMatrix;
  }
  class SVGMetadataElement {
  }
  class SVGNumber {
    value: number;
  }
  class SVGNumberList {
    readonly numberOfItems: number;
    clear(): void;
    initialize(newItem: SVGNumber): SVGNumber;
    getItem(index: number): SVGNumber;
    insertItemBefore(newItem: SVGNumber, index: number): SVGNumber;
    replaceItem(newItem: SVGNumber, index: number): SVGNumber;
    removeItem(index: number): SVGNumber;
    appendItem(newItem: SVGNumber): SVGNumber;
    readonly length: number;
  }
  class SVGPathElement {
    getPathSegAtLength(distance: number): number;
    readonly pathSegList: SVGPathSegList;
    readonly animatedPathSegList: SVGPathSegList;
  }
  class SVGPathSeg {
    readonly pathSegType: number;
    readonly pathSegTypeAsLetter: string;
  }
  class SVGPathSegClosePath {
  }
  class SVGPathSegMovetoAbs {
    x: number;
    y: number;
  }
  class SVGPathSegMovetoRel {
    x: number;
    y: number;
  }
  class SVGPathSegLinetoAbs {
    x: number;
    y: number;
  }
  class SVGPathSegLinetoRel {
    x: number;
    y: number;
  }
  class SVGPathSegCurvetoCubicAbs {
    x: number;
    y: number;
    x1: number;
    y1: number;
    x2: number;
    y2: number;
  }
  class SVGPathSegCurvetoCubicRel {
    x: number;
    y: number;
    x1: number;
    y1: number;
    x2: number;
    y2: number;
  }
  class SVGPathSegCurvetoQuadraticAbs {
    x: number;
    y: number;
    x1: number;
    y1: number;
  }
  class SVGPathSegCurvetoQuadraticRel {
    x: number;
    y: number;
    x1: number;
    y1: number;
  }
  class SVGPathSegArcAbs {
    x: number;
    y: number;
    r1: number;
    r2: number;
    angle: number;
    largeArcFlag: boolean;
    sweepFlag: boolean;
  }
  class SVGPathSegArcRel {
    x: number;
    y: number;
    r1: number;
    r2: number;
    angle: number;
    largeArcFlag: boolean;
    sweepFlag: boolean;
  }
  class SVGPathSegLinetoHorizontalAbs {
    x: number;
  }
  class SVGPathSegLinetoHorizontalRel {
    x: number;
  }
  class SVGPathSegLinetoVerticalAbs {
    y: number;
  }
  class SVGPathSegLinetoVerticalRel {
    y: number;
  }
  class SVGPathSegCurvetoCubicSmoothAbs {
    x: number;
    y: number;
    x2: number;
    y2: number;
  }
  class SVGPathSegCurvetoCubicSmoothRel {
    x: number;
    y: number;
    x2: number;
    y2: number;
  }
  class SVGPathSegCurvetoQuadraticSmoothAbs {
    x: number;
    y: number;
  }
  class SVGPathSegCurvetoQuadraticSmoothRel {
    x: number;
    y: number;
  }
  class SVGPathSegList {
    readonly numberOfItems: number;
    getItem(index: number): SVGPathSeg;
    readonly length: number;
  }
  class SVGPatternElement {
    readonly patternUnits: SVGAnimatedEnumeration;
    readonly patternContentUnits: SVGAnimatedEnumeration;
    readonly patternTransform: SVGAnimatedTransformList;
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly viewBox: SVGAnimatedRect;
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
    readonly href: SVGAnimatedString;
  }
  class SVGPoint {
    x: number;
    y: number;
    matrixTransform(matrix: SVGMatrix): SVGPoint;
  }
  class SVGPointList {
    readonly numberOfItems: number;
    clear(): void;
    initialize(newItem: SVGPoint): SVGPoint;
    getItem(index: number): SVGPoint;
    insertItemBefore(newItem: SVGPoint, index: number): SVGPoint;
    replaceItem(newItem: SVGPoint, index: number): SVGPoint;
    removeItem(index: number): SVGPoint;
    appendItem(newItem: SVGPoint): SVGPoint;
    readonly length: number;
  }
  class SVGPolygonElement {
    readonly points: SVGPointList;
    readonly animatedPoints: SVGPointList;
  }
  class SVGPolylineElement {
    readonly points: SVGPointList;
    readonly animatedPoints: SVGPointList;
  }
  class SVGPreserveAspectRatio {
    align: number;
    meetOrSlice: number;
  }
  class SVGRadialGradientElement {
    readonly cx: SVGAnimatedLength;
    readonly cy: SVGAnimatedLength;
    readonly r: SVGAnimatedLength;
    readonly fx: SVGAnimatedLength;
    readonly fy: SVGAnimatedLength;
    readonly fr: SVGAnimatedLength;
  }
  class SVGRect {
    x: number;
    y: number;
    width: number;
    height: number;
  }
  class SVGRectElement {
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly rx: SVGAnimatedLength;
    readonly ry: SVGAnimatedLength;
  }
  class SVGSVGElement {
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly useCurrentView: boolean;
    currentScale: number;
    readonly currentTranslate: SVGPoint;
    suspendRedraw(maxWaitMilliseconds: number): number;
    unsuspendRedraw(suspendHandleID: number): void;
    unsuspendRedrawAll(): void;
    forceRedraw(): void;
    pauseAnimations(): void;
    unpauseAnimations(): void;
    animationsPaused(): boolean;
    getCurrentTime(): number;
    setCurrentTime(seconds: number): void;
    deselectAll(): void;
    createSVGNumber(): SVGNumber;
    createSVGLength(): SVGLength;
    createSVGAngle(): SVGAngle;
    createSVGPoint(): SVGPoint;
    createSVGMatrix(): SVGMatrix;
    createSVGRect(): SVGRect;
    createSVGTransform(): SVGTransform;
    createSVGTransformFromMatrix(matrix: SVGMatrix): SVGTransform;
    getElementById(elementId: string): Element | null;
    readonly viewBox: SVGAnimatedRect;
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
    zoomAndPan: number;
  }
  class SVGScriptElement {
    type: string;
    crossOrigin: string | null;
    readonly href: SVGAnimatedString;
  }
  class SVGSetElement {
  }
  class SVGStopElement {
    readonly offset: SVGAnimatedNumber;
  }
  class SVGStringList {
    readonly length: number;
    readonly numberOfItems: number;
    clear(): void;
    initialize(newItem: string): string;
    getItem(index: number): string;
    __indexedgetter(index: number): string;
    insertItemBefore(newItem: string, index: number): string;
    replaceItem(newItem: string, index: number): string;
    removeItem(index: number): string;
    appendItem(newItem: string): string;
  }
  class SVGStyleElement {
    xmlspace: string;
    type: string;
    media: string;
    title: string;
    readonly sheet: StyleSheet | null;
  }
  class SVGSwitchElement {
  }
  class SVGSymbolElement {
    readonly viewBox: SVGAnimatedRect;
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
    readonly requiredExtensions: SVGStringList;
    readonly systemLanguage: SVGStringList;
  }
  class SVGTSpanElement {
  }
  class SVGTextContentElement {
    readonly textLength: SVGAnimatedLength;
    readonly lengthAdjust: SVGAnimatedEnumeration;
    getNumberOfChars(): number;
    getComputedTextLength(): number;
    getSubStringLength(charnum: number, nchars: number): number;
    getStartPositionOfChar(charnum: number): SVGPoint;
    getEndPositionOfChar(charnum: number): SVGPoint;
    getExtentOfChar(charnum: number): SVGRect;
    getRotationOfChar(charnum: number): number;
    getCharNumAtPosition(point?: DOMPointInit): number;
    selectSubString(charnum: number, nchars: number): void;
  }
  class SVGTextElement {
  }
  class SVGTextPathElement {
    readonly startOffset: SVGAnimatedLength;
    readonly method: SVGAnimatedEnumeration;
    readonly spacing: SVGAnimatedEnumeration;
    readonly href: SVGAnimatedString;
  }
  class SVGTextPositioningElement {
    readonly x: SVGAnimatedLengthList;
    readonly y: SVGAnimatedLengthList;
    readonly dx: SVGAnimatedLengthList;
    readonly dy: SVGAnimatedLengthList;
    readonly rotate: SVGAnimatedNumberList;
  }
  class SVGTitleElement {
  }
  class SVGTransform {
    readonly type: number;
    readonly matrix: SVGMatrix;
    readonly angle: number;
    setMatrix(matrix: SVGMatrix): void;
    setTranslate(tx: number, ty: number): void;
    setScale(sx: number, sy: number): void;
    setRotate(angle: number, cx: number, cy: number): void;
    setSkewX(angle: number): void;
    setSkewY(angle: number): void;
  }
  class SVGTransformList {
    readonly numberOfItems: number;
    clear(): void;
    initialize(newItem: SVGTransform): SVGTransform;
    getItem(index: number): SVGTransform;
    insertItemBefore(newItem: SVGTransform, index: number): SVGTransform;
    replaceItem(newItem: SVGTransform, index: number): SVGTransform;
    removeItem(index: number): SVGTransform;
    appendItem(newItem: SVGTransform): SVGTransform;
    createSVGTransformFromMatrix(matrix: SVGMatrix): SVGTransform;
    consolidate(): SVGTransform | null;
    readonly length: number;
  }
  class SVGUnitTypes {
  }
  class SVGUseElement {
    readonly x: SVGAnimatedLength;
    readonly y: SVGAnimatedLength;
    readonly width: SVGAnimatedLength;
    readonly height: SVGAnimatedLength;
    readonly href: SVGAnimatedString;
  }
  class SVGViewElement {
    readonly viewBox: SVGAnimatedRect;
    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;
    zoomAndPan: number;
  }
  class Screen {
    readonly availWidth: number;
    readonly availHeight: number;
    readonly width: number;
    readonly height: number;
    readonly colorDepth: number;
    readonly pixelDepth: number;
    readonly top: number;
    readonly left: number;
    readonly availTop: number;
    readonly availLeft: number;
    readonly mozOrientation: string;
    onmozorientationchange: EventHandlerNonNull | null;
    mozLockOrientation(orientation: string): boolean;
    mozLockOrientation(orientation: string[]): boolean;
    mozUnlockOrientation(): void;
    readonly orientation: ScreenOrientation;
    readonly colorGamut: ScreenColorGamut;
    readonly luminance: ScreenLuminance | null;
    onchange: EventHandlerNonNull | null;
  }
  enum ScreenColorGamut {
    Srgb = "srgb",
    P_ = "p3",
    Rec____ = "rec2020",
  }
  class ScreenLuminance {
    readonly min: number;
    readonly max: number;
    readonly maxAverage: number;
  }
  enum OrientationType {
    Portrait_primary = "portrait-primary",
    Portrait_secondary = "portrait-secondary",
    Landscape_primary = "landscape-primary",
    Landscape_secondary = "landscape-secondary",
  }
  enum OrientationLockType {
    Any = "any",
    Natural = "natural",
    Landscape = "landscape",
    Portrait = "portrait",
    Portrait_primary = "portrait-primary",
    Portrait_secondary = "portrait-secondary",
    Landscape_primary = "landscape-primary",
    Landscape_secondary = "landscape-secondary",
  }
  class ScreenOrientation {
    lock(orientation: OrientationLockType): Promise<void>;
    unlock(): void;
    readonly type: OrientationType;
    readonly angle: number;
    onchange: EventHandlerNonNull | null;
  }
  class ScriptProcessorNode {
    onaudioprocess: EventHandlerNonNull | null;
    readonly bufferSize: number;
    passThrough: boolean;
  }
  class ScrollAreaEvent {
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
    initScrollAreaEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, detail?: number, x?: number, y?: number, width?: number, height?: number): void;
    readonly isTrusted: boolean;
  }
  enum ScrollState {
    Started = "started",
    Stopped = "stopped",
  }
  interface ScrollViewChangeEventInit {
    state?: ScrollState
  }
  class ScrollViewChangeEvent {
    readonly state: ScrollState;
    readonly isTrusted: boolean;
  }
  enum SecurityPolicyViolationEventDisposition {
    Enforce = "enforce",
    Report = "report",
  }
  class SecurityPolicyViolationEvent {
    readonly documentURI: string;
    readonly referrer: string;
    readonly blockedURI: string;
    readonly violatedDirective: string;
    readonly effectiveDirective: string;
    readonly originalPolicy: string;
    readonly sourceFile: string;
    readonly sample: string;
    readonly disposition: SecurityPolicyViolationEventDisposition;
    readonly statusCode: number;
    readonly lineNumber: number;
    readonly columnNumber: number;
    readonly isTrusted: boolean;
  }
  interface SecurityPolicyViolationEventInit {
    blockedURI?: string
    columnNumber?: number
    disposition?: SecurityPolicyViolationEventDisposition
    documentURI?: string
    effectiveDirective?: string
    lineNumber?: number
    originalPolicy?: string
    referrer?: string
    sample?: string
    sourceFile?: string
    statusCode?: number
    violatedDirective?: string
  }
  class Selection {
    readonly anchorNode: Node | null;
    readonly anchorOffset: number;
    readonly focusNode: Node | null;
    readonly focusOffset: number;
    readonly isCollapsed: boolean;
    readonly rangeCount: number;
    readonly type: string;
    getRangeAt(index: number): Range;
    addRange(range: Range): void;
    removeRange(range: Range): void;
    removeAllRanges(): void;
    empty(): void;
    collapse(node: Node | null, offset?: number): void;
    setPosition(node: Node | null, offset?: number): void;
    collapseToStart(): void;
    collapseToEnd(): void;
    extend(node: Node, offset?: number): void;
    setBaseAndExtent(anchorNode: Node, anchorOffset: number, focusNode: Node, focusOffset: number): void;
    selectAllChildren(node: Node): void;
    deleteFromDocument(): void;
    containsNode(node: Node, allowPartialContainment?: boolean): boolean;
    __stringifier(): string;
    modify(alter: string, direction: string, granularity: string): void;
    interlinePosition: boolean;
    caretBidiLevel: number | null;
    toStringWithFormat(formatType: string, flags: number, wrapColumn: number): string;
    addSelectionListener(newListener: nsISelectionListener): void;
    removeSelectionListener(listenerToRemove: nsISelectionListener): void;
    readonly selectionType: number;
    GetRangesForInterval(beginNode: Node, beginOffset: number, endNode: Node, endOffset: number, allowAdjacent: boolean): Range[];
    scrollIntoView(aRegion: number, aIsSynchronous: boolean, aVPercent: number, aHPercent: number): void;
    setColors(aForegroundColor: string, aBackgroundColor: string, aAltForegroundColor: string, aAltBackgroundColor: string): void;
    resetColors(): void;
  }
  class ServiceWorker {
    readonly scriptURL: string;
    readonly state: ServiceWorkerState;
    onstatechange: EventHandlerNonNull | null;
    postMessage(message: any, transferable: object[]): void;
    postMessage(message: any, options?: PostMessageOptions): void;
    onerror: EventHandlerNonNull | null;
  }
  enum ServiceWorkerState {
    Parsed = "parsed",
    Installing = "installing",
    Installed = "installed",
    Activating = "activating",
    Activated = "activated",
    Redundant = "redundant",
  }
  class ServiceWorkerContainer {
    readonly controller: ServiceWorker | null;
    readonly ready: Promise<ServiceWorkerRegistration>;
    register(scriptURL: string, options?: RegistrationOptions): Promise<ServiceWorkerRegistration>;
    getRegistration(documentURL?: string): Promise<any>;
    getRegistrations(): Promise<ServiceWorkerRegistration[]>;
    startMessages(): void;
    oncontrollerchange: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onmessage: EventHandlerNonNull | null;
    onmessageerror: EventHandlerNonNull | null;
    getScopeForUrl(url: string): string;
  }
  interface RegistrationOptions {
    scope?: string
    updateViaCache?: ServiceWorkerUpdateViaCache
  }
  class ServiceWorkerGlobalScope {
    readonly clients: Clients;
    readonly registration: ServiceWorkerRegistration;
    skipWaiting(): Promise<void>;
    oninstall: EventHandlerNonNull | null;
    onactivate: EventHandlerNonNull | null;
    onfetch: EventHandlerNonNull | null;
    onmessage: EventHandlerNonNull | null;
    onmessageerror: EventHandlerNonNull | null;
    onpush: EventHandlerNonNull | null;
    onpushsubscriptionchange: EventHandlerNonNull | null;
    onnotificationclick: EventHandlerNonNull | null;
    onnotificationclose: EventHandlerNonNull | null;
  }
  class ServiceWorkerRegistration {
    readonly installing: ServiceWorker | null;
    readonly waiting: ServiceWorker | null;
    readonly active: ServiceWorker | null;
    readonly scope: string;
    readonly updateViaCache: ServiceWorkerUpdateViaCache;
    update(): Promise<void>;
    unregister(): Promise<boolean>;
    onupdatefound: EventHandlerNonNull | null;
    readonly pushManager: PushManager;
    showNotification(title: string, options?: NotificationOptions): Promise<void>;
    getNotifications(filter?: GetNotificationOptions): Promise<Notification[]>;
  }
  enum ServiceWorkerUpdateViaCache {
    Imports = "imports",
    All = "all",
    None = "none",
  }
  enum ShadowRootMode {
    Open = "open",
    Closed = "closed",
  }
  class ShadowRoot {
    readonly mode: ShadowRootMode;
    readonly host: Element;
    getElementById(elementId: string): Element | null;
    innerHTML: string;
    importNodeAndAppendChildAt(parentNode: Node, node: Node, deep?: boolean): Node;
    createElementAndAppendChildAt(parentNode: Node, localName: string): Node;
    setIsUAWidget(): void;
    isUAWidget(): boolean;
    elementFromPoint(x: number, y: number): Element | null;
    elementsFromPoint(x: number, y: number): Element[];
    nodeFromPoint(x: number, y: number): Node | null;
    nodesFromPoint(x: number, y: number): Node[];
    readonly activeElement: Element | null;
    readonly styleSheets: StyleSheetList;
    readonly pointerLockElement: Element | null;
    readonly fullscreenElement: Element | null;
    readonly mozFullScreenElement: Element | null;
    getAnimations(): Animation[];
  }
  class SharedWorker {
    readonly port: MessagePort;
    onerror: EventHandlerNonNull | null;
  }
  class SharedWorkerGlobalScope {
    readonly name: string;
    close(): void;
    onconnect: EventHandlerNonNull | null;
  }
  class SimpleGestureEvent {
    allowedDirections: number;
    readonly direction: number;
    readonly delta: number;
    readonly clickCount: number;
    initSimpleGestureEvent(typeArg: string, canBubbleArg?: boolean, cancelableArg?: boolean, viewArg?: Window | null, detailArg?: number, screenXArg?: number, screenYArg?: number, clientXArg?: number, clientYArg?: number, ctrlKeyArg?: boolean, altKeyArg?: boolean, shiftKeyArg?: boolean, metaKeyArg?: boolean, buttonArg?: number, relatedTargetArg?: EventTarget | null, allowedDirectionsArg?: number, directionArg?: number, deltaArg?: number, clickCount?: number): void;
    readonly isTrusted: boolean;
  }
  enum SocketReadyState {
    Opening = "opening",
    Open = "open",
    Closing = "closing",
    Closed = "closed",
    Halfclosed = "halfclosed",
  }
  enum SourceBufferAppendMode {
    Segments = "segments",
    Sequence = "sequence",
  }
  class SourceBuffer {
    mode: SourceBufferAppendMode;
    readonly updating: boolean;
    readonly buffered: TimeRanges;
    timestampOffset: number;
    appendWindowStart: number;
    appendWindowEnd: number;
    onupdatestart: EventHandlerNonNull | null;
    onupdate: EventHandlerNonNull | null;
    onupdateend: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onabort: EventHandlerNonNull | null;
    appendBuffer(data: ArrayBuffer): void;
    appendBuffer(data: ArrayBufferView): void;
    appendBufferAsync(data: ArrayBuffer): Promise<void>;
    appendBufferAsync(data: ArrayBufferView): Promise<void>;
    abort(): void;
    remove(start: number, end: number): void;
    removeAsync(start: number, end: number): Promise<void>;
    changeType(type: string): void;
  }
  class SourceBufferList {
    readonly length: number;
    onaddsourcebuffer: EventHandlerNonNull | null;
    onremovesourcebuffer: EventHandlerNonNull | null;
    __indexedgetter(index: number): SourceBuffer;
  }
  class SpeechGrammar {
    src: string;
    weight: number;
  }
  class SpeechGrammarList {
    readonly length: number;
    item(index: number): SpeechGrammar;
    addFromURI(src: string, weight?: number): void;
    addFromString(string: string, weight?: number): void;
  }
  class SpeechRecognition {
    grammars: SpeechGrammarList;
    lang: string;
    continuous: boolean;
    interimResults: boolean;
    maxAlternatives: number;
    serviceURI: string;
    start(stream?: MediaStream): void;
    stop(): void;
    abort(): void;
    onaudiostart: EventHandlerNonNull | null;
    onsoundstart: EventHandlerNonNull | null;
    onspeechstart: EventHandlerNonNull | null;
    onspeechend: EventHandlerNonNull | null;
    onsoundend: EventHandlerNonNull | null;
    onaudioend: EventHandlerNonNull | null;
    onresult: EventHandlerNonNull | null;
    onnomatch: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onstart: EventHandlerNonNull | null;
    onend: EventHandlerNonNull | null;
  }
  class SpeechRecognitionAlternative {
    readonly transcript: string;
    readonly confidence: number;
  }
  enum SpeechRecognitionErrorCode {
    No_speech = "no-speech",
    Aborted = "aborted",
    Audio_capture = "audio-capture",
    Network = "network",
    Not_allowed = "not-allowed",
    Service_not_allowed = "service-not-allowed",
    Bad_grammar = "bad-grammar",
    Language_not_supported = "language-not-supported",
  }
  class SpeechRecognitionError {
    readonly error: SpeechRecognitionErrorCode;
    readonly message: string | null;
    readonly isTrusted: boolean;
  }
  interface SpeechRecognitionErrorInit {
    error?: SpeechRecognitionErrorCode
    message?: string
  }
  class SpeechRecognitionEvent {
    readonly resultIndex: number;
    readonly results: SpeechRecognitionResultList | null;
    readonly interpretation: any;
    readonly emma: Document | null;
    readonly isTrusted: boolean;
  }
  interface SpeechRecognitionEventInit {
    emma?: Document | null
    interpretation?: any
    resultIndex?: number
    results?: SpeechRecognitionResultList | null
  }
  class SpeechRecognitionResult {
    readonly length: number;
    item(index: number): SpeechRecognitionAlternative;
    readonly isFinal: boolean;
  }
  class SpeechRecognitionResultList {
    readonly length: number;
    item(index: number): SpeechRecognitionResult;
  }
  class SpeechSynthesis {
    readonly pending: boolean;
    readonly speaking: boolean;
    readonly paused: boolean;
    speak(utterance: SpeechSynthesisUtterance): void;
    cancel(): void;
    pause(): void;
    resume(): void;
    getVoices(): SpeechSynthesisVoice[];
    onvoiceschanged: EventHandlerNonNull | null;
    forceEnd(): void;
  }
  enum SpeechSynthesisErrorCode {
    Canceled = "canceled",
    Interrupted = "interrupted",
    Audio_busy = "audio-busy",
    Audio_hardware = "audio-hardware",
    Network = "network",
    Synthesis_unavailable = "synthesis-unavailable",
    Synthesis_failed = "synthesis-failed",
    Language_unavailable = "language-unavailable",
    Voice_unavailable = "voice-unavailable",
    Text_too_long = "text-too-long",
    Invalid_argument = "invalid-argument",
  }
  class SpeechSynthesisErrorEvent {
    readonly error: SpeechSynthesisErrorCode;
    readonly isTrusted: boolean;
  }
  interface SpeechSynthesisErrorEventInit {
    error: SpeechSynthesisErrorCode
  }
  class SpeechSynthesisEvent {
    readonly utterance: SpeechSynthesisUtterance;
    readonly charIndex: number;
    readonly charLength: number | null;
    readonly elapsedTime: number;
    readonly name: string | null;
    readonly isTrusted: boolean;
  }
  interface SpeechSynthesisEventInit {
    charIndex?: number
    charLength?: number | null
    elapsedTime?: number
    name?: string
    utterance: SpeechSynthesisUtterance
  }
  class SpeechSynthesisUtterance {
    text: string;
    lang: string;
    voice: SpeechSynthesisVoice | null;
    volume: number;
    rate: number;
    pitch: number;
    onstart: EventHandlerNonNull | null;
    onend: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onpause: EventHandlerNonNull | null;
    onresume: EventHandlerNonNull | null;
    onmark: EventHandlerNonNull | null;
    onboundary: EventHandlerNonNull | null;
    readonly chosenVoiceURI: string;
  }
  class SpeechSynthesisVoice {
    readonly voiceURI: string;
    readonly name: string;
    readonly lang: string;
    readonly localService: boolean;
    readonly default: boolean;
  }
  class StaticRange {
  }
  interface StaticRangeInit {
    endContainer: Node
    endOffset: number
    startContainer: Node
    startOffset: number
  }
  interface StereoPannerOptions {
    pan?: number
  }
  class StereoPannerNode {
    readonly pan: AudioParam;
    passThrough: boolean;
  }
  class Storage {
    readonly length: number;
    key(index: number): string | null;
    getItem(key: string): string | null;
    setItem(key: string, value: string): void;
    removeItem(key: string): void;
    clear(): void;
    readonly isSessionOnly: boolean;
    open(): void;
    close(): void;
    beginExplicitSnapshot(): void;
    endExplicitSnapshot(): void;
    readonly hasActiveSnapshot: boolean;
  }
  class StorageEvent {
    readonly key: string | null;
    readonly oldValue: string | null;
    readonly newValue: string | null;
    readonly url: string | null;
    readonly storageArea: Storage | null;
    initStorageEvent(type: string, canBubble?: boolean, cancelable?: boolean, key?: string | null, oldValue?: string | null, newValue?: string | null, url?: string | null, storageArea?: Storage | null): void;
    readonly isTrusted: boolean;
  }
  interface StorageEventInit {
    key?: string | null
    newValue?: string | null
    oldValue?: string | null
    storageArea?: Storage | null
    url?: string
  }
  class StorageManager {
    persisted(): Promise<boolean>;
    persist(): Promise<boolean>;
    estimate(): Promise<StorageEstimate>;
  }
  interface StorageEstimate {
    quota?: number
    usage?: number
  }
  enum StorageType {
    Persistent = "persistent",
    Temporary = "temporary",
    Default = "default",
  }
  enum StreamFilterStatus {
    Uninitialized = "uninitialized",
    Transferringdata = "transferringdata",
    Finishedtransferringdata = "finishedtransferringdata",
    Suspended = "suspended",
    Closed = "closed",
    Disconnected = "disconnected",
    Failed = "failed",
  }
  class StreamFilter {
    create(requestId: number, addonId: string): StreamFilter;
    suspend(): void;
    resume(): void;
    close(): void;
    disconnect(): void;
    write(data: ArrayBuffer | Uint8Array): void;
    readonly status: StreamFilterStatus;
    readonly error: string;
    ondata: EventHandlerNonNull | null;
    onstart: EventHandlerNonNull | null;
    onstop: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
  }
  class StreamFilterDataEvent {
    readonly data: ArrayBuffer;
    readonly isTrusted: boolean;
  }
  interface StreamFilterDataEventInit {
    data: ArrayBuffer
  }
  class StructuredCloneTester {
    readonly serializable: boolean;
    readonly deserializable: boolean;
  }
  class StyleSheet {
    readonly type: string;
    readonly href: string | null;
    readonly ownerNode: Node | null;
    readonly parentStyleSheet: StyleSheet | null;
    readonly title: string | null;
    readonly media: MediaList;
    disabled: boolean;
    readonly sourceMapURL: string;
    readonly sourceURL: string;
  }
  class StyleSheetApplicableStateChangeEvent {
    readonly stylesheet: CSSStyleSheet | null;
    readonly applicable: boolean;
    readonly isTrusted: boolean;
  }
  interface StyleSheetApplicableStateChangeEventInit {
    applicable?: boolean
    stylesheet?: CSSStyleSheet | null
  }
  class StyleSheetList {
    readonly length: number;
    item(index: number): StyleSheet | null;
  }
  interface Algorithm {
    name: string
  }
  interface AesCbcParams {
    iv: ArrayBufferView | ArrayBuffer
  }
  interface AesCtrParams {
    counter: ArrayBufferView | ArrayBuffer
    length: number
  }
  interface AesGcmParams {
    additionalData?: ArrayBufferView | ArrayBuffer
    iv: ArrayBufferView | ArrayBuffer
    tagLength?: number
  }
  interface HmacImportParams {
    hash: object | string
  }
  interface Pbkdf2Params {
    hash: object | string
    iterations: number
    salt: ArrayBufferView | ArrayBuffer
  }
  interface RsaHashedImportParams {
    hash: object | string
  }
  interface AesKeyGenParams {
    length: number
  }
  interface HmacKeyGenParams {
    hash: object | string
    length?: number
  }
  interface RsaHashedKeyGenParams {
    hash: object | string
    modulusLength: number
    publicExponent: Uint8Array
  }
  interface RsaOaepParams {
    label?: ArrayBufferView | ArrayBuffer
  }
  interface RsaPssParams {
    saltLength: number
  }
  interface EcKeyGenParams {
    namedCurve: string
  }
  interface AesDerivedKeyParams {
    length: number
  }
  interface HmacDerivedKeyParams {
    length?: number
  }
  interface EcdhKeyDeriveParams {
    public: CryptoKey
  }
  interface DhImportKeyParams {
    generator: Uint8Array
    prime: Uint8Array
  }
  interface EcdsaParams {
    hash: object | string
  }
  interface EcKeyImportParams {
    namedCurve?: string
  }
  interface HkdfParams {
    hash: object | string
    info: ArrayBufferView | ArrayBuffer
    salt: ArrayBufferView | ArrayBuffer
  }
  interface RsaOtherPrimesInfo {
    d: string
    r: string
    t: string
  }
  interface JsonWebKey {
    alg?: string
    crv?: string
    d?: string
    dp?: string
    dq?: string
    e?: string
    ext?: boolean
    k?: string
    key_ops?: string[]
    kty: string
    n?: string
    oth?: RsaOtherPrimesInfo[]
    p?: string
    q?: string
    qi?: string
    use?: string
    x?: string
    y?: string
  }
  class CryptoKey {
    readonly type: string;
    readonly extractable: boolean;
    readonly algorithm: object;
    readonly usages: string[];
  }
  interface CryptoKeyPair {
    privateKey: CryptoKey
    publicKey: CryptoKey
  }
  class SubtleCrypto {
    encrypt(algorithm: object | string, key: CryptoKey, data: ArrayBufferView | ArrayBuffer): Promise<any>;
    decrypt(algorithm: object | string, key: CryptoKey, data: ArrayBufferView | ArrayBuffer): Promise<any>;
    sign(algorithm: object | string, key: CryptoKey, data: ArrayBufferView | ArrayBuffer): Promise<any>;
    verify(algorithm: object | string, key: CryptoKey, signature: ArrayBufferView | ArrayBuffer, data: ArrayBufferView | ArrayBuffer): Promise<any>;
    digest(algorithm: object | string, data: ArrayBufferView | ArrayBuffer): Promise<any>;
    generateKey(algorithm: object | string, extractable: boolean, keyUsages: string[]): Promise<any>;
    deriveKey(algorithm: object | string, baseKey: CryptoKey, derivedKeyType: object | string, extractable: boolean, keyUsages: string[]): Promise<any>;
    deriveBits(algorithm: object | string, baseKey: CryptoKey, length: number): Promise<any>;
    importKey(format: string, keyData: object, algorithm: object | string, extractable: boolean, keyUsages: string[]): Promise<any>;
    exportKey(format: string, key: CryptoKey): Promise<any>;
    wrapKey(format: string, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: object | string): Promise<any>;
    unwrapKey(format: string, wrappedKey: ArrayBufferView | ArrayBuffer, unwrappingKey: CryptoKey, unwrapAlgorithm: object | string, unwrappedKeyAlgorithm: object | string, extractable: boolean, keyUsages: string[]): Promise<any>;
  }
  interface ServerSocketOptions {
    binaryType?: TCPSocketBinaryType
  }
  class TCPServerSocket {
    readonly localPort: number;
    onconnect: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    close(): void;
  }
  class TCPServerSocketEvent {
    readonly socket: TCPSocket;
    readonly isTrusted: boolean;
  }
  interface TCPServerSocketEventInit {
    socket?: TCPSocket | null
  }
  enum TCPSocketBinaryType {
    Arraybuffer = "arraybuffer",
    String = "string",
  }
  interface SocketOptions {
    binaryType?: TCPSocketBinaryType
    useSecureTransport?: boolean
  }
  enum TCPReadyState {
    Connecting = "connecting",
    Open = "open",
    Closing = "closing",
    Closed = "closed",
  }
  class LegacyMozTCPSocket {
    open(host: string, port: number, options?: SocketOptions): TCPSocket;
    listen(port: number, options?: ServerSocketOptions, backlog?: number): TCPServerSocket;
  }
  class TCPSocket {
    upgradeToSecure(): void;
    readonly host: string;
    readonly port: number;
    readonly ssl: boolean;
    readonly bufferedAmount: number;
    suspend(): void;
    resume(): void;
    close(): void;
    closeImmediately(): void;
    send(data: string): boolean;
    send(data: ArrayBuffer, byteOffset?: number, byteLength?: number): boolean;
    readonly readyState: TCPReadyState;
    readonly binaryType: TCPSocketBinaryType;
    onopen: EventHandlerNonNull | null;
    ondrain: EventHandlerNonNull | null;
    ondata: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
  }
  class TCPSocketErrorEvent {
    readonly name: string;
    readonly message: string;
    readonly isTrusted: boolean;
  }
  interface TCPSocketErrorEventInit {
    message?: string
    name?: string
  }
  class TCPSocketEvent {
    readonly data: any;
    readonly isTrusted: boolean;
  }
  interface TCPSocketEventInit {
    data?: any
  }
  class Text {
    splitText(offset: number): Text;
    readonly wholeText: string;
    readonly assignedSlot: HTMLSlotElement | null;
    readonly openOrClosedAssignedSlot: HTMLSlotElement | null;
    getBoxQuads(options?: BoxQuadOptions): DOMQuad[];
    convertQuadFromNode(quad: DOMQuad, from: Text | Element | Document, options?: ConvertCoordinateOptions): DOMQuad;
    convertRectFromNode(rect: DOMRectReadOnly, from: Text | Element | Document, options?: ConvertCoordinateOptions): DOMQuad;
    convertPointFromNode(point: DOMPointInit, from: Text | Element | Document, options?: ConvertCoordinateOptions): DOMPoint;
  }
  class TextClause {
    readonly startOffset: number;
    readonly endOffset: number;
    readonly isCaret: boolean;
    readonly isTargetClause: boolean;
  }
  class TextDecoder {
    readonly encoding: string;
    readonly fatal: boolean;
    readonly ignoreBOM: boolean;
    decode(input?: ArrayBufferView | ArrayBuffer, options?: TextDecodeOptions): string;
  }
  interface TextDecoderOptions {
    fatal?: boolean
    ignoreBOM?: boolean
  }
  interface TextDecodeOptions {
    stream?: boolean
  }
  interface TextEncoderEncodeIntoResult {
    read?: number
    written?: number
  }
  class TextEncoder {
    readonly encoding: string;
    encode(input?: string): Uint8Array;
    encodeInto(source: string, destination: Uint8Array): TextEncoderEncodeIntoResult;
  }
  enum TextTrackKind {
    Subtitles = "subtitles",
    Captions = "captions",
    Descriptions = "descriptions",
    Chapters = "chapters",
    Metadata = "metadata",
  }
  enum TextTrackMode {
    Disabled = "disabled",
    Hidden = "hidden",
    Showing = "showing",
  }
  class TextTrack {
    readonly kind: TextTrackKind;
    readonly label: string;
    readonly language: string;
    readonly id: string;
    readonly inBandMetadataTrackDispatchType: string;
    mode: TextTrackMode;
    readonly cues: TextTrackCueList | null;
    readonly activeCues: TextTrackCueList | null;
    addCue(cue: VTTCue): void;
    removeCue(cue: VTTCue): void;
    oncuechange: EventHandlerNonNull | null;
    readonly textTrackList: TextTrackList | null;
  }
  class TextTrackCue {
    readonly track: TextTrack | null;
    id: string;
    startTime: number;
    endTime: number;
    pauseOnExit: boolean;
    onenter: EventHandlerNonNull | null;
    onexit: EventHandlerNonNull | null;
  }
  class TextTrackCueList {
    readonly length: number;
    __indexedgetter(index: number): VTTCue;
    getCueById(id: string): VTTCue | null;
  }
  class TextTrackList {
    readonly length: number;
    __indexedgetter(index: number): TextTrack;
    getTrackById(id: string): TextTrack | null;
    onchange: EventHandlerNonNull | null;
    onaddtrack: EventHandlerNonNull | null;
    onremovetrack: EventHandlerNonNull | null;
    readonly mediaElement: HTMLMediaElement | null;
  }
  class TimeEvent {
    readonly detail: number;
    readonly view: WindowProxy | null;
    initTimeEvent(aType: string, aView?: Window | null, aDetail?: number): void;
    readonly isTrusted: boolean;
  }
  class TimeRanges {
    readonly length: number;
    start(index: number): number;
    end(index: number): number;
  }
  interface TouchInit {
    clientX?: number
    clientY?: number
    force?: number
    identifier: number
    pageX?: number
    pageY?: number
    radiusX?: number
    radiusY?: number
    rotationAngle?: number
    screenX?: number
    screenY?: number
    target: EventTarget
  }
  class Touch {
    readonly identifier: number;
    readonly target: EventTarget | null;
    readonly screenX: number;
    readonly screenY: number;
    readonly clientX: number;
    readonly clientY: number;
    readonly pageX: number;
    readonly pageY: number;
    readonly radiusX: number;
    readonly radiusY: number;
    readonly rotationAngle: number;
    readonly force: number;
  }
  interface TouchEventInit {
    changedTouches?: Touch[]
    targetTouches?: Touch[]
    touches?: Touch[]
  }
  class TouchEvent {
    readonly touches: TouchList;
    readonly targetTouches: TouchList;
    readonly changedTouches: TouchList;
    readonly altKey: boolean;
    readonly metaKey: boolean;
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    initTouchEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, detail?: number, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean, touches?: TouchList | null, targetTouches?: TouchList | null, changedTouches?: TouchList | null): void;
    readonly isTrusted: boolean;
  }
  class TouchList {
    readonly length: number;
    item(index: number): Touch | null;
  }
  class TrackEvent {
    readonly track: VideoTrack | AudioTrack | TextTrack | null;
    readonly isTrusted: boolean;
  }
  interface TrackEventInit {
    track?: VideoTrack | AudioTrack | TextTrack | null
  }
  class TransceiverImpl {
    getReceiveTrack(): MediaStreamTrack;
    setReceiveTrackMuted(muted: boolean): void;
    syncWithJS(transceiver: RTCRtpTransceiver): void;
  }
  class TransitionEvent {
    readonly propertyName: string;
    readonly elapsedTime: number;
    readonly pseudoElement: string;
    readonly isTrusted: boolean;
  }
  interface TransitionEventInit {
    elapsedTime?: number
    propertyName?: string
    pseudoElement?: string
  }
  class TreeColumn {
    readonly element: Element;
    readonly columns: TreeColumns | null;
    readonly x: number;
    readonly width: number;
    readonly id: string;
    readonly index: number;
    readonly primary: boolean;
    readonly cycler: boolean;
    readonly editable: boolean;
    readonly type: number;
    getNext(): TreeColumn | null;
    getPrevious(): TreeColumn | null;
    readonly previousColumn: TreeColumn | null;
    invalidate(): void;
  }
  class TreeColumns {
    readonly tree: XULTreeElement | null;
    readonly count: number;
    readonly length: number;
    getFirstColumn(): TreeColumn | null;
    getLastColumn(): TreeColumn | null;
    getPrimaryColumn(): TreeColumn | null;
    getSortedColumn(): TreeColumn | null;
    getKeyColumn(): TreeColumn | null;
    getColumnFor(element: Element | null): TreeColumn | null;
    getNamedColumn(name: string): TreeColumn | null;
    getColumnAt(index: number): TreeColumn | null;
    invalidateColumns(): void;
    restoreNaturalOrder(): void;
  }
  class TreeContentView {
    getItemAtIndex(row: number): Element | null;
    getIndexOfItem(item: Element | null): number;
    readonly rowCount: number;
    selection: nsITreeSelection | null;
    getRowProperties(row: number): string;
    getCellProperties(row: number, column: TreeColumn): string;
    getColumnProperties(column: TreeColumn): string;
    isContainer(row: number): boolean;
    isContainerOpen(row: number): boolean;
    isContainerEmpty(row: number): boolean;
    isSeparator(row: number): boolean;
    isSorted(): boolean;
    canDrop(row: number, orientation: number, dataTransfer: DataTransfer | null): boolean;
    drop(row: number, orientation: number, dataTransfer: DataTransfer | null): void;
    getParentIndex(row: number): number;
    hasNextSibling(row: number, afterIndex: number): boolean;
    getLevel(row: number): number;
    getImageSrc(row: number, column: TreeColumn): string;
    getCellValue(row: number, column: TreeColumn): string;
    getCellText(row: number, column: TreeColumn): string;
    setTree(tree: XULTreeElement | null): void;
    toggleOpenState(row: number): void;
    cycleHeader(column: TreeColumn): void;
    selectionChanged(): void;
    cycleCell(row: number, column: TreeColumn): void;
    isEditable(row: number, column: TreeColumn): boolean;
    setCellValue(row: number, column: TreeColumn, value: string): void;
    setCellText(row: number, column: TreeColumn, value: string): void;
  }
  class TreeWalker {
    readonly root: Node;
    readonly whatToShow: number;
    readonly filter: NodeFilter | null;
    currentNode: Node;
    parentNode(): Node | null;
    firstChild(): Node | null;
    lastChild(): Node | null;
    previousSibling(): Node | null;
    nextSibling(): Node | null;
    previousNode(): Node | null;
    nextNode(): Node | null;
  }
  enum Transport {
    Bt = "bt",
    Ble = "ble",
    Nfc = "nfc",
    Usb = "usb",
  }
  interface U2FClientData {
    challenge?: string
    origin?: string
    typ?: string
  }
  interface RegisterRequest {
    challenge?: string
    version?: string
  }
  interface RegisterResponse {
    clientData?: string
    errorCode?: number | null
    errorMessage?: string | null
    registrationData?: string
    version?: string
  }
  interface RegisteredKey {
    appId?: string | null
    keyHandle?: string
    transports?: Transport[] | null
    version?: string
  }
  interface SignResponse {
    clientData?: string
    errorCode?: number | null
    errorMessage?: string | null
    keyHandle?: string
    signatureData?: string
  }
  function U2FRegisterCallback(response: RegisterResponse): void;
  function U2FSignCallback(response: SignResponse): void;
  class U2F {
    readonly register: object;
    register_impl(appId: string, registerRequests: RegisterRequest[], registeredKeys: RegisteredKey[], callback: U2FRegisterCallback, opt_timeoutSeconds?: number | null): void;
    readonly sign: object;
    sign_impl(appId: string, challenge: string, registeredKeys: RegisteredKey[], callback: U2FSignCallback, opt_timeoutSeconds?: number | null): void;
  }
  class UDPMessageEvent {
    readonly remoteAddress: string;
    readonly remotePort: number;
    readonly data: any;
    readonly isTrusted: boolean;
  }
  interface UDPMessageEventInit {
    data?: any
    remoteAddress?: string
    remotePort?: number
  }
  interface UDPOptions {
    addressReuse?: boolean
    localAddress?: string
    localPort?: number
    loopback?: boolean
    remoteAddress?: string
    remotePort?: number
  }
  class UDPSocket {
    readonly localAddress: string | null;
    readonly localPort: number | null;
    readonly remoteAddress: string | null;
    readonly remotePort: number | null;
    readonly addressReuse: boolean;
    readonly loopback: boolean;
    readonly readyState: SocketReadyState;
    readonly opened: Promise<void>;
    readonly closed: Promise<void>;
    onmessage: EventHandlerNonNull | null;
    close(): Promise<void>;
    joinMulticastGroup(multicastGroupAddress: string): void;
    leaveMulticastGroup(multicastGroupAddress: string): void;
    send(data: string | Blob | ArrayBuffer | ArrayBufferView, remoteAddress?: string | null, remotePort?: number | null): boolean;
  }
  class UIEvent {
    readonly view: WindowProxy | null;
    readonly detail: number;
    initUIEvent(aType: string, aCanBubble?: boolean, aCancelable?: boolean, aView?: Window | null, aDetail?: number): void;
    readonly layerX: number;
    readonly layerY: number;
    readonly which: number;
    readonly rangeParent: Node | null;
    readonly rangeOffset: number;
    readonly isTrusted: boolean;
  }
  interface UIEventInit {
    detail?: number
    view?: Window | null
  }
  interface EventModifierInit {
    altKey?: boolean
    ctrlKey?: boolean
    metaKey?: boolean
    modifierAltGraph?: boolean
    modifierCapsLock?: boolean
    modifierFn?: boolean
    modifierFnLock?: boolean
    modifierNumLock?: boolean
    modifierOS?: boolean
    modifierScrollLock?: boolean
    modifierSymbol?: boolean
    modifierSymbolLock?: boolean
    shiftKey?: boolean
  }
  class URL {
    href: string;
    readonly origin: string;
    protocol: string;
    username: string;
    password: string;
    host: string;
    hostname: string;
    port: string;
    pathname: string;
    search: string;
    readonly searchParams: URLSearchParams;
    hash: string;
    toJSON(): string;
    createObjectURL(blob: Blob): string;
    createObjectURL(source: MediaSource): string;
    revokeObjectURL(url: string): void;
    isValidURL(url: string): boolean;
    __stringifier(): string;
  }
  class URLSearchParams {
    append(name: string, value: string): void;
    delete(name: string): void;
    get(name: string): string | null;
    getAll(name: string): string[];
    has(name: string): boolean;
    set(name: string, value: string): void;
    sort(): void;
    __stringifier(): string;
    entries(): URLSearchParamsIterator;
    keys(): URLSearchParamsIterator;
    values(): URLSearchParamsIterator;
    forEach(callback: object, thisArg?: any): void;
  }
  class UserProximityEvent {
    readonly near: boolean;
    readonly isTrusted: boolean;
  }
  interface UserProximityEventInit {
    near?: boolean
  }
  enum VREye {
    Left = "left",
    Right = "right",
  }
  class VRFieldOfView {
    readonly upDegrees: number;
    readonly rightDegrees: number;
    readonly downDegrees: number;
    readonly leftDegrees: number;
  }
  interface VRLayer {
    leftBounds?: number[]
    rightBounds?: number[]
    source?: HTMLCanvasElement | null
  }
  class VRDisplayCapabilities {
    readonly hasPosition: boolean;
    readonly hasOrientation: boolean;
    readonly hasExternalDisplay: boolean;
    readonly canPresent: boolean;
    readonly maxLayers: number;
  }
  class VRStageParameters {
    readonly sittingToStandingTransform: Float32Array;
    readonly sizeX: number;
    readonly sizeZ: number;
  }
  class VRPose {
    readonly position: Float32Array | null;
    readonly linearVelocity: Float32Array | null;
    readonly linearAcceleration: Float32Array | null;
    readonly orientation: Float32Array | null;
    readonly angularVelocity: Float32Array | null;
    readonly angularAcceleration: Float32Array | null;
  }
  class VRFrameData {
    readonly timestamp: number;
    readonly leftProjectionMatrix: Float32Array;
    readonly leftViewMatrix: Float32Array;
    readonly rightProjectionMatrix: Float32Array;
    readonly rightViewMatrix: Float32Array;
    readonly pose: VRPose;
  }
  class VREyeParameters {
    readonly offset: Float32Array;
    readonly fieldOfView: VRFieldOfView;
    readonly renderWidth: number;
    readonly renderHeight: number;
  }
  class VRDisplay {
    readonly presentingGroups: number;
    groupMask: number;
    readonly isConnected: boolean;
    readonly isPresenting: boolean;
    readonly capabilities: VRDisplayCapabilities;
    readonly stageParameters: VRStageParameters | null;
    getEyeParameters(whichEye: VREye): VREyeParameters;
    readonly displayId: number;
    readonly displayName: string;
    getFrameData(frameData: VRFrameData): boolean;
    getPose(): VRPose;
    resetPose(): void;
    depthNear: number;
    depthFar: number;
    requestAnimationFrame(callback: FrameRequestCallback): number;
    cancelAnimationFrame(handle: number): void;
    requestPresent(layers: VRLayer[]): Promise<void>;
    exitPresent(): Promise<void>;
    getLayers(): VRLayer[];
    submitFrame(): void;
  }
  enum VRDisplayEventReason {
    Mounted = "mounted",
    Navigation = "navigation",
    Requested = "requested",
    Unmounted = "unmounted",
  }
  interface VRDisplayEventInit {
    display: VRDisplay
    reason?: VRDisplayEventReason
  }
  class VRDisplayEvent {
    readonly display: VRDisplay;
    readonly reason: VRDisplayEventReason | null;
    readonly isTrusted: boolean;
  }
  class VRMockDisplay {
    create(): void;
    capPosition: boolean;
    capOrientation: boolean;
    capPresent: boolean;
    capExternal: boolean;
    capAngularAcceleration: boolean;
    capLinearAcceleration: boolean;
    capStageParameters: boolean;
    capMountDetection: boolean;
    capPositionEmulated: boolean;
    setEyeFOV(eye: VREye, upDegree: number, rightDegree: number, downDegree: number, leftDegree: number): void;
    setEyeOffset(eye: VREye, offsetX: number, offsetY: number, offsetZ: number): void;
    setEyeResolution(renderWidth: number, renderHeight: number): void;
    setConnected(connected: boolean): void;
    setMounted(mounted: boolean): void;
    setStageSize(width: number, height: number): void;
    setSittingToStandingTransform(sittingToStandingTransform: Float32Array): void;
    setPose(position: Float32Array | null, linearVelocity: Float32Array | null, linearAcceleration: Float32Array | null, orientation: Float32Array | null, angularVelocity: Float32Array | null, angularAcceleration: Float32Array | null): void;
  }
  class VRMockController {
    create(): void;
    clear(): void;
    hand: GamepadHand;
    capPosition: boolean;
    capOrientation: boolean;
    capAngularAcceleration: boolean;
    capLinearAcceleration: boolean;
    axisCount: number;
    buttonCount: number;
    hapticCount: number;
    setPose(position: Float32Array | null, linearVelocity: Float32Array | null, linearAcceleration: Float32Array | null, orientation: Float32Array | null, angularVelocity: Float32Array | null, angularAcceleration: Float32Array | null): void;
    setButtonPressed(buttonIdx: number, pressed: boolean): void;
    setButtonTouched(buttonIdx: number, touched: boolean): void;
    setButtonTrigger(buttonIdx: number, trigger: number): void;
    setAxisValue(axisIdx: number, value: number): void;
  }
  class VRServiceTest {
    getVRDisplay(): VRMockDisplay;
    getVRController(controllerIdx: number): VRMockController;
    run(): Promise<void>;
    reset(): Promise<void>;
    commit(): void;
    end(): void;
    clearAll(): void;
    timeout(duration: number): void;
    wait(duration: number): void;
    waitSubmit(): void;
    waitPresentationStart(): void;
    waitPresentationEnd(): void;
    waitHapticIntensity(controllerIdx: number, hapticIdx: number, intensity: number): void;
    captureFrame(): void;
    acknowledgeFrame(): void;
    rejectFrame(): void;
    startTimer(): void;
    stopTimer(): void;
  }
  enum AutoKeyword {
    Auto = "auto",
  }
  enum LineAlignSetting {
    Start = "start",
    Center = "center",
    End = "end",
  }
  enum PositionAlignSetting {
    Line_left = "line-left",
    Center = "center",
    Line_right = "line-right",
    Auto = "auto",
  }
  enum AlignSetting {
    Start = "start",
    Center = "center",
    End = "end",
    Left = "left",
    Right = "right",
  }
  enum DirectionSetting {
    _empty = "",
    Rl = "rl",
    Lr = "lr",
  }
  class VTTCue {
    region: VTTRegion | null;
    vertical: DirectionSetting;
    snapToLines: boolean;
    line: number | AutoKeyword;
    lineAlign: LineAlignSetting;
    position: number | AutoKeyword;
    positionAlign: PositionAlignSetting;
    size: number;
    align: AlignSetting;
    text: string;
    getCueAsHTML(): DocumentFragment;
    displayState: HTMLDivElement | null;
    readonly hasBeenReset: boolean;
    readonly computedLine: number;
    readonly computedPosition: number;
    readonly computedPositionAlign: PositionAlignSetting;
    readonly getActive: boolean;
  }
  enum ScrollSetting {
    _empty = "",
    Up = "up",
  }
  class VTTRegion {
    id: string;
    width: number;
    lines: number;
    regionAnchorX: number;
    regionAnchorY: number;
    viewportAnchorX: number;
    viewportAnchorY: number;
    scroll: ScrollSetting;
  }
  class ValidityState {
    readonly valueMissing: boolean;
    readonly typeMismatch: boolean;
    readonly patternMismatch: boolean;
    readonly tooLong: boolean;
    readonly tooShort: boolean;
    readonly rangeUnderflow: boolean;
    readonly rangeOverflow: boolean;
    readonly stepMismatch: boolean;
    readonly badInput: boolean;
    readonly customError: boolean;
    readonly valid: boolean;
  }
  class VideoPlaybackQuality {
    readonly creationTime: number;
    readonly totalVideoFrames: number;
    readonly droppedVideoFrames: number;
  }
  class VideoTrack {
    readonly id: string;
    readonly kind: string;
    readonly label: string;
    readonly language: string;
    selected: boolean;
  }
  class VideoTrackList {
    readonly length: number;
    __indexedgetter(index: number): VideoTrack;
    getTrackById(id: string): VideoTrack | null;
    readonly selectedIndex: number;
    onchange: EventHandlerNonNull | null;
    onaddtrack: EventHandlerNonNull | null;
    onremovetrack: EventHandlerNonNull | null;
  }
  class VisualViewport {
    readonly offsetLeft: number;
    readonly offsetTop: number;
    readonly pageLeft: number;
    readonly pageTop: number;
    readonly width: number;
    readonly height: number;
    readonly scale: number;
    onresize: EventHandlerNonNull | null;
    onscroll: EventHandlerNonNull | null;
  }
  enum OverSampleType {
    None = "none",
    _x = "2x",
    _x = "4x",
  }
  interface WaveShaperOptions {
    curve?: number[]
    oversample?: OverSampleType
  }
  class WaveShaperNode {
    curve: Float32Array | null;
    oversample: OverSampleType;
    passThrough: boolean;
  }
  class PublicKeyCredential {
    readonly rawId: ArrayBuffer;
    readonly response: AuthenticatorResponse;
    getClientExtensionResults(): AuthenticationExtensionsClientOutputs;
    isUserVerifyingPlatformAuthenticatorAvailable(): Promise<boolean>;
    isExternalCTAP2SecurityKeySupported(): Promise<boolean>;
  }
  class AuthenticatorResponse {
    readonly clientDataJSON: ArrayBuffer;
  }
  class AuthenticatorAttestationResponse {
    readonly attestationObject: ArrayBuffer;
  }
  class AuthenticatorAssertionResponse {
    readonly authenticatorData: ArrayBuffer;
    readonly signature: ArrayBuffer;
    readonly userHandle: ArrayBuffer | null;
  }
  interface PublicKeyCredentialParameters {
    alg: number
    type: PublicKeyCredentialType
  }
  interface PublicKeyCredentialCreationOptions {
    attestation?: AttestationConveyancePreference
    authenticatorSelection?: AuthenticatorSelectionCriteria
    challenge: ArrayBufferView | ArrayBuffer
    excludeCredentials?: PublicKeyCredentialDescriptor[]
    extensions?: AuthenticationExtensionsClientInputs
    pubKeyCredParams: PublicKeyCredentialParameters[]
    rp: PublicKeyCredentialRpEntity
    timeout?: number
    user: PublicKeyCredentialUserEntity
  }
  interface PublicKeyCredentialEntity {
    icon?: string
    name: string
  }
  interface PublicKeyCredentialRpEntity {
    id?: string
  }
  interface PublicKeyCredentialUserEntity {
    displayName: string
    id: ArrayBufferView | ArrayBuffer
  }
  interface AuthenticatorSelectionCriteria {
    authenticatorAttachment?: AuthenticatorAttachment
    requireResidentKey?: boolean
    userVerification?: UserVerificationRequirement
  }
  enum AuthenticatorAttachment {
    Platform = "platform",
    Cross_platform = "cross-platform",
  }
  enum AttestationConveyancePreference {
    None = "none",
    Indirect = "indirect",
    Direct = "direct",
  }
  enum UserVerificationRequirement {
    Required = "required",
    Preferred = "preferred",
    Discouraged = "discouraged",
  }
  interface PublicKeyCredentialRequestOptions {
    allowCredentials?: PublicKeyCredentialDescriptor[]
    challenge: ArrayBufferView | ArrayBuffer
    extensions?: AuthenticationExtensionsClientInputs
    rpId?: string
    timeout?: number
    userVerification?: UserVerificationRequirement
  }
  interface AuthenticationExtensionsClientInputs {
    appid?: string
    hmacCreateSecret?: boolean
  }
  interface AuthenticationExtensionsClientOutputs {
    appid?: boolean
    hmacCreateSecret?: boolean
  }
  interface CollectedClientData {
    authenticatorExtensions?: Record<string, string>
    challenge: string
    clientExtensions?: AuthenticationExtensionsClientInputs
    hashAlgorithm: string
    origin: string
    tokenBindingId?: string
    type: string
  }
  enum PublicKeyCredentialType {
    Public_key = "public-key",
  }
  interface PublicKeyCredentialDescriptor {
    id: ArrayBufferView | ArrayBuffer
    transports?: string[]
    type: PublicKeyCredentialType
  }
  enum AuthenticatorTransport {
    Usb = "usb",
    Nfc = "nfc",
    Ble = "ble",
    Internal = "internal",
  }
  function LifecycleConnectedCallback(): void;
  function LifecycleDisconnectedCallback(): void;
  function LifecycleAdoptedCallback(oldDocument: Document | null, newDocment: Document | null): void;
  function LifecycleAttributeChangedCallback(attrName: string, oldValue: string | null, newValue: string | null, namespaceURI: string | null): void;
  function LifecycleGetCustomInterfaceCallback(iid: any): object | null;
  interface LifecycleCallbacks {
    adoptedCallback?: LifecycleAdoptedCallback
    attributeChangedCallback?: LifecycleAttributeChangedCallback
    connectedCallback?: LifecycleConnectedCallback
    disconnectedCallback?: LifecycleDisconnectedCallback
    getCustomInterfaceCallback?: LifecycleGetCustomInterfaceCallback
  }
  class WebGLSampler {
  }
  class WebGLSync {
  }
  class WebGLTransformFeedback {
  }
  class WebGL2RenderingContext {
    bufferData(target: number, size: number, usage: number): void;
    bufferData(target: number, srcData: ArrayBuffer | null, usage: number): void;
    bufferData(target: number, srcData: ArrayBufferView, usage: number): void;
    bufferData(target: number, srcData: ArrayBufferView, usage: number, srcOffset: number, length?: number): void;
    bufferSubData(target: number, offset: number, srcData: ArrayBuffer): void;
    bufferSubData(target: number, offset: number, srcData: ArrayBufferView): void;
    bufferSubData(target: number, dstByteOffset: number, srcData: ArrayBufferView, srcOffset: number, length?: number): void;
    copyBufferSubData(readTarget: number, writeTarget: number, readOffset: number, writeOffset: number, size: number): void;
    getBufferSubData(target: number, srcByteOffset: number, dstData: ArrayBufferView, dstOffset?: number, length?: number): void;
    blitFramebuffer(srcX0: number, srcY0: number, srcX1: number, srcY1: number, dstX0: number, dstY0: number, dstX1: number, dstY1: number, mask: number, filter: number): void;
    framebufferTextureLayer(target: number, attachment: number, texture: WebGLTexture | null, level: number, layer: number): void;
    invalidateFramebuffer(target: number, attachments: number[]): void;
    invalidateSubFramebuffer(target: number, attachments: number[], x: number, y: number, width: number, height: number): void;
    readBuffer(src: number): void;
    getInternalformatParameter(target: number, internalformat: number, pname: number): any;
    renderbufferStorageMultisample(target: number, samples: number, internalformat: number, width: number, height: number): void;
    texStorage2D(target: number, levels: number, internalformat: number, width: number, height: number): void;
    texStorage3D(target: number, levels: number, internalformat: number, width: number, height: number, depth: number): void;
    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: ArrayBufferView | null): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, source: HTMLCanvasElement): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, source: HTMLImageElement): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, source: HTMLVideoElement): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, source: ImageBitmap): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, source: ImageData): void;
    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pboOffset: number): void;
    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, source: HTMLCanvasElement): void;
    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, source: HTMLImageElement): void;
    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, source: HTMLVideoElement): void;
    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, source: ImageBitmap): void;
    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, source: ImageData): void;
    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, srcData: ArrayBufferView, srcOffset: number): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView | null): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, source: HTMLCanvasElement): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, source: HTMLImageElement): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, source: HTMLVideoElement): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, source: ImageBitmap): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, source: ImageData): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, pboOffset: number): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, source: HTMLCanvasElement): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, source: HTMLImageElement): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, source: HTMLVideoElement): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, source: ImageBitmap): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, source: ImageData): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, srcData: ArrayBufferView, srcOffset: number): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pboOffset: number): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, source: HTMLCanvasElement): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, source: HTMLImageElement): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, source: HTMLVideoElement): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, source: ImageBitmap): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, source: ImageData): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, srcData: ArrayBufferView | null): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, srcData: ArrayBufferView, srcOffset: number): void;
    texSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, type: number, pboOffset: number): void;
    texSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, type: number, source: HTMLCanvasElement): void;
    texSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, type: number, source: HTMLImageElement): void;
    texSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, type: number, source: HTMLVideoElement): void;
    texSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, type: number, source: ImageBitmap): void;
    texSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, type: number, source: ImageData): void;
    texSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, type: number, srcData: ArrayBufferView | null, srcOffset?: number): void;
    copyTexSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, x: number, y: number, width: number, height: number): void;
    compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, imageSize: number, offset: number): void;
    compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, srcData: ArrayBufferView, srcOffset?: number, srcLengthOverride?: number): void;
    compressedTexImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, imageSize: number, offset: number): void;
    compressedTexImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, srcData: ArrayBufferView, srcOffset?: number, srcLengthOverride?: number): void;
    compressedTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, imageSize: number, offset: number): void;
    compressedTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, srcData: ArrayBufferView, srcOffset?: number, srcLengthOverride?: number): void;
    compressedTexSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, imageSize: number, offset: number): void;
    compressedTexSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, srcData: ArrayBufferView, srcOffset?: number, srcLengthOverride?: number): void;
    getFragDataLocation(program: WebGLProgram, name: string): number;
    uniform1ui(location: WebGLUniformLocation | null, v0: number): void;
    uniform2ui(location: WebGLUniformLocation | null, v0: number, v1: number): void;
    uniform3ui(location: WebGLUniformLocation | null, v0: number, v1: number, v2: number): void;
    uniform4ui(location: WebGLUniformLocation | null, v0: number, v1: number, v2: number, v3: number): void;
    uniform1fv(location: WebGLUniformLocation | null, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform2fv(location: WebGLUniformLocation | null, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform3fv(location: WebGLUniformLocation | null, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform4fv(location: WebGLUniformLocation | null, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform1iv(location: WebGLUniformLocation | null, data: Int32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform2iv(location: WebGLUniformLocation | null, data: Int32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform3iv(location: WebGLUniformLocation | null, data: Int32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform4iv(location: WebGLUniformLocation | null, data: Int32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform1uiv(location: WebGLUniformLocation | null, data: Uint32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform2uiv(location: WebGLUniformLocation | null, data: Uint32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform3uiv(location: WebGLUniformLocation | null, data: Uint32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniform4uiv(location: WebGLUniformLocation | null, data: Uint32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniformMatrix3x2fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniformMatrix4x2fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniformMatrix2x3fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniformMatrix4x3fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniformMatrix2x4fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniformMatrix3x4fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[], srcOffset?: number, srcLength?: number): void;
    vertexAttribI4i(index: number, x: number, y: number, z: number, w: number): void;
    vertexAttribI4iv(index: number, values: Int32Array | number[]): void;
    vertexAttribI4ui(index: number, x: number, y: number, z: number, w: number): void;
    vertexAttribI4uiv(index: number, values: Uint32Array | number[]): void;
    vertexAttribIPointer(index: number, size: number, type: number, stride: number, offset: number): void;
    vertexAttribDivisor(index: number, divisor: number): void;
    drawArraysInstanced(mode: number, first: number, count: number, instanceCount: number): void;
    drawElementsInstanced(mode: number, count: number, type: number, offset: number, instanceCount: number): void;
    drawRangeElements(mode: number, start: number, end: number, count: number, type: number, offset: number): void;
    readPixels(x: number, y: number, width: number, height: number, format: number, type: number, dstData: ArrayBufferView | null): void;
    readPixels(x: number, y: number, width: number, height: number, format: number, type: number, offset: number): void;
    readPixels(x: number, y: number, width: number, height: number, format: number, type: number, dstData: ArrayBufferView, dstOffset: number): void;
    drawBuffers(buffers: number[]): void;
    clearBufferfv(buffer: number, drawbuffer: number, values: Float32Array | number[], srcOffset?: number): void;
    clearBufferiv(buffer: number, drawbuffer: number, values: Int32Array | number[], srcOffset?: number): void;
    clearBufferuiv(buffer: number, drawbuffer: number, values: Uint32Array | number[], srcOffset?: number): void;
    clearBufferfi(buffer: number, drawbuffer: number, depth: number, stencil: number): void;
    createQuery(): WebGLQuery | null;
    deleteQuery(query: WebGLQuery | null): void;
    isQuery(query: WebGLQuery | null): boolean;
    beginQuery(target: number, query: WebGLQuery): void;
    endQuery(target: number): void;
    getQuery(target: number, pname: number): any;
    getQueryParameter(query: WebGLQuery, pname: number): any;
    createSampler(): WebGLSampler | null;
    deleteSampler(sampler: WebGLSampler | null): void;
    isSampler(sampler: WebGLSampler | null): boolean;
    bindSampler(unit: number, sampler: WebGLSampler | null): void;
    samplerParameteri(sampler: WebGLSampler, pname: number, param: number): void;
    samplerParameterf(sampler: WebGLSampler, pname: number, param: number): void;
    getSamplerParameter(sampler: WebGLSampler, pname: number): any;
    fenceSync(condition: number, flags: number): WebGLSync | null;
    isSync(sync: WebGLSync | null): boolean;
    deleteSync(sync: WebGLSync | null): void;
    clientWaitSync(sync: WebGLSync, flags: number, timeout: number): number;
    waitSync(sync: WebGLSync, flags: number, timeout: number): void;
    getSyncParameter(sync: WebGLSync, pname: number): any;
    createTransformFeedback(): WebGLTransformFeedback | null;
    deleteTransformFeedback(tf: WebGLTransformFeedback | null): void;
    isTransformFeedback(tf: WebGLTransformFeedback | null): boolean;
    bindTransformFeedback(target: number, tf: WebGLTransformFeedback | null): void;
    beginTransformFeedback(primitiveMode: number): void;
    endTransformFeedback(): void;
    transformFeedbackVaryings(program: WebGLProgram, varyings: string[], bufferMode: number): void;
    getTransformFeedbackVarying(program: WebGLProgram, index: number): WebGLActiveInfo | null;
    pauseTransformFeedback(): void;
    resumeTransformFeedback(): void;
    bindBufferBase(target: number, index: number, buffer: WebGLBuffer | null): void;
    bindBufferRange(target: number, index: number, buffer: WebGLBuffer | null, offset: number, size: number): void;
    getIndexedParameter(target: number, index: number): any;
    getUniformIndices(program: WebGLProgram, uniformNames: string[]): number[] | null;
    getActiveUniforms(program: WebGLProgram, uniformIndices: number[], pname: number): any;
    getUniformBlockIndex(program: WebGLProgram, uniformBlockName: string): number;
    getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: number, pname: number): any;
    getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: number): string | null;
    uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: number, uniformBlockBinding: number): void;
    createVertexArray(): WebGLVertexArrayObject | null;
    deleteVertexArray(vertexArray: WebGLVertexArrayObject | null): void;
    isVertexArray(vertexArray: WebGLVertexArrayObject | null): boolean;
    bindVertexArray(array: WebGLVertexArrayObject | null): void;
    readonly canvas: HTMLCanvasElement | OffscreenCanvas | null;
    readonly drawingBufferWidth: number;
    readonly drawingBufferHeight: number;
    getContextAttributes(): WebGLContextAttributes | null;
    isContextLost(): boolean;
    getSupportedExtensions(): string[] | null;
    getExtension(name: string): object | null;
    activeTexture(texture: number): void;
    attachShader(program: WebGLProgram, shader: WebGLShader): void;
    bindAttribLocation(program: WebGLProgram, index: number, name: string): void;
    bindBuffer(target: number, buffer: WebGLBuffer | null): void;
    bindFramebuffer(target: number, framebuffer: WebGLFramebuffer | null): void;
    bindRenderbuffer(target: number, renderbuffer: WebGLRenderbuffer | null): void;
    bindTexture(target: number, texture: WebGLTexture | null): void;
    blendColor(red: number, green: number, blue: number, alpha: number): void;
    blendEquation(mode: number): void;
    blendEquationSeparate(modeRGB: number, modeAlpha: number): void;
    blendFunc(sfactor: number, dfactor: number): void;
    blendFuncSeparate(srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;
    checkFramebufferStatus(target: number): number;
    clear(mask: number): void;
    clearColor(red: number, green: number, blue: number, alpha: number): void;
    clearDepth(depth: number): void;
    clearStencil(s: number): void;
    colorMask(red: boolean, green: boolean, blue: boolean, alpha: boolean): void;
    compileShader(shader: WebGLShader): void;
    copyTexImage2D(target: number, level: number, internalformat: number, x: number, y: number, width: number, height: number, border: number): void;
    copyTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
    createBuffer(): WebGLBuffer | null;
    createFramebuffer(): WebGLFramebuffer | null;
    createProgram(): WebGLProgram | null;
    createRenderbuffer(): WebGLRenderbuffer | null;
    createShader(type: number): WebGLShader | null;
    createTexture(): WebGLTexture | null;
    cullFace(mode: number): void;
    deleteBuffer(buffer: WebGLBuffer | null): void;
    deleteFramebuffer(framebuffer: WebGLFramebuffer | null): void;
    deleteProgram(program: WebGLProgram | null): void;
    deleteRenderbuffer(renderbuffer: WebGLRenderbuffer | null): void;
    deleteShader(shader: WebGLShader | null): void;
    deleteTexture(texture: WebGLTexture | null): void;
    depthFunc(func: number): void;
    depthMask(flag: boolean): void;
    depthRange(zNear: number, zFar: number): void;
    detachShader(program: WebGLProgram, shader: WebGLShader): void;
    disable(cap: number): void;
    disableVertexAttribArray(index: number): void;
    drawArrays(mode: number, first: number, count: number): void;
    drawElements(mode: number, count: number, type: number, offset: number): void;
    enable(cap: number): void;
    enableVertexAttribArray(index: number): void;
    finish(): void;
    flush(): void;
    framebufferRenderbuffer(target: number, attachment: number, renderbuffertarget: number, renderbuffer: WebGLRenderbuffer | null): void;
    framebufferTexture2D(target: number, attachment: number, textarget: number, texture: WebGLTexture | null, level: number): void;
    frontFace(mode: number): void;
    generateMipmap(target: number): void;
    getActiveAttrib(program: WebGLProgram, index: number): WebGLActiveInfo | null;
    getActiveUniform(program: WebGLProgram, index: number): WebGLActiveInfo | null;
    getAttachedShaders(program: WebGLProgram): WebGLShader[] | null;
    getAttribLocation(program: WebGLProgram, name: string): number;
    getBufferParameter(target: number, pname: number): any;
    getParameter(pname: number): any;
    getError(): number;
    getFramebufferAttachmentParameter(target: number, attachment: number, pname: number): any;
    getProgramParameter(program: WebGLProgram, pname: number): any;
    getProgramInfoLog(program: WebGLProgram): string | null;
    getRenderbufferParameter(target: number, pname: number): any;
    getShaderParameter(shader: WebGLShader, pname: number): any;
    getShaderPrecisionFormat(shadertype: number, precisiontype: number): WebGLShaderPrecisionFormat | null;
    getShaderInfoLog(shader: WebGLShader): string | null;
    getShaderSource(shader: WebGLShader): string | null;
    getTexParameter(target: number, pname: number): any;
    getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;
    getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation | null;
    getVertexAttrib(index: number, pname: number): any;
    getVertexAttribOffset(index: number, pname: number): number;
    hint(target: number, mode: number): void;
    isBuffer(buffer: WebGLBuffer | null): boolean;
    isEnabled(cap: number): boolean;
    isFramebuffer(framebuffer: WebGLFramebuffer | null): boolean;
    isProgram(program: WebGLProgram | null): boolean;
    isRenderbuffer(renderbuffer: WebGLRenderbuffer | null): boolean;
    isShader(shader: WebGLShader | null): boolean;
    isTexture(texture: WebGLTexture | null): boolean;
    lineWidth(width: number): void;
    linkProgram(program: WebGLProgram): void;
    pixelStorei(pname: number, param: number): void;
    polygonOffset(factor: number, units: number): void;
    renderbufferStorage(target: number, internalformat: number, width: number, height: number): void;
    sampleCoverage(value: number, invert: boolean): void;
    scissor(x: number, y: number, width: number, height: number): void;
    shaderSource(shader: WebGLShader, source: string): void;
    stencilFunc(func: number, ref: number, mask: number): void;
    stencilFuncSeparate(face: number, func: number, ref: number, mask: number): void;
    stencilMask(mask: number): void;
    stencilMaskSeparate(face: number, mask: number): void;
    stencilOp(fail: number, zfail: number, zpass: number): void;
    stencilOpSeparate(face: number, fail: number, zfail: number, zpass: number): void;
    texParameterf(target: number, pname: number, param: number): void;
    texParameteri(target: number, pname: number, param: number): void;
    uniform1f(location: WebGLUniformLocation | null, x: number): void;
    uniform2f(location: WebGLUniformLocation | null, x: number, y: number): void;
    uniform3f(location: WebGLUniformLocation | null, x: number, y: number, z: number): void;
    uniform4f(location: WebGLUniformLocation | null, x: number, y: number, z: number, w: number): void;
    uniform1i(location: WebGLUniformLocation | null, x: number): void;
    uniform2i(location: WebGLUniformLocation | null, x: number, y: number): void;
    uniform3i(location: WebGLUniformLocation | null, x: number, y: number, z: number): void;
    uniform4i(location: WebGLUniformLocation | null, x: number, y: number, z: number, w: number): void;
    useProgram(program: WebGLProgram | null): void;
    validateProgram(program: WebGLProgram): void;
    vertexAttrib1f(indx: number, x: number): void;
    vertexAttrib1fv(indx: number, values: Float32Array | number[]): void;
    vertexAttrib2f(indx: number, x: number, y: number): void;
    vertexAttrib2fv(indx: number, values: Float32Array | number[]): void;
    vertexAttrib3f(indx: number, x: number, y: number, z: number): void;
    vertexAttrib3fv(indx: number, values: Float32Array | number[]): void;
    vertexAttrib4f(indx: number, x: number, y: number, z: number, w: number): void;
    vertexAttrib4fv(indx: number, values: Float32Array | number[]): void;
    vertexAttribPointer(indx: number, size: number, type: number, normalized: boolean, stride: number, offset: number): void;
    viewport(x: number, y: number, width: number, height: number): void;
    makeXRCompatible(): Promise<void>;
  }
  class EXT_color_buffer_float {
  }
  class OVR_multiview2 {
    framebufferTextureMultiviewOVR(target: number, attachment: number, texture: WebGLTexture | null, level: number, baseViewIndex: number, numViews: number): void;
  }
  class WebGLContextEvent {
    readonly statusMessage: string;
    readonly isTrusted: boolean;
  }
  interface WebGLContextEventInit {
    statusMessage?: string
  }
  enum WebGLPowerPreference {
    Default = "default",
    Low_power = "low-power",
    High_performance = "high-performance",
  }
  interface WebGLContextAttributes {
    alpha?: boolean
    antialias?: boolean
    depth?: boolean
    failIfMajorPerformanceCaveat?: boolean
    powerPreference?: WebGLPowerPreference
    premultipliedAlpha?: boolean
    preserveDrawingBuffer?: boolean
    stencil?: boolean
    xrCompatible?: boolean
  }
  class WebGLBuffer {
  }
  class WebGLFramebuffer {
  }
  class WebGLProgram {
  }
  class WebGLRenderbuffer {
  }
  class WebGLShader {
  }
  class WebGLTexture {
  }
  class WebGLUniformLocation {
  }
  class WebGLVertexArrayObject {
  }
  class WebGLActiveInfo {
    readonly size: number;
    readonly type: number;
    readonly name: string;
  }
  class WebGLShaderPrecisionFormat {
    readonly rangeMin: number;
    readonly rangeMax: number;
    readonly precision: number;
  }
  class WebGLRenderingContext {
    bufferData(target: number, size: number, usage: number): void;
    bufferData(target: number, data: ArrayBuffer | null, usage: number): void;
    bufferData(target: number, data: ArrayBufferView, usage: number): void;
    bufferSubData(target: number, offset: number, data: ArrayBuffer): void;
    bufferSubData(target: number, offset: number, data: ArrayBufferView): void;
    compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, data: ArrayBufferView): void;
    compressedTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, data: ArrayBufferView): void;
    readPixels(x: number, y: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView | null): void;
    texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: ArrayBufferView | null): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, pixels: ImageBitmap): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, pixels: ImageData): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, image: HTMLImageElement): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, canvas: HTMLCanvasElement): void;
    texImage2D(target: number, level: number, internalformat: number, format: number, type: number, video: HTMLVideoElement): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView | null): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, pixels: ImageBitmap): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, pixels: ImageData): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, image: HTMLImageElement): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, canvas: HTMLCanvasElement): void;
    texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, video: HTMLVideoElement): void;
    uniform1fv(location: WebGLUniformLocation | null, data: Float32Array | number[]): void;
    uniform2fv(location: WebGLUniformLocation | null, data: Float32Array | number[]): void;
    uniform3fv(location: WebGLUniformLocation | null, data: Float32Array | number[]): void;
    uniform4fv(location: WebGLUniformLocation | null, data: Float32Array | number[]): void;
    uniform1iv(location: WebGLUniformLocation | null, data: Int32Array | number[]): void;
    uniform2iv(location: WebGLUniformLocation | null, data: Int32Array | number[]): void;
    uniform3iv(location: WebGLUniformLocation | null, data: Int32Array | number[]): void;
    uniform4iv(location: WebGLUniformLocation | null, data: Int32Array | number[]): void;
    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[]): void;
    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[]): void;
    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: boolean, data: Float32Array | number[]): void;
    commit(): void;
    readonly canvas: HTMLCanvasElement | OffscreenCanvas | null;
    readonly drawingBufferWidth: number;
    readonly drawingBufferHeight: number;
    getContextAttributes(): WebGLContextAttributes | null;
    isContextLost(): boolean;
    getSupportedExtensions(): string[] | null;
    getExtension(name: string): object | null;
    activeTexture(texture: number): void;
    attachShader(program: WebGLProgram, shader: WebGLShader): void;
    bindAttribLocation(program: WebGLProgram, index: number, name: string): void;
    bindBuffer(target: number, buffer: WebGLBuffer | null): void;
    bindFramebuffer(target: number, framebuffer: WebGLFramebuffer | null): void;
    bindRenderbuffer(target: number, renderbuffer: WebGLRenderbuffer | null): void;
    bindTexture(target: number, texture: WebGLTexture | null): void;
    blendColor(red: number, green: number, blue: number, alpha: number): void;
    blendEquation(mode: number): void;
    blendEquationSeparate(modeRGB: number, modeAlpha: number): void;
    blendFunc(sfactor: number, dfactor: number): void;
    blendFuncSeparate(srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;
    checkFramebufferStatus(target: number): number;
    clear(mask: number): void;
    clearColor(red: number, green: number, blue: number, alpha: number): void;
    clearDepth(depth: number): void;
    clearStencil(s: number): void;
    colorMask(red: boolean, green: boolean, blue: boolean, alpha: boolean): void;
    compileShader(shader: WebGLShader): void;
    copyTexImage2D(target: number, level: number, internalformat: number, x: number, y: number, width: number, height: number, border: number): void;
    copyTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
    createBuffer(): WebGLBuffer | null;
    createFramebuffer(): WebGLFramebuffer | null;
    createProgram(): WebGLProgram | null;
    createRenderbuffer(): WebGLRenderbuffer | null;
    createShader(type: number): WebGLShader | null;
    createTexture(): WebGLTexture | null;
    cullFace(mode: number): void;
    deleteBuffer(buffer: WebGLBuffer | null): void;
    deleteFramebuffer(framebuffer: WebGLFramebuffer | null): void;
    deleteProgram(program: WebGLProgram | null): void;
    deleteRenderbuffer(renderbuffer: WebGLRenderbuffer | null): void;
    deleteShader(shader: WebGLShader | null): void;
    deleteTexture(texture: WebGLTexture | null): void;
    depthFunc(func: number): void;
    depthMask(flag: boolean): void;
    depthRange(zNear: number, zFar: number): void;
    detachShader(program: WebGLProgram, shader: WebGLShader): void;
    disable(cap: number): void;
    disableVertexAttribArray(index: number): void;
    drawArrays(mode: number, first: number, count: number): void;
    drawElements(mode: number, count: number, type: number, offset: number): void;
    enable(cap: number): void;
    enableVertexAttribArray(index: number): void;
    finish(): void;
    flush(): void;
    framebufferRenderbuffer(target: number, attachment: number, renderbuffertarget: number, renderbuffer: WebGLRenderbuffer | null): void;
    framebufferTexture2D(target: number, attachment: number, textarget: number, texture: WebGLTexture | null, level: number): void;
    frontFace(mode: number): void;
    generateMipmap(target: number): void;
    getActiveAttrib(program: WebGLProgram, index: number): WebGLActiveInfo | null;
    getActiveUniform(program: WebGLProgram, index: number): WebGLActiveInfo | null;
    getAttachedShaders(program: WebGLProgram): WebGLShader[] | null;
    getAttribLocation(program: WebGLProgram, name: string): number;
    getBufferParameter(target: number, pname: number): any;
    getParameter(pname: number): any;
    getError(): number;
    getFramebufferAttachmentParameter(target: number, attachment: number, pname: number): any;
    getProgramParameter(program: WebGLProgram, pname: number): any;
    getProgramInfoLog(program: WebGLProgram): string | null;
    getRenderbufferParameter(target: number, pname: number): any;
    getShaderParameter(shader: WebGLShader, pname: number): any;
    getShaderPrecisionFormat(shadertype: number, precisiontype: number): WebGLShaderPrecisionFormat | null;
    getShaderInfoLog(shader: WebGLShader): string | null;
    getShaderSource(shader: WebGLShader): string | null;
    getTexParameter(target: number, pname: number): any;
    getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;
    getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation | null;
    getVertexAttrib(index: number, pname: number): any;
    getVertexAttribOffset(index: number, pname: number): number;
    hint(target: number, mode: number): void;
    isBuffer(buffer: WebGLBuffer | null): boolean;
    isEnabled(cap: number): boolean;
    isFramebuffer(framebuffer: WebGLFramebuffer | null): boolean;
    isProgram(program: WebGLProgram | null): boolean;
    isRenderbuffer(renderbuffer: WebGLRenderbuffer | null): boolean;
    isShader(shader: WebGLShader | null): boolean;
    isTexture(texture: WebGLTexture | null): boolean;
    lineWidth(width: number): void;
    linkProgram(program: WebGLProgram): void;
    pixelStorei(pname: number, param: number): void;
    polygonOffset(factor: number, units: number): void;
    renderbufferStorage(target: number, internalformat: number, width: number, height: number): void;
    sampleCoverage(value: number, invert: boolean): void;
    scissor(x: number, y: number, width: number, height: number): void;
    shaderSource(shader: WebGLShader, source: string): void;
    stencilFunc(func: number, ref: number, mask: number): void;
    stencilFuncSeparate(face: number, func: number, ref: number, mask: number): void;
    stencilMask(mask: number): void;
    stencilMaskSeparate(face: number, mask: number): void;
    stencilOp(fail: number, zfail: number, zpass: number): void;
    stencilOpSeparate(face: number, fail: number, zfail: number, zpass: number): void;
    texParameterf(target: number, pname: number, param: number): void;
    texParameteri(target: number, pname: number, param: number): void;
    uniform1f(location: WebGLUniformLocation | null, x: number): void;
    uniform2f(location: WebGLUniformLocation | null, x: number, y: number): void;
    uniform3f(location: WebGLUniformLocation | null, x: number, y: number, z: number): void;
    uniform4f(location: WebGLUniformLocation | null, x: number, y: number, z: number, w: number): void;
    uniform1i(location: WebGLUniformLocation | null, x: number): void;
    uniform2i(location: WebGLUniformLocation | null, x: number, y: number): void;
    uniform3i(location: WebGLUniformLocation | null, x: number, y: number, z: number): void;
    uniform4i(location: WebGLUniformLocation | null, x: number, y: number, z: number, w: number): void;
    useProgram(program: WebGLProgram | null): void;
    validateProgram(program: WebGLProgram): void;
    vertexAttrib1f(indx: number, x: number): void;
    vertexAttrib1fv(indx: number, values: Float32Array | number[]): void;
    vertexAttrib2f(indx: number, x: number, y: number): void;
    vertexAttrib2fv(indx: number, values: Float32Array | number[]): void;
    vertexAttrib3f(indx: number, x: number, y: number, z: number): void;
    vertexAttrib3fv(indx: number, values: Float32Array | number[]): void;
    vertexAttrib4f(indx: number, x: number, y: number, z: number, w: number): void;
    vertexAttrib4fv(indx: number, values: Float32Array | number[]): void;
    vertexAttribPointer(indx: number, size: number, type: number, normalized: boolean, stride: number, offset: number): void;
    viewport(x: number, y: number, width: number, height: number): void;
    makeXRCompatible(): Promise<void>;
  }
  class EXT_texture_compression_bptc {
  }
  class EXT_texture_compression_rgtc {
  }
  class WEBGL_compressed_texture_s3tc {
  }
  class WEBGL_compressed_texture_s3tc_srgb {
  }
  class WEBGL_compressed_texture_astc {
    getSupportedProfiles(): string[] | null;
  }
  class WEBGL_compressed_texture_etc {
  }
  class WEBGL_compressed_texture_etc1 {
  }
  class WEBGL_compressed_texture_pvrtc {
  }
  class WEBGL_debug_renderer_info {
  }
  class WEBGL_debug_shaders {
    getTranslatedShaderSource(shader: WebGLShader): string;
  }
  class WEBGL_depth_texture {
  }
  class OES_element_index_uint {
  }
  class EXT_frag_depth {
  }
  class WEBGL_lose_context {
    loseContext(): void;
    restoreContext(): void;
  }
  class EXT_texture_filter_anisotropic {
  }
  class EXT_sRGB {
  }
  class OES_standard_derivatives {
  }
  class OES_texture_float {
  }
  class WEBGL_draw_buffers {
    drawBuffersWEBGL(buffers: number[]): void;
  }
  class OES_texture_float_linear {
  }
  class EXT_shader_texture_lod {
  }
  class OES_texture_half_float {
  }
  class OES_texture_half_float_linear {
  }
  class WEBGL_color_buffer_float {
  }
  class EXT_color_buffer_half_float {
  }
  class OES_vertex_array_object {
    createVertexArrayOES(): WebGLVertexArrayObject | null;
    deleteVertexArrayOES(arrayObject: WebGLVertexArrayObject | null): void;
    isVertexArrayOES(arrayObject: WebGLVertexArrayObject | null): boolean;
    bindVertexArrayOES(arrayObject: WebGLVertexArrayObject | null): void;
  }
  class ANGLE_instanced_arrays {
    drawArraysInstancedANGLE(mode: number, first: number, count: number, primcount: number): void;
    drawElementsInstancedANGLE(mode: number, count: number, type: number, offset: number, primcount: number): void;
    vertexAttribDivisorANGLE(index: number, divisor: number): void;
  }
  class EXT_blend_minmax {
  }
  class WebGLQuery {
  }
  class EXT_disjoint_timer_query {
    createQueryEXT(): WebGLQuery | null;
    deleteQueryEXT(query: WebGLQuery | null): void;
    isQueryEXT(query: WebGLQuery | null): boolean;
    beginQueryEXT(target: number, query: WebGLQuery): void;
    endQueryEXT(target: number): void;
    queryCounterEXT(query: WebGLQuery, target: number): void;
    getQueryEXT(target: number, pname: number): any;
    getQueryObjectEXT(query: WebGLQuery, pname: number): any;
  }
  class MOZ_debug {
    getParameter(pname: number): any;
  }
  class EXT_float_blend {
  }
  class OES_fbo_render_mipmap {
  }
  class WEBGL_explicit_present {
    present(): void;
  }
  interface GPUColorDict {
    a: number
    b: number
    g: number
    r: number
  }
  interface GPUOrigin2DDict {
    x?: number
    y?: number
  }
  interface GPUOrigin3DDict {
    x?: number
    y?: number
    z?: number
  }
  interface GPUExtent3DDict {
    depth: number
    height: number
    width: number
  }
  interface GPUObjectDescriptorBase {
    label?: string | null
  }
  class GPU {
    requestAdapter(options?: GPURequestAdapterOptions): Promise<GPUAdapter>;
  }
  enum GPUPowerPreference {
    Low_power = "low-power",
    High_performance = "high-performance",
  }
  interface GPURequestAdapterOptions {
    powerPreference?: GPUPowerPreference
  }
  class GPUAdapter {
    readonly name: string;
    requestDevice(descriptor?: GPUDeviceDescriptor): Promise<GPUDevice>;
    label: string | null;
  }
  interface GPUExtensions {
    anisotropicFiltering?: boolean
  }
  interface GPULimits {
    maxBindGroups?: number
  }
  class GPUDevice {
    createBuffer(descriptor: GPUBufferDescriptor): GPUBuffer;
    createBufferMapped(descriptor: GPUBufferDescriptor): any[];
    label: string | null;
  }
  interface GPUDeviceDescriptor {
    extensions?: GPUExtensions
    limits?: GPULimits
  }
  class GPUDeviceLostInfo {
    readonly message: string;
  }
  enum GPUErrorFilter {
    None = "none",
    Out_of_memory = "out-of-memory",
    Validation = "validation",
  }
  class GPUOutOfMemoryError {
  }
  class GPUValidationError {
  }
  class GPUBufferUsage {
  }
  interface GPUBufferDescriptor {
    size: number
    usage: number
  }
  class GPUBuffer {
    mapReadAsync(): Promise<ArrayBuffer>;
    unmap(): void;
    label: string | null;
  }
  enum GPUTextureDimension {
    _d = "1d",
    _d = "2d",
    _d = "3d",
  }
  enum GPUTextureFormat {
    R_unorm = "r8unorm",
    R_snorm = "r8snorm",
    R_uint = "r8uint",
    R_sint = "r8sint",
    R__uint = "r16uint",
    R__sint = "r16sint",
    R__float = "r16float",
    Rg_unorm = "rg8unorm",
    Rg_snorm = "rg8snorm",
    Rg_uint = "rg8uint",
    Rg_sint = "rg8sint",
    R__uint = "r32uint",
    R__sint = "r32sint",
    R__float = "r32float",
    Rg__uint = "rg16uint",
    Rg__sint = "rg16sint",
    Rg__float = "rg16float",
    Rgba_unorm = "rgba8unorm",
    Rgba_unorm_srgb = "rgba8unorm-srgb",
    Rgba_snorm = "rgba8snorm",
    Rgba_uint = "rgba8uint",
    Rgba_sint = "rgba8sint",
    Bgra_unorm = "bgra8unorm",
    Bgra_unorm_srgb = "bgra8unorm-srgb",
    Rgb__a_unorm = "rgb10a2unorm",
    Rg__b__float = "rg11b10float",
    Rg__uint = "rg32uint",
    Rg__sint = "rg32sint",
    Rg__float = "rg32float",
    Rgba__uint = "rgba16uint",
    Rgba__sint = "rgba16sint",
    Rgba__float = "rgba16float",
    Rgba__uint = "rgba32uint",
    Rgba__sint = "rgba32sint",
    Rgba__float = "rgba32float",
    Depth__float = "depth32float",
    Depth__plus = "depth24plus",
    Depth__plus_stencil_ = "depth24plus-stencil8",
  }
  class GPUTextureUsage {
  }
  interface GPUTextureDescriptor {
    arrayLayerCount?: number
    dimension?: GPUTextureDimension
    format: GPUTextureFormat
    mipLevelCount?: number
    sampleCount?: number
    size: number[] | GPUExtent3DDict
    usage: number
  }
  class GPUTexture {
    label: string | null;
  }
  enum GPUTextureViewDimension {
    _d = "1d",
    _d = "2d",
    _d_array = "2d-array",
    Cube = "cube",
    Cube_array = "cube-array",
    _d = "3d",
  }
  enum GPUTextureAspect {
    All = "all",
    Stencil_only = "stencil-only",
    Depth_only = "depth-only",
  }
  interface GPUTextureViewDescriptor {
    arrayLayerCount?: number
    aspect: GPUTextureAspect
    baseArrayLayer?: number
    baseMipLevel?: number
    dimension: GPUTextureViewDimension
    format: GPUTextureFormat
    mipLevelCount?: number
  }
  class GPUTextureView {
    label: string | null;
  }
  enum GPUAddressMode {
    Clamp_to_edge = "clamp-to-edge",
    Repeat = "repeat",
    Mirror_repeat = "mirror-repeat",
  }
  enum GPUFilterMode {
    Nearest = "nearest",
    Linear = "linear",
  }
  enum GPUCompareFunction {
    Never = "never",
    Less = "less",
    Equal = "equal",
    Less_equal = "less-equal",
    Greater = "greater",
    Not_equal = "not-equal",
    Greater_equal = "greater-equal",
    Always = "always",
  }
  interface GPUSamplerDescriptor {
    addressModeU?: GPUAddressMode
    addressModeV?: GPUAddressMode
    addressModeW?: GPUAddressMode
    compare?: GPUCompareFunction
    lodMaxClamp?: number
    lodMinClamp?: number
    magFilter?: GPUFilterMode
    minFilter?: GPUFilterMode
    mipmapFilter?: GPUFilterMode
  }
  class GPUSampler {
    label: string | null;
  }
  enum GPUTextureComponentType {
    Float = "float",
    Sint = "sint",
    Uint = "uint",
  }
  interface GPUPipelineLayoutDescriptor {
    bindGroupLayouts: GPUBindGroupLayout[]
  }
  class GPUPipelineLayout {
    label: string | null;
  }
  class GPUShaderStage {
  }
  enum GPUBindingType {
    Uniform_buffer = "uniform-buffer",
    Storage_buffer = "storage-buffer",
    Readonly_storage_buffer = "readonly-storage-buffer",
    Sampler = "sampler",
    Sampled_texture = "sampled-texture",
    Storage_texture = "storage-texture",
  }
  interface GPUBindGroupLayoutBinding {
    binding: number
    dynamic?: boolean
    multisampled?: boolean
    textureComponentType?: GPUTextureComponentType
    textureDimension?: GPUTextureViewDimension
    type: GPUBindingType
    visibility: number
  }
  interface GPUBindGroupLayoutDescriptor {
    bindings: GPUBindGroupLayoutBinding[]
  }
  class GPUBindGroupLayout {
    label: string | null;
  }
  interface GPUBufferBinding {
    buffer: GPUBuffer
    offset?: number
    size?: number
  }
  interface GPUBindGroupBinding {
    binding: number
    resource: GPUSampler | GPUTextureView | GPUBufferBinding
  }
  interface GPUBindGroupDescriptor {
    bindings: GPUBindGroupBinding[]
    layout: GPUBindGroupLayout
  }
  class GPUBindGroup {
    label: string | null;
  }
  enum GPUBlendFactor {
    Zero = "zero",
    One = "one",
    Src_color = "src-color",
    One_minus_src_color = "one-minus-src-color",
    Src_alpha = "src-alpha",
    One_minus_src_alpha = "one-minus-src-alpha",
    Dst_color = "dst-color",
    One_minus_dst_color = "one-minus-dst-color",
    Dst_alpha = "dst-alpha",
    One_minus_dst_alpha = "one-minus-dst-alpha",
    Src_alpha_saturated = "src-alpha-saturated",
    Blend_color = "blend-color",
    One_minus_blend_color = "one-minus-blend-color",
  }
  enum GPUBlendOperation {
    Add = "add",
    Subtract = "subtract",
    Reverse_subtract = "reverse-subtract",
    Min = "min",
    Max = "max",
  }
  interface GPUBlendDescriptor {
    dstFactor?: GPUBlendFactor
    operation?: GPUBlendOperation
    srcFactor?: GPUBlendFactor
  }
  class GPUColorWrite {
  }
  interface GPUColorStateDescriptor {
    alpha?: GPUBlendDescriptor
    color?: GPUBlendDescriptor
    format: GPUTextureFormat
    writeMask?: number
  }
  enum GPUStencilOperation {
    Keep = "keep",
    Zero = "zero",
    Replace = "replace",
    Invert = "invert",
    Increment_clamp = "increment-clamp",
    Decrement_clamp = "decrement-clamp",
    Increment_wrap = "increment-wrap",
    Decrement_wrap = "decrement-wrap",
  }
  interface GPUStencilStateFaceDescriptor {
    compare?: GPUCompareFunction
    depthFailOp?: GPUStencilOperation
    failOp?: GPUStencilOperation
    passOp?: GPUStencilOperation
  }
  interface GPUDepthStencilStateDescriptor {
    depthCompare?: GPUCompareFunction
    depthWriteEnabled?: boolean
    format: GPUTextureFormat
    stencilBack: GPUStencilStateFaceDescriptor
    stencilFront: GPUStencilStateFaceDescriptor
    stencilReadMask?: number
    stencilWriteMask?: number
  }
  enum GPUIndexFormat {
    Uint__ = "uint16",
    Uint__ = "uint32",
  }
  enum GPUVertexFormat {
    Uchar_ = "uchar2",
    Uchar_ = "uchar4",
    Char_ = "char2",
    Char_ = "char4",
    Uchar_norm = "uchar2norm",
    Uchar_norm = "uchar4norm",
    Char_norm = "char2norm",
    Char_norm = "char4norm",
    Ushort_ = "ushort2",
    Ushort_ = "ushort4",
    Short_ = "short2",
    Short_ = "short4",
    Ushort_norm = "ushort2norm",
    Ushort_norm = "ushort4norm",
    Short_norm = "short2norm",
    Short_norm = "short4norm",
    Half_ = "half2",
    Half_ = "half4",
    Float = "float",
    Float_ = "float2",
    Float_ = "float3",
    Float_ = "float4",
    Uint = "uint",
    Uint_ = "uint2",
    Uint_ = "uint3",
    Uint_ = "uint4",
    Int = "int",
    Int_ = "int2",
    Int_ = "int3",
    Int_ = "int4",
  }
  enum GPUInputStepMode {
    Vertex = "vertex",
    Instance = "instance",
  }
  interface GPUVertexAttributeDescriptor {
    format: GPUVertexFormat
    offset?: number
    shaderLocation: number
  }
  interface GPUVertexBufferDescriptor {
    attributeSet: GPUVertexAttributeDescriptor[]
    stepMode?: GPUInputStepMode
    stride: number
  }
  interface GPUVertexInputDescriptor {
    indexFormat?: GPUIndexFormat
    vertexBuffers: GPUVertexBufferDescriptor | null[]
  }
  interface GPUShaderModuleDescriptor {
    code: Uint32Array | string
  }
  class GPUShaderModule {
    label: string | null;
  }
  interface GPUPipelineDescriptorBase {
    layout: GPUPipelineLayout
  }
  interface GPUProgrammableStageDescriptor {
    entryPoint: string
    module_: GPUShaderModule
  }
  interface GPUComputePipelineDescriptor {
    computeStage: GPUProgrammableStageDescriptor
  }
  class GPUComputePipeline {
    label: string | null;
  }
  enum GPUPrimitiveTopology {
    Point_list = "point-list",
    Line_list = "line-list",
    Line_strip = "line-strip",
    Triangle_list = "triangle-list",
    Triangle_strip = "triangle-strip",
  }
  interface GPURasterizationStateDescriptor {
    cullMode?: GPUCullMode
    depthBias?: number
    depthBiasClamp?: number
    depthBiasSlopeScale?: number
    frontFace?: GPUFrontFace
  }
  enum GPUFrontFace {
    Ccw = "ccw",
    Cw = "cw",
  }
  enum GPUCullMode {
    None = "none",
    Front = "front",
    Back = "back",
  }
  interface GPURenderPipelineDescriptor {
    alphaToCoverageEnabled?: boolean
    colorStates: GPUColorStateDescriptor[]
    depthStencilState?: GPUDepthStencilStateDescriptor
    fragmentStage?: GPUProgrammableStageDescriptor
    primitiveTopology: GPUPrimitiveTopology
    rasterizationState?: GPURasterizationStateDescriptor
    sampleCount?: number
    sampleMask?: number
    vertexInput: GPUVertexInputDescriptor
    vertexStage: GPUProgrammableStageDescriptor
  }
  class GPURenderPipeline {
    label: string | null;
  }
  enum GPULoadOp {
    Load = "load",
  }
  enum GPUStoreOp {
    Store = "store",
    Clear = "clear",
  }
  interface GPURenderPassColorAttachmentDescriptor {
    attachment: GPUTextureView
    loadValue: GPULoadOp | number[] | GPUColorDict
    resolveTarget?: GPUTextureView
    storeOp: GPUStoreOp
  }
  interface GPURenderPassDepthStencilAttachmentDescriptor {
    attachment: GPUTextureView
    depthLoadValue: GPULoadOp | number
    depthStoreOp: GPUStoreOp
    stencilLoadValue: GPULoadOp | number
    stencilStoreOp: GPUStoreOp
  }
  interface GPURenderPassDescriptor {
    colorAttachments: GPURenderPassColorAttachmentDescriptor[]
    depthStencilAttachment?: GPURenderPassDepthStencilAttachmentDescriptor
  }
  interface GPUBufferCopyView {
    buffer: GPUBuffer
    imageHeight: number
    offset?: number
    rowPitch: number
  }
  interface GPUTextureCopyView {
    arrayLayer?: number
    mipLevel?: number
    origin?: number[] | GPUOrigin3DDict
    texture: GPUTexture
  }
  interface GPUImageBitmapCopyView {
    origin?: number[] | GPUOrigin2DDict
  }
  interface GPUCommandEncoderDescriptor {
  }
  class GPUCommandEncoder {
    label: string | null;
  }
  class GPUProgrammablePassEncoder {
    label: string | null;
  }
  class GPURenderEncoderBase {
  }
  class GPURenderPassEncoder {
  }
  interface GPUComputePassDescriptor {
  }
  class GPUComputePassEncoder {
  }
  interface GPUCommandBufferDescriptor {
  }
  class GPUCommandBuffer {
    label: string | null;
  }
  interface GPURenderBundleEncoderDescriptor {
    colorFormats: GPUTextureFormat[]
    depthStencilFormat?: GPUTextureFormat
    sampleCount?: number
  }
  class GPURenderBundleEncoder {
  }
  interface GPURenderBundleDescriptor {
  }
  class GPURenderBundle {
    label: string | null;
  }
  interface GPUFenceDescriptor {
    initialValue?: number
  }
  class GPUFence {
    label: string | null;
  }
  class GPUQueue {
    label: string | null;
  }
  class GPUSwapChain {
    label: string | null;
  }
  interface GPUSwapChainDescriptor {
    device: GPUDevice
    format: GPUTextureFormat
    usage?: number
  }
  class GPUCanvasContext {
  }
  enum BinaryType {
    Blob = "blob",
    Arraybuffer = "arraybuffer",
  }
  class WebSocket {
    readonly url: string;
    readonly readyState: number;
    readonly bufferedAmount: number;
    onopen: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    readonly extensions: string;
    readonly protocol: string;
    close(code?: number, reason?: string): void;
    onmessage: EventHandlerNonNull | null;
    binaryType: BinaryType;
    send(data: string): void;
    send(data: Blob): void;
    send(data: ArrayBuffer): void;
    send(data: ArrayBufferView): void;
    createServerWebSocket(url: string, protocols: string[], transportProvider: nsITransportProvider, negotiatedExtensions: string): WebSocket;
  }
  class mozRTCIceCandidate {
  }
  class mozRTCPeerConnection {
  }
  class mozRTCSessionDescription {
  }
  interface WebrtcGlobalStatisticsReport {
    reports?: RTCStatsReportInternal[]
  }
  function WebrtcGlobalStatisticsCallback(reports: WebrtcGlobalStatisticsReport): void;
  function WebrtcGlobalLoggingCallback(logMessages: string[]): void;
  class WheelEvent {
    readonly deltaX: number;
    readonly deltaY: number;
    readonly deltaZ: number;
    readonly deltaMode: number;
    readonly isTrusted: boolean;
  }
  interface WheelEventInit {
    deltaMode?: number
    deltaX?: number
    deltaY?: number
    deltaZ?: number
  }
  interface WidevineCDMManifest {
    description: string
    name: string
    version: string
    "x-cdm-codecs": string
    "x-cdm-host-versions": string
    "x-cdm-interface-versions": string
    "x-cdm-module-versions": string
  }
  class WindowRoot {
  }
  class Worker {
    terminate(): void;
    postMessage(message: any, transfer: object[]): void;
    postMessage(message: any, aOptions?: PostMessageOptions): void;
    onmessage: EventHandlerNonNull | null;
    onmessageerror: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
  }
  interface WorkerOptions {
    name?: string
  }
  class ChromeWorker {
  }
  class WorkerDebuggerGlobalScope {
    readonly global: object;
    createSandbox(name: string, prototype: object): object;
    loadSubScript(url: string, sandbox?: object): void;
    enterEventLoop(): void;
    leaveEventLoop(): void;
    postMessage(message: string): void;
    onmessage: EventHandlerNonNull | null;
    setImmediate(handler: Function): void;
    reportError(message: string): void;
    retrieveConsoleEvents(): any[];
    setConsoleEventHandler(handler: AnyCallback | null): void;
    btoa(btoa: string): string;
    atob(atob: string): string;
    dump(string?: string): void;
  }
  class WorkerGlobalScope {
    readonly self: WorkerGlobalScope;
    readonly location: WorkerLocation;
    readonly navigator: WorkerNavigator;
    importScripts(urls?: string): void;
    onerror: OnErrorEventHandlerNonNull | null;
    onoffline: EventHandlerNonNull | null;
    ononline: EventHandlerNonNull | null;
    onrejectionhandled: EventHandlerNonNull | null;
    onunhandledrejection: EventHandlerNonNull | null;
    dump(str?: string): void;
    readonly performance: Performance;
    getJSTestingFunctions(): object;
    readonly crypto: Crypto;
    readonly origin: string;
    readonly crossOriginIsolated: boolean;
    btoa(btoa: string): string;
    atob(atob: string): string;
    setTimeout(handler: Function, timeout?: number, arguments?: any): number;
    setTimeout(handler: string, timeout?: number, unused?: any): number;
    clearTimeout(handle?: number): void;
    setInterval(handler: Function, timeout?: number, arguments?: any): number;
    setInterval(handler: string, timeout?: number, unused?: any): number;
    clearInterval(handle?: number): void;
    queueMicrotask(callback: VoidFunction): void;
    createImageBitmap(aImage: HTMLImageElement | SVGImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap | Blob | CanvasRenderingContext2D | ImageData): Promise<ImageBitmap>;
    createImageBitmap(aImage: HTMLImageElement | SVGImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap | Blob | CanvasRenderingContext2D | ImageData, aSx: number, aSy: number, aSw: number, aSh: number): Promise<ImageBitmap>;
    fetch(input: Request | string, init?: RequestInit): Promise<Response>;
    readonly isSecureContext: boolean;
    readonly indexedDB: IDBFactory | null;
    readonly caches: CacheStorage;
  }
  class WorkerLocation {
    readonly href: string;
    readonly origin: string;
    readonly protocol: string;
    readonly host: string;
    readonly hostname: string;
    readonly port: string;
    readonly pathname: string;
    readonly search: string;
    readonly hash: string;
    __stringifier(): string;
  }
  class WorkerNavigator {
    readonly connection: NetworkInformation;
    readonly mediaCapabilities: MediaCapabilities;
    readonly hardwareConcurrency: number;
    readonly appCodeName: string;
    readonly appName: string;
    readonly appVersion: string;
    readonly platform: string;
    readonly userAgent: string;
    readonly product: string;
    taintEnabled(): boolean;
    readonly language: string | null;
    readonly languages: string[];
    readonly onLine: boolean;
    readonly storage: StorageManager;
  }
  class Worklet {
    addModule(moduleURL: string, options?: WorkletOptions): Promise<void>;
  }
  interface WorkletOptions {
    credentials?: RequestCredentials
  }
  class WorkletGlobalScope {
    dump(str?: string): void;
  }
  class XMLDocument {
    readonly location: Location | null;
  }
  enum XMLHttpRequestResponseType {
    _empty = "",
    Arraybuffer = "arraybuffer",
    Blob = "blob",
    Document = "document",
    Json = "json",
    Text = "text",
  }
  interface MozXMLHttpRequestParameters {
    mozAnon?: boolean
    mozSystem?: boolean
  }
  class XMLHttpRequest {
    onreadystatechange: EventHandlerNonNull | null;
    readonly readyState: number;
    open(method: string, url: string): void;
    open(method: string, url: string, async: boolean, user?: string | null, password?: string | null): void;
    setRequestHeader(header: string, value: string): void;
    timeout: number;
    withCredentials: boolean;
    readonly upload: XMLHttpRequestUpload;
    send(body?: Document | Blob | ArrayBufferView | ArrayBuffer | FormData | URLSearchParams | string | null): void;
    abort(): void;
    readonly responseURL: string;
    readonly status: number;
    readonly statusText: string;
    getResponseHeader(header: string): string | null;
    getAllResponseHeaders(): string;
    overrideMimeType(mime: string): void;
    responseType: XMLHttpRequestResponseType;
    readonly response: any;
    readonly responseText: string | null;
    readonly responseXML: Document | null;
    mozBackgroundRequest: boolean;
    readonly channel: MozChannel | null;
    getInterface(iid: any): any;
    setOriginAttributes(originAttributes?: OriginAttributesDictionary): void;
    sendInputStream(body: InputStream): void;
    readonly errorCode: number;
    readonly mozAnon: boolean;
    readonly mozSystem: boolean;
  }
  class XMLHttpRequestEventTarget {
    onloadstart: EventHandlerNonNull | null;
    onprogress: EventHandlerNonNull | null;
    onabort: EventHandlerNonNull | null;
    onerror: EventHandlerNonNull | null;
    onload: EventHandlerNonNull | null;
    ontimeout: EventHandlerNonNull | null;
    onloadend: EventHandlerNonNull | null;
  }
  class XMLHttpRequestUpload {
  }
  class XMLSerializer {
    serializeToString(root: Node): string;
    serializeToStream(root: Node, stream: OutputStream, charset: string | null): void;
  }
  class XPathEvaluator {
    createExpression(expression: string, resolver?: XPathNSResolver | null): XPathExpression;
    createNSResolver(nodeResolver: Node): Node;
    evaluate(expression: string, contextNode: Node, resolver?: XPathNSResolver | null, type?: number, result?: object | null): XPathResult;
  }
  class XPathExpression {
    evaluate(contextNode: Node, type?: number, result?: object | null): XPathResult;
    evaluateWithContext(contextNode: Node, contextPosition: number, contextSize: number, type?: number, result?: object | null): XPathResult;
  }
  class XPathNSResolver {
    lookupNamespaceURI(prefix: string | null): string | null;
  }
  class XPathResult {
    readonly resultType: number;
    readonly numberValue: number;
    readonly stringValue: string;
    readonly booleanValue: boolean;
    readonly singleNodeValue: Node | null;
    readonly invalidIteratorState: boolean;
    readonly snapshotLength: number;
    iterateNext(): Node | null;
    snapshotItem(index: number): Node | null;
  }
  class XSLTProcessor {
    importStylesheet(style: Node): void;
    transformToFragment(source: Node, output: Document): DocumentFragment;
    transformToDocument(source: Node): Document;
    setParameter(namespaceURI: string, localName: string, value: any): void;
    getParameter(namespaceURI: string, localName: string): nsIVariant | null;
    removeParameter(namespaceURI: string, localName: string): void;
    clearParameters(): void;
    reset(): void;
    flags: number;
  }
  class XULCommandEvent {
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly altKey: boolean;
    readonly metaKey: boolean;
    readonly inputSource: number;
    readonly sourceEvent: Event | null;
    initCommandEvent(type: string, canBubble?: boolean, cancelable?: boolean, view?: Window | null, detail?: number, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean, sourceEvent?: Event | null, inputSource?: number): void;
    readonly isTrusted: boolean;
  }
  class XULElement {
    flex: string;
    orient: string;
    hidden: boolean;
    collapsed: boolean;
    observes: string;
    menu: string;
    contextMenu: string;
    tooltip: string;
    width: string;
    height: string;
    minWidth: string;
    minHeight: string;
    maxWidth: string;
    maxHeight: string;
    left: string;
    top: string;
    readonly screenX: number;
    readonly screenY: number;
    tooltipText: string;
    src: string;
    allowEvents: boolean;
    readonly controllers: XULControllers;
    click(): void;
    doCommand(): void;
    hasMenu(): boolean;
    openMenu(open: boolean): void;
    readonly style: CSSStyleDeclaration;
    onabort: EventHandlerNonNull | null;
    onblur: EventHandlerNonNull | null;
    onfocus: EventHandlerNonNull | null;
    onauxclick: EventHandlerNonNull | null;
    oncanplay: EventHandlerNonNull | null;
    oncanplaythrough: EventHandlerNonNull | null;
    onchange: EventHandlerNonNull | null;
    onclick: EventHandlerNonNull | null;
    onclose: EventHandlerNonNull | null;
    oncontextmenu: EventHandlerNonNull | null;
    oncuechange: EventHandlerNonNull | null;
    ondblclick: EventHandlerNonNull | null;
    ondrag: EventHandlerNonNull | null;
    ondragend: EventHandlerNonNull | null;
    ondragenter: EventHandlerNonNull | null;
    ondragexit: EventHandlerNonNull | null;
    ondragleave: EventHandlerNonNull | null;
    ondragover: EventHandlerNonNull | null;
    ondragstart: EventHandlerNonNull | null;
    ondrop: EventHandlerNonNull | null;
    ondurationchange: EventHandlerNonNull | null;
    onemptied: EventHandlerNonNull | null;
    onended: EventHandlerNonNull | null;
    onformdata: EventHandlerNonNull | null;
    oninput: EventHandlerNonNull | null;
    oninvalid: EventHandlerNonNull | null;
    onkeydown: EventHandlerNonNull | null;
    onkeypress: EventHandlerNonNull | null;
    onkeyup: EventHandlerNonNull | null;
    onload: EventHandlerNonNull | null;
    onloadeddata: EventHandlerNonNull | null;
    onloadedmetadata: EventHandlerNonNull | null;
    onloadend: EventHandlerNonNull | null;
    onloadstart: EventHandlerNonNull | null;
    onmousedown: EventHandlerNonNull | null;
    onmouseenter: EventHandlerNonNull | null;
    onmouseleave: EventHandlerNonNull | null;
    onmousemove: EventHandlerNonNull | null;
    onmouseout: EventHandlerNonNull | null;
    onmouseover: EventHandlerNonNull | null;
    onmouseup: EventHandlerNonNull | null;
    onwheel: EventHandlerNonNull | null;
    onpause: EventHandlerNonNull | null;
    onplay: EventHandlerNonNull | null;
    onplaying: EventHandlerNonNull | null;
    onprogress: EventHandlerNonNull | null;
    onratechange: EventHandlerNonNull | null;
    onreset: EventHandlerNonNull | null;
    onresize: EventHandlerNonNull | null;
    onscroll: EventHandlerNonNull | null;
    onseeked: EventHandlerNonNull | null;
    onseeking: EventHandlerNonNull | null;
    onselect: EventHandlerNonNull | null;
    onshow: EventHandlerNonNull | null;
    onstalled: EventHandlerNonNull | null;
    onsubmit: EventHandlerNonNull | null;
    onsuspend: EventHandlerNonNull | null;
    ontimeupdate: EventHandlerNonNull | null;
    onvolumechange: EventHandlerNonNull | null;
    onwaiting: EventHandlerNonNull | null;
    onselectstart: EventHandlerNonNull | null;
    ontoggle: EventHandlerNonNull | null;
    onpointercancel: EventHandlerNonNull | null;
    onpointerdown: EventHandlerNonNull | null;
    onpointerup: EventHandlerNonNull | null;
    onpointermove: EventHandlerNonNull | null;
    onpointerout: EventHandlerNonNull | null;
    onpointerover: EventHandlerNonNull | null;
    onpointerenter: EventHandlerNonNull | null;
    onpointerleave: EventHandlerNonNull | null;
    ongotpointercapture: EventHandlerNonNull | null;
    onlostpointercapture: EventHandlerNonNull | null;
    onmozfullscreenchange: EventHandlerNonNull | null;
    onmozfullscreenerror: EventHandlerNonNull | null;
    onanimationcancel: EventHandlerNonNull | null;
    onanimationend: EventHandlerNonNull | null;
    onanimationiteration: EventHandlerNonNull | null;
    onanimationstart: EventHandlerNonNull | null;
    ontransitioncancel: EventHandlerNonNull | null;
    ontransitionend: EventHandlerNonNull | null;
    ontransitionrun: EventHandlerNonNull | null;
    ontransitionstart: EventHandlerNonNull | null;
    onwebkitanimationend: EventHandlerNonNull | null;
    onwebkitanimationiteration: EventHandlerNonNull | null;
    onwebkitanimationstart: EventHandlerNonNull | null;
    onwebkittransitionend: EventHandlerNonNull | null;
    readonly dataset: DOMStringMap;
    tabIndex: number;
    focus(options?: FocusOptions): void;
    blur(): void;
    onerror: EventHandlerNonNull | null;
    ontouchstart: EventHandlerNonNull | null;
    ontouchend: EventHandlerNonNull | null;
    ontouchmove: EventHandlerNonNull | null;
    ontouchcancel: EventHandlerNonNull | null;
  }
  interface OpenPopupOptions {
    attributesOverride?: boolean
    isContextMenu?: boolean
    position?: string
    triggerEvent?: Event | null
    x?: number
    y?: number
  }
  class XULPopupElement {
    autoPosition: boolean;
    openPopup(anchorElement?: Element | null, options?: string | OpenPopupOptions, x?: number, y?: number, isContextMenu?: boolean, attributesOverride?: boolean, triggerEvent?: Event | null): void;
    openPopupAtScreen(x?: number, y?: number, isContextMenu?: boolean, triggerEvent?: Event | null): void;
    openPopupAtScreenRect(position?: string, x?: number, y?: number, width?: number, height?: number, isContextMenu?: boolean, attributesOverride?: boolean, triggerEvent?: Event | null): void;
    hidePopup(cancel?: boolean): void;
    label: string;
    position: string;
    readonly state: string;
    readonly triggerNode: Node | null;
    readonly anchorNode: Element | null;
    getOuterScreenRect(): DOMRect;
    moveTo(left: number, top: number): void;
    moveToAnchor(anchorElement?: Element | null, position?: string, x?: number, y?: number, attributesOverride?: boolean): void;
    sizeTo(width: number, height: number): void;
    readonly alignmentPosition: string;
    readonly alignmentOffset: number;
    setConstraintRect(rect: DOMRectReadOnly): void;
  }
  class MozSharedMapIterator {
    next(): object;
  }
  class FormDataIterator {
    next(): object;
  }
  class HeadersIterator {
    next(): object;
  }
  class MediaKeyStatusMapIterator {
    next(): object;
  }
  class URLSearchParamsIterator {
    next(): object;
  }
}
