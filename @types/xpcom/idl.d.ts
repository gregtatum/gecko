/// <reference path="types.d.ts" />
/*
 * DO NOT EDIT. THIS FILE IS AUTOMATICALLY GENERATED.
 */

declare namespace XPCOM {
  export interface nsIPaymentShowActionResponseRef {
    readonly name: "nsIPaymentShowActionResponse";
    readonly number: "{184385cb-2d35-4b99-a9a3-7c780bf66b9b}";
  }

  /**
   *  The response for show action.
   *  Notice that to represent user's cancel, we should use nsIPaymentShowActionResponse
   *  with PAYMENT_REJECTED status, not nsIPaymentAbortActionResponse.
   */
  export interface nsIPaymentShowActionResponse extends nsIPaymentActionResponse {

    /**
     *  Accept status of the payment.
     *  Using the defined consts(PAYMENT_XXX) in nsIPaymentActionResponse.
     */
    readonly acceptStatus: number;

    /**
     *  The decided payment method name. i.e. "basic-card".
     */
    readonly methodName: IDLAString;

    /**
     *  The data needed by the payment method. (it must be serializable)
     */
    readonly data: (nsIPaymentResponseData | null);

    /**
     *  The payer name information.
     */
    readonly payerName: IDLAString;

    /**
     *  The payer email information.
     */
    readonly payerEmail: IDLAString;

    /**
     *  The payer phone information.
     */
    readonly payerPhone: IDLAString;

    /**
     *  The initial method.
     *  @param aRequestId - the request identifier of the payment request.
     *  @param aAcceptStatus - the payment status.
     *  @param aMethodName - the decided method name.
     *  @param aData - the response data for the decided payment method.
     *  @param aPayerName - the payer's name.
     *  @param aPayerEmail - the payer's email.
     *  @param aPayerPhone - the payer's phone.
     */
    readonly init: (aRequestId: IDLAString, aAcceptStatus: number, aMethodName: IDLAString, aData: (nsIPaymentResponseData | null), aPayerName: IDLAString, aPayerEmail: IDLAString, aPayerPhone: IDLAString) => void;
  }

  export interface nsIObjectOutputStreamRef {
    readonly name: "nsIObjectOutputStream";
    readonly number: "{92c898ac-5fde-4b99-87b3-5d486422094b}";
  }

  /**
   * @See nsIObjectInputStream
   * @See nsIBinaryOutputStream
   */
  export interface nsIObjectOutputStream extends nsIBinaryOutputStream {

    /**
     * Write the object whose "root" or XPCOM-identity nsISupports is aObject.
     * The cause for writing this object is a strong or weak reference, so the
     * aIsStrongRef argument must tell which kind of pointer is being followed
     * here during serialization.
     *
     * If the object has only one strong reference in the serialization and no
     * weak refs, use writeSingleRefObject.  This is a valuable optimization:
     * it saves space in the stream, and cycles on both ends of the process.
     *
     * If the reference being serialized is a pointer to an interface not on
     * the primary inheritance chain ending in the root nsISupports, you must
     * call writeCompoundObject instead of this method.
     */
    readonly writeObject: (aObject: (nsISupports | null), aIsStrongRef: boolean) => void;

    /**
     * Write an object referenced singly and strongly via its root nsISupports
     * or a subclass of its root nsISupports.  There must not be other refs to
     * aObject in memory, or in the serialization.
     */
    readonly writeSingleRefObject: (aObject: (nsISupports | null)) => void;
  }

  export interface nsIProxyInfoRef {
    readonly name: "nsIProxyInfo";
    readonly number: "{63fff172-2564-4138-96c6-3ae7d245fbed}";

    /****************************************************************************
     * The following "Proxy Flags" may be bit-wise combined to construct the
     * flags attribute defined on this interface.  All unspecified bits are
     * reserved for future use.
     */
    /**
     * This flag is set if the proxy is to perform name resolution itself.  If
     * this is the case, the hostname is used in some fashion, and we shouldn't
     * do any form of DNS lookup ourselves.
     */
    TRANSPARENT_PROXY_RESOLVES_HOST: 1;
  }

  /**
   * This interface identifies a proxy server.
   */
  export interface nsIProxyInfo extends nsISupports {

    /**
     * This attribute specifies the hostname of the proxy server.
     */
    readonly host: IDLAUTF8String;

    /**
     * This attribute specifies the port number of the proxy server.
     */
    readonly port: number;

    /**
     * This attribute specifies the type of the proxy server as an ASCII string.
     *
     * Some special values for this attribute include (but are not limited to)
     * the following:
     *   "http"     HTTP proxy (or SSL CONNECT for HTTPS)
     *   "https"    HTTP proxying over TLS connection to proxy
     *   "socks"    SOCKS v5 proxy
     *   "socks4"   SOCKS v4 proxy
     *   "direct"   no proxy
     *   "unknown"  unknown proxy (see nsIProtocolProxyService::resolve)
     *
     * A future version of this interface may define additional types.
     */
    readonly type: IDLACString;

    /**
     * This attribute specifies flags that modify the proxy type.  The value of
     * this attribute is the bit-wise combination of the Proxy Flags defined
     * below.  Any undefined bits are reserved for future use.
     */
    readonly flags: number;

    /**
     * This attribute specifies flags that were used by nsIProxyProtocolService when
     * creating this ProxyInfo element.
     */
    resolveFlags: number;

    /**
     * Specifies a proxy username.
     */
    readonly username: IDLACString;

    /**
     * Specifies a proxy password.
     */
    readonly password: IDLACString;

    /**
     * This attribute specifies the failover timeout in seconds for this proxy.
     * If a nsIProxyInfo is reported as failed via nsIProtocolProxyService::
     * getFailoverForProxy, then the failed proxy will not be used again for this
     * many seconds.
     */
    readonly failoverTimeout: number;

    /**
     * This attribute specifies the proxy to failover to when this proxy fails.
     */
    failoverProxy: (nsIProxyInfo | null);

    /**
     * Any non-empty value will be passed directly as Proxy-Authorization header
     * value for the CONNECT request attempt.  However, this header set on the
     * resource request itself takes precedence.
     */
    readonly proxyAuthorizationHeader: IDLACString;

    /**
     * An optional key used for additional isolation of this proxy connection.
     */
    readonly connectionIsolationKey: IDLACString;
  }

  export interface nsIMemoryInfoDumperRef {
    readonly name: "nsIMemoryInfoDumper";
    readonly number: "{48541b74-47ee-4a62-9557-7f4b809bda5c}";
  }

  export interface nsIMemoryInfoDumper extends nsISupports {

    /**
     * This dumps gzipped memory reports for this process and its child
     * processes.  If a file of the given name exists, it will be overwritten.
     *
     * @param aFilename The output file.
     *
     * @param aFinishDumping The callback called on completion.
     *
     * @param aFinishDumpingData The environment for the callback.
     *
     * @param aAnonymize Should the reports be anonymized?
     *
     * Sample output, annotated with comments for explanatory purposes.
     *
     * {
     *   // The version number of the format, which will be incremented each time
     *   // backwards-incompatible changes are made. A mandatory integer.
     *   "version": 1
     *
     *   // Equal to nsIMemoryReporterManager::hasMozMallocUsableSize. A
     *   // mandatory boolean.
     *   "hasMozMallocUsableSize": true,
     *
     *   // The memory reports. A mandatory array.
     *   "reports": [
     *     // The properties correspond to the arguments of
     *     // nsIHandleReportCallback::callback. Every one is mandatory.
     *     {"process":"Main Process (pid 12345)", "path":"explicit/foo/bar",
     *      "kind":1, "units":0, "amount":2000000, "description":"Foo bar."},
     *     {"process":"Main Process (pid 12345)", "path":"heap-allocated",
     *      "kind":1, "units":0, "amount":3000000, "description":"Heap allocated."},
     *     {"process":"Main Process (pid 12345)", "path":"vsize",
     *      "kind":1, "units":0, "amount":10000000, "description":"Vsize."}
     *   ]
     * }
     */
    readonly dumpMemoryReportsToNamedFile: (aFilename: IDLAString, aFinishDumping: (nsIFinishDumpingCallback | nsIFinishDumpingCallbackFunction | null), aFinishDumpingData: (nsISupports | null), aAnonymize: boolean) => void;

    /**
     * Similar to dumpMemoryReportsToNamedFile, this method dumps gzipped memory
     * reports for this process and its child processes to files in the tmp
     * directory called memory-reports-<identifier>-<pid>.json.gz (or something
     * similar, such as memory-reports-<identifier>-<pid>-1.json.gz; no existing
     * file will be overwritten).
     *
     * If DMD is enabled, this method also dumps gzipped DMD output for this
     * process and its child processes to files in the tmp directory called
     * dmd-<identifier>-<pid>.txt.gz (or something similar; again, no existing
     * file will be overwritten).
     *
     * @param aIdentifier this identifier will appear in the filename of our
     *   about:memory dump and those of our children.
     *
     *   If the identifier is empty, the implementation may set it arbitrarily
     *   and use that new value for its own dump and the dumps of its child
     *   processes.  For example, the implementation may set |aIdentifier| to the
     *   number of seconds since the epoch.
     *
     * @param aAnonymize Should the reports be anonymized?
     *
     * @param aMinimizeMemoryUsage indicates whether we should run a series of
     *   gc/cc's in an attempt to reduce our memory usage before collecting our
     *   memory report.
     */
    readonly dumpMemoryInfoToTempDir: (aIdentifier: IDLAString, aAnonymize: boolean, aMinimizeMemoryUsage: boolean) => void;

    /**
     * Dump GC and CC logs to files in the OS's temp directory (or in
     * $MOZ_CC_LOG_DIRECTORY, if that environment variable is specified).
     *
     * @param aIdentifier If aIdentifier is non-empty, this string will appear in
     *   the filenames of the logs we create (both for this process and, if
     *   aDumpChildProcesses is true, for our child processes).
     *
     *   If aIdentifier is empty, the implementation may set it to an
     *   arbitrary value; for example, it may set aIdentifier to the number
     *   of seconds since the epoch.
     *
     * @param aDumpAllTraces indicates whether we should run an all-traces CC
     *   log.  An all-traces log visits all objects currently eligible for cycle
     *   collection, while a non-all-traces log avoids visiting some objects
     *   which we know are reachable.
     *
     *   All-traces logs are much bigger than the alternative, but they may be
     *   helpful when trying to understand why a particular object is alive.  For
     *   example, a non-traces-log will skip references held by an active
     *   document; if your object is being held alive by such a document, you
     *   probably want to see those references.
     *
     * @param aDumpChildProcesses indicates whether we should call
     *   DumpGCAndCCLogsToFile in our child processes.  If so, the child processes
     *   will dump their children, and so on.
     *
     */
    readonly dumpGCAndCCLogsToFile: (aIdentifier: IDLAString, aDumpAllTraces: boolean, aDumpChildProcesses: boolean, aCallback: (nsIDumpGCAndCCLogsCallback | null)) => void;

    /**
     * Like |dumpGCAndCCLogsToFile|, but sends the logs to the given log
     * sink object instead of accessing the filesystem directly, and
     * dumps the current process only.
     */
    readonly dumpGCAndCCLogsToSink: (aDumpAllTraces: boolean, aSink: (nsICycleCollectorLogSink | null)) => void;
  }

  export interface nsITimerRef {
    readonly name: "nsITimer";
    readonly number: "{3de4b105-363c-482c-a409-baac83a01bfc}";

    /**
     * nsITimer instances must be initialized by calling one of the "init" methods
     * documented below.  You may also re-initialize (using one of the init()
     * methods) an existing instance to avoid the overhead of destroying and
     * creating a timer.  It is not necessary to cancel the timer in that case.
     *
     * By default a timer will fire on the thread that created it.  Set the .target
     * attribute to fire on a different thread.  Once you have set a timer's .target
     * and called one of its init functions, any further interactions with the timer
     * (calling cancel(), changing member fields, etc) should only be done by the
     * target thread, or races may occur with bad results like timers firing after
     * they've been canceled, and/or not firing after re-initiatization.
     */
    /**
     * Type of a timer that fires once only.
     */
    TYPE_ONE_SHOT: 0;

    /**
     * After firing, a TYPE_REPEATING_SLACK timer is stopped and not restarted
     * until its callback completes.  Specified timer period will be at least
     * the time between when processing for last firing the callback completes
     * and when the next firing occurs.
     *
     * This is the preferable repeating type for most situations.
     */
    TYPE_REPEATING_SLACK: 1;

    /**
     * TYPE_REPEATING_PRECISE is just a synonym for
     * TYPE_REPEATING_PRECISE_CAN_SKIP. They used to be distinct, but the old
     * TYPE_REPEATING_PRECISE kind was similar to TYPE_REPEATING_PRECISE_CAN_SKIP
     * while also being less useful. So the distinction was removed.
     */
    TYPE_REPEATING_PRECISE: 2;

    /**
     * A TYPE_REPEATING_PRECISE_CAN_SKIP repeating timer aims to have constant
     * period between firings.  The processing time for each timer callback
     * should not influence the timer period.  However this timer type
     * guarantees that it will not queue up new events to fire the callback
     * until the previous callback event finishes firing.  If the callback
     * takes a long time, then the next callback will be scheduled immediately
     * afterward, but only once.  This is the only non-slack timer available.
     */
    TYPE_REPEATING_PRECISE_CAN_SKIP: 3;

    /**
     * Same as TYPE_REPEATING_SLACK with the exception that idle events
     * won't yield to timers with this type.  Use this when you want an
     * idle callback to be scheduled to run even though this timer is
     * about to fire.
     */
    TYPE_REPEATING_SLACK_LOW_PRIORITY: 4;

    /**
     * Same as TYPE_ONE_SHOT with the exception that idle events won't
     * yield to timers with this type.  Use this when you want an idle
     * callback to be scheduled to run even though this timer is about
     * to fire.
     */
    TYPE_ONE_SHOT_LOW_PRIORITY: 5;
  }

  /**
   * The callback interface for timers.
   */
  export interface nsITimer extends nsISupports {

    /**
     * Initialize a timer that will fire after the said delay.
     * A user must keep a reference to this timer till it is
     * is no longer needed or has been cancelled.
     *
     * @param aObserver   the callback object that observes the
     *                    ``timer-callback'' topic with the subject being
     *                    the timer itself when the timer fires:
     *
     *                    observe(nsISupports aSubject, => nsITimer
     *                            string aTopic,        => ``timer-callback''
     *                            wstring data          =>  null
     *
     * @param aDelay      delay in milliseconds for timer to fire
     * @param aType       timer type per TYPE* consts defined above
     */
    readonly init: (aObserver: (nsIObserver | nsIObserverFunction | null), aDelay: number, aType: number) => void;

    /**
     * Initialize a timer to fire after the given millisecond interval.
     * This version takes a callback object.
     *
     * @param aFunc      nsITimerCallback interface to call when timer expires
     * @param aDelay     The millisecond interval
     * @param aType      Timer type per TYPE* consts defined above
     */
    readonly initWithCallback: (aCallback: (nsITimerCallback | nsITimerCallbackFunction | null), aDelay: number, aType: number) => void;

    /**
     * Cancel the timer.  This method works on all types, not just on repeating
     * timers -- you might want to cancel a TYPE_ONE_SHOT timer, and even reuse
     * it by re-initializing it (to avoid object destruction and creation costs
     * by conserving one timer instance).
     */
    readonly cancel: () => void;

    /**
     * The millisecond delay of the timeout.
     *
     * NOTE: Re-setting the delay on a one-shot timer that has already fired
     * doesn't restart the timer. Call one of the init() methods to restart
     * a one-shot timer.
     */
    delay: number;

    /**
     * The timer type - one of the above TYPE_* constants.
     */
    type: number;

    /**
     * The nsITimerCallback object passed to initWithCallback.
     */
    readonly callback: (nsITimerCallback | null);

    /**
     * The nsIEventTarget where the callback will be dispatched. Note that this
     * target may only be set before the call to one of the init methods above.
     *
     * By default the target is the thread that created the timer.
     */
    target: (nsIEventTarget | null);
  }

  export interface nsITraceableChannelRef {
    readonly name: "nsITraceableChannel";
    readonly number: "{68167b0b-ef34-4d79-a09a-8045f7c5140e}";
  }

  /**
   * A channel implementing this interface allows one to intercept its data by
   * inserting intermediate stream listeners.
   */
  export interface nsITraceableChannel extends nsISupports {

    readonly setNewListener: (aListener: (nsIStreamListener | null)) => (nsIStreamListener | null);
  }

  export interface nsIProtocolProxyChannelFilterRef {
    readonly name: "nsIProtocolProxyChannelFilter";
    readonly number: "{245b0880-82c5-4e6e-be6d-bc586aa55a90}";
  }

  /**
   * This interface is used to apply filters to the proxies selected for a given
   * channel.  Use nsIProtocolProxyService::registerChannelFilter to hook up instances of
   * this interface. See also nsIProtocolProxyFilter.
   */
  export interface nsIProtocolProxyChannelFilter extends nsISupports {

    /**
     * This method is called to apply proxy filter rules for the given channel
     * and proxy object (or list of proxy objects).
     *
     * @param aProxyService
     *        A reference to the Protocol Proxy Service.  This is passed so that
     *        implementations may easily access methods such as newProxyInfo.
     * @param aChannel
     *        The channel for which these proxy settings apply.
     * @param aProxy
     *        The proxy (or list of proxies) that would be used by default for
     *        the given channel. This may be null.
     *
     * @param aCallback
     *        An object that the implementer is obligated to call on with
     *        the result (from within applyFilter() or asynchronously) when
     *        applyFilter didn't throw.  The argument passed to onProxyFilterResult
     *        is the proxy (or list of proxies) that should be used in place of
     *        aProxy.  This can be just be aProxy if the filter chooses not to
     *        modify the proxy.  It can also be null to indicate that a direct
     *        connection should be used.  Use aProxyService.newProxyInfo to
     *        construct nsIProxyInfo objects.
     */
    readonly applyFilter: (aProxyService: (nsIProtocolProxyService | null), aChannel: (nsIChannel | null), aProxy: (nsIProxyInfo | null), aCallback: (nsIProxyProtocolFilterResult | null)) => void;
  }

  export interface nsIPreloadedStyleSheetRef {
    readonly name: "nsIPreloadedStyleSheet";
    readonly number: "{2e2a84d0-2102-4b9e-9b78-1670623a582d}";
  }

  /**
   * The nsIPreloadedStyleSheet interface is an opaque interface for
   * style sheets returned by nsIStyleSheetService.preloadSheet, and
   * which can be passed to nsIDOMWindowUtils.addSheet.
   */
  export interface nsIPreloadedStyleSheet extends nsISupports {
  }

  export interface nsIDebug2Ref {
    readonly name: "nsIDebug2";
    readonly number: "{9641dc15-10fb-42e3-a285-18be90a5c10b}";
  }

  /**
   *   For use by consumers in scripted languages (JavaScript, Java, Python,
   *   Perl, ...).
   *
   *   @note C/C++ consumers who are planning to use the nsIDebug2 interface with
   *   the "@mozilla.org/xpcom;1" contract should use NS_DebugBreak from xpcom
   *   glue instead.
   *
   */
  export interface nsIDebug2 extends nsISupports {

    /**
     * Whether XPCOM was compiled with DEBUG defined.  This often
     * correlates to whether other code (e.g., Firefox, XULRunner) was
     * compiled with DEBUG defined.
     */
    readonly isDebugBuild: boolean;

    /**
     * The number of assertions since process start.
     */
    readonly assertionCount: number;

    /**
     * Whether a debugger is currently attached.
     * Supports Windows + Mac
     */
    readonly isDebuggerAttached: boolean;

    /**
     * Show an assertion and trigger nsIDebug2.break().
     *
     * @param aStr assertion message
     * @param aExpr expression that failed
     * @param aFile file containing assertion
     * @param aLine line number of assertion
     */
    readonly assertion: (aStr: string, aExpr: string, aFile: string, aLine: number) => void;

    /**
     * Show a warning.
     *
     * @param aStr warning message
     * @param aFile file containing assertion
     * @param aLine line number of assertion
     */
    readonly warning: (aStr: string, aFile: string, aLine: number) => void;

    /**
     * Request to break into a debugger.
     *
     * @param aFile file containing break request
     * @param aLine line number of break request
     */
    readonly break: (aFile: string, aLine: number) => void;

    /**
     * Request the process to trigger a fatal abort.
     *
     * @param aFile file containing abort request
     * @param aLine line number of abort request
     */
    readonly abort: (aFile: string, aLine: number) => void;

    /**
     * Request the process to trigger a fatal panic!() from Rust code.
     *
     * @param aMessage the string to pass to panic!().
     */
    readonly rustPanic: (aMessage: string) => void;
  }

  export interface nsIAsyncStreamReaderRef {
    readonly name: "nsIAsyncStreamReader";
    readonly number: "{aafadd3f-fe7e-4a75-83d3-26fe3d992364}";
  }

  export interface nsIAsyncStreamReader extends nsISupports {

    /**
     * Read an asynchronous input stream and return a promise which will resolve
     * with a string containing the contents of the stream when the read is
     * finished successfully, or rejected with an error.
     *
     * @param aInputStream the input stream to read from.
     */
    readonly readAsyncStream: (aInputStream: (nsIAsyncInputStream | null)) => IDLPromise;
  }

  export interface nsINativeFileWatcherCallbackRef {
    readonly name: "nsINativeFileWatcherCallback";
    readonly number: "{fe4d86c9-243f-4195-b544-aece3df4b86a}";
  }

  type nsINativeFileWatcherCallbackFunction = (resourcePath: IDLAString, flags: number) => void;

  /**
   * The interface for the callback invoked when a change on a watched
   * resource is detected.
   */
  export interface nsINativeFileWatcherCallback extends nsISupports {

    /**
     * @param resourcePath
     *        The path of the changed resource. If there were too many changes,
     *        the string "*" is passed.
     * @param flags Reserved for future uses, not currently used.
     */
    readonly changed: (resourcePath: IDLAString, flags: number) => void;
  }

  export interface nsISupportsPRBoolRef {
    readonly name: "nsISupportsPRBool";
    readonly number: "{ddc3b490-4a1c-11d3-9890-006008962422}";
  }

  /**
   * The rest are truly primitive and are passed by value
   */
  /**
   * Scriptable storage for booleans
   */
  export interface nsISupportsPRBool extends nsISupportsPrimitive {

    data: boolean;

    readonly toString: () => string;
  }

  export interface nsIScriptErrorNoteRef {
    readonly name: "nsIScriptErrorNote";
    readonly number: "{e8933fc9-c302-4e12-a55b-4f88611d9c6c}";
  }

  export interface nsIScriptErrorNote extends nsISupports {

    readonly errorMessage: IDLAString;

    readonly sourceName: IDLAString;

    /**
     * Unique identifier within the process for the script source this note is
     * associated with, or zero.
     */
    readonly sourceId: number;

    readonly lineNumber: number;

    readonly columnNumber: number;

    readonly toString: () => IDLAUTF8String;
  }

  export interface nsIObserverRef {
    readonly name: "nsIObserver";
    readonly number: "{db242e01-e4d9-11d2-9dde-000064657374}";
  }

  type nsIObserverFunction = (aSubject: (nsISupports | null), aTopic: string, aData: string) => void;

  /**
   * This interface is implemented by an object that wants
   * to observe an event corresponding to a topic.
   */
  export interface nsIObserver extends nsISupports {

    /**
     * Observe will be called when there is a notification for the
     * topic |aTopic|.  This assumes that the object implementing
     * this interface has been registered with an observer service
     * such as the nsIObserverService.
     *
     * If you expect multiple topics/subjects, the impl is
     * responsible for filtering.
     *
     * You should not modify, add, remove, or enumerate
     * notifications in the implemention of observe.
     *
     * @param aSubject : Notification specific interface pointer.
     * @param aTopic   : The notification topic or subject.
     * @param aData    : Notification specific wide string.
     *                    subject event.
     */
    readonly observe: (aSubject: (nsISupports | null), aTopic: string, aData: string) => void;
  }

  export interface nsIAudioDeviceInfoRef {
    readonly name: "nsIAudioDeviceInfo";
    readonly number: "{feb979a8-f8cc-4522-9dff-6c055ca50762}";

    TYPE_UNKNOWN: 0;

    TYPE_INPUT: 1;

    TYPE_OUTPUT: 2;

    STATE_DISABLED: 0;

    STATE_UNPLUGGED: 1;

    STATE_ENABLED: 2;

    PREF_NONE: 0;

    PREF_MULTIMEDIA: 1;

    PREF_VOICE: 2;

    PREF_NOTIFICATION: 4;

    PREF_ALL: 15;

    FMT_S16LE: 16;

    FMT_S16BE: 32;

    FMT_F32LE: 4096;

    FMT_F32BE: 8192;
  }

  export interface nsIAudioDeviceInfo extends nsISupports {

    readonly name: IDLAString;

    readonly groupId: IDLAString;

    readonly vendor: IDLAString;

    readonly type: number;

    readonly state: number;

    readonly preferred: number;

    readonly supportedFormat: number;

    readonly defaultFormat: number;

    readonly maxChannels: number;

    readonly defaultRate: number;

    readonly maxRate: number;

    readonly minRate: number;

    readonly maxLatency: number;

    readonly minLatency: number;
  }

  export interface nsIApplicationCacheServiceRef {
    readonly name: "nsIApplicationCacheService";
    readonly number: "{b8b6546c-6cec-4bda-82df-08e006a97b56}";
  }

  /**
   * The application cache service manages the set of application cache
   * groups.
   */
  export interface nsIApplicationCacheService extends nsISupports {

    /**
     * Create group string identifying cache group according the manifest
     * URL and the given principal.
     */
    readonly buildGroupIDForInfo: (aManifestURL: (nsIURI | null), aLoadContextInfo: (nsILoadContextInfo | null)) => IDLACString;

    readonly buildGroupIDForSuffix: (aManifestURL: (nsIURI | null), aOriginSuffix: IDLACString) => IDLACString;

    /**
     * Create a new, empty application cache for the given cache
     * group.
     */
    readonly createApplicationCache: (group: IDLACString) => (nsIApplicationCache | null);

    /**
     * Create a new, empty application cache for the given cache
     * group residing in a custom directory with a custom quota.
     *
     * @param group
     *    URL of the manifest
     * @param directory
     *    Actually a reference to a profile directory where to
     *    create the OfflineCache sub-dir.
     * @param quota
     *    Optional override of the default quota.
     */
    readonly createCustomApplicationCache: (group: IDLACString, profileDir: (nsIFile | null), quota: number) => (nsIApplicationCache | null);

    /**
     * Get an application cache object for the given client ID.
     */
    readonly getApplicationCache: (clientID: IDLACString) => (nsIApplicationCache | null);

    /**
     * Get the currently active cache object for a cache group.
     */
    readonly getActiveCache: (group: IDLACString) => (nsIApplicationCache | null);

    /**
     * Deactivate the currently-active cache object for a cache group.
     */
    readonly deactivateGroup: (group: IDLACString) => void;

    /**
     * Evict offline cache entries, either all of them or those belonging
     * to the given origin.
     */
    readonly evict: (aLoadContextInfo: (nsILoadContextInfo | null)) => void;

    /**
     * Delete caches whom origin attributes matches the given pattern.
     */
    readonly evictMatchingOriginAttributes: (aPattern: IDLAString) => void;

    /**
     * Try to find the best application cache to serve a resource.
     */
    readonly chooseApplicationCache: (key: IDLACString, aLoadContextInfo?: (nsILoadContextInfo | null)) => (nsIApplicationCache | null);

    /**
     * Flags the key as being opportunistically cached.
     *
     * This method should also propagate the entry to other
     * application caches with the same opportunistic namespace, but
     * this is not currently implemented.
     *
     * @param cache
     *        The cache in which the entry is cached now.
     * @param key
     *        The cache entry key.
     */
    readonly cacheOpportunistically: (cache: (nsIApplicationCache | null), key: IDLACString) => void;

    /**
     * Get the list of application cache groups.
     */
    readonly getGroups: () => IDLACString[];

    /**
     * Get the list of application cache groups in the order of
     * activating time.
     */
    readonly getGroupsTimeOrdered: () => IDLACString[];
  }

  export interface nsIUploadChannelRef {
    readonly name: "nsIUploadChannel";
    readonly number: "{5cfe15bd-5adb-4a7f-9e55-4f5a67d15794}";
  }

  /**
   * nsIUploadChannel
   *
   * A channel may optionally implement this interface if it supports the
   * notion of uploading a data stream.  The upload stream may only be set
   * prior to the invocation of asyncOpen on the channel.
   */
  export interface nsIUploadChannel extends nsISupports {

    /**
     * Sets a stream to be uploaded by this channel.
     *
     * Most implementations of this interface require that the stream:
     *   (1) implement threadsafe addRef and release
     *   (2) implement nsIInputStream::readSegments
     *   (3) implement nsISeekableStream::seek
     *
     * History here is that we need to support both streams that already have
     * headers (e.g., Content-Type and Content-Length) information prepended to
     * the stream (by plugins) as well as clients (composer, uploading
     * application) that want to upload data streams without any knowledge of
     * protocol specifications.  For this reason, we have a special meaning
     * for the aContentType parameter (see below).
     *
     * @param aStream
     *        The stream to be uploaded by this channel.
     * @param aContentType
     *        If aContentType is empty, the protocol will assume that no
     *        content headers are to be added to the uploaded stream and that
     *        any required headers are already encoded in the stream.  In the
     *        case of HTTP, if this parameter is non-empty, then its value will
     *        replace any existing Content-Type header on the HTTP request.
     *        In the case of FTP and FILE, this parameter is ignored.
     * @param aContentLength
     *        A value of -1 indicates that the length of the stream should be
     *        determined by calling the stream's |available| method.
     */
    readonly setUploadStream: (aStream: (nsIInputStream | null), aContentType: IDLACString, aContentLength: number) => void;

    /**
     * Get the stream (to be) uploaded by this channel.
     */
    readonly uploadStream: (nsIInputStream | null);
  }

  export interface nsIConsoleServiceRef {
    readonly name: "nsIConsoleService";
    readonly number: "{0eb81d20-c37e-42d4-82a8-ca9ae96bdf52}";
  }

  export interface nsIConsoleService extends nsISupports {

    readonly logMessage: (message: (nsIConsoleMessage | null)) => void;

    /**
     * Convenience method for logging simple messages.
     */
    readonly logStringMessage: (message: string) => void;

    /**
     * Get an array of all the messages logged so far.
     */
    readonly getMessageArray: () => (nsIConsoleMessage | null)[];

    /**
     * To guard against stack overflows from listeners that could log
     * messages (it's easy to do this inadvertently from listeners
     * implemented in JavaScript), we don't call any listeners when
     * another error is already being logged.
     */
    readonly registerListener: (listener: (nsIConsoleListener | nsIConsoleListenerFunction | null)) => void;

    /**
     * Each registered listener should also be unregistered.
     */
    readonly unregisterListener: (listener: (nsIConsoleListener | nsIConsoleListenerFunction | null)) => void;

    /**
     * Clear the message buffer (e.g. for privacy reasons).
     */
    readonly reset: () => void;

    /**
     * Clear the message buffer for a given window.
     */
    readonly resetWindow: (windowInnerId: number) => void;
  }

  export interface nsIGeolocationProviderRef {
    readonly name: "nsIGeolocationProvider";
    readonly number: "{ac4a133b-9f92-4f7c-b369-d40cb6b17650}";
  }

  /**
   * Interface provides location information to the nsGeolocator
   * via the nsIDOMGeolocationCallback interface.  After
   * startup is called, any geo location change should call
   * callback.update().
   */
  export interface nsIGeolocationProvider extends nsISupports {

    /**
     * Start up the provider.  This is called before any other
     * method.  may be called multiple times.
     */
    readonly startup: () => void;

    /**
     * watch
     * When a location change is observed, notify the callback.
     */
    readonly watch: (callback: (nsIGeolocationUpdate | null)) => void;

    /**
     * shutdown
     * Shuts down the location device.
     */
    readonly shutdown: () => void;

    /**
     * hint to provide to use any amount of power to provide a better result
     */
    readonly setHighAccuracy: (enable: boolean) => void;
  }

  export interface nsIPresentationControlChannelListenerRef {
    readonly name: "nsIPresentationControlChannelListener";
    readonly number: "{96dd548f-7d0f-43c1-b1ad-28e666cf1e82}";
  }

  export interface nsIPresentationControlChannelListener extends nsISupports {

    readonly onOffer: (offer: (nsIPresentationChannelDescription | null)) => void;

    readonly onAnswer: (answer: (nsIPresentationChannelDescription | null)) => void;

    readonly onIceCandidate: (candidate: IDLAString) => void;

    readonly notifyConnected: () => void;

    readonly notifyDisconnected: (reason: number) => void;

    readonly notifyReconnected: () => void;
  }

  export interface nsIPaymentAbortActionResponseRef {
    readonly name: "nsIPaymentAbortActionResponse";
    readonly number: "{8c72bcdb-0c37-4786-a9e5-510afa2f8ede}";
  }

  /**
   *  The response for abort action.
   */
  export interface nsIPaymentAbortActionResponse extends nsIPaymentActionResponse {

    /**
     *  The abort action status.
     *  Using the defined consts(ABORT_XXX) in nsIPaymentActionResponse.
     */
    readonly abortStatus: number;

    /**
     *  The Initial method.
     *  @param aRequestId - the request identifier of payment request.
     *  @param aAbortStatus - the abort action result.
     */
    readonly init: (aRequestId: IDLAString, aAbortStatus: number) => void;

    /**
     *  Check if the abort action is succeeded
     */
    readonly isSucceeded: () => boolean;
  }

  export interface nsIEventListenerInfoRef {
    readonly name: "nsIEventListenerInfo";
    readonly number: "{11ba5fd7-8db2-4b1a-9f67-342cfa11afad}";
  }

  /**
   * An instance of this interface describes how an event listener
   * was added to an event target.
   */
  export interface nsIEventListenerInfo extends nsISupports {

    /**
     * The type of the event for which the listener was added.
     * Null if the listener is for all the events.
     */
    readonly type: IDLAString;

    readonly capturing: boolean;

    readonly allowsUntrusted: boolean;

    readonly inSystemEventGroup: boolean;

    /**
     * The underlying JS object of the event listener, if this listener
     * has one.  Null otherwise.
     */
    readonly listenerObject: IDLjsval;

    /**
     * Tries to serialize event listener to a string.
     * Returns null if serialization isn't possible
     * (for example with C++ listeners).
     */
    readonly toSource: () => IDLAString;
  }

  export interface nsIUrlClassifierSkipListObserverRef {
    readonly name: "nsIUrlClassifierSkipListObserver";
    readonly number: "{f7c918e5-94bf-4b6e-9758-ef7bdab6af7e}";
  }

  type nsIUrlClassifierSkipListObserverFunction = (aList: IDLACString) => void;

  /**
   * Observer for skip list updates.
   */
  export interface nsIUrlClassifierSkipListObserver extends nsISupports {

    /**
     * Called by nsIUrlClassifierSkipListService when the skip list
     * for a designated feature changes and when the observer is first registered.
     *
     * @param aList
     *        A comma-separated list of url patterns, intended to be parsed
     *        by nsContentUtils::IsURIInList.
     */
    readonly onSkipListUpdate: (aList: IDLACString) => void;
  }

  export interface nsICaptivePortalServiceCallbackRef {
    readonly name: "nsICaptivePortalServiceCallback";
    readonly number: "{b5fd5629-d04c-4138-9529-9311f291ecd4}";
  }

  export interface nsICaptivePortalServiceCallback extends nsISupports {

    /**
     * Invoke callbacks after captive portal detection finished.
     */
    readonly complete: (success: boolean, error: number) => void;
  }

  export interface nsIWindowMediatorListenerRef {
    readonly name: "nsIWindowMediatorListener";
    readonly number: "{2f276982-0d60-4377-a595-d350ba516395}";
  }

  export interface nsIWindowMediatorListener extends nsISupports {

    readonly onOpenWindow: (window: (nsIAppWindow | null)) => void;

    readonly onCloseWindow: (window: (nsIAppWindow | null)) => void;
  }

  export interface nsIDOMXULContainerElementRef {
    readonly name: "nsIDOMXULContainerElement";
    readonly number: "{b2bc96b8-31fc-42f4-937a-bd27291af40b}";
  }

  export interface nsIDOMXULContainerElement extends nsIDOMXULContainerItemElement {
  }

  export interface nsIWorkerDebuggerManagerRef {
    readonly name: "nsIWorkerDebuggerManager";
    readonly number: "{056d7918-dc86-452a-b4e6-86da3405f015}";
  }

  export interface nsIWorkerDebuggerManager extends nsISupports {

    readonly getWorkerDebuggerEnumerator: () => (nsISimpleEnumerator | null);

    readonly addListener: (listener: (nsIWorkerDebuggerManagerListener | null)) => void;

    readonly removeListener: (listener: (nsIWorkerDebuggerManagerListener | null)) => void;
  }

  export interface nsISiteSecurityStateRef {
    readonly name: "nsISiteSecurityState";
    readonly number: "{31313372-842c-4110-bdf1-6aea17c845ad}";

    SECURITY_PROPERTY_UNSET: 0;

    SECURITY_PROPERTY_SET: 1;

    SECURITY_PROPERTY_KNOCKOUT: 2;

    SECURITY_PROPERTY_NEGATIVE: 3;
  }

  export interface nsISiteSecurityState extends nsISupports {

    readonly hostname: IDLACString;

    readonly expireTime: number;

    readonly securityPropertyState: number;

    readonly includeSubdomains: boolean;

    readonly originAttributes: IDLjsval;
  }

  export interface nsIPropertyBagRef {
    readonly name: "nsIPropertyBag";
    readonly number: "{bfcd37b0-a49f-11d5-910d-0010a4e73d9a}";
  }

  export interface nsIPropertyBag extends nsISupports {

    /**
     * Get a nsISimpleEnumerator whose elements are nsIProperty objects.
     */
    readonly enumerator: (nsISimpleEnumerator | null);

    /**
     * Get a property value for the given name.
     * @throws NS_ERROR_FAILURE if a property with that name doesn't
     * exist.
     */
    readonly getProperty: (name: IDLAString) => (nsIVariant | null);
  }

  export interface nsIFontEnumeratorRef {
    readonly name: "nsIFontEnumerator";
    readonly number: "{924d98d9-3518-4cb4-8708-c74fe8e3ec3c}";
  }

  export interface nsIFontEnumerator extends nsISupports {

    /**
     * Return a sorted array of the names of all installed fonts.
     *
     * @return array of names
     * @return void
     */
    readonly EnumerateAllFonts: () => IDLAString[];

    /**
     * Return a sorted array of names of fonts that support the given language
     * group and are suitable for use as the given CSS generic font.
     *
     * @param  aLangGroup language group
     * @param  aGeneric   CSS generic font
     * @return            array of names
     * @return void
     */
    readonly EnumerateFonts: (aLangGroup: string, aGeneric: string) => IDLAString[];

    /**
     * Return a promise that resolves to a sorted array of the names of all
     * installed fonts.
     *
     * @return Promise that resolves to Array
     */
    readonly EnumerateAllFontsAsync: () => IDLjsval;

    /**
     * Return a promise that resolves to a sorted array of names of fonts
     * that support the given language group and are suitable for use as the given
     * CSS generic font.
     *
     * @param  aLangGroup language group
     * @param  aGeneric   CSS generic font
     * @return Promise that resolves to Array
     */
    readonly EnumerateFontsAsync: (aLangGroup: string, aGeneric: string) => IDLjsval;

    /**
        @param  aLangGroup language group
        @return bool do we have a font for this language group
       */
    readonly HaveFontFor: (aLangGroup: string) => boolean;

    /**
     * @param  aLangGroup language group
     * @param  aGeneric CSS generic font
     * @return suggested default font for this language group and generic family
     */
    readonly getDefaultFont: (aLangGroup: string, aGeneric: string) => string;

    /**
     * update the global font list
     * return true if font list is changed
     */
    readonly updateFontList: () => boolean;

    /**
     * get the standard family name on the system from given family
     * @param  aName family name which may be alias
     * @return the standard family name on the system, if given name does not
     *         exist, returns empty string
     */
    readonly getStandardFamilyName: (aName: string) => string;
  }

  export interface nsIStringInputStreamRef {
    readonly name: "nsIStringInputStream";
    readonly number: "{450cd2d4-f0fd-424d-b365-b1251f80fd53}";
  }

  /**
   * nsIStringInputStream
   *
   * Provides scriptable and specialized C++-only methods for initializing a
   * nsIInputStream implementation with a simple character array.
   */
  export interface nsIStringInputStream extends nsIInputStream {

    /**
     * SetData - assign data to the input stream (copied on assignment).
     *
     * @param data    - stream data
     * @param dataLen - stream data length (-1 if length should be computed)
     *
     * NOTE: C++ code should consider using AdoptData or ShareData to avoid
     * making an extra copy of the stream data.
     *
     * NOTE: For JS callers, the given data must not contain null characters
     * (other than a null terminator) because a null character in the middle of
     * the data string will be seen as a terminator when the data is converted
     * from a JS string to a C++ character array.
     */
    readonly setData: (data: string, dataLen: number) => void;

    /**
     * SetUTF8Data - encode input data to UTF-8 and assign it to the input
     * stream.
     *
     * @param data    - stream data
     *
     * NOTE: This method is meant to be used by JS callers,
     */
    readonly setUTF8Data: (data: IDLAUTF8String) => void;
  }

  export interface nsIAddonPolicyServiceRef {
    readonly name: "nsIAddonPolicyService";
    readonly number: "{8a034ef9-9d14-4c5d-8319-06c1ab574baa}";
  }

  /**
   * This interface allows the security manager to query custom per-addon security
   * policy.
   */
  export interface nsIAddonPolicyService extends nsISupports {

    /**
     * Returns the base content security policy, which is applied to all
     * extension documents, in addition to any custom policies.
     */
    readonly baseCSP: IDLAString;

    /**
     * Returns the default content security policy which applies to extension
     * documents which do not specify any custom policies.
     */
    readonly defaultCSP: IDLAString;

    /**
     * Returns the content security policy which applies to documents belonging
     * to the extension with the given ID. This may be either a custom policy,
     * if one was supplied, or the default policy if one was not.
     */
    readonly getExtensionPageCSP: (aAddonId: IDLAString) => IDLAString;

    /**
     * Returns the content security policy which applies to content scripts belonging
     * to the extension with the given ID. This may be either a custom policy,
     * if one was supplied, or the default policy if one was not.
     */
    readonly getContentScriptCSP: (aAddonId: IDLAString) => IDLAString;

    /**
     * Returns the generated background page as a data-URI, if any. If the addon
     * does not have an auto-generated background page, an empty string is
     * returned.
     */
    readonly getGeneratedBackgroundPageUrl: (aAddonId: IDLACString) => IDLACString;

    /**
     * Returns true if the addon was granted the |aPerm| API permission.
     */
    readonly addonHasPermission: (aAddonId: IDLAString, aPerm: IDLAString) => boolean;

    /**
     * Returns true if unprivileged code associated with the given addon may load
     * data from |aURI|.  If |aExplicit| is true, the <all_urls> permission and
     * permissive host globs are ignored when checking for a match.
     */
    readonly addonMayLoadURI: (aAddonId: IDLAString, aURI: (nsIURI | null), aExplicit?: boolean) => boolean;

    /**
     * Returns the name of the WebExtension with the given ID, or the ID string
     * if no matching add-on can be found.
     */
    readonly getExtensionName: (aAddonId: IDLAString) => IDLAString;

    /**
     * Returns true if a given extension:// URI is web-accessible.
     */
    readonly extensionURILoadableByAnyone: (aURI: (nsIURI | null)) => boolean;

    /**
     * Maps an extension URI to the ID of the addon it belongs to.
     */
    readonly extensionURIToAddonId: (aURI: (nsIURI | null)) => IDLAString;
  }

  export interface nsIProfileStartupRef {
    readonly name: "nsIProfileStartup";
    readonly number: "{048e5ca1-0eb7-4bb1-a9a2-a36f7d4e0e3c}";
  }

  /**
   * Helper interface for nsIProfileMigrator.
   *
   * @provider Toolkit (Startup code)
   * @client   Application (Profile-migration code)
   * @obtainable nsIProfileMigrator.migrate
   */
  export interface nsIProfileStartup extends nsISupports {

    /**
     * The root directory of the semi-current profile, during profile migration.
     * After nsIProfileMigrator.migrate has returned, this object will not be
     * useful.
     */
    readonly directory: (nsIFile | null);

    /**
     * Do profile-startup by setting NS_APP_USER_PROFILE_50_DIR in the directory
     * service and notifying the profile-startup observer topics.
     */
    readonly doStartup: () => void;
  }

  /**
   * Returns the allowing status for flash plugin for this channel.
   */
  export enum nsIHttpChannel_FlashPluginState {
    FlashPluginUnknown = 0,
    FlashPluginAllowed = 1,
    FlashPluginDenied = 2,
    FlashPluginDeniedInSubdocuments = 3,
    FlashPluginLastValue = 3,
  }

  export interface nsIHttpChannelRef {
    readonly name: "nsIHttpChannel";
    readonly number: "{c5a4a073-4539-49c7-a3f2-cec3f0619c6c}";

    FlashPluginUnknown: 0;
    FlashPluginAllowed: 1;
    FlashPluginDenied: 2;
    FlashPluginDeniedInSubdocuments: 3;
    FlashPluginLastValue: 3;
  }

  /**
   * nsIHttpChannel
   *
   * This interface allows for the modification of HTTP request parameters and
   * the inspection of the resulting HTTP response status and headers when they
   * become available.
   */
  export interface nsIHttpChannel extends nsIIdentChannel {

    /**************************************************************************
     * REQUEST CONFIGURATION
     *
     * Modifying request parameters after asyncOpen has been called is an error.
     */
    /**
     * Set/get the HTTP request method (default is "GET").  Both setter and
     * getter are case sensitive.
     *
     * This attribute may only be set before the channel is opened.
     *
     * NOTE: The data for a "POST" or "PUT" request can be configured via
     * nsIUploadChannel; however, after setting the upload data, it may be
     * necessary to set the request method explicitly.  The documentation
     * for nsIUploadChannel has further details.
     *
     * @throws NS_ERROR_IN_PROGRESS if set after the channel has been opened.
     */
    requestMethod: IDLACString;

    /**
     * Get/set the referrer information.  This contains the referrer (URI) of the
     * resource from which this channel's URI was obtained (see RFC2616 section
     * 14.36) and the referrer policy applied to the referrer.
     *
     * This attribute may only be set before the channel is opened.
     *
     * Setting this attribute will clone new referrerInfo object by default.
     *
     * NOTE: The channel may silently refuse to set the Referer header if the
     * URI does not pass certain security checks (e.g., a "https://" URL will
     * never be sent as the referrer for a plaintext HTTP request).  The
     * implementation is not required to throw an exception when the referrer
     * URI is rejected.
     *
     * @throws NS_ERROR_IN_PROGRESS if set after the channel has been opened.
     * @throws NS_ERROR_FAILURE if used for setting referrer during
     *         visitRequestHeaders. Getting the value will not throw.
     */
    referrerInfo: (nsIReferrerInfo | null);

    /**
     * Returns the network protocol used to fetch the resource as identified
     * by the ALPN Protocol ID.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     */
    readonly protocolVersion: IDLACString;

    /**
     * size consumed by the response header fields and the response payload body
     */
    readonly transferSize: number;

    /**
     * size consumed by the request header fields and the request payload body
     */
    readonly requestSize: number;

    /**
     * The size of the message body received by the client,
     * after removing any applied content-codings
     */
    readonly decodedBodySize: number;

    /**
     * The size in octets of the payload body, prior to removing content-codings
     */
    readonly encodedBodySize: number;

    /**
     * Get the value of a particular request header.
     *
     * @param aHeader
     *        The case-insensitive name of the request header to query (e.g.,
     *        "Cache-Control").
     *
     * @return the value of the request header.
     * @throws NS_ERROR_NOT_AVAILABLE if the header is not set.
     */
    readonly getRequestHeader: (aHeader: IDLACString) => IDLACString;

    /**
     * Set the value of a particular request header.
     *
     * This method allows, for example, the cookies module to add "Cookie"
     * headers to the outgoing HTTP request.
     *
     * This method may only be called before the channel is opened.
     *
     * @param aHeader
     *        The case-insensitive name of the request header to set (e.g.,
     *        "Cookie").
     * @param aValue
     *        The request header value to set (e.g., "X=1").
     * @param aMerge
     *        If true, the new header value will be merged with any existing
     *        values for the specified header.  This flag is ignored if the
     *        specified header does not support merging (e.g., the "Content-
     *        Type" header can only have one value).  The list of headers for
     *        which this flag is ignored is an implementation detail.  If this
     *        flag is false, then the header value will be replaced with the
     *        contents of |aValue|.
     *
     * If aValue is empty and aMerge is false, the header will be cleared.
     *
     * @throws NS_ERROR_IN_PROGRESS if called after the channel has been
     *         opened.
     * @throws NS_ERROR_FAILURE if called during visitRequestHeaders.
     */
    readonly setRequestHeader: (aHeader: IDLACString, aValue: IDLACString, aMerge: boolean) => void;

    /**
     * Set a request header with empty value.
     *
     * This should be used with caution in the cases where the behavior of
     * setRequestHeader ignoring empty header values is undesirable.
     *
     * This method may only be called before the channel is opened.
     *
     * @param aHeader
     *        The case-insensitive name of the request header to set (e.g.,
     *        "Cookie").
     *
     * @throws NS_ERROR_IN_PROGRESS if called after the channel has been
     *         opened.
     * @throws NS_ERROR_FAILURE if called during visitRequestHeaders.
     */
    readonly setEmptyRequestHeader: (aHeader: IDLACString) => void;

    /**
     * Call this method to visit all request headers.  Calling setRequestHeader
     * while visiting request headers has undefined behavior.  Don't do it!
     *
     * @param aVisitor
     *        the header visitor instance.
     */
    readonly visitRequestHeaders: (aVisitor: (nsIHttpHeaderVisitor | nsIHttpHeaderVisitorFunction | null)) => void;

    /**
     * Call this method to visit all non-default (UA-provided) request headers.
     * Calling setRequestHeader while visiting request headers has undefined
     * behavior. Don't do it!
     *
     * @param aVisitor
     *        the header visitor instance.
     */
    readonly visitNonDefaultRequestHeaders: (aVisitor: (nsIHttpHeaderVisitor | nsIHttpHeaderVisitorFunction | null)) => void;

    /**
     * This attribute no longer has any effect, it remains for backwards compat
     *
     * @throws NS_ERROR_FAILURE if set after the channel has been opened.
     */
    allowPipelining: boolean;

    /**
     * This attribute of the channel indicates whether or not
     * the underlying HTTP transaction should be honor stored Strict Transport
     * Security directives for its principal. It defaults to true. Using
     * OCSP to bootstrap the HTTPs is the likely use case for setting it to
     * false.
     *
     * This attribute may only be set before the channel is opened.
     *
     * @throws NS_ERROR_IN_PROGRESS or NS_ERROR_ALREADY_OPENED
     *         if called after the channel has been opened.
     */
    allowSTS: boolean;

    /**
     * This attribute specifies the number of redirects this channel is allowed
     * to make.  If zero, the channel will fail to redirect and will generate
     * a NS_ERROR_REDIRECT_LOOP failure status.
     *
     * NOTE: An HTTP redirect results in a new channel being created.  If the
     * new channel supports nsIHttpChannel, then it will be assigned a value
     * to its |redirectionLimit| attribute one less than the value of the
     * redirected channel's |redirectionLimit| attribute.  The initial value
     * for this attribute may be a configurable preference (depending on the
     * implementation).
     */
    redirectionLimit: number;

    /**************************************************************************
     * RESPONSE INFO
     *
     * Accessing response info before the onStartRequest event is an error.
     */
    /**
     * Get the HTTP response code (e.g., 200).
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     */
    readonly responseStatus: number;

    /**
     * Get the HTTP response status text (e.g., "OK").
     *
     * NOTE: This returns the raw (possibly 8-bit) text from the server.  There
     * are no assumptions made about the charset of the returned text.  You
     * have been warned!
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     */
    readonly responseStatusText: IDLACString;

    /**
     * Returns true if the HTTP response code indicates success.  The value of
     * nsIRequest::status will be NS_OK even when processing a 404 response
     * because a 404 response may include a message body that (in some cases)
     * should be shown to the user.
     *
     * Use this attribute to distinguish server error pages from normal pages,
     * instead of comparing the response status manually against the set of
     * valid response codes, if that is required by your application.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     */
    readonly requestSucceeded: boolean;

    /** Indicates whether channel should be treated as the main one for the
     *  current document.  If manually set to true, will always remain true.  Otherwise,
     *  will be true if LOAD_DOCUMENT_URI is set in the channel's loadflags.
     */
    isMainDocumentChannel: boolean;

    /**
     * Get the value of a particular response header.
     *
     * @param aHeader
     *        The case-insensitive name of the response header to query (e.g.,
     *        "Set-Cookie").
     *
     * @return the value of the response header.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest) or if the header is
     *         not set in the response.
     */
    readonly getResponseHeader: (header: IDLACString) => IDLACString;

    /**
     * Set the value of a particular response header.
     *
     * This method allows, for example, the HTML content sink to inform the HTTP
     * channel about HTTP-EQUIV headers found in HTML <META> tags.
     *
     * @param aHeader
     *        The case-insensitive name of the response header to set (e.g.,
     *        "Cache-control").
     * @param aValue
     *        The response header value to set (e.g., "no-cache").
     * @param aMerge
     *        If true, the new header value will be merged with any existing
     *        values for the specified header.  This flag is ignored if the
     *        specified header does not support merging (e.g., the "Content-
     *        Type" header can only have one value).  The list of headers for
     *        which this flag is ignored is an implementation detail.  If this
     *        flag is false, then the header value will be replaced with the
     *        contents of |aValue|.
     *
     * If aValue is empty and aMerge is false, the header will be cleared.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     * @throws NS_ERROR_ILLEGAL_VALUE if changing the value of this response
     *         header is not allowed.
     * @throws NS_ERROR_FAILURE if called during visitResponseHeaders,
     *         VisitOriginalResponseHeaders or getOriginalResponseHeader.
     */
    readonly setResponseHeader: (header: IDLACString, value: IDLACString, merge: boolean) => void;

    /**
     * Call this method to visit all response headers.  Calling
     * setResponseHeader while visiting response headers has undefined
     * behavior.  Don't do it!
     *
     * @param aVisitor
     *        the header visitor instance.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     */
    readonly visitResponseHeaders: (aVisitor: (nsIHttpHeaderVisitor | nsIHttpHeaderVisitorFunction | null)) => void;

    /**
     * Get the value(s) of a particular response header in the form and order
     * it has been received from the remote peer. There can be multiple headers
     * with the same name.
     *
     * @param aHeader
     *        The case-insensitive name of the response header to query (e.g.,
     *        "Set-Cookie").
     *
     * @param aVisitor
     *        the header visitor instance.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest) or if the header is
     *         not set in the response.
     */
    readonly getOriginalResponseHeader: (aHeader: IDLACString, aVisitor: (nsIHttpHeaderVisitor | nsIHttpHeaderVisitorFunction | null)) => void;

    /**
     * Call this method to visit all response headers in the form and order as
     * they have been received from the remote peer.
     * Calling setResponseHeader while visiting response headers has undefined
     * behavior.  Don't do it!
     *
     * @param aVisitor
     *        the header visitor instance.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     */
    readonly visitOriginalResponseHeaders: (aVisitor: (nsIHttpHeaderVisitor | nsIHttpHeaderVisitorFunction | null)) => void;

    /**
     * Returns true if the server sent a "Cache-Control: no-store" response
     * header.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     */
    readonly isNoStoreResponse: () => boolean;

    /**
     * Returns true if the server sent the equivalent of a "Cache-control:
     * no-cache" response header.  Equivalent response headers include:
     * "Pragma: no-cache", "Expires: 0", and "Expires" with a date value
     * in the past relative to the value of the "Date" header.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     */
    readonly isNoCacheResponse: () => boolean;

    /**
     * Returns true if the server sent a "Cache-Control: private" response
     * header.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called before the response
     *         has been received (before onStartRequest).
     */
    readonly isPrivateResponse: () => boolean;

    /**
     * Instructs the channel to immediately redirect to a new destination.
     * Can only be called on channels that have not yet called their
     * listener's OnStartRequest(). Generally that means the latest time
     * this can be used is one of:
     *    "http-on-examine-response"
     *    "http-on-examine-merged-response"
     *    "http-on-examine-cached-response"
     *
     * When non-null URL is set before AsyncOpen:
     *  we attempt to redirect to the targetURI before we even start building
     *  and sending the request to the cache or the origin server.
     *  If the redirect is vetoed, we fail the channel.
     *
     * When set between AsyncOpen and first call to OnStartRequest being called:
     *  we attempt to redirect before we start delivery of network or cached
     *  response to the listener.  If vetoed, we continue with delivery of
     *  the original content to the channel listener.
     *
     * When passed aTargetURI is null the channel behaves normally (can be
     * rewritten).
     *
     * This method provides no explicit conflict resolution. The last
     * caller to call it wins.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called after the channel has already
     *         started to deliver the content to its listener.
     */
    readonly redirectTo: (aTargetURI: (nsIURI | null)) => void;

    /**
     * Flags a channel to be upgraded to HTTPS.
     *
     * Upgrading to a secure channel must happen before or during
     * "http-on-modify-request". If redirectTo is called early as well, it
     * will win and upgradeToSecure will be a no-op.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if called after the channel has already
     *         started to deliver the content to its listener.
     */
    readonly upgradeToSecure: () => void;

    /**
     * ID of the top-level document's inner window.  Identifies the content
     * this channels is being load in.
     */
    topLevelContentWindowId: number;

    readonly flashPluginState: nsIHttpChannel_FlashPluginState;

    /**
     * ID of the top-level outer content window. Identifies this channel's
     * top-level window it comes from.
     *
     * NOTE: The setter of this attribute is currently for xpcshell test only.
     *       Don't alter it otherwise.
     */
    topLevelOuterContentWindowId: number;

    /**
     * In e10s, the information that the CORS response blocks the load is in the
     * parent, which doesn't know the true window id of the request, so we may
     * need to proxy the request to the child.
     *
     * @param aMessage
     *        The message to print in the console.
     *
     * @param aCategory
     *        The category under which the message should be displayed.
     */
    readonly logBlockedCORSRequest: (aMessage: IDLAString, aCategory: IDLACString) => void;

    readonly logMimeTypeMismatch: (aMessageName: IDLACString, aWarning: boolean, aURL: IDLAString, aContentType: IDLAString) => void;
  }

  export interface nsICacheEntryOpenCallbackRef {
    readonly name: "nsICacheEntryOpenCallback";
    readonly number: "{1fc9fe11-c6ac-4748-94bd-8555a5a12b94}";

    /**
     * State of the entry determined by onCacheEntryCheck.
     *
     * ENTRY_WANTED - the consumer is interested in the entry, we will pass it.
     * RECHECK_AFTER_WRITE_FINISHED - the consumer cannot use the entry while data is
     *    still being written and wants to check it again after the current write is
     *    finished. This actually prevents concurrent read/write and is used with
     *    non-resumable HTTP responses.
     * ENTRY_NEEDS_REVALIDATION - entry needs to be revalidated first with origin server,
     *    this means the loading channel will decide whether to use the entry content
     *    as is after it gets a positive response from the server about validity of the
     *    content ; when a new content needs to be loaded from the server, the loading
     *    channel opens a new entry with OPEN_TRUNCATE flag which dooms the one
     *    this check has been made for.
     * ENTRY_NOT_WANTED - the consumer is not interested in the entry, we will not pass it.
     */
    ENTRY_WANTED: 0;

    RECHECK_AFTER_WRITE_FINISHED: 1;

    ENTRY_NEEDS_REVALIDATION: 2;

    ENTRY_NOT_WANTED: 3;
  }

  export interface nsICacheEntryOpenCallback extends nsISupports {

    /**
     * Callback to perform any validity checks before the entry should be used.
     * Called before onCacheEntryAvailable callback, depending on the result it
     * may be called more then one time.
     *
     * This callback is ensured to be called on the same thread on which asyncOpenURI
     * has been called, unless nsICacheStorage.CHECK_MULTITHREADED flag has been specified.
     * In that case this callback can be invoked on any thread, usually it is the cache I/O
     * or cache management thread.
     *
     * IMPORTANT NOTE:
     * This callback may be invoked sooner then respective asyncOpenURI call exits.
     *
     * @param aEntry
     *    An entry to examine.  Consumer has a chance to decide whether the
     *    entry is valid or not.
     * @param aApplicationCache
     *    Optional, application cache the entry has been found in, if any.
     * @return
     *    State of the entry, see the constants just above.
     */
    readonly onCacheEntryCheck: (aEntry: (nsICacheEntry | null), aApplicationCache: (nsIApplicationCache | null)) => number;

    /**
     * Callback giving actual result of asyncOpenURI.  It may give consumer the cache
     * entry or a failure result when it's not possible to open it from some reason.
     * This callback is ensured to be called on the same thread on which asyncOpenURI
     * has been called.
     *
     * IMPORTANT NOTE:
     * This callback may be invoked sooner then respective asyncOpenURI call exits.
     *
     * @param aEntry
     *    The entry bound to the originally requested URI.  May be null when
     *    loading from a particular application cache and the URI has not
     *    been found in that application cache.
     * @param aNew
     *    Whether no data so far has been stored for this entry, i.e. reading
     *    it will just fail.  When aNew is true, a server request should be
     *    made and data stored to this new entry.
     * @param aApplicationCache
     *    When an entry had been found in an application cache, this is the
     *    given application cache.  It should be associated with the loading
     *    channel.
     * @param aResult
     *    Result of the request.  This may be a failure only when one of these
     *    issues occur:
     *    - the cache storage service could not be started due to some unexpected
     *      faulure
     *    - there is not enough disk space to create new entries
     *    - cache entry was not found in a given application cache
     */
    readonly onCacheEntryAvailable: (aEntry: (nsICacheEntry | null), aNew: boolean, aApplicationCache: (nsIApplicationCache | null), aResult: number) => void;
  }

  export interface nsIWritableVariantRef {
    readonly name: "nsIWritableVariant";
    readonly number: "{5586a590-8c82-11d5-90f3-0010a4e73d9a}";
  }

  /**
   * An object that implements nsIVariant may or may NOT also implement this
   * nsIWritableVariant.
   *
   * If the 'writable' attribute is false then attempts to call any of the 'set'
   * methods can be expected to fail. Setting the 'writable' attribute may or
   * may not succeed.
   *
   */
  export interface nsIWritableVariant extends nsIVariant {

    writable: boolean;

    readonly setAsInt8: (aValue: number) => void;

    readonly setAsInt16: (aValue: number) => void;

    readonly setAsInt32: (aValue: number) => void;

    readonly setAsInt64: (aValue: number) => void;

    readonly setAsUint8: (aValue: number) => void;

    readonly setAsUint16: (aValue: number) => void;

    readonly setAsUint32: (aValue: number) => void;

    readonly setAsUint64: (aValue: number) => void;

    readonly setAsFloat: (aValue: number) => void;

    readonly setAsDouble: (aValue: number) => void;

    readonly setAsBool: (aValue: boolean) => void;

    readonly setAsChar: (aValue: string) => void;

    readonly setAsWChar: (aValue: string) => void;

    readonly setAsAString: (aValue: IDLAString) => void;

    readonly setAsACString: (aValue: IDLACString) => void;

    readonly setAsAUTF8String: (aValue: IDLAUTF8String) => void;

    readonly setAsString: (aValue: string) => void;

    readonly setAsWString: (aValue: string) => void;

    readonly setAsISupports: (aValue: (nsISupports | null)) => void;

    readonly setAsStringWithSize: (size: number) => void;

    readonly setAsWStringWithSize: (size: number) => void;

    readonly setAsVoid: () => void;

    readonly setAsEmpty: () => void;

    readonly setAsEmptyArray: () => void;

    readonly setFromVariant: (aValue: (nsIVariant | null)) => void;
  }

  export interface nsIDNSServiceDiscoveryListenerRef {
    readonly name: "nsIDNSServiceDiscoveryListener";
    readonly number: "{3025b7f2-97bb-435b-b43d-26731b3f5fc4}";
  }

  /**
   * The callback interface for service discovery
   */
  export interface nsIDNSServiceDiscoveryListener extends nsISupports {

    /**
     * Callback when the discovery begins.
     * @param   aServiceType
     *          the service type of |startDiscovery|.
     */
    readonly onDiscoveryStarted: (aServiceType: IDLAUTF8String) => void;

    /**
     * Callback when the discovery ends.
     * @param   aServiceType
     *          the service type of |startDiscovery|.
     */
    readonly onDiscoveryStopped: (aServiceType: IDLAUTF8String) => void;

    /**
     * Callback when the a service is found.
     * @param   aServiceInfo
     *          the info about the found service, where |serviceName|, |aServiceType|, and |domainName| are set.
     */
    readonly onServiceFound: (aServiceInfo: (nsIDNSServiceInfo | null)) => void;

    /**
     * Callback when the a service is lost.
     * @param   aServiceInfo
     *          the info about the lost service, where |serviceName|, |aServiceType|, and |domainName| are set.
     */
    readonly onServiceLost: (aServiceInfo: (nsIDNSServiceInfo | null)) => void;

    /**
     * Callback when the discovery cannot start.
     * @param   aServiceType
     *          the service type of |startDiscovery|.
     * @param   aErrorCode
     *          the error code.
     */
    readonly onStartDiscoveryFailed: (aServiceType: IDLAUTF8String, aErrorCode: number) => void;

    /**
     * Callback when the discovery cannot stop.
     * @param   aServiceType
     *          the service type of |startDiscovery|.
     * @param   aErrorCode
     *          the error code.
     */
    readonly onStopDiscoveryFailed: (aServiceType: IDLAUTF8String, aErrorCode: number) => void;
  }

  export interface nsIEditActionListenerRef {
    readonly name: "nsIEditActionListener";
    readonly number: "{b22907b1-ee93-11d2-8d50-000064657374}";
  }

  /**
   * A generic editor action listener interface.
   * <P>
   * nsIEditActionListener is the interface used by applications wishing to be notified
   * when the editor modifies the DOM tree.
   *
   * Note:  this is the wrong class to implement if you are interested in generic
   * change notifications.  For generic notifications, you should implement
   * nsIDocumentObserver.
   */
  export interface nsIEditActionListener extends nsISupports {

    /**
     * Called after the editor creates a node.
     * @param aTag      The tag name of the DOM Node to create.
     * @param aNewNode  The DOM Node that was created.
     * @param aResult   The result of the create node operation.
     */
    readonly DidCreateNode: (aTag: IDLAString, aNewNode: WebIDL.Node, aResult: number) => void;

    /**
     * Called after the editor inserts a node.
     * @param aNode     The DOM Node to insert.
     * @param aResult   The result of the insert node operation.
     */
    readonly DidInsertNode: (aNode: WebIDL.Node, aResult: number) => void;

    /**
     * Called after the editor deletes a node.
     * @param aChild    The node to delete
     * @param aResult   The result of the delete node operation.
     */
    readonly DidDeleteNode: (aChild: WebIDL.Node, aResult: number) => void;

    /**
     * Called after the editor splits a node.
     * @param aExistingRightNode   The node which was split.  It will become the
     *                             next sibling of the new left node.
     * @param aNewLeftNode         The new node resulting from the split, becomes
     *                             the previous sibling of aExistingRightNode.
     */
    readonly DidSplitNode: (aExistingRightNode: WebIDL.Node, aNewLeftNode: WebIDL.Node) => void;

    /**
     * Called after the editor joins 2 nodes.
     * @param aLeftNode   This node will be merged into the right node
     * @param aRightNode  The node that will be merged into.
     *                    There is no requirement that the two nodes be of
     *                    the same type.
     * @param aParent     The parent of aRightNode
     * @param aResult     The result of the join operation.
     */
    readonly DidJoinNodes: (aLeftNode: WebIDL.Node, aRightNode: WebIDL.Node, aParent: WebIDL.Node, aResult: number) => void;

    /**
     * Called after the editor inserts text.
     * @param aTextNode   This node getting inserted text.
     * @param aOffset     The offset in aTextNode to insert at.
     * @param aString     The string that gets inserted.
     * @param aResult     The result of the insert text operation.
     */
    readonly DidInsertText: (aTextNode: WebIDL.CharacterData, aOffset: number, aString: IDLAString, aResult: number) => void;

    /**
     * Called before the editor deletes text.
     * @param aTextNode   This node getting text deleted.
     * @param aOffset     The offset in aTextNode to delete at.
     * @param aLength     The amount of text to delete.
     */
    readonly WillDeleteText: (aTextNode: WebIDL.CharacterData, aOffset: number, aLength: number) => void;

    /**
     * Called before the editor deletes text.
     * @param aTextNode   This node getting text deleted.
     * @param aOffset     The offset in aTextNode to delete at.
     * @param aLength     The amount of text to delete.
     * @param aResult     The result of the delete text operation.
     */
    readonly DidDeleteText: (aTextNode: WebIDL.CharacterData, aOffset: number, aLength: number, aResult: number) => void;

    /**
     * Called before the editor deletes the selection.
     * @param aSelection   The selection to be deleted
     */
    readonly WillDeleteSelection: (aSelection: WebIDL.Selection) => void;

    /**
     * Called after the editor deletes the selection.
     * @param aSelection   The selection, after deletion
     */
    readonly DidDeleteSelection: (aSelection: WebIDL.Selection) => void;
  }

  export interface nsITLSServerConnectionInfoRef {
    readonly name: "nsITLSServerConnectionInfo";
    readonly number: "{8a93f5d5-eddd-4c62-a4bd-bfd297653184}";
  }

  /**
   * Connection info for a given TLS client connection being handled by a
   * |nsITLSServerSocket| server.  This object is thread-safe.
   *
   * This is exposed as the security info object on the transport, so it can be
   * accessed via |transport.securityInfo|.
   *
   * This interface is available by the time the |onSocketAttached| is called,
   * which is the first time the TLS server consumer is notified of a new client.
   */
  export interface nsITLSServerConnectionInfo extends nsISupports {

    /**
     * setSecurityObserver
     *
     * Set the security observer to be notified when the TLS handshake has
     * completed.
     */
    readonly setSecurityObserver: (observer: (nsITLSServerSecurityObserver | null)) => void;

    /**
     * serverSocket
     *
     * The nsITLSServerSocket instance that accepted this client connection.
     */
    readonly serverSocket: (nsITLSServerSocket | null);

    /**
     * status
     *
     * Security summary for this TLS client connection.  Note that the values of
     * this interface are not available until the TLS handshake has completed.
     * See |nsITLSClientStatus| above for more details.
     */
    readonly status: (nsITLSClientStatus | null);
  }

  export interface nsIClipboardRef {
    readonly name: "nsIClipboard";
    readonly number: "{ceaa0047-647f-4b8e-ad1c-aff9fa62aa51}";

    kSelectionClipboard: 0;

    kGlobalClipboard: 1;

    kFindClipboard: 2;

    kSelectionCache: 3;
  }

  export interface nsIClipboard extends nsISupports {

    /**
     * Given a transferable, set the data on the native clipboard
     *
     * @param  aTransferable The transferable
     * @param  anOwner The owner of the transferable
     * @param  aWhichClipboard Specifies the clipboard to which this operation applies.
     * @result NS_Ok if no errors
     */
    readonly setData: (aTransferable: (nsITransferable | null), anOwner: (nsIClipboardOwner | null), aWhichClipboard: number) => void;

    /**
     * Given a transferable, get the clipboard data.
     *
     * @param  aTransferable The transferable
     * @param  aWhichClipboard Specifies the clipboard to which this operation applies.
     * @result NS_Ok if no errors
     */
    readonly getData: (aTransferable: (nsITransferable | null), aWhichClipboard: number) => void;

    /**
     * This empties the clipboard and notifies the clipboard owner.
     * This empties the "logical" clipboard. It does not clear the native clipboard.
     *
     * @param  aWhichClipboard Specifies the clipboard to which this operation applies.
     * @result NS_OK if successful.
     */
    readonly emptyClipboard: (aWhichClipboard: number) => void;

    /**
     * This provides a way to give correct UI feedback about, for instance, a paste
     * should be allowed. It does _NOT_ actually retreive the data and should be a very
     * inexpensive call. All it does is check if there is data on the clipboard matching
     * any of the flavors in the given list.
     *
     * @param  aFlavorList     An array of ASCII strings.
     * @param  aWhichClipboard Specifies the clipboard to which this operation applies.
     * @outResult - if data is present matching one of
     * @result NS_OK if successful.
     */
    readonly hasDataMatchingFlavors: (aFlavorList: IDLACString[], aWhichClipboard: number) => boolean;

    /**
     * Allows clients to determine if the implementation supports the concept of a
     * separate clipboard for selection.
     *
     * @outResult - true if
     * @result NS_OK if successful.
     */
    readonly supportsSelectionClipboard: () => boolean;

    /**
     * Allows clients to determine if the implementation supports the concept of a
     * separate clipboard for find search strings.
     *
     * @result NS_OK if successful.
     */
    readonly supportsFindClipboard: () => boolean;
  }

  export interface nsIPresentationSessionTransportRef {
    readonly name: "nsIPresentationSessionTransport";
    readonly number: "{670b7e1b-65be-42b6-a596-be571907fa18}";
  }

  export interface nsIPresentationSessionTransport extends nsISupports {

    callback: (nsIPresentationSessionTransportCallback | null);

    readonly selfAddress: (nsINetAddr | null);

    readonly enableDataNotification: () => void;

    readonly send: (data: IDLAString) => void;

    readonly sendBinaryMsg: (data: IDLACString) => void;

    readonly sendBlob: (blob: WebIDL.Blob) => void;

    readonly close: (reason: number) => void;
  }

  export interface nsIStreamConverterRef {
    readonly name: "nsIStreamConverter";
    readonly number: "{0b6e2c69-5cf5-48b0-9dfd-c95950e2cc7b}";
  }

  /**
   * nsIStreamConverter provides an interface to implement when you have code
   * that converts data from one type to another.
   *
   * Suppose you had code that converted plain text into HTML. You could implement
   * this interface to allow everyone else to use your conversion logic using a
   * standard api.
   * <p>
   * <b>STREAM CONVERTER USERS</b>
   *
   * There are currently two ways to use a stream converter:
   * <ol>
   * <li> <b>SYNCHRONOUS</b> Stream to Stream
   *    You can supply the service with a stream of type X
   *    and it will convert it to your desired output type and return
   *    a converted (blocking) stream to you.</li>
   *
   * <li> <b>ASYNCHRONOUS</b> nsIStreamListener to nsIStreamListener
   *    You can supply data directly to the converter by calling it's
   *    nsIStreamListener::OnDataAvailable() method. It will then
   *    convert that data from type X to your desired output type and
   *    return converted data to you via the nsIStreamListener you passed
   *    in by calling its OnDataAvailable() method.</li>
   * </ol>
   * <p>
   *
   * <b>STREAM CONVERTER SUPPLIERS</b>
   *
   * Registering a stream converter:
   * Stream converter registration is a two step process. First of all the stream
   * converter implementation must register itself with the component manager using
   * a contractid in the format below. Second, the stream converter must add the contractid
   * to the registry.
   *
   * Stream converter contractid format (the stream converter root key is defined in this
   * file):
   *
   * <pre>@mozilla.org/streamconv;1?from=FROM_MIME_TYPE&to=TO_MIME_TYPE</pre>
   *
   * @author Jud Valeski
   * @see nsIStreamConverterService
   */
  export interface nsIStreamConverter extends nsIStreamListener {

    /**
     * <b>SYNCRONOUS VERSION</b>
     * Converts a stream of one type, to a stream of another type.
     *
     * Use this method when you have a stream you want to convert.
     *
     * @param aFromStream   The stream representing the original/raw data.
     * @param aFromType     The MIME type of aFromStream.
     * @param aToType       The MIME type of the returned stream.
     * @param aCtxt         Either an opaque context, or a converter specific context
     *                      (implementation specific).
     * @return              The converted stream. NOTE: The returned stream may not
     *                      already be converted. An efficient stream converter
     *                      implementation will converter data on demand rather than
     *                      buffering the converted data until it is used.
     */
    readonly convert: (aFromStream: (nsIInputStream | null), aFromType: string, aToType: string, aCtxt: (nsISupports | null)) => (nsIInputStream | null);

    /**
     * <b>ASYNCRONOUS VERSION</b>
     * Converts data arriving via the converter's nsIStreamListener::OnDataAvailable()
     * method from one type to another, pushing the converted data out to the caller
     * via aListener::OnDataAvailable().
     *
     * Use this method when you want to proxy (and convert) nsIStreamListener callbacks
     * asynchronously.
     *
     * @param aFromType     The MIME type of the original/raw data.
     * @param aToType       The MIME type of the converted data.
     * @param aListener     The listener who receives the converted data.
     * @param aCtxt         Either an opaque context, or a converter specific context
     *                      (implementation specific).
     */
    readonly asyncConvertData: (aFromType: string, aToType: string, aListener: (nsIStreamListener | null), aCtxt: (nsISupports | null)) => void;

    /**
     * Returns the content type that the stream listener passed to asyncConvertData will
     * see on the channel if the conversion is being done from aFromType to * /*.
     *
     * @throws if the converter does not support conversion to * /* or if it doesn't know
     *         the type in advance.
     */
    readonly getConvertedType: (aFromType: IDLACString) => IDLACString;
  }

  export interface nsIUrlClassifierFeatureCallbackRef {
    readonly name: "nsIUrlClassifierFeatureCallback";
    readonly number: "{2ea83c26-dfc9-44ed-9cfc-171d4753d78e}";
  }

  type nsIUrlClassifierFeatureCallbackFunction = (aResults: (nsIUrlClassifierFeatureResult | null)[]) => void;

  /**
   * Callback function for nsIURIClassifier lookups.
   * See asyncClassifyLocalWithFeatures() in nsIURIClassifier.idl.
   */
  export interface nsIUrlClassifierFeatureCallback extends nsISupports {

    /**
     * Called by the URI classifier service when it is done checking a URI.
     *
     * Clients are responsible for associating callback objects with classify()
     * calls.
     *
     * @param aResults
     *        List of nsIUrlClassifierFeatureResult objects.
     */
    readonly onClassifyComplete: (aResults: (nsIUrlClassifierFeatureResult | null)[]) => void;
  }

  export interface nsISupportsWeakReferenceRef {
    readonly name: "nsISupportsWeakReference";
    readonly number: "{9188bc86-f92e-11d2-81ef-0060083a0bcf}";
  }

  /**
   * |nsISupportsWeakReference| is a factory interface which produces appropriate
   * instances of |nsIWeakReference|.  Weak references in this scheme can only be
   * produced for objects that implement this interface.
   *
   * @version 1.0
   * @see nsIWeakReference
   * @see nsSupportsWeakReference
   */
  export interface nsISupportsWeakReference extends nsISupports {

    /**
     * |GetWeakReference| produces an appropriate instance of |nsIWeakReference|.
     * As with all good XPCOM `getters', you own the resulting interface and should
     * manage it with an |nsCOMPtr|.
     *
     * @see nsIWeakReference
     * @see nsWeakPtr
     * @see nsCOMPtr
     */
    readonly GetWeakReference: () => (nsIWeakReference | null);
  }

  export interface nsIAsyncFileMetadataRef {
    readonly name: "nsIAsyncFileMetadata";
    readonly number: "{de15b80b-29ba-4b7f-9220-a3d75b17ae8c}";
  }

  export interface nsIAsyncFileMetadata extends nsIFileMetadata {

    /**
     * Asynchronously wait for the object to be ready.
     *
     * @param aCallback The callback will be used when the stream is ready to
     *                  return File metadata. Use a nullptr to cancel a
     *                  previous operation.
     *
     * @param aEventTarget The event target where aCallback will be executed.
     *                     If aCallback is passed, aEventTarget cannot be null.
     */
    readonly asyncFileMetadataWait: (aCallback: (nsIFileMetadataCallback | nsIFileMetadataCallbackFunction | null), aEventTarget: (nsIEventTarget | null)) => void;
  }

  export interface nsINavHistoryQueryResultNodeRef {
    readonly name: "nsINavHistoryQueryResultNode";
    readonly number: "{62817759-4fee-44a3-b58c-3e2f5afc9d0a}";
  }

  export interface nsINavHistoryQueryResultNode extends nsINavHistoryContainerResultNode {

    /**
     * Used for places queries and as a base for bookmark folders.
     *
     * Note that if you request places to *not* be expanded in the options that
     * generated this node, this item will report it has no children and never try
     * to populate itself.
     */
    /**
     * Get the query which builds this node's children.
     * Only valid for RESULT_TYPE_QUERY nodes.
     */
    readonly query: (nsINavHistoryQuery | null);

    /**
     * Get the options which group this node's children.
     * Only valid for RESULT_TYPE_QUERY nodes.
     */
    readonly queryOptions: (nsINavHistoryQueryOptions | null);

    /**
     * For both simple folder queries and folder shortcut queries, this is set to
     * the concrete itemId of the folder (i.e. for folder shortcuts it's the
     * target folder id).  Otherwise, this is set to -1.
     */
    readonly folderItemId: number;

    /**
     * For both simple folder queries and folder shortcut queries, this is set to
     * the concrete guid of the folder (i.e. for folder shortcuts it's the target
     * folder guid). Otherwise, this is set to an empty string.
     */
    readonly targetFolderGuid: IDLACString;
  }

  export interface nsILoadGroupRef {
    readonly name: "nsILoadGroup";
    readonly number: "{f0c87725-7a35-463c-9ceb-2c07f23406cc}";
  }

  export interface nsILoadGroup extends nsIRequest {

    /**
     * A load group maintains a collection of nsIRequest objects.
     * This is used in lots of places where groups of requests need to be tracked.
     * For example, Document::mDocumentLoadGroup is used to track all requests
     * made for subdocuments in order to track page load progress and allow all
     * requests made on behalf of the document to be stopped, etc.
     */
    /**
     * The group observer is notified when requests are added to and removed
     * from this load group.  The groupObserver is weak referenced.
     */
    groupObserver: (nsIRequestObserver | null);

    /**
     * Accesses the default load request for the group.  Each time a number
     * of requests are added to a group, the defaultLoadRequest may be set
     * to indicate that all of the requests are related to a base request.
     *
     * The load group inherits its load flags from the default load request.
     * If the default load request is NULL, then the group's load flags are
     * not changed.
     */
    defaultLoadRequest: (nsIRequest | null);

    /**
     * Adds a new request to the group.  This will cause the default load
     * flags to be applied to the request.  If this is a foreground
     * request then the groupObserver's onStartRequest will be called.
     *
     * If the request is the default load request or if the default load
     * request is null, then the load group will inherit its load flags from
     * the request.
     */
    readonly addRequest: (aRequest: (nsIRequest | null), aContext: (nsISupports | null)) => void;

    /**
     * Removes a request from the group.  If this is a foreground request
     * then the groupObserver's onStopRequest will be called.
     *
     * By the time this call ends, aRequest will have been removed from the
     * loadgroup, even if this function throws an exception.
     */
    readonly removeRequest: (aRequest: (nsIRequest | null), aContext: (nsISupports | null), aStatus: number) => void;

    /**
     * Returns the requests contained directly in this group.
     * Enumerator element type: nsIRequest.
     */
    readonly requests: (nsISimpleEnumerator | null);

    /**
     * Returns the count of "active" requests (ie. requests without the
     * LOAD_BACKGROUND bit set).
     */
    readonly activeCount: number;

    /**
     * Notification callbacks for the load group.
     */
    notificationCallbacks: (nsIInterfaceRequestor | null);

    /**
     * Context for managing things like js/css connection blocking,
     * and per-tab connection grouping.
     */
    readonly requestContextID: number;

    /**
     * The set of load flags that will be added to all new requests added to
     * this group. Any existing requests in the load group are not modified,
     * so it is expected these flags will be added before requests are added
     * to the group - typically via nsIDocShell::defaultLoadFlags on a new
     * docShell.
     * Note that these flags are *not* added to the default request for the
     * load group; it is expected the default request will already have these
     * flags (again, courtesy of setting nsIDocShell::defaultLoadFlags before
     * the docShell has created the default request.)
     */
    defaultLoadFlags: number;
  }

  export interface nsILoginReputationQueryCallbackRef {
    readonly name: "nsILoginReputationQueryCallback";
    readonly number: "{b527be1e-8fbb-41d9-bee4-267a71236368}";
  }

  export interface nsILoginReputationQueryCallback extends nsISupports {

    readonly onComplete: (aStatus: number, aVerdict: number) => void;
  }

  export interface mozIStorageCompletionCallbackRef {
    readonly name: "mozIStorageCompletionCallback";
    readonly number: "{8cbf2dc2-91e0-44bc-984f-553638412071}";
  }

  type mozIStorageCompletionCallbackFunction = (status: number, value?: (nsISupports | null)) => void;

  export interface mozIStorageCompletionCallback extends nsISupports {

    /**
     * Indicates that the event this callback was passed in for has completed.
     *
     * @param status
     *        The status of the call. Generally NS_OK if the operation
     *        completed successfully.
     * @param value
     *        If the operation produces a result, the result. Otherwise,
     *        |null|.
     *
     * @see The calling method for expected values.
     */
    readonly complete: (status: number, value?: (nsISupports | null)) => void;
  }

  export interface nsIProtectedAuthThreadRef {
    readonly name: "nsIProtectedAuthThread";
    readonly number: "{4bb27cb7-8984-4cee-8ce7-9b014c3d091b}";
  }

  /**
   *  Used to communicate with the thread for logging on to a token with
   *  CKF_PROTECTED_AUTHENTICATION_PATH set.
   */
  export interface nsIProtectedAuthThread extends nsISupports {

    /**
     * login - run the thread
     *   A user interface implementing this interface needs to
     *   call this method as soon as the message to the user is
     *   displayed. This will trigger login operation. No user
     *   cancellation is possible during login operation.
     *
     *   When the login is done, the observe method of @observer will
     *   be called on the UI thread with a topic of "login-finished"
     *   and null data and subject.
     */
    readonly login: (observer: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * The PKCS11 slot
     */
    readonly slot: (nsIPKCS11Slot | null);

    /**
     * Gets token to be logged in name.
     */
    readonly getTokenName: () => IDLAString;
  }

  export interface nsIExternalProtocolServiceRef {
    readonly name: "nsIExternalProtocolService";
    readonly number: "{70f93b7a-3ec6-4bcb-b093-92d9984c9f83}";
  }

  /**
   * The external protocol service is used for finding and launching
   * web handlers (a la registerProtocolHandler in the HTML5 draft) or
   * platform-specific applications for handling particular protocols.
   *
   * You can ask the external protocol service if it has an external
   * handler for a given protocol scheme. And you can ask it to load
   * the url using the default handler.
   */
  export interface nsIExternalProtocolService extends nsISupports {

    /**
     * Check whether a handler for a specific protocol exists.  Specifically,
     * this looks to see whether there are any known possible application handlers
     * in either the nsIHandlerService datastore or registered with the OS.
     *
     * @param aProtocolScheme The scheme from a url: http, ftp, mailto, etc.
     *
     * @return true if we have a handler and false otherwise.
     *
     * XXX shouldn't aProtocolScheme be an ACString like nsIURI::scheme?
     */
    readonly externalProtocolHandlerExists: (aProtocolScheme: string) => boolean;

    /**
     * Check whether a handler for a specific protocol is "exposed" as a visible
     * feature of the current application.
     *
     * An exposed protocol handler is one that can be used in all contexts.  A
     * non-exposed protocol handler is one that can only be used internally by the
     * application.  For example, a non-exposed protocol would not be loaded by the
     * application in response to a link click or a X-remote openURL command.
     * Instead, it would be deferred to the system's external protocol handler.
     * XXX shouldn't aProtocolScheme be an ACString like nsIURI::scheme?
     */
    readonly isExposedProtocol: (aProtocolScheme: string) => boolean;

    /**
     * Retrieve the handler for the given protocol.  If neither the application
     * nor the OS knows about a handler for the protocol, the object this method
     * returns will represent a default handler for unknown content.
     *
     * @param aProtocolScheme the scheme from a URL: http, ftp, mailto, etc.
     *
     * Note: aProtocolScheme should not include a trailing colon, which is part
     * of the URI syntax, not part of the scheme itself (i.e. pass "mailto" not
     * "mailto:").
     *
     * @return the handler, if any; otherwise a default handler
     */
    readonly getProtocolHandlerInfo: (aProtocolScheme: IDLACString) => (nsIHandlerInfo | null);

    /**
     * Given a scheme, looks up the protocol info from the OS.  This should be
     * overridden by each OS's implementation.
     *
     * @param aScheme The protocol scheme we are looking for.
     * @param aFound  Was an OS default handler for this scheme found?
     * @return An nsIHanderInfo for the protocol.
     */
    readonly getProtocolHandlerInfoFromOS: (aProtocolScheme: IDLACString, aFound: Out<boolean>) => (nsIHandlerInfo | null);

    /**
     * Set some sane defaults for a protocol handler object.
     *
     * @param aHandlerInfo      nsIHandlerInfo object, as returned by
     *                          getProtocolHandlerInfoFromOS
     * @param aOSHandlerExists  was the object above created for an extant
     *                          OS default handler?  This is generally the
     *                          value of the aFound out param from
     *                          getProtocolHandlerInfoFromOS.
     */
    readonly setProtocolHandlerDefaults: (aHandlerInfo: (nsIHandlerInfo | null), aOSHandlerExists: boolean) => void;

    /**
     * Used to load a URI via an external application. Might prompt the user for
     * permission to load the external application.
     *
     * @param aURI
     *        The URI to load
     *
     * @param aWindowContext
     *        The window to parent the dialog against, and, if a web handler
     *        is chosen, it is loaded in this window as well.  This parameter
     *        may be ultimately passed nsIURILoader.openURI in the case of a
     *        web handler, and aWindowContext is null or not present, web
     *        handlers will fail.  We need to do better than that; bug 394483
     *        filed in order to track.
     *
     * @note  Embedders that do not expose the http protocol should not currently
     *        use web-based protocol handlers, as handoff won't work correctly
     *        (bug 394479).
     */
    readonly loadURI: (aURI: (nsIURI | null), aWindowContext?: (nsIInterfaceRequestor | null)) => void;

    /**
     * Gets a human-readable description for the application responsible for
     * handling a specific protocol.
     *
     * @param aScheme The scheme to look up. For example, "mms".
     *
     * @throw NS_ERROR_NOT_IMPLEMENTED
     *        If getting descriptions for protocol helpers is not supported
     * @throw NS_ERROR_NOT_AVAILABLE
     *        If no protocol helper exists for this scheme, or if it is not
     *        possible to get a description for it.
     */
    readonly getApplicationDescription: (aScheme: IDLAUTF8String) => IDLAString;

    /**
     * Check if this app is registered as the OS default for a given scheme.
     *
     * @param aScheme The scheme to look up. For example, "mms".
     */
    readonly isCurrentAppOSDefaultForProtocol: (aScheme: IDLAUTF8String) => boolean;
  }

  export interface nsISDBConnectionRef {
    readonly name: "nsISDBConnection";
    readonly number: "{ea420fdd-548f-44f9-9286-59aad6a40f01}";
  }

  export interface nsISDBConnection extends nsISupports {

    readonly init: (aPrincipal: (nsIPrincipal | null)) => void;

    readonly open: (aName: IDLAString) => (nsISDBRequest | null);

    readonly seek: (offset: number) => (nsISDBRequest | null);

    readonly read: (size: number) => (nsISDBRequest | null);

    readonly write: (value: IDLjsval) => (nsISDBRequest | null);

    readonly close: () => (nsISDBRequest | null);

    closeCallback: (nsISDBCloseCallback | null);
  }

  export interface nsISerialEventTargetRef {
    readonly name: "nsISerialEventTarget";
    readonly number: "{9f982380-24b4-49f3-88f6-45e2952036c7}";
  }

  /**
   * A serial event target is an event dispatching interface like
   * nsIEventTarget. Runnables dispatched to an nsISerialEventTarget are required
   * to execute serially. That is, two different runnables dispatched to the
   * target should never be allowed to execute simultaneously. One exception to
   * this rule is nested event loops. If a runnable spins a nested event loop,
   * causing another runnable dispatched to the target to run, the target may
   * still be considered "serial".
   *
   * Examples:
   * - nsIThread is a serial event target.
   * - Thread pools are not serial event targets.
   * - However, one can "convert" a thread pool into an nsISerialEventTarget
   *   by putting a TaskQueue in front of it.
   */
  export interface nsISerialEventTarget extends nsIEventTarget {
  }

  export interface nsINetworkPredictorRef {
    readonly name: "nsINetworkPredictor";
    readonly number: "{acc88e7c-3f39-42c7-ac31-6377c2c3d73e}";

    /**
     * Prediction reasons
     *
     * PREDICT_LINK - we are being asked to take predictive action because
     * the user is hovering over a link.
     *
     * PREDICT_LOAD - we are being asked to take predictive action because
     * the user has initiated a pageload.
     *
     * PREDICT_STARTUP - we are being asked to take predictive action
     * because the browser is starting up.
     */
    PREDICT_LINK: 0;

    PREDICT_LOAD: 1;

    PREDICT_STARTUP: 2;

    LEARN_LOAD_TOPLEVEL: 0;

    LEARN_LOAD_SUBRESOURCE: 1;

    LEARN_LOAD_REDIRECT: 2;

    LEARN_STARTUP: 3;
  }

  /**
   * nsINetworkPredictor - learn about pages users visit, and allow us to take
   *                       predictive actions upon future visits.
   *                       NOTE: nsINetworkPredictor should only
   *                       be used on the main thread.
   */
  export interface nsINetworkPredictor extends nsISupports {

    /**
     * Start taking predictive actions
     *
     * Calling this will cause the predictor to (possibly) start
     * taking actions such as DNS prefetch and/or TCP preconnect based on
     * (1) the host name that we are given, and (2) the reason we are being
     * asked to take actions.
     *
     * @param targetURI - The URI we are being asked to take actions based on.
     * @param sourceURI - The URI that is currently loaded. This is so we can
     *   avoid doing predictive actions for link hover on an HTTPS page (for
     *   example).
     * @param reason - The reason we are being asked to take actions. Can be
     *   any of the PREDICT_* values above.
     *   In the case of PREDICT_LINK, targetURI should be the URI of the link
     *   that is being hovered over, and sourceURI should be the URI of the page
     *   on which the link appears.
     *   In the case of PREDICT_LOAD, targetURI should be the URI of the page that
     *   is being loaded and sourceURI should be null.
     *   In the case of PREDICT_STARTUP, both targetURI and sourceURI should be
     *   null.
     * @param originAttributes - The originAttributes of the page load we are
     *   predicting about.
     * @param verifier - An nsINetworkPredictorVerifier used in testing to ensure
     *   we're predicting the way we expect to. Not necessary (or desired) for
     *   normal operation.
     */
    readonly predict: (targetURI: (nsIURI | null), sourceURI: (nsIURI | null), reason: number, originAttributes: IDLjsval, verifier: (nsINetworkPredictorVerifier | null)) => void;

    /**
     * Add to our compendium of knowledge
     *
     * This adds to our prediction database to make things (hopefully)
     * smarter next time we predict something.
     *
     * @param targetURI - The URI that was loaded that we are keeping track of.
     * @param sourceURI - The URI that caused targetURI to be loaded (for page
     *   loads). This means the DOCUMENT URI.
     * @param reason - The reason we are learning this bit of knowledge.
     *   Reason can be any of the LEARN_* values.
     *   In the case of LEARN_LOAD_SUBRESOURCE, targetURI should be the URI of a
     *   subresource of a page, and sourceURI should be the top-level URI.
     *   In the case of LEARN_LOAD_REDIRECT, targetURI is the NEW URI of a
     *   top-level resource that was redirected to, and sourceURI is the
     *   ORIGINAL URI of said top-level resource.
     *   In the case of LEARN_STARTUP, targetURI should be the URI of a page
     *   that was loaded immediately after browser startup, and sourceURI should
     *   be null.
     * @param originAttributes - The originAttributes for the page load that we
     *   are learning about.
     */
    readonly learn: (targetURI: (nsIURI | null), sourceURI: (nsIURI | null), reason: number, originAttributes: IDLjsval) => void;

    /**
     * Clear out all our learned knowledge
     *
     * This removes everything from our database so that any predictions begun
     * after this completes will start from a blank slate.
     */
    readonly reset: () => void;
  }

  export interface nsIScheduledGCCallbackRef {
    readonly name: "nsIScheduledGCCallback";
    readonly number: "{71000535-b0fd-44d1-8ce0-909760e3953c}";
  }

  type nsIScheduledGCCallbackFunction = () => void;

  /**
   * interface for callback to be passed to Cu.schedulePreciseGC
   */
  export interface nsIScheduledGCCallback extends nsISupports {

    readonly callback: () => void;
  }

  export interface nsIBackgroundFileSaverRef {
    readonly name: "nsIBackgroundFileSaver";
    readonly number: "{c43544a4-682c-4262-b407-2453d26e660d}";
  }

  /**
   * Allows saving data to a file, while handling all the input/output on a
   * background thread, including the initial file name assignment and any
   * subsequent renaming of the target file.
   *
   * This interface is designed for file downloads.  Generally, they start in the
   * temporary directory, while the user is selecting the final name.  Then, they
   * are moved to the chosen target directory with a ".part" extension appended to
   * the file name.  Finally, they are renamed when the download is completed.
   *
   * Components implementing both nsIBackgroundFileSaver and nsIStreamListener
   * allow data to be fed using an implementation of OnDataAvailable that never
   * blocks the calling thread.  They suspend the request that drives the stream
   * listener in case too much data is being fed, and resume it when the data has
   * been written.  Calling OnStopRequest does not necessarily close the target
   * file, and the Finish method must be called to complete the operation.
   *
   * Components implementing both nsIBackgroundFileSaver and nsIAsyncOutputStream
   * allow data to be fed directly to the non-blocking output stream, that however
   * may return NS_BASE_STREAM_WOULD_BLOCK in case too much data is being fed.
   * Closing the output stream does not necessarily close the target file, and the
   * Finish method must be called to complete the operation.
   *
   * @remarks Implementations may require the consumer to always call Finish.  If
   *          the object reference is released without calling Finish, a memory
   *          leak may occur, and the target file might be kept locked. All
   *          public methods of the interface may only be called from the main
   *          thread.
   */
  export interface nsIBackgroundFileSaver extends nsISupports {

    /**
     * This observer receives notifications when the target file name changes and
     * when the operation completes, successfully or not.
     *
     * @remarks A strong reference to the observer is held.  Notification events
     *          are dispatched to the thread that created the object that
     *          implements nsIBackgroundFileSaver.
     */
    observer: (nsIBackgroundFileSaverObserver | null);

    /**
     * An Array of Array of Array of bytes, representing a chain of
     * X.509 certificates, the last of which signed the downloaded file.
     * Each list may belong to a different signer and contain certificates
     * all the way up to the root.
     *
     * @throws NS_ERROR_NOT_AVAILABLE
     *         In case this is called before the onSaveComplete method has been
     *         called to notify success, or enableSignatureInfo has not been
     *         called.
     */
    readonly signatureInfo: number[][][];

    /**
     * The SHA-256 hash, in raw bytes, associated with the data that was saved.
     *
     * In case the enableAppend method has been called, the hash computation
     * includes the contents of the existing file, if any.
     *
     * @throws NS_ERROR_NOT_AVAILABLE
     *         In case the enableSha256 method has not been called, or before the
     *         onSaveComplete method has been called to notify success.
     */
    readonly sha256Hash: IDLACString;

    /**
     * Instructs the component to compute the signatureInfo of the target file,
     * and make it available in the signatureInfo property.
     *
     * @remarks This must be set on the main thread before the first call to
     *          setTarget.
     */
    readonly enableSignatureInfo: () => void;

    /**
     * Instructs the component to compute the SHA-256 hash of the target file, and
     * make it available in the sha256Hash property.
     *
     * @remarks This must be set on the main thread before the first call to
     *          setTarget.
     */
    readonly enableSha256: () => void;

    /**
     * Instructs the component to append data to the initial target file, that
     * will be specified by the first call to the setTarget method, instead of
     * overwriting the file.
     *
     * If the initial target file does not exist, this method has no effect.
     *
     * @remarks This must be set on the main thread before the first call to
     *          setTarget.
     */
    readonly enableAppend: () => void;

    /**
     * Sets the name of the output file to be written.  The target can be changed
     * after data has already been fed, in which case the existing file will be
     * moved to the new destination.
     *
     * In case the specified file already exists, and this method is called for
     * the first time, the file may be either overwritten or appended to, based on
     * whether the enableAppend method was called.  Subsequent calls always
     * overwrite the specified target file with the previously saved data.
     *
     * No file will be written until this function is called at least once.  It's
     * recommended not to feed any data until the output file is set.
     *
     * If an input/output error occurs with the specified file, the save operation
     * fails.  Failure is notified asynchronously through the observer.
     *
     * @param aTarget
     *        New output file to be written.
     * @param aKeepPartial
     *        Indicates whether aFile should be kept as partially completed,
     *        rather than deleted, if the operation fails or is canceled.  This is
     *        generally set for downloads that use temporary ".part" files.
     */
    readonly setTarget: (aTarget: (nsIFile | null), aKeepPartial: boolean) => void;

    /**
     * Terminates access to the output file, then notifies the observer with the
     * specified status code.  A failure code will force the operation to be
     * canceled, in which case the output file will be deleted if requested.
     *
     * This forces the involved streams to be closed, thus no more data should be
     * fed to the component after this method has been called.
     *
     * This is the last method that should be called on this object, and the
     * target file name cannot be changed anymore after this method has been
     * called.  Conversely, before calling this method, the file can still be
     * renamed even if all the data has been fed.
     *
     * @param aStatus
     *        Result code that determines whether the operation should succeed or
     *        be canceled, and is notified to the observer.  If the operation
     *        fails meanwhile for other reasons, or the observer has been already
     *        notified of completion, this status code is ignored.
     */
    readonly finish: (aStatus: number) => void;
  }

  export interface nsITelemetryRef {
    readonly name: "nsITelemetry";
    readonly number: "{273d2dd0-6c63-475a-b864-cb65160a1909}";

    /**
     * Histogram types:
     * HISTOGRAM_EXPONENTIAL - buckets increase exponentially
     * HISTOGRAM_LINEAR - buckets increase linearly
     * HISTOGRAM_BOOLEAN - For storing 0/1 values
     * HISTOGRAM_FLAG - For storing a single value; its count is always == 1.
     * HISTOGRAM_COUNT - For storing counter values without bucketing.
     * HISTOGRAM_CATEGORICAL - For storing enumerated values by label.
     */
    HISTOGRAM_EXPONENTIAL: 0;

    HISTOGRAM_LINEAR: 1;

    HISTOGRAM_BOOLEAN: 2;

    HISTOGRAM_FLAG: 3;

    HISTOGRAM_COUNT: 4;

    HISTOGRAM_CATEGORICAL: 5;

    /**
     * Scalar types:
     * SCALAR_TYPE_COUNT - for storing a numeric value
     * SCALAR_TYPE_STRING - for storing a string value
     * SCALAR_TYPE_BOOLEAN - for storing a boolean value
     */
    SCALAR_TYPE_COUNT: 0;

    SCALAR_TYPE_STRING: 1;

    SCALAR_TYPE_BOOLEAN: 2;

    /**
     * Dataset types:
     * DATASET_ALL_CHANNELS - the basic dataset that is on-by-default on all channels
     * DATASET_PRERELEASE_CHANNELS - the extended dataset that is opt-in on release,
     *                                 opt-out on pre-release channels.
     */
    DATASET_ALL_CHANNELS: 0;

    DATASET_PRERELEASE_CHANNELS: 1;
  }

  export interface nsITelemetry extends nsISupports {

    /**
       * Serializes the histograms from the given store to a JSON-style object.
       * The returned structure looks like:
       *   { "process": { "name1": histogramData1, "name2": histogramData2 }, ... }
       *
       * Each histogram is represented in a packed format and has the following properties:
       *   bucket_count - Number of buckets of this histogram
       *   histogram_type - HISTOGRAM_EXPONENTIAL, HISTOGRAM_LINEAR, HISTOGRAM_BOOLEAN,
       *                    HISTOGRAM_FLAG, HISTOGRAM_COUNT, or HISTOGRAM_CATEGORICAL
       *   sum - sum of the bucket contents
       *   range - A 2-item array of minimum and maximum bucket size
       *   values - Map from bucket to the bucket's count
       *
       * @param aStoreName The name of the store to snapshot.
       *                   Defaults to "main".
       *                   Custom stores are available when probes have them defined.
       *                   See the `record_into_store` attribute on histograms.
       *                   @see https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/histograms.html#record-into-store
       * @param aClearStore Whether to clear out the histograms in the named store after snapshotting.
       *                    Defaults to false.
       * @param aFilterTest If true, `TELEMETRY_TEST_` histograms will be filtered out.
                            Filtered histograms are still cleared if `aClearStore` is true.
       *                    Defaults to false.
       */
    readonly getSnapshotForHistograms: (aStoreName?: IDLACString, aClearStore?: boolean, aFilterTest?: boolean) => IDLjsval;

    /**
       * Serializes the keyed histograms from the given store to a JSON-style object.
       * The returned structure looks like:
       *   { "process": { "name1": { "key_1": histogramData1, "key_2": histogramData2 }, ...}, ... }
       *
       * @param aStoreName The name of the store to snapshot.
       *                   Defaults to "main".
       *                   Custom stores are available when probes have them defined.
       *                   See the `record_into_store` attribute on histograms.
       *                   @see https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/histograms.html#record-into-store
       * @param aClearStore Whether to clear out the keyed histograms in the named store after snapshotting.
       *                    Defaults to false.
       * @param aFilterTest If true, `TELEMETRY_TEST_` histograms will be filtered out.
                            Filtered histograms are still cleared if `aClearStore` is true.
       *                    Defaults to false.
       */
    readonly getSnapshotForKeyedHistograms: (aStoreName?: IDLACString, aClearStore?: boolean, aFilterTest?: boolean) => IDLjsval;

    /**
       * Serializes the scalars from the given store to a JSON-style object.
       * The returned structure looks like:
       *   { "process": { "category1.probe": 1,"category1.other_probe": false, ... }, ... }.
       *
       * @param aStoreName The name of the store to snapshot.
       *                   Defaults to "main".
       *                   Custom stores are available when probes have them defined.
       *                   See the `record_into_store` attribute on scalars.
       *                   @see https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/scalars.html#optional-fields
       * @param aClearStore Whether to clear out the scalars in the named store after snapshotting.
       *                    Defaults to false.
       * @param aFilterTest If true, `telemetry.test` scalars will be filtered out.
                            Filtered scalars are still cleared if `aClearStore` is true.
       *                    Defaults to false.
       */
    readonly getSnapshotForScalars: (aStoreName?: IDLACString, aClearStore?: boolean, aFilterTest?: boolean) => IDLjsval;

    /**
       * Serializes the keyed scalars from the given store to a JSON-style object.
       * The returned structure looks like:
       *   { "process": { "category1.probe": { "key_1": 2, "key_2": 1, ... }, ... }, ... }
       *
       * @param aStoreName The name of the store to snapshot.
       *                   Defaults to "main".
       *                   Custom stores are available when probes have them defined.
       *                   See the `record_into_store` attribute on scalars.
       *                   @see https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/scalars.html#optional-fields
       * @param aClearStore Whether to clear out the keyed scalars in the named store after snapshotting.
       *                    Defaults to false.
       * @param aFilterTest If true, `telemetry.test` scalars will be filtered out.
                            Filtered scalars are still cleared if `aClearStore` is true.
       *                    Defaults to false.
       */
    readonly getSnapshotForKeyedScalars: (aStoreName?: IDLACString, aClearStore?: boolean, aFilterTest?: boolean) => IDLjsval;

    /**
     * The amount of time, in milliseconds, that the last session took
     * to shutdown.  Reads as 0 to indicate failure.
     */
    readonly lastShutdownDuration: number;

    /**
     * The number of failed profile lock attempts that have occurred prior to
     * successfully locking the profile
     */
    readonly failedProfileLockCount: number;

    readonly slowSQL: IDLjsval;

    readonly debugSlowSQL: IDLjsval;

    /**
     * A number representing the highest number of concurrent threads
     * reached during this session.
     */
    readonly maximalNumberOfConcurrentThreads: number;

    readonly getUntrustedModuleLoadEvents: () => IDLPromise;

    readonly captureStack: (name: IDLACString) => void;

    readonly snapshotCapturedStacks: (clear?: boolean) => IDLjsval;

    readonly getLoadedModules: () => IDLPromise;

    readonly lateWrites: IDLjsval;

    /**
       * Create and return a histogram registered in TelemetryHistograms.h.
       *
       * @param id - unique identifier from TelemetryHistograms.h
       * The returned object has the following functions:
       *   add(int) - Adds an int value to the appropriate bucket.
       *   snapshot([optional] {store}) - Returns a snapshot of the histogram with the same data fields
                                          as in getSnapshotForHistograms().
                                          Defaults to the "main" store.
       *   clear([optional] {store}) - Zeros out the histogram's buckets and sum.
                                       Defaults to the "main" store.
                                       Note: This is intended to be only used in tests.
       */
    readonly getHistogramById: (id: IDLACString) => IDLjsval;

    /**
       * Create and return a histogram registered in TelemetryHistograms.h.
       *
       * @param id - unique identifier from TelemetryHistograms.h
       * The returned object has the following functions:
       *   add(string key, [optional] int) - Add an int value to the histogram for that key.
                                             If no histogram for that key exists yet, it is created.
       *   snapshot([optional] {store}) - Returns the snapshots of all the registered keys in the form
                                          {key1: snapshot1, key2: snapshot2, ...} in the specified store.
       *                                  Defaults to the "main" store.
       *   keys([optional] {store}) - Returns an array with the string keys of the currently registered
                                      histograms in the given store.
                                      Defaults to "main".
       *   clear([optional] {store}) - Clears the registered histograms from this.
       *                               Defaults to the "main" store.
       *                               Note: This is intended to be only used in tests.
       */
    readonly getKeyedHistogramById: (id: IDLACString) => IDLjsval;

    /**
     * A flag indicating if Telemetry can record base data (FHR data). This is true if the
     * FHR data reporting service or self-support are enabled.
     *
     * In the unlikely event that adding a new base probe is needed, please check the data
     * collection wiki at https://wiki.mozilla.org/Firefox/Data_Collection and talk to the
     * Telemetry team.
     */
    canRecordBase: boolean;

    /**
     * A flag indicating if Telemetry is allowed to record extended data. Returns false if
     * the user hasn't opted into "extended Telemetry" on the Release channel, when the
     * user has explicitly opted out of Telemetry on Nightly/Aurora/Beta or if manually
     * set to false during tests.
     *
     * Set this to false in tests to disable gathering of extended telemetry statistics.
     */
    canRecordExtended: boolean;

    /**
     * A flag indicating whether Telemetry is recording release data, which is a
     * smallish subset of our usage data that we're prepared to handle from our
     * largish release population.
     *
     * This is true most of the time.
     *
     * This does not indicate whether Telemetry will send any data. That is
     * governed by user preference and other mechanisms.
     *
     * You may use this to determine if it's okay to record your data.
     */
    readonly canRecordReleaseData: boolean;

    /**
     * A flag indicating whether Telemetry is recording prerelease data, which is
     * a largish amount of usage data that we're prepared to handle from our
     * smallish pre-release population.
     *
     * This is true on pre-release branches of Firefox.
     *
     * This does not indicate whether Telemetry will send any data. That is
     * governed by user preference and other mechanisms.
     *
     * You may use this to determine if it's okay to record your data.
     */
    readonly canRecordPrereleaseData: boolean;

    /**
     * A flag indicating whether Telemetry can submit official results (for base or extended
     * data). This is true on official, non-debug builds with built in support for Mozilla
     * Telemetry reporting.
     */
    readonly isOfficialTelemetry: boolean;

    /**
     * Enable/disable recording for this histogram at runtime.
     * Recording is enabled by default, unless listed at kRecordingInitiallyDisabledIDs[].
     * Name must be a valid Histogram identifier, otherwise an assertion will be triggered.
     *
     * @param id - unique identifier from histograms.json
     * @param enabled - whether or not to enable recording from now on.
     */
    readonly setHistogramRecordingEnabled: (id: IDLACString, enabled: boolean) => void;

    /**
     * Read data from the previous run. After the callback is called, the last
     * shutdown time is available in lastShutdownDuration and any late
     * writes in lateWrites.
     */
    readonly asyncFetchTelemetryData: (aCallback: (nsIFetchTelemetryDataCallback | nsIFetchTelemetryDataCallbackFunction | null)) => void;

    /**
     * Get statistics of file IO reports, null, if not recorded.
     *
     * The statistics are returned as an object whose propoerties are the names
     * of the files that have been accessed and whose corresponding values are
     * arrays of size three, representing startup, normal, and shutdown stages.
     * Each stage's entry is either null or an array with the layout
     * [total_time, #creates, #reads, #writes, #fsyncs, #stats]
     */
    readonly fileIOReports: IDLjsval;

    /**
     * Return the number of milliseconds since process start using monotonic
     * timestamps (unaffected by system clock changes).
     * @throws NS_ERROR_NOT_AVAILABLE if TimeStamp doesn't have the data.
     */
    readonly msSinceProcessStart: () => number;

    /**
     * Time since the system wide epoch. This is not a monotonic timer but
     * can be used across process boundaries.
     */
    readonly msSystemNow: () => number;

    /**
     * Adds the value to the given scalar.
     *
     * @param aName The scalar name.
     * @param aValue The numeric value to add to the scalar. Only unsigned integers supported.
     */
    readonly scalarAdd: (aName: IDLACString, aValue: IDLjsval) => void;

    /**
     * Sets the scalar to the given value.
     *
     * @param aName The scalar name.
     * @param aValue The value to set the scalar to. If the type of aValue doesn't match the
     *        type of the scalar, the function will fail. For scalar string types, the this
     *        is truncated to 50 characters.
     */
    readonly scalarSet: (aName: IDLACString, aValue: IDLjsval) => void;

    /**
     * Sets the scalar to the maximum of the current and the passed value.
     *
     * @param aName The scalar name.
     * @param aValue The numeric value to set the scalar to. Only unsigned integers supported.
     */
    readonly scalarSetMaximum: (aName: IDLACString, aValue: IDLjsval) => void;

    /**
     * Adds the value to the given keyed scalar.
     *
     * @param aName The scalar name.
     * @param aKey The key name.
     * @param aValue The numeric value to add to the scalar. Only unsigned integers supported.
     */
    readonly keyedScalarAdd: (aName: IDLACString, aKey: IDLAString, aValue: IDLjsval) => void;

    /**
     * Sets the keyed scalar to the given value.
     *
     * @param aName The scalar name.
     * @param aKey The key name.
     * @param aValue The value to set the scalar to. If the type of aValue doesn't match the
     *        type of the scalar, the function will fail.
     */
    readonly keyedScalarSet: (aName: IDLACString, aKey: IDLAString, aValue: IDLjsval) => void;

    /**
     * Sets the keyed scalar to the maximum of the current and the passed value.
     *
     * @param aName The scalar name.
     * @param aKey The key name.
     * @param aValue The numeric value to set the scalar to. Only unsigned integers supported.
     */
    readonly keyedScalarSetMaximum: (aName: IDLACString, aKey: IDLAString, aValue: IDLjsval) => void;

    /**
     * Resets all the stored scalars. This is intended to be only used in tests.
     */
    readonly clearScalars: () => void;

    /**
     * Immediately sends any Telemetry batched on this process to the parent
     * process. This is intended only to be used on process shutdown.
     */
    readonly flushBatchedChildTelemetry: () => void;

    /**
     * Record an event in Telemetry.
     *
     * @param aCategory The category name.
     * @param aMethod The method name.
     * @param aObject The object name.
     * @param aValue An optional string value to record.
     * @param aExtra An optional object of the form (string -> string).
     *               It should only contain registered extra keys.
     *
     * @throws NS_ERROR_INVALID_ARG When trying to record an unknown event.
     */
    readonly recordEvent: (aCategory: IDLACString, aMethod: IDLACString, aObject: IDLACString, aValue?: IDLjsval, extra?: IDLjsval) => void;

    /**
     * Enable recording of events in a category.
     * Events default to recording disabled. This allows to toggle recording for all events
     * in the specified category.
     *
     * @param aCategory The category name.
     * @param aEnabled Whether recording is enabled for events in that category.
     */
    readonly setEventRecordingEnabled: (aCategory: IDLACString, aEnabled: boolean) => void;

    /**
     * Serializes the recorded events to a JSON-appropriate array and optionally resets them.
     * The returned structure looks like this:
     *   [
     *     // [timestamp, category, method, object, stringValue, extraValues]
     *     [43245, "category1", "method1", "object1", "string value", null],
     *     [43258, "category1", "method2", "object1", null, {"key1": "string value"}],
     *     ...
     *   ]
     *
     * @param aDataset DATASET_ALL_CHANNELS or DATASET_PRERELEASE_CHANNELS.
     * @param [aClear=false] Whether to clear out the events after snapshotting.
     * @param aEventLimit How many events per process to limit the snapshot to contain, all if unspecified.
     *                    Even if aClear, the leftover event records are not cleared.
     */
    readonly snapshotEvents: (aDataset: number, aClear?: boolean, aEventLimit?: number) => IDLjsval;

    /**
     * Register new events to record them from addons. This allows registering multiple
     * events for a category. They will be valid only for the current Firefox session.
     * Note that events shipping in Firefox should be registered in Events.yaml.
     *
     * @param aCategory The unique category the events are registered in.
     * @param aEventData An object that contains registration data for 1-N events of the form:
     *   {
     *     "categoryName": {
     *       "methods": ["test1"],
     *       "objects": ["object1"],
     *       "record_on_release": false,
     *       "extra_keys": ["key1", "key2"], // optional
     *       "expired": false // optional, defaults to false.
     *     },
     *     ...
     *   }
     * @param aEventData.<name>.methods List of methods for this event entry.
     * @param aEventData.<name>.objects List of objects for this event entry.
     * @param aEventData.<name>.extra_keys Optional, list of allowed extra keys for this event entry.
     * @param aEventData.<name>.record_on_release Optional, whether to record this data on release.
     *                                            Defaults to false.
     * @param aEventData.<name>.expired Optional, whether this event entry is expired. This allows
     *                                  recording it without error, but it will be discarded. Defaults to false.
     */
    readonly registerEvents: (aCategory: IDLACString, aEventData: IDLjsval) => void;

    /**
     * Parent process only. Register dynamic builtin events. The parameters
     * have the same meaning as the usual |registerEvents| function.
     *
     * This function is only meant to be used to support the "artifact build"/
     * "build faster" developers by allowing to add new events without rebuilding
     * the C++ components including the headers files.
     */
    readonly registerBuiltinEvents: (aCategory: IDLACString, aEventData: IDLjsval) => void;

    /**
     * Parent process only. Register new scalars to record them from addons. This
     * allows registering multiple scalars for a category. They will be valid only for
     * the current Firefox session.
     * Note that scalars shipping in Firefox should be registered in Scalars.yaml.
     *
     * @param aCategoryName The unique category the scalars are registered in.
     * @param aScalarData An object that contains registration data for multiple scalars in the form:
     *   {
     *     "sample_scalar": {
     *       "kind": Ci.nsITelemetry.SCALAR_TYPE_COUNT,
     *       "keyed": true, //optional, defaults to false
     *       "record_on_release: true, // optional, defaults to false
     *       "expired": false // optional, defaults to false.
     *     },
     *     ...
     *   }
     * @param aScalarData.<name>.kind One of the scalar types defined in this file (SCALAR_TYPE_*)
     * @param aScalarData.<name>.keyed Optional, whether this is a keyed scalar or not. Defaults to false.
     * @param aScalarData.<name>.record_on_release Optional, whether to record this data on release.
     *                                             Defaults to false.
     * @param aScalarData.<name>.expired Optional, whether this scalar entry is expired. This allows
     *                                   recording it without error, but it will be discarded. Defaults to false.
     */
    readonly registerScalars: (aCategoryName: IDLACString, aScalarData: IDLjsval) => void;

    /**
     * Parent process only. Register dynamic builtin scalars. The parameters
     * have the same meaning as the usual |registerScalars| function.
     *
     * This function is only meant to be used to support the "artifact build"/
     * "build faster" developers by allowing to add new scalars without rebuilding
     * the C++ components including the headers files.
     */
    readonly registerBuiltinScalars: (aCategoryName: IDLACString, aScalarData: IDLjsval) => void;

    /**
     * Resets all the stored events. This is intended to be only used in tests.
     */
    readonly clearEvents: () => void;

    /**
     * Get a list of all registered stores.
     *
     * The list is deduplicated, but unordered.
     */
    readonly getAllStores: () => IDLjsval;

    /**
     * Reset the storage for all the collection primitives so that GeckoView
     * can issue a single Clear signal for histograms, scalars, events, ...
     *
     * This is needed for supporting the current implementation of GeckoView
     * measurement persistence: all the measurements are stored in a single file and
     * they can't be cleared independently.
     *
     * Please note that this is only intended to be used by GeckoViewTelemetryController.
     */
    readonly clearProbes: () => void;

    /**
     * Does early, cheap initialization for native telemetry data providers.
     * Currently, this includes only MemoryTelemetry.
     */
    readonly earlyInit: () => void;

    /**
     * Does late, expensive initialization for native telemetry data providers.
     * Currently, this includes only MemoryTelemetry.
     *
     * This should only be called after startup has completed and the event loop
     * is idle.
     */
    readonly delayedInit: () => void;

    /**
     * Shuts down native telemetry providers. Currently, this includes only
     * MemoryTelemetry.
     */
    readonly shutdown: () => void;

    /**
     * Gathers telemetry data for memory usage and records it to the data store.
     * Returns a promise which resolves when asynchronous data collection has
     * completed and all data has been recorded.
     */
    readonly gatherMemory: () => IDLPromise;

    /**
     * Serializes the per-origin data in plain text, optionally clearing
     * the storage. Only to be used by about:telemetry.
     *
     * The returned structure looks like:
     *   { metric: {origin1: count1, origin2: count2, ...}, ...}
     *
     * @param aClear Whether to clear the storage. Default false.
     * @return a snapshot of the per-origin data.
     */
    readonly getOriginSnapshot: (aClear?: boolean) => IDLjsval;

    /**
     * Encodes the per-origin information then serializes it.
     * Returns a Promise.
     *
     * @param aClear Whether to clear the storage. Default false.
     * @return Promise that resolves to the serialized encoded data.
     */
    readonly getEncodedOriginSnapshot: (aClear?: boolean) => IDLPromise;

    /**
     * Clears Firefox Origin Telemetry. Only to be used in tests.
     */
    readonly clearOrigins: () => void;
  }

  export interface mozIDownloadPlatformRef {
    readonly name: "mozIDownloadPlatform";
    readonly number: "{9f556e4a-d9b3-46c3-9f8f-d0db1ac6c8c1}";

    /**
     * Security Zone constants. Used by mapUrlToZone().
     */
    ZONE_MY_COMPUTER: 0;

    ZONE_INTRANET: 1;

    ZONE_TRUSTED: 2;

    ZONE_INTERNET: 3;

    ZONE_RESTRICTED: 4;
  }

  export interface mozIDownloadPlatform extends nsISupports {

    /**
     * Perform platform specific operations when a download is done.
     *
     *   Windows:
     *     Add the download to the recent documents list
     *     Set the file to be indexed for searching
     *   Mac:
     *     Bounce the downloads dock icon
     *   GTK:
     *     Add the download to the recent documents list
     *     Save the source uri in the downloaded file's metadata
     *   Android:
     *     Scan media
     *
     * @param aSource
     *        Source URI of the download
     * @param aReferrer
     *        Referrer URI of the download
     * @param aTarget
     *        Downloaded file
     * @param aContentType
     *        The source's content type
     * @param aIsPrivate
     *        True for private downloads
     * @return Promise that resolves once operations have completed.
     */
    readonly downloadDone: (aSource: (nsIURI | null), aReferrer: (nsIURI | null), aTarget: (nsIFile | null), aContentType: IDLACString, aIsPrivate: boolean) => IDLPromise;

    /**
     * Proxy for IInternetSecurityManager::MapUrlToZone().
     *
     *   Windows only.
     *
     * @param aURL
     *        URI of the download
     * @return Security Zone corresponding to aURL.
     */
    readonly mapUrlToZone: (aURL: IDLAString) => number;
  }

  export interface nsIJSInspectorRef {
    readonly name: "nsIJSInspector";
    readonly number: "{6758d0d7-e96a-4c5c-bca8-3bcbe5a15943}";
  }

  /**
   * Utilities for running nested event loops, asking them to return, and
   * keeping track of which ones are still running.
   */
  export interface nsIJSInspector extends nsISupports {

    /**
     * Process the current thread's event queue, calling event handlers until
     * a call to exitNestedEventLoop, below, asks us to return.
     *
     * The name 'enterNestedEventLoop' may be misleading if read too literally.
     * This method loops calling event handlers until one asks it to stop, and
     * then returns. So by that point, the nested event loop has been not only
     * entered, but also run and exited.
     *
     * When enterNestedEventLoop calls an event handler, that handler may itself
     * call enterNestedEventLoop, and so on, so that there may be arbitrarily
     * many such calls on the stack at the same time.
     *
     * We say an enterNestedEventLoop call is "running" if it has not yet been
     * asked to return, or "stopped" if it has been asked to return once it has
     * finished processing the current event.
     *
     * @param requestor   A token of the caller's choice to identify this event
     *                    loop.
     *
     * @return depth      The number of running enterNestedEventLoop calls
     *                    remaining, now that this one has returned.
     *
     *                    (Note that not all calls still on the stack are
     *                    necessary running; exitNestedEventLoop can ask any
     *                    number of enterNestedEventLoop calls to return.)
     */
    readonly enterNestedEventLoop: (requestor: IDLjsval) => number;

    /**
     * Stop the youngest running enterNestedEventLoop call, asking it to return
     * once it has finished processing the current event.
     *
     * The name 'exitNestedEventLoop' may be misleading if read too literally.
     * The affected event loop does not return immediately when this method is
     * called. Rather, this method simply returns to its caller; the affected
     * loop's current event handler is allowed to run to completion; and then
     * that loop returns without processing any more events.
     *
     * This method ignores loops that have already been stopped, and operates on
     * the youngest loop that is still running. Each call to this method stops
     * another running loop.
     *
     * @return depth      The number of running enterNestedEventLoop calls
     *                    remaining, now that one has been stopped.
     *
     * @throws NS_ERROR_FAILURE if there are no running enterNestedEventLoop calls.
     */
    readonly exitNestedEventLoop: () => number;

    /**
     * The number of running enterNestedEventLoop calls on the stack.
     * This count does not include stopped enterNestedEventLoop calls.
     */
    readonly eventLoopNestLevel: number;

    /**
     * The |requestor| value that was passed to the youngest running
     * enterNestedEventLoop call.
     */
    readonly lastNestRequestor: IDLjsval;
  }

  export interface nsIAsyncShutdownBlockerRef {
    readonly name: "nsIAsyncShutdownBlocker";
    readonly number: "{4ef43f29-6715-4b57-a750-2ff83695ddce}";
  }

  /**
   * A blocker installed by a client to be informed during some stage of
   * shutdown and block shutdown asynchronously until some condition is
   * complete.
   *
   * If you wish to use AsyncShutdown, you will need to implement this
   * interface (and only this interface).
   */
  export interface nsIAsyncShutdownBlocker extends nsISupports {

    /**
     * The *unique* name of the blocker.
     *
     * By convention, it should respect the following format:
     * "MyModuleName: Doing something while it's time"
     * e.g.
     * "OS.File: Flushing before profile-before-change"
     *
     * This attribute is uploaded as part of crash reports.
     */
    readonly name: IDLAString;

    /**
     * Inform the blocker that the stage of shutdown has started.
     * Shutdown will NOT proceed until `aBarrierClient.removeBlocker(this)`
     * has been called.
     */
    readonly blockShutdown: (aBarrierClient: (nsIAsyncShutdownClient | null)) => void;

    /**
     * The current state of the blocker.
     *
     * In case of crash, this is converted to JSON and attached to
     * the crash report.
     *
     * This field may be used to provide JSON-style data structures.
     * For this purpose, use
     * - nsIPropertyBag to represent objects;
     * - nsIVariant to represent field values (which may hold nsIPropertyBag
     * themselves).
     */
    readonly state: (nsIPropertyBag | null);
  }

  export interface nsISHistoryRef {
    readonly name: "nsISHistory";
    readonly number: "{7b807041-e60a-4384-935f-af3061d8b815}";
  }

  /**
   * An interface to the primary properties of the Session History
   * component. In an embedded browser environment, the nsIWebBrowser
   * object creates an instance of session history for each open window.
   * A handle to the session history object can be obtained from
   * nsIWebNavigation. In a non-embedded situation, the  owner of the
   * session history component must create a instance of it and set
   * it in the nsIWebNavigation object.
   * This interface is accessible from javascript.
   */
  export interface nsISHistory extends nsISupports {

    /**
     * A readonly property of the interface that returns
     * the number of toplevel documents currently available
     * in session history.
     */
    readonly count: number;

    /**
     * The index of the current document in session history. Not infallible
     * because setting can fail if the assigned value is out of range.
     */
    index: number;

    /**
     * A readonly property of the interface that returns
     * the index of the last document that started to load and
     * didn't finished yet. When document finishes the loading
     * value -1 is returned.
     */
    readonly requestedIndex: number;

    /**
     * Get the history entry at a given index. Returns non-null on success.
     *
     * @param index             The index value whose entry is requested.
     *                          The oldest entry is located at index == 0.
     * @return                  The found entry; never null.
     */
    readonly getEntryAtIndex: (aIndex: number) => (nsISHEntry | null);

    /**
     * Called to purge older documents from history.
     * Documents can be removed from session history for various
     * reasons. For example to  control memory usage of the browser, to
     * prevent users from loading documents from history, to erase evidence of
     * prior page loads etc...
     *
     * @param numEntries        The number of toplevel documents to be
     *                          purged from history. During purge operation,
     *                          the latest documents are maintained and older
     *                          'numEntries' documents are removed from history.
     * @throws                  <code>NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA</code>
     *                          Purge was vetod.
     * @throws                  <code>NS_ERROR_FAILURE</code> numEntries is
     *                          invalid or out of bounds with the size of history.
     */
    readonly PurgeHistory: (aNumEntries: number) => void;

    /**
     * Called to register a listener for the session history component.
     * Listeners are notified when pages are loaded or purged from history.
     *
     * @param aListener         Listener object to be notified for all
     *                          page loads that initiate in session history.
     *
     * @note                    A listener object must implement
     *                          nsISHistoryListener and nsSupportsWeakReference
     *
     * @see nsISHistoryListener
     * @see nsSupportsWeakReference
     */
    readonly addSHistoryListener: (aListener: (nsISHistoryListener | null)) => void;

    /**
     * Called to remove a listener for the session history component.
     * Listeners are notified when pages are loaded from history.
     *
     * @param aListener         Listener object to be removed from
     *                          session history.
     *
     * @note                    A listener object must implement
     *                          nsISHistoryListener and nsSupportsWeakReference
     * @see nsISHistoryListener
     * @see nsSupportsWeakReference
     */
    readonly removeSHistoryListener: (aListener: (nsISHistoryListener | null)) => void;

    readonly reloadCurrentEntry: () => void;

    /**
     * Add a new Entry to the History List.
     *
     * @param aEntry            The entry to add.
     * @param aPersist          If true this specifies that the entry should
     *                          persist in the list. If false, this means that
     *                          when new entries are added this element will not
     *                          appear in the session history list.
     */
    readonly addEntry: (aEntry: (nsISHEntry | null), aPersist: boolean) => void;

    /**
     * Update the index maintained by sessionHistory
     */
    readonly updateIndex: () => void;

    /**
     * Replace the nsISHEntry at a particular index
     *
     * @param aIndex            The index at which the entry should be replaced.
     * @param aReplaceEntry     The replacement entry for the index.
     */
    readonly replaceEntry: (aIndex: number, aReplaceEntry: (nsISHEntry | null)) => void;

    /**
     * Notifies all registered session history listeners about an impending
     * reload.
     *
     * @return                  Whether the operation can proceed.
     */
    readonly notifyOnHistoryReload: () => boolean;

    /**
     * Evict content viewers which don't lie in the "safe" range around aIndex.
     * In practice, this should leave us with no more than gHistoryMaxViewers
     * viewers associated with this SHistory object.
     *
     * Also make sure that the total number of content viewers in all windows is
     * not greater than our global max; if it is, evict viewers as appropriate.
     *
     * @param aIndex           The index around which the "safe" range is
     *                         centered.  In general, if you just navigated the
     *                         history, aIndex should be the index history was
     *                         navigated to.
     */
    readonly evictOutOfRangeContentViewers: (aIndex: number) => void;

    /**
     * Evict the content viewer associated with a bfcache entry that has timed
     * out.
     */
    readonly evictExpiredContentViewerForEntry: (aEntry: (nsIBFCacheEntry | null)) => void;

    /**
     * Evict all the content viewers in this session history
     */
    readonly evictAllContentViewers: () => void;

    readonly createEntry: () => (nsISHEntry | null);
  }

  export interface nsIServiceWorkerRegistrationInfoRef {
    readonly name: "nsIServiceWorkerRegistrationInfo";
    readonly number: "{ddbc1fd4-2f2e-4fca-a395-6e010bbedfe3}";

    UPDATE_VIA_CACHE_IMPORTS: 0;

    UPDATE_VIA_CACHE_ALL: 1;

    UPDATE_VIA_CACHE_NONE: 2;
  }

  export interface nsIServiceWorkerRegistrationInfo extends nsISupports {

    readonly principal: (nsIPrincipal | null);

    readonly scope: IDLAString;

    readonly scriptSpec: IDLAString;

    readonly updateViaCache: number;

    readonly lastUpdateTime: number;

    readonly evaluatingWorker: (nsIServiceWorkerInfo | null);

    readonly installingWorker: (nsIServiceWorkerInfo | null);

    readonly waitingWorker: (nsIServiceWorkerInfo | null);

    readonly activeWorker: (nsIServiceWorkerInfo | null);

    readonly getWorkerByID: (aID: number) => (nsIServiceWorkerInfo | null);

    readonly addListener: (listener: (nsIServiceWorkerRegistrationInfoListener | null)) => void;

    readonly removeListener: (listener: (nsIServiceWorkerRegistrationInfoListener | null)) => void;
  }

  export interface nsIFileRef {
    readonly name: "nsIFile";
    readonly number: "{2fa6884a-ae65-412a-9d4c-ce6e34544ba1}";

    /**
     * An nsIFile is an abstract representation of a filename. It manages
     * filename encoding issues, pathname component separators ('/' vs. '\\'
     * vs. ':') and weird stuff like differing volumes with identical names, as
     * on pre-Darwin Macintoshes.
     *
     * This file has long introduced itself to new hackers with this opening
     * paragraph:
     *
     *    This is the only correct cross-platform way to specify a file.
     *    Strings are not such a way. If you grew up on windows or unix, you
     *    may think they are.  Welcome to reality.
     *
     * While taking the pose struck here to heart would be uncalled for, one
     * may safely conclude that writing cross-platform code is an embittering
     * experience.
     *
     * All methods with string parameters have two forms.  The preferred
     * form operates on UCS-2 encoded characters strings.  An alternate
     * form operates on characters strings encoded in the "native" charset.
     *
     * A string containing characters encoded in the native charset cannot
     * be safely passed to javascript via xpconnect.  Therefore, the "native
     * methods" are not scriptable.
     */
    /**
     *  Create Types
     *
     *  NORMAL_FILE_TYPE - A normal file.
     *  DIRECTORY_TYPE   - A directory/folder.
     */
    NORMAL_FILE_TYPE: 0;

    DIRECTORY_TYPE: 1;

    /**
     * Flag for openNSPRFileDesc(), to hint to the OS that the file will be
     * read sequentially with agressive readahead.
     */
    OS_READAHEAD: 1073741824;

    /**
     * Flag for openNSPRFileDesc(). Deprecated and unreliable!
     * Instead use NS_OpenAnonymousTemporaryFile() to create a temporary
     * file which will be deleted upon close!
     */
    DELETE_ON_CLOSE: 2147483648;
  }

  export interface nsIFile extends nsISupports {

    /**
     *  append[Native]
     *
     *  This function is used for constructing a descendent of the
     *  current nsIFile.
     *
     *   @param node
     *       A string which is intended to be a child node of the nsIFile.
     *       For the |appendNative| method, the node must be in the native
     *       filesystem charset.
     */
    readonly append: (node: IDLAString) => void;

    /**
     *  Normalize the pathName (e.g. removing .. and . components on Unix).
     */
    readonly normalize: () => void;

    /**
     *  create
     *
     *  This function will create a new file or directory in the
     *  file system. Any nodes that have not been created or
     *  resolved, will be.  If the file or directory already
     *  exists create() will return NS_ERROR_FILE_ALREADY_EXISTS.
     *
     *   @param type
     *       This specifies the type of file system object
     *       to be made.  The only two types at this time
     *       are file and directory which are defined above.
     *       If the type is unrecongnized, we will return an
     *       error (NS_ERROR_FILE_UNKNOWN_TYPE).
     *
     *   @param permissions
     *       The unix style octal permissions.  This may
     *       be ignored on systems that do not need to do
     *       permissions.
     */
    readonly create: (type: number, permissions: number) => void;

    /**
     *  Accessor to the leaf name of the file itself.
     *  For the |nativeLeafName| method, the nativeLeafName must
     *  be in the native filesystem charset.
     */
    leafName: IDLAString;

    /**
     *  copyTo[Native]
     *
     *  This will copy this file to the specified newParentDir.
     *  If a newName is specified, the file will be renamed.
     *  If 'this' is not created we will return an error
     *  (NS_ERROR_FILE_TARGET_DOES_NOT_EXIST).
     *
     *  copyTo may fail if the file already exists in the destination
     *  directory.
     *
     *  copyTo will NOT resolve aliases/shortcuts during the copy.
     *
     *   @param newParentDir
     *       This param is the destination directory. If the
     *       newParentDir is null, copyTo() will use the parent
     *       directory of this file. If the newParentDir is not
     *       empty and is not a directory, an error will be
     *       returned (NS_ERROR_FILE_DESTINATION_NOT_DIR). For the
     *       |CopyToNative| method, the newName must be in the
     *       native filesystem charset.
     *
     *   @param newName
     *       This param allows you to specify a new name for
     *       the file to be copied. This param may be empty, in
     *       which case the current leaf name will be used.
     */
    readonly copyTo: (newParentDir: (nsIFile | null), newName: IDLAString) => void;

    /**
     *  copyToFollowingLinks[Native]
     *
     *  This function is identical to copyTo with the exception that,
     *  as the name implies, it follows symbolic links.  The XP_UNIX
     *  implementation always follow symbolic links when copying.  For
     *  the |CopyToFollowingLinks| method, the newName must be in the
     *  native filesystem charset.
     */
    readonly copyToFollowingLinks: (newParentDir: (nsIFile | null), newName: IDLAString) => void;

    /**
     *  moveTo[Native]
     *
     *  A method to move this file or directory to newParentDir.
     *  If a newName is specified, the file or directory will be renamed.
     *  If 'this' is not created we will return an error
     *  (NS_ERROR_FILE_TARGET_DOES_NOT_EXIST).
     *  If 'this' is a file, and the destination file already exists, moveTo
     *  will replace the old file.
     *  This object is updated to refer to the new file.
     *
     *  moveTo will NOT resolve aliases/shortcuts during the copy.
     *  moveTo will do the right thing and allow copies across volumes.
     *  moveTo will return an error (NS_ERROR_FILE_DIR_NOT_EMPTY) if 'this' is
     *  a directory and the destination directory is not empty.
     *  moveTo will return an error (NS_ERROR_FILE_ACCESS_DENIED) if 'this' is
     *  a directory and the destination directory is not writable.
     *
     *   @param newParentDir
     *       This param is the destination directory. If the
     *       newParentDir is empty, moveTo() will rename the file
     *       within its current directory. If the newParentDir is
     *       not empty and does not name a directory, an error will
     *       be returned (NS_ERROR_FILE_DESTINATION_NOT_DIR).  For
     *       the |moveToNative| method, the newName must be in the
     *       native filesystem charset.
     *
     *   @param newName
     *       This param allows you to specify a new name for
     *       the file to be moved. This param may be empty, in
     *       which case the current leaf name will be used.
     */
    readonly moveTo: (newParentDir: (nsIFile | null), newName: IDLAString) => void;

    /**
     *  renameTo
     *
     *  This method is identical to moveTo except that if this file or directory
     *  is moved to a a different volume, it fails and returns an error
     *  (NS_ERROR_FILE_ACCESS_DENIED).
     *  This object will still point to the old location after renaming.
     */
    readonly renameTo: (newParentDir: (nsIFile | null), newName: IDLAString) => void;

    /**
     *  This will try to delete this file.  The 'recursive' flag
     *  must be PR_TRUE to delete directories which are not empty.
     *
     *  This will not resolve any symlinks.
     */
    readonly remove: (recursive: boolean) => void;

    /**
     *  Attributes of nsIFile.
     */
    permissions: number;

    permissionsOfLink: number;

    /**
     *  File Times are to be in milliseconds from
     *  midnight (00:00:00), January 1, 1970 Greenwich Mean
     *  Time (GMT).
     */
    lastModifiedTime: number;

    lastModifiedTimeOfLink: number;

    /**
     *  WARNING!  On the Mac, getting/setting the file size with nsIFile
     *  only deals with the size of the data fork.  If you need to
     *  know the size of the combined data and resource forks use the
     *  GetFileSizeWithResFork() method defined on nsILocalFileMac.
     */
    fileSize: number;

    readonly fileSizeOfLink: number;

    /**
     *  target & path
     *
     *  Accessor to the string path.  The native version of these
     *  strings are not guaranteed to be a usable path to pass to
     *  NSPR or the C stdlib.  There are problems that affect
     *  platforms on which a path does not fully specify a file
     *  because two volumes can have the same name (e.g., mac).
     *  This is solved by holding "private", native data in the
     *  nsIFile implementation.  This native data is lost when
     *  you convert to a string.
     *
     *      DO NOT PASS TO USE WITH NSPR OR STDLIB!
     *
     *  target
     *      Find out what the symlink points at.  Will give error
     *      (NS_ERROR_FILE_INVALID_PATH) if not a symlink.
     *
     *  path
     *      Find out what the nsIFile points at.
     *
     *  Note that the ACString attributes are returned in the
     *  native filesystem charset.
     *
     */
    readonly target: IDLAString;

    readonly path: IDLAString;

    readonly exists: () => boolean;

    readonly isWritable: () => boolean;

    readonly isReadable: () => boolean;

    readonly isExecutable: () => boolean;

    readonly isHidden: () => boolean;

    readonly isDirectory: () => boolean;

    readonly isFile: () => boolean;

    readonly isSymlink: () => boolean;

    /**
     * Not a regular file, not a directory, not a symlink.
     */
    readonly isSpecial: () => boolean;

    /**
     *  createUnique
     *
     *  This function will create a new file or directory in the
     *  file system. Any nodes that have not been created or
     *  resolved, will be.  If this file already exists, we try
     *  variations on the leaf name "suggestedName" until we find
     *  one that did not already exist.
     *
     *  If the search for nonexistent files takes too long
     *  (thousands of the variants already exist), we give up and
     *  return NS_ERROR_FILE_TOO_BIG.
     *
     *   @param type
     *       This specifies the type of file system object
     *       to be made.  The only two types at this time
     *       are file and directory which are defined above.
     *       If the type is unrecongnized, we will return an
     *       error (NS_ERROR_FILE_UNKNOWN_TYPE).
     *
     *   @param permissions
     *       The unix style octal permissions.  This may
     *       be ignored on systems that do not need to do
     *       permissions.
     */
    readonly createUnique: (type: number, permissions: number) => void;

    /**
     * clone()
     *
     * This function will allocate and initialize a nsIFile object to the
     * exact location of the |this| nsIFile.
     *
     *   @param file
     *          A nsIFile which this object will be initialize
     *          with.
     *
     */
    readonly clone: () => (nsIFile | null);

    /**
     *  Will determine if the inFile equals this.
     */
    readonly equals: (inFile: (nsIFile | null)) => boolean;

    /**
     *  Will determine if inFile is a descendant of this file.
     *  This routine looks in subdirectories too.
     */
    readonly contains: (inFile: (nsIFile | null)) => boolean;

    /**
     *  Parent will be null when this is at the top of the volume.
     */
    readonly parent: (nsIFile | null);

    /**
     *  Returns an enumeration of the elements in a directory. Each
     *  element in the enumeration is an nsIFile.
     *
     *   @throws NS_ERROR_FILE_NOT_DIRECTORY if the current nsIFile does
     *           not specify a directory.
     */
    readonly directoryEntries: (nsIDirectoryEnumerator | null);

    /**
     *  initWith[Native]Path
     *
     *  This function will initialize the nsIFile object.  Any
     *  internal state information will be reset.
     *
     *   @param filePath
     *       A string which specifies a full file path to a
     *       location.  Relative paths will be treated as an
     *       error (NS_ERROR_FILE_UNRECOGNIZED_PATH).  For
     *       initWithNativePath, the filePath must be in the native
     *       filesystem charset.
     */
    readonly initWithPath: (filePath: IDLAString) => void;

    /**
     *  initWithFile
     *
     *  Initialize this object with another file
     *
     *   @param aFile
     *       the file this becomes equivalent to
     */
    readonly initWithFile: (aFile: (nsIFile | null)) => void;

    /**
     *  followLinks
     *
     *  This attribute will determine if the nsLocalFile will auto
     *  resolve symbolic links.  By default, this value will be false
     *  on all non unix systems.  On unix, this attribute is effectively
     *  a noop.
     */
    followLinks: boolean;

    readonly diskSpaceAvailable: number;

    /**
     *  appendRelative[Native]Path
     *
     *  Append a relative path to the current path of the nsIFile object.
     *
     *   @param relativeFilePath
     *       relativeFilePath is a native relative path. For security reasons,
     *       this cannot contain .. or cannot start with a directory separator.
     *       For the |appendRelativeNativePath| method, the relativeFilePath
     *       must be in the native filesystem charset.
     */
    readonly appendRelativePath: (relativeFilePath: IDLAString) => void;

    /**
     *  Accessor to a null terminated string which will specify
     *  the file in a persistent manner for disk storage.
     *
     *  The character set of this attribute is undefined.  DO NOT TRY TO
     *  INTERPRET IT AS HUMAN READABLE TEXT!
     */
    persistentDescriptor: IDLACString;

    /**
     *  reveal
     *
     *  Ask the operating system to open the folder which contains
     *  this file or folder. This routine only works on platforms which
     *  support the ability to open a folder and is run async on Windows.
     *  This routine must be called on the main.
     */
    readonly reveal: () => void;

    /**
     *  launch
     *
     *  Ask the operating system to attempt to open the file.
     *  this really just simulates "double clicking" the file on your platform.
     *  This routine only works on platforms which support this functionality
     *  and is run async on Windows.  This routine must be called on the
     *  main thread.
     */
    readonly launch: () => void;

    /**
     *  getRelativeDescriptor
     *
     *  Returns a relative file path in an opaque, XP format. It is therefore
     *  not a native path.
     *
     *  The character set of the string returned from this function is
     *  undefined.  DO NOT TRY TO INTERPRET IT AS HUMAN READABLE TEXT!
     *
     *   @param fromFile
     *       the file from which the descriptor is relative.
     *       Throws if fromFile is null.
     */
    readonly getRelativeDescriptor: (fromFile: (nsIFile | null)) => IDLACString;

    /**
     *  setRelativeDescriptor
     *
     *  Initializes the file to the location relative to fromFile using
     *  a string returned by getRelativeDescriptor.
     *
     *   @param fromFile
     *       the file to which the descriptor is relative
     *   @param relative
     *       the relative descriptor obtained from getRelativeDescriptor
     */
    readonly setRelativeDescriptor: (fromFile: (nsIFile | null), relativeDesc: IDLACString) => void;

    /**
     *  getRelativePath
     *
     *  Returns a relative file from 'fromFile' to this file as a UTF-8 string.
     *  Going up the directory tree is represented via "../".  '/' is used as
     *  the path segment separator.  This is not a native path, since it's UTF-8
     *  encoded.
     *
     *   @param fromFile
     *       the file from which the path is relative.
     *       Throws if fromFile is null.
     */
    readonly getRelativePath: (fromFile: (nsIFile | null)) => IDLAUTF8String;

    /**
     *  setRelativePath
     *
     *  Initializes the file to the location relative to fromFile using
     *  a string returned by getRelativePath.
     *
     *   @param fromFile
     *       the file from which the path is relative
     *   @param relative
     *       the relative path obtained from getRelativePath
     */
    readonly setRelativePath: (fromFile: (nsIFile | null), relativeDesc: IDLAUTF8String) => void;
  }

  export interface nsICrashServiceRef {
    readonly name: "nsICrashService";
    readonly number: "{70bd93ff-88fa-4600-8af8-57c8d002dbac}";

    PROCESS_TYPE_MAIN: 0;

    PROCESS_TYPE_PLUGIN: 1;

    PROCESS_TYPE_CONTENT: 2;

    PROCESS_TYPE_IPDLUNITTEST: 3;

    PROCESS_TYPE_GMPLUGIN: 4;

    PROCESS_TYPE_GPU: 5;

    PROCESS_TYPE_VR: 6;

    PROCESS_TYPE_RDD: 7;

    PROCESS_TYPE_SOCKET: 8;

    PROCESS_TYPE_SANDBOX_BROKER: 9;

    PROCESS_TYPE_FORKSERVER: 10;

    CRASH_TYPE_CRASH: 0;

    CRASH_TYPE_HANG: 1;
  }

  export interface nsICrashService extends nsISupports {

    /**
     * Records the occurrence of a crash.
     *
     * @param processType
     *        One of the PROCESS_TYPE constants defined below.
     * @param crashType
     *        One of the CRASH_TYPE constants defined below.
     * @param id
     *        Crash ID. Likely a UUID.
     *
     * @return A promise that resolves after the crash has been stored
     */
    readonly addCrash: (processType: number, crashType: number, id: IDLAString) => IDLPromise;
  }

  export interface nsIQuotaRequestBaseRef {
    readonly name: "nsIQuotaRequestBase";
    readonly number: "{9af54222-0407-48fd-a4ab-9457c986fc49}";
  }

  export interface nsIQuotaRequestBase extends nsISupports {

    readonly principal: (nsIPrincipal | null);

    readonly resultCode: number;
  }

  export interface nsIUrlClassifierSkipListServiceRef {
    readonly name: "nsIUrlClassifierSkipListService";
    readonly number: "{75c3d1a3-e977-4079-9e27-b3b56bdb76ea}";
  }

  /**
   * A service that monitors updates to the skip list of url-classifier
   * feature from sources such as a local pref and remote settings updates.
   */
  export interface nsIUrlClassifierSkipListService extends nsISupports {

    /**
     * Register a new observer to skip list updates. When the observer is
     * registered it is called immediately once. Afterwards it will be called
     * whenever the specified pref changes or when remote settings for
     * url-classifier features updates.
     *
     * @param aFeature
     *        The feature for which to observe the skip list.
     *
     * @param aPrefName
     *        (Optional) A pref name to monitor. The pref must be of string
     *        type and contain a comma-separated list of URL patterns.
     *
     * @param aObserver
     *        An nsIUrlClassifierSkipListObserver object or function that
     *        will receive updates to the skip list as a comma-separated
     *        string. Will be called immediately with the current skip
     *        list value.
     */
    readonly registerAndRunSkipListObserver: (aFeature: IDLACString, aPrefName: IDLACString, aObserver: (nsIUrlClassifierSkipListObserver | nsIUrlClassifierSkipListObserverFunction | null)) => void;

    /**
     * Unregister an observer.
     *
     * @param aFeature
     *        The feature for which to stop observing.
     *
     * @param aObserver
     *        The nsIUrlClassifierSkipListObserver object to unregister.
     */
    readonly unregisterSkipListObserver: (aFeature: IDLACString, aObserver: (nsIUrlClassifierSkipListObserver | nsIUrlClassifierSkipListObserverFunction | null)) => void;
  }

  export interface nsIPresentationTransportBuilderConstructorRef {
    readonly name: "nsIPresentationTransportBuilderConstructor";
    readonly number: "{706482b2-1b51-4bed-a21d-785a9cfcfac7}";
  }

  /**
   * The constructor for creating a transport builder.
   */
  export interface nsIPresentationTransportBuilderConstructor extends nsISupports {

    readonly createTransportBuilder: (type: number) => (nsIPresentationSessionTransportBuilder | null);
  }

  export interface nsISDBCallbackRef {
    readonly name: "nsISDBCallback";
    readonly number: "{8cbd576c-c6bf-42fd-96ee-3b824dafe1d4}";
  }

  type nsISDBCallbackFunction = (aRequest: (nsISDBRequest | null)) => void;

  export interface nsISDBCallback extends nsISupports {

    readonly onComplete: (aRequest: (nsISDBRequest | null)) => void;
  }

  export interface nsICategoryEntryRef {
    readonly name: "nsICategoryEntry";
    readonly number: "{de021d54-57a3-4025-ae63-4c8eedbe74c0}";
  }

  export interface nsICategoryEntry extends nsISupportsCString {

    readonly entry: IDLACString;

    readonly value: IDLACString;
  }

  export interface nsIPresentationDeviceRef {
    readonly name: "nsIPresentationDevice";
    readonly number: "{b1e0a7af-5936-4066-8f2e-f789fb9a7e8f}";
  }

  export interface nsIPresentationDevice extends nsISupports {

    readonly id: IDLAUTF8String;

    readonly name: IDLAUTF8String;

    readonly type: IDLAUTF8String;

    readonly establishControlChannel: () => (nsIPresentationControlChannel | null);

    readonly disconnect: () => void;

    readonly isRequestedUrlSupported: (requestedUrl: IDLAString) => boolean;
  }

  export interface nsIDocumentEncoderRef {
    readonly name: "nsIDocumentEncoder";
    readonly number: "{21f112df-d96f-47da-bfcb-5331273003d1}";

    /**
     * Output only the selection (as opposed to the whole document).
     */
    OutputSelectionOnly: 1;

    /** Plaintext output: Convert html to plaintext that looks like the html.
     * Can't be used in conjunction with `OutputPreformatted`.
     * Implies wrap (except inside <pre>), since html wraps.
     * HTML, XHTML and XML output: do prettyprinting, ignoring existing formatting.
     * XML output : it doesn't implicitly wrap
     */
    OutputFormatted: 2;

    /** Don't do prettyprinting. Don't do any wrapping that's not in the existing
     * HTML/XML source. This option overrides OutputFormatted if both are set.
     * HTML/XHTML output: If neither are set, there won't be prettyprinting too, but
     * long lines will be wrapped.
     * Supported also in XML and Plaintext output.
     * @note This option does not affect entity conversion.
     */
    OutputRaw: 4;

    /**
     * Do not print html head tags.
     * XHTML/HTML output only.
     */
    OutputBodyOnly: 8;

    /**
     * Output as though the content is preformatted
     * (e.g. maybe it's wrapped in a PRE or PRE_WRAP style tag)
     * Plaintext output only.
     * Can't be used together with `OutputFormatted`/`OutputFormatFlowed`.
     * XXXbz How does this interact with OutputRaw?
     */
    OutputPreformatted: 16;

    /**
     * Wrap even if we're not doing formatted output (e.g. for text fields).
     * Supported in XML, XHTML, HTML and Plaintext output.
     * Set implicitly in HTML/XHTML output when no OutputRaw.
     * Ignored when OutputRaw.
     * XXXLJ: set implicitly in HTML/XHTML output, to keep compatible behaviors
     *        for old callers of this interface
     * XXXbz How does this interact with OutputFormatFlowed?
     */
    OutputWrap: 32;

    /**
     * Output for format flowed (RFC 2646). This is used when converting
     * to text for mail sending. This differs just slightly
     * but in an important way from normal formatted, and that is that
     * lines are space stuffed. This can't (correctly) be done later.
     * PlainText output only.
     * If this flag is set, `OutputFormat` has to be set too.
     * XXXbz How does this interact with OutputRaw/OutputWrap?
     */
    OutputFormatFlowed: 64;

    /**
     * Convert links, image src, and script src to absolute URLs when possible.
     * XHTML/HTML output only.
     */
    OutputAbsoluteLinks: 128;

    /**
     * LineBreak processing: if this flag is set than CR line breaks will
     * be written. If neither this nor OutputLFLineBreak is set, then we
     * will use platform line breaks. The combination of the two flags will
     * cause CRLF line breaks to be written.
     */
    OutputCRLineBreak: 512;

    /**
     * LineBreak processing: if this flag is set than LF line breaks will
     * be written. If neither this nor OutputCRLineBreak is set, then we
     * will use platform line breaks. The combination of the two flags will
     * cause CRLF line breaks to be written.
     */
    OutputLFLineBreak: 1024;

    /**
     * Output the content of noscript elements (only for serializing
     * to plaintext).
     */
    OutputNoScriptContent: 2048;

    /**
     * Output the content of noframes elements (only for serializing
     * to plaintext). (Used only internally in the plain text serializer;
     * ignored if passed by the caller.)
     */
    OutputNoFramesContent: 4096;

    /**
     * Don't allow any formatting nodes (e.g. <br>, <b>) inside a <pre>.
     * This is used primarily by mail. XHTML/HTML output only.
     */
    OutputNoFormattingInPre: 8192;

    /**
     * Encode entities when outputting to a string.
     * E.g. If set, we'll output &nbsp; if clear, we'll output 0xa0.
     * The basic set is just &nbsp; &amp; &lt; &gt; &quot; for interoperability
     * with older products that don't support &alpha; and friends.
     * HTML output only.
     */
    OutputEncodeBasicEntities: 16384;

    /**
     * Normally &nbsp; is replaced with a space character when
     * encoding data as plain text, set this flag if that's
     * not desired.
     * Plaintext output only.
     */
    OutputPersistNBSP: 131072;

    /**
     * Normally when serializing the whole document using the HTML or
     * XHTML serializer, the encoding declaration is rewritten to match.
     * This flag suppresses that behavior.
     */
    OutputDontRewriteEncodingDeclaration: 262144;

    /**
     * When using the HTML or XHTML serializer, skip elements that are not
     * visible when this flag is set.  Elements are not visible when they
     * have CSS style display:none or visibility:collapse, for example.
     */
    SkipInvisibleContent: 524288;

    /**
     * Output for delsp=yes (RFC 3676). This is used with OutputFormatFlowed
     * when converting to text for mail sending.
     * PlainText output only.
     */
    OutputFormatDelSp: 1048576;

    /**
     * Drop <br> elements considered "invisible" by the editor. OutputPreformatted
     * implies this flag.
     */
    OutputDropInvisibleBreak: 2097152;

    /**
     * Don't check for _moz_dirty attributes when deciding whether to
     * pretty-print if this flag is set (bug 599983).
     */
    OutputIgnoreMozDirty: 4194304;

    /**
     * Serialize in a way that is suitable for copying a plaintext version of the
     * document to the clipboard.  This can for example cause line endings to be
     * injected at preformatted block element boundaries.
     */
    OutputForPlainTextClipboardCopy: 33554432;

    /**
     * Include ruby annotations and ruby parentheses in the output.
     * PlainText output only.
     */
    OutputRubyAnnotation: 67108864;

    /**
     * Disallow breaking of long character strings. This is important
     * for serializing e-mail which contains CJK strings. These must
     * not be broken just as "normal" longs strings aren't broken.
     */
    OutputDisallowLineBreaking: 134217728;

    /**
     * Release reference of Document after using encodeTo* method to recycle
     * this encoder without holding Document. To use this encoder again,
     * we have to call init again.
     */
    RequiresReinitAfterOutput: 268435456;
  }

  export interface nsIDocumentEncoder extends nsISupports {

    /**
     * Initialize with a pointer to the document and the mime type.
     * Resets wrap column to 72 and resets node fixup.
     * @param aDocument Document to encode.
     * @param aMimeType MimeType to use. May also be set by SetMimeType.
     * @param aFlags Flags to use while encoding. May also be set by SetFlags.
     */
    readonly init: (aDocument: WebIDL.Document, aMimeType: IDLAString, aFlags: number) => void;

    /**
     *  If the selection is set to a non-null value, then the
     *  selection is used for encoding, otherwise the entire
     *  document is encoded.
     * @param aSelection The selection to encode.
     */
    readonly setSelection: (aSelection: WebIDL.Selection) => void;

    /**
     *  If the range is set to a non-null value, then the
     *  range is used for encoding, otherwise the entire
     *  document or selection is encoded.
     * @param aRange The range to encode.
     */
    readonly setRange: (aRange: WebIDL.Range) => void;

    /**
     *  If the node is set to a non-null value, then the
     *  node is used for encoding, otherwise the entire
     *  document or range or selection is encoded.
     * @param aNode The node to encode.
     */
    readonly setNode: (aNode: WebIDL.Node) => void;

    /**
     *  If the container is set to a non-null value, then its
     *  child nodes are used for encoding, otherwise the entire
     *  document or range or selection or node is encoded.
     *  @param aContainer The node which child nodes will be encoded.
     */
    readonly setContainerNode: (aContainer: WebIDL.Node) => void;

    /**
     *  Documents typically have an intrinsic character set,
     *  but if no intrinsic value is found, the platform character set
     *  is used. This function overrides both the intrinisc and platform
     *  charset.
     *  @param aCharset Overrides the both the intrinsic or platform
     *  character set when encoding the document.
     *
     *  Possible result codes: NS_ERROR_NO_CHARSET_CONVERTER
     */
    readonly setCharset: (aCharset: IDLACString) => void;

    /**
     *  Set a wrap column.  This may have no effect in some types of encoders.
     * @param aWrapColumn Column to which to wrap. If 0, wrapping is disabled.
     */
    readonly setWrapColumn: (aWrapColumn: number) => void;

    /**
     *  The mime type preferred by the encoder.  This piece of api was
     *  added because the copy encoder may need to switch mime types on you
     *  if you ask it to copy html that really represents plaintext content.
     *  Call this AFTER Init() and SetSelection() have both been called.
     */
    readonly mimeType: IDLAString;

    /**
     *  Encode the document and send the result to the nsIOutputStream.
     *
     *  Possible result codes are the stream errors which might have
     *  been encountered.
     * @param aStream Stream into which to encode.
     */
    readonly encodeToStream: (aStream: (nsIOutputStream | null)) => void;

    /**
     * Encode the document into a string.
     *
     * @return The document encoded into a string.
     */
    readonly encodeToString: () => IDLAString;

    /**
     * Encode the document into a string. Stores the extra context information
     * into the two arguments.
     * @param [OUT] aContextString The string where the parent hierarchy
     *              information will be stored.
     * @param [OUT] aInfoString The string where extra context info will
     *              be stored.
     * @return The document encoded as a string.
     *
     */
    readonly encodeToStringWithContext: (aContextString: Out<IDLAString>, aInfoString: Out<IDLAString>) => IDLAString;

    /**
     * Encode the document into a string of limited size.
     * @param aMaxLength After aMaxLength characters, the encoder will stop
     *                   encoding new data.
     *                   Only values > 0 will be considered.
     *                   The returned string may be slightly larger than
     *                   aMaxLength because some serializers (eg. HTML)
     *                   may need to close some tags after they stop
     *                   encoding new data, or finish a line (72 columns
     *                   by default for the plain text serializer).
     *
     * @return The document encoded into a string.
     */
    readonly encodeToStringWithMaxLength: (aMaxLength: number) => IDLAString;

    /**
     * Set the fixup object associated with node persistence.
     * @param aFixup The fixup object.
     */
    readonly setNodeFixup: (aFixup: (nsIDocumentEncoderNodeFixup | null)) => void;
  }

  export interface nsIHTTPHeaderListenerRef {
    readonly name: "nsIHTTPHeaderListener";
    readonly number: "{ea51e0b8-871c-4b85-92da-6f400394c5ec}";
  }

  /**
   * The nsIHTTPHeaderListener interface allows plugin authors to
   * access HTTP Response headers after issuing an
   * nsIPluginHost::{GetURL,PostURL}() call. <P>
   */
  export interface nsIHTTPHeaderListener extends nsISupports {

    /**
     * Called for each HTTP Response header.
     * NOTE: You must copy the values of the params.
     */
    readonly newResponseHeader: (headerName: string, headerValue: string) => void;

    /**
     * Called once for the HTTP Response status line.
     * Value does NOT include a terminating newline.
     * NOTE: You must copy this value.
     */
    readonly statusLine: (line: string) => void;
  }

  export interface nsIWebBrowserFindInFramesRef {
    readonly name: "nsIWebBrowserFindInFrames";
    readonly number: "{e0f5d182-34bc-11d5-be5b-b760676c6ebc}";
  }

  /**
   * nsIWebBrowserFindInFrames
   *
   * Controls how find behaves when multiple frames or iframes are present.
   *
   * Get by doing a QueryInterface from nsIWebBrowserFind.
   */
  export interface nsIWebBrowserFindInFrames extends nsISupports {

    /**
     * currentSearchFrame
     *
     * Frame at which to start the search. Once the search is done, this will
     * be set to be the last frame searched, whether or not a result was found.
     * Has to be equal to or contained within the rootSearchFrame.
     */
    currentSearchFrame: (mozIDOMWindowProxy | null);

    /**
     * rootSearchFrame
     *
     * Frame within which to confine the search (normally the content area frame).
     * Set this to only search a subtree of the frame hierarchy.
     */
    rootSearchFrame: (mozIDOMWindowProxy | null);

    /**
     * searchSubframes
     *
     * Whether to recurse down into subframes while searching. Default is true.
     *
     * Setting nsIWebBrowserfind.searchFrames to true sets this to true.
     */
    searchSubframes: boolean;

    /**
     * searchParentFrames
     *
     * Whether to allow the search to propagate out of the currentSearchFrame into its
     * parent frame(s). Search is always confined within the rootSearchFrame. Default
     * is true.
     *
     * Setting nsIWebBrowserfind.searchFrames to true sets this to true.
     */
    searchParentFrames: boolean;
  }

  export interface nsICompressConvStatsRef {
    readonly name: "nsICompressConvStats";
    readonly number: "{58172ad0-46a9-4893-8fde-cd909c10792a}";
  }

  /**
   * nsICompressConvStats
   *
   * This interface allows for the observation of decoded resource sizes
   */
  export interface nsICompressConvStats extends nsISupports {

    readonly decodedDataLength: number;
  }

  export interface inIDeepTreeWalkerRef {
    readonly name: "inIDeepTreeWalker";
    readonly number: "{6657e8eb-b646-48e7-993e-cfa6e96415b4}";
  }

  export interface inIDeepTreeWalker extends nsISupports {

    showAnonymousContent: boolean;

    showSubDocuments: boolean;

    showDocumentsAsNodes: boolean;

    readonly init: (aRoot: WebIDL.Node, aWhatToShow: number) => void;

    readonly root: WebIDL.Node;

    readonly whatToShow: number;

    currentNode: WebIDL.Node;

    readonly parentNode: () => WebIDL.Node;

    readonly firstChild: () => WebIDL.Node;

    readonly lastChild: () => WebIDL.Node;

    readonly previousSibling: () => WebIDL.Node;

    readonly nextSibling: () => WebIDL.Node;

    readonly previousNode: () => WebIDL.Node;

    readonly nextNode: () => WebIDL.Node;
  }

  export interface nsIRemoteWebProgressRequestRef {
    readonly name: "nsIRemoteWebProgressRequest";
    readonly number: "{e14ff4c2-7e26-4748-8755-dfd074b9c746}";
  }

  export interface nsIRemoteWebProgressRequest extends nsISupports {

    readonly init: (aURI: (nsIURI | null), aOriginalURI: (nsIURI | null)) => void;

    readonly elapsedLoadTimeMS: number;
  }

  export interface nsIASN1PrintableItemRef {
    readonly name: "nsIASN1PrintableItem";
    readonly number: "{114e1142-1dd2-11b2-ac26-b6db19d9184a}";
  }

  export interface nsIASN1PrintableItem extends nsIASN1Object {
  }

  export interface nsIInputStreamReceiverRef {
    readonly name: "nsIInputStreamReceiver";
    readonly number: "{1fb8ccf2-5fa5-45ec-bc57-8c8022a5d0d3}";
  }

  export interface nsIInputStreamReceiver extends nsISupports {

    readonly onInputStreamReady: (aStream: (nsIInputStream | null)) => void;
  }

  export interface nsIWindowCreatorRef {
    readonly name: "nsIWindowCreator";
    readonly number: "{30465632-a777-44cc-90f9-8145475ef999}";
  }

  export interface nsIWindowCreator extends nsISupports {

    /** Create a new window. Gecko will/may call this method, if made
          available to it, to create new windows.
          @param parent Parent window, if any. Null if not. The newly created
                        window should be made a child/dependent window of
                        the parent, if any (and if the concept applies
                        to the underlying OS).
          @param chromeFlags Chrome features from nsIWebBrowserChrome
          @param aOpeningTab The RemoteTab that is trying to open this new chrome
                             window. Can be nullptr.
          @param aOpener The window which is trying to open this new chrome window.
                         Can be nullptr
          @param aNextRemoteTabId The integer ID of the next remote tab actor to use.
                                  0 means there is no next remote tab ID to use.
          @param cancel Return |true| to reject window creation. If true the
                        implementation has determined the window should not
                        be created at all. The caller should not default
                        to any possible backup scheme for creating the window.
          @return the new window. Will be null if canceled or an error occurred.
      */
    readonly createChromeWindow: (parent: (nsIWebBrowserChrome | null), chromeFlags: number, aOpeningTab: (nsIRemoteTab | null), aOpener: (mozIDOMWindowProxy | null), aNextRemoteTabId: number, cancel: Out<boolean>) => (nsIWebBrowserChrome | null);
  }

  export interface nsIAlertNotificationImageListenerRef {
    readonly name: "nsIAlertNotificationImageListener";
    readonly number: "{a71a637d-de1d-47c6-a8d2-c60b2596f471}";
  }

  export interface nsIAlertNotificationImageListener extends nsISupports {

    /**
     * Called when the image finishes loading.
     *
     * @param aUserData An opaque parameter passed to |loadImage|.
     * @param aRequest  The image request.
     */
    readonly onImageReady: (aUserData: (nsISupports | null), aRequest: (imgIRequest | null)) => void;

    /**
     * Called if the alert doesn't have an image, or if the image request times
     * out or fails.
     *
     * @param aUserData An opaque parameter passed to |loadImage|.
     */
    readonly onImageMissing: (aUserData: (nsISupports | null)) => void;
  }

  export interface nsIQuotaUsageResultRef {
    readonly name: "nsIQuotaUsageResult";
    readonly number: "{d8c9328b-9aa8-4f5d-90e6-482de4a6d5b8}";
  }

  export interface nsIQuotaUsageResult extends nsISupports {

    readonly origin: IDLACString;

    readonly persisted: boolean;

    readonly usage: number;

    readonly lastAccessed: number;
  }

  export interface nsIWebBrowserPersistRef {
    readonly name: "nsIWebBrowserPersist";
    readonly number: "{8cd752a4-60b1-42c3-a819-65c7a1138a28}";

    /** No special persistence behaviour. */
    PERSIST_FLAGS_NONE: 0;

    /** Use cached data if present (skipping validation), else load from network */
    PERSIST_FLAGS_FROM_CACHE: 1;

    /** Bypass the cached data. */
    PERSIST_FLAGS_BYPASS_CACHE: 2;

    /** Ignore any redirected data (usually adverts). */
    PERSIST_FLAGS_IGNORE_REDIRECTED_DATA: 4;

    /** Ignore IFRAME content (usually adverts). */
    PERSIST_FLAGS_IGNORE_IFRAMES: 8;

    /** Do not run the incoming data through a content converter e.g. to decompress it */
    PERSIST_FLAGS_NO_CONVERSION: 16;

    /** Replace existing files on the disk (use with due diligence!) */
    PERSIST_FLAGS_REPLACE_EXISTING_FILES: 32;

    /** Don't modify or add base tags */
    PERSIST_FLAGS_NO_BASE_TAG_MODIFICATIONS: 64;

    /** Make changes to original dom rather than cloning nodes */
    PERSIST_FLAGS_FIXUP_ORIGINAL_DOM: 128;

    /** Fix links relative to destination location (not origin) */
    PERSIST_FLAGS_FIXUP_LINKS_TO_DESTINATION: 256;

    /** Don't make any adjustments to links */
    PERSIST_FLAGS_DONT_FIXUP_LINKS: 512;

    /** Force serialization of output (one file at a time; not concurrent) */
    PERSIST_FLAGS_SERIALIZE_OUTPUT: 1024;

    /** Don't make any adjustments to filenames */
    PERSIST_FLAGS_DONT_CHANGE_FILENAMES: 2048;

    /** Fail on broken inline links */
    PERSIST_FLAGS_FAIL_ON_BROKEN_LINKS: 4096;

    /**
     * Automatically cleanup after a failed or cancelled operation, deleting all
     * created files and directories. This flag does nothing for failed upload
     * operations to remote servers.
     */
    PERSIST_FLAGS_CLEANUP_ON_FAILURE: 8192;

    /**
     * Let the WebBrowserPersist decide whether the incoming data is encoded
     * and whether it needs to go through a content converter e.g. to
     * decompress it.
     */
    PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION: 16384;

    /**
     * Append the downloaded data to the target file.
     * This can only be used when persisting to a local file.
     */
    PERSIST_FLAGS_APPEND_TO_FILE: 32768;

    /** Persister is ready to save data */
    PERSIST_STATE_READY: 1;

    /** Persister is saving data */
    PERSIST_STATE_SAVING: 2;

    /** Persister has finished saving data */
    PERSIST_STATE_FINISHED: 3;

    /** Output only the current selection as opposed to the whole document. */
    ENCODE_FLAGS_SELECTION_ONLY: 1;

    /**
     * For plaintext output. Convert html to plaintext that looks like the html.
     * Implies wrap (except inside &lt;pre&gt;), since html wraps.
     * HTML output: always do prettyprinting, ignoring existing formatting.
     */
    ENCODE_FLAGS_FORMATTED: 2;

    /**
     * Output without formatting or wrapping the content. This flag
     * may be used to preserve the original formatting as much as possible.
     */
    ENCODE_FLAGS_RAW: 4;

    /** Output only the body section, no HTML tags. */
    ENCODE_FLAGS_BODY_ONLY: 8;

    /** Wrap even if when not doing formatted output (e.g. for text fields). */
    ENCODE_FLAGS_PREFORMATTED: 16;

    /** Wrap documents at the specified column. */
    ENCODE_FLAGS_WRAP: 32;

    /**
     * For plaintext output. Output for format flowed (RFC 2646). This is used
     * when converting to text for mail sending. This differs just slightly
     * but in an important way from normal formatted, and that is that
     * lines are space stuffed. This can't (correctly) be done later.
     */
    ENCODE_FLAGS_FORMAT_FLOWED: 64;

    /** Convert links to absolute links where possible. */
    ENCODE_FLAGS_ABSOLUTE_LINKS: 128;

    /**
     * Output with carriage return line breaks. May also be combined with
     * ENCODE_FLAGS_LF_LINEBREAKS and if neither is specified, the platform
     * default format is used.
     */
    ENCODE_FLAGS_CR_LINEBREAKS: 512;

    /**
     * Output with linefeed line breaks. May also be combined with
     * ENCODE_FLAGS_CR_LINEBREAKS and if neither is specified, the platform
     * default format is used.
     */
    ENCODE_FLAGS_LF_LINEBREAKS: 1024;

    /** For plaintext output. Output the content of noscript elements. */
    ENCODE_FLAGS_NOSCRIPT_CONTENT: 2048;

    /** For plaintext output. Output the content of noframes elements. */
    ENCODE_FLAGS_NOFRAMES_CONTENT: 4096;

    /**
     * Encode basic entities, e.g. output &nbsp; instead of character code 0xa0.
     * The basic set is just &nbsp; &amp; &lt; &gt; &quot; for interoperability
     * with older products that don't support &alpha; and friends.
     */
    ENCODE_FLAGS_ENCODE_BASIC_ENTITIES: 8192;
  }

  /**
   * Interface for persisting DOM documents and URIs to local or remote storage.
   */
  export interface nsIWebBrowserPersist extends nsICancelable {

    /**
     * Flags governing how data is fetched and saved from the network.
     * It is best to set this value explicitly unless you are prepared
     * to accept the default values.
     */
    persistFlags: number;

    /**
     * Current state of the persister object.
     */
    readonly currentState: number;

    /**
     * Value indicating the success or failure of the persist
     * operation.
     *
     * @throws NS_BINDING_ABORTED Operation cancelled.
     * @throws NS_ERROR_FAILURE Non-specific failure.
     */
    readonly result: number;

    /**
     * Callback listener for progress notifications. The object that the
     * embbedder supplies may also implement nsIInterfaceRequestor and be
     * prepared to return nsIAuthPrompt or other interfaces that may be required
     * to download data.
     *
     * @see nsIAuthPrompt
     * @see nsIInterfaceRequestor
     */
    progressListener: (nsIWebProgressListener | null);

    /**
     * Save the specified URI to file.
     *
     * @param aURI       URI to save to file. Some implementations of this interface
     *                   may also support <CODE>nullptr</CODE> to imply the currently
     *                   loaded URI.
     * @param aTriggeringPrincipal
     *                   The triggering principal for the URI we're saving.
     * @param aCacheKey  The necko cache key integer.
     * @param aReferrerInfo  The referrer info for compute and send referrer via
     *                   HTTP Referer header.
     * @param aPostData  Post data to pass with an HTTP request or
     *                   <CODE>nullptr</CODE>.
     * @param aExtraHeaders Additional headers to supply with an HTTP request
     *                   or <CODE>nullptr</CODE>.
     * @param aFile      Target file. This may be a nsIFile object or an
     *                   nsIURI object with a file scheme or a scheme that
     *                   supports uploading (e.g. ftp).
     * @param aPrivacyContext A context from which the privacy status of this
     *                   save operation can be determined. Must only be null
     *                   in situations in which no such context is available
     *                   (eg. the operation has no logical association with any
     *                   window or document)
     *
     * @see nsIFile
     * @see nsIURI
     * @see nsIInputStream
     *
     * @throws NS_ERROR_INVALID_ARG One or more arguments was invalid.
     */
    readonly saveURI: (aURI: (nsIURI | null), aTriggeringPrincipal: (nsIPrincipal | null), aCacheKey: number, aReferrerInfo: (nsIReferrerInfo | null), aPostData: (nsIInputStream | null), aExtraHeaders: string, aFile: (nsISupports | null), aPrivacyContext: (nsILoadContext | null)) => void;

    /**
     * @param aIsPrivate Treat the save operation as private (ie. with
     *                   regards to networking operations and persistence
     *                   of intermediate data, etc.)
     * @see saveURI for all other parameter descriptions
     */
    readonly savePrivacyAwareURI: (aURI: (nsIURI | null), aTriggeringPrincipal: (nsIPrincipal | null), aCacheKey: number, aReferrerInfo: (nsIReferrerInfo | null), aPostData: (nsIInputStream | null), aExtraHeaders: string, aFile: (nsISupports | null), aIsPrivate: boolean) => void;

    /**
     * Save a channel to a file. It must not be opened yet.
     * @see saveURI
     */
    readonly saveChannel: (aChannel: (nsIChannel | null), aFile: (nsISupports | null)) => void;

    /**
     * Save the specified DOM document to file and optionally all linked files
     * (e.g. images, CSS, JS & subframes). Do not call this method until the
     * document has finished loading!
     *
     * @param aDocument          Document to save to file. Some implementations of
     *                           this interface may also support <CODE>nullptr</CODE>
     *                           to imply the currently loaded document.  Can be an
     *                           nsIWebBrowserPersistDocument or Document.
     * @param aFile              Target local file. This may be a nsIFile object or an
     *                           nsIURI object with a file scheme or a scheme that
     *                           supports uploading (e.g. ftp).
     * @param aDataPath          Path to directory where URIs linked to the document
     *                           are saved or nullptr if no linked URIs should be saved.
     *                           This may be a nsIFile object or an nsIURI object
     *                           with a file scheme.
     * @param aOutputContentType The desired MIME type format to save the
     *                           document and all subdocuments into or nullptr to use
     *                           the default behaviour.
     * @param aEncodingFlags     Flags to pass to the encoder.
     * @param aWrapColumn        For text documents, indicates the desired width to
     *                           wrap text at. Parameter is ignored if wrapping is not
     *                           specified by the encoding flags.
     *
     * @see nsIWebBrowserPersistDocument
     * @see WebBrowserPersistable
     * @see nsIFile
     * @see nsIURI
     *
     * @throws NS_ERROR_INVALID_ARG One or more arguments was invalid.
     */
    readonly saveDocument: (aDocument: (nsISupports | null), aFile: (nsISupports | null), aDataPath: (nsISupports | null), aOutputContentType: string, aEncodingFlags: number, aWrapColumn: number) => void;

    /**
     * Cancels the current operation. The caller is responsible for cleaning up
     * partially written files or directories. This has the same effect as calling
     * cancel with an argument of NS_BINDING_ABORTED.
     */
    readonly cancelSave: () => void;
  }

  export interface nsIConverterOutputStreamRef {
    readonly name: "nsIConverterOutputStream";
    readonly number: "{4b71113a-cb0d-479f-8ed5-01daeba2e8d4}";
  }

  /**
   * This interface allows writing strings to a stream, doing automatic
   * character encoding conversion.
   */
  export interface nsIConverterOutputStream extends nsIUnicharOutputStream {

    /**
     * Initialize this stream. Must be called before any other method on this
     * interface, or you will crash. The output stream passed to this method
     * must not be null, or you will crash.
     *
     * @param aOutStream
     *        The underlying output stream to which the converted strings will
     *        be written.
     * @param aCharset
     *        The character set to use for encoding the characters. A null
     *        charset will be interpreted as UTF-8.
     */
    readonly init: (aOutStream: (nsIOutputStream | null), aCharset: string) => void;
  }

  export interface nsIDOMChromeWindowRef {
    readonly name: "nsIDOMChromeWindow";
    readonly number: "{78bdcb41-1efa-409f-aaba-70842213f80f}";
  }

  export interface nsIDOMChromeWindow extends nsISupports {
  }

  export interface nsIToolkitChromeRegistryRef {
    readonly name: "nsIToolkitChromeRegistry";
    readonly number: "{8727651c-9530-45a0-b81e-0e0690c30c50}";
  }

  export interface nsIToolkitChromeRegistry extends nsIXULChromeRegistry {

    /**
     * Get a list of locales available for the specified package.
     */
    readonly getLocalesForPackage: (aPackage: IDLAUTF8String) => (nsIUTF8StringEnumerator | null);
  }

  export interface nsIRandomGeneratorRef {
    readonly name: "nsIRandomGenerator";
    readonly number: "{2362d97a-747a-4576-8863-697667309209}";
  }

  /**
   * Interface used to generate random data.
   *
   * @threadsafe
   */
  export interface nsIRandomGenerator extends nsISupports {

    /**
     * Generates the specified amount of random bytes.
     *
     * @param aLength
     *        The length of the data to generate.
     * @param aBuffer
     *        A buffer that contains random bytes of size aLength.
     */
    readonly generateRandomBytes: (aLength: number) => number[];
  }

  export interface nsIRaceCacheWithNetworkRef {
    readonly name: "nsIRaceCacheWithNetwork";
    readonly number: "{4d963475-8b16-4c58-b804-8a23d49436c5}";
  }

  /**
   * This holds methods used to race the cache with the network for a specific
   * channel. This interface is was designed with nsHttpChannel in mind, and it's
   * expected this will be the only class implementing it.
   */
  export interface nsIRaceCacheWithNetwork extends nsISupports {

    /****************************************************************************
       * TEST ONLY: The following methods are for testing purposes only. Do not use
       * them to do anything important in your code.
       ****************************************************************************

      /**
       * Triggers network activity after given timeout. If timeout is 0, network
       * activity is triggered immediately. If the cache.asyncOpenURI callbacks
       * have already been called, the network activity may have already been triggered
       * or the content may have already been delivered from the cache, so this
       * operation will have no effect.
       *
       * @param timeout
       *        - the delay in milliseconds until the network will be triggered.
       */
    readonly test_triggerNetwork: (timeout: number) => void;

    /**
     * Normally a HTTP channel would immediately call AsyncOpenURI leading to the
     * cache storage to lookup the cache entry and return it. In order to
     * simmulate real life conditions where fetching a cache entry takes a long
     * time, we set a timer to delay the operation.
     * Can only be called on the main thread.
     *
     * @param timeout
     *        - the delay in milliseconds until the cache open will be triggered.
     */
    readonly test_delayCacheEntryOpeningBy: (timeout: number) => void;

    /**
     * Immediatelly triggers AsyncOpenURI if the timer hasn't fired.
     * Can only be called on the main thread.
     * This is only called in tests to reliably trigger the opening of the cache
     * entry.
     * @throws NS_ERROR_NOT_AVAILABLE if opening the cache wasn't delayed.
     */
    readonly test_triggerDelayedOpenCacheEntry: () => void;
  }

  export interface nsISocketProviderRef {
    readonly name: "nsISocketProvider";
    readonly number: "{508d5469-9e1e-4a08-b5b0-7cfebba1e51a}";

    /**
     * PROXY_RESOLVES_HOST
     *
     * This flag is set if the proxy is to perform hostname resolution instead
     * of the client.  When set, the hostname parameter passed when in this
     * interface will be used instead of the address structure passed for a
     * later connect et al. request.
     */
    PROXY_RESOLVES_HOST: 1;

    /**
     * When setting this flag, the socket will not apply any
     * credentials when establishing a connection. For example,
     * an SSL connection would not send any client-certificates
     * if this flag is set.
     */
    ANONYMOUS_CONNECT: 2;

    /**
     * If set, indicates that the connection was initiated from a source
     * defined as being private in the sense of Private Browsing. Generally,
     * there should be no state shared between connections that are private
     * and those that are not; it is OK for multiple private connections
     * to share state with each other, and it is OK for multiple non-private
     * connections to share state with each other.
     */
    NO_PERMANENT_STORAGE: 4;

    /**
     * If set, do not use newer protocol features that might have interop problems
     * on the Internet. Intended only for use with critical infra like the updater.
     * default is false.
     */
    BE_CONSERVATIVE: 8;
  }

  /**
   * nsISocketProvider
   */
  export interface nsISocketProvider extends nsISupports {
  }

  export interface mozIStorageServiceRef {
    readonly name: "mozIStorageService";
    readonly number: "{07b6b2f5-6d97-47b4-9584-e65bc467fe9e}";
  }

  /**
   * The mozIStorageService interface is intended to be implemented by
   * a service that can create storage connections (mozIStorageConnection)
   * to either a well-known profile database or to a specific database file.
   *
   * This is the only way to open a database connection.
   *
   * @note The first reference to mozIStorageService must be made on the main
   * thread.
   */
  export interface mozIStorageService extends nsISupports {

    /**
     * Open an asynchronous connection to a database.
     *
     * This method MUST be called from the main thread. The connection object
     * returned by this function is not threadsafe. You MUST use it only from
     * the main thread.
     *
     * If you have more than one connection to a file, you MUST use the EXACT
     * SAME NAME for the file each time, including case. The sqlite code uses
     * a simple string compare to see if there is already a connection. Opening
     * a connection to "Foo.sqlite" and "foo.sqlite" will CORRUPT YOUR DATABASE.
     *
     * @param aDatabaseStore Either a nsIFile representing the file that contains
     * the database or a special string to open a special database. The special
     * string may be:
     * - "memory" to open an in-memory database.
     *
     * @param aOptions A set of options (may be null). Options may contain:
     * - bool shared (defaults to |false|).
     *   -- If |true|, opens the database with a shared-cache. The
     *     shared-cache mode is more memory-efficient when many
     *     connections to the same database are expected, though, the
     *     connections will contend the cache resource. In any cases
     *     where performance matter, working without a shared-cache will
     *     improve concurrency.  @see openUnsharedDatabase
     *
     * - int growthIncrement (defaults to none).
     *   -- Set the growth increment for the main database.  This hints SQLite to
     *      grow the database file by a given chunk size and may reduce
     *      filesystem fragmentation on large databases.
     *      @see mozIStorageConnection::setGrowthIncrement
     *
     * @param aCallback A callback that will receive the result of the operation.
     *  In case of error, it may receive as status:
     *  - NS_ERROR_OUT_OF_MEMORY if allocating a new storage object fails.
     *  - NS_ERROR_FILE_CORRUPTED if the database file is corrupted.
     *  In case of success, it receives as argument the new database
     *  connection, as an instance of |mozIStorageAsyncConnection|.
     *
     * @throws NS_ERROR_INVALID_ARG if |aDatabaseStore| is neither a file nor
     *         one of the special strings understood by this method, or if one of
     *         the options passed through |aOptions| does not have the right type.
     * @throws NS_ERROR_NOT_SAME_THREAD if called from a thread other than the
     *         main thread.
     */
    readonly openAsyncDatabase: (aDatabaseStore: (nsIVariant | null), aOptions?: (nsIPropertyBag2 | null), aCallback?: (mozIStorageCompletionCallback | mozIStorageCompletionCallbackFunction | null)) => void;

    /**
     * Get a connection to a named special database storage.
     *
     * @param aStorageKey a string key identifying the type of storage
     * requested.  Valid values include: "memory".
     *
     * @see openDatabase for restrictions on how database connections may be
     * used. For the profile database, you should only access it from the main
     * thread since other callers may also have connections.
     *
     * @returns a new mozIStorageConnection for the requested
     * storage database.
     *
     * @throws NS_ERROR_INVALID_ARG if aStorageKey is invalid.
     */
    readonly openSpecialDatabase: (aStorageKey: string) => (mozIStorageConnection | null);

    /**
     * Open a connection to the specified file.
     *
     * Consumers should check mozIStorageConnection::connectionReady to ensure
     * that they can use the database.  If this value is false, it is strongly
     * recommended that the database be backed up with
     * mozIStorageConnection::backupDB so user data is not lost.
     *
     * ==========
     *   DANGER
     * ==========
     *
     * If you have more than one connection to a file, you MUST use the EXACT
     * SAME NAME for the file each time, including case. The sqlite code uses
     * a simple string compare to see if there is already a connection. Opening
     * a connection to "Foo.sqlite" and "foo.sqlite" will CORRUPT YOUR DATABASE.
     *
     * The connection object returned by this function is not threadsafe. You must
     * use it only from the thread you created it from.
     *
     * @param aDatabaseFile
     *        A nsIFile that represents the database that is to be opened..
     *
     * @returns a mozIStorageConnection for the requested database file.
     *
     * @throws NS_ERROR_OUT_OF_MEMORY
     *         If allocating a new storage object fails.
     * @throws NS_ERROR_FILE_CORRUPTED
     *         If the database file is corrupted.
     */
    readonly openDatabase: (aDatabaseFile: (nsIFile | null)) => (mozIStorageConnection | null);

    /**
     * Open a connection to the specified file that doesn't share a sqlite cache.
     *
     * Without a shared-cache, each connection uses its own pages cache, which
     * may be memory inefficient with a large number of connections, in such a
     * case so you should use openDatabase instead.  On the other side, if cache
     * contention may be an issue, for instance when concurrency is important to
     * ensure responsiveness, using unshared connections may be a performance win.
     *
     * ==========
     *   DANGER
     * ==========
     *
     * If you have more than one connection to a file, you MUST use the EXACT
     * SAME NAME for the file each time, including case. The sqlite code uses
     * a simple string compare to see if there is already a connection. Opening
     * a connection to "Foo.sqlite" and "foo.sqlite" will CORRUPT YOUR DATABASE.
     *
     * The connection object returned by this function is not threadsafe. You must
     * use it only from the thread you created it from.
     *
     * @param aDatabaseFile
     *        A nsIFile that represents the database that is to be opened.
     *
     * @returns a mozIStorageConnection for the requested database file.
     *
     * @throws NS_ERROR_OUT_OF_MEMORY
     *         If allocating a new storage object fails.
     * @throws NS_ERROR_FILE_CORRUPTED
     *         If the database file is corrupted.
     */
    readonly openUnsharedDatabase: (aDatabaseFile: (nsIFile | null)) => (mozIStorageConnection | null);

    /**
     * See openDatabase(). Exactly the same only initialized with a file URL.
     * Custom parameters can be passed to SQLite and VFS implementations through
     * the query part of the URL.
     *
     * @param aURL
     *        A nsIFileURL that represents the database that is to be opened.
     */
    readonly openDatabaseWithFileURL: (aFileURL: (nsIFileURL | null)) => (mozIStorageConnection | null);

    /**
     * Copies the specified database file to the specified parent directory with
     * the specified file name.  If the parent directory is not specified, it
     * places the backup in the same directory as the current file.  This function
     * ensures that the file being created is unique.
     *
     * @param aDBFile
     *        The database file that will be backed up.
     * @param aBackupFileName
     *        The name of the new backup file to create.
     * @param [optional] aBackupParentDirectory
     *        The directory you'd like the backup file to be placed.
     * @return The nsIFile representing the backup file.
     */
    readonly backupDatabaseFile: (aDBFile: (nsIFile | null), aBackupFileName: IDLAString, aBackupParentDirectory?: (nsIFile | null)) => (nsIFile | null);
  }

  export interface nsIFileURLMutatorRef {
    readonly name: "nsIFileURLMutator";
    readonly number: "{a588b6f2-d2b9-4024-84c7-be3368546b57}";
  }

  export interface nsIFileURLMutator extends nsISupports {
  }

  export interface nsICryptoHashRef {
    readonly name: "nsICryptoHash";
    readonly number: "{1e5b7c43-4688-45ce-92e1-77ed931e3bbe}";

    /**
     * Hashing Algorithms.  These values are to be used by the
     * |init| method to indicate which hashing function to
     * use.  These values must be identical to the values defined
     * in security/nss/lib/util/hasht.h in type HASH_HashType.
     * This allows us to use NSS mapping functions like
     * HASH_GetHashOidTagByHashType with these values.
     */
    MD5: 2;

    SHA1: 3;

    SHA256: 4;

    SHA384: 5;

    SHA512: 6;
  }

  /**
   * nsICryptoHash
   * This interface provides crytographic hashing algorithms.
   */
  export interface nsICryptoHash extends nsISupports {

    /**
     * Initialize the hashing object. This method may be
     * called multiple times with different algorithm types.
     *
     * @param aAlgorithm the algorithm type to be used.
     *        This value must be one of the above valid
     *        algorithm types.
     *
     * @throws NS_ERROR_INVALID_ARG if an unsupported algorithm
     *         type is passed.
     *
     * NOTE: This method or initWithString must be called
     *       before any other method on this interface is called.
     */
    readonly init: (aAlgorithm: number) => void;

    /**
     * Initialize the hashing object. This method may be
     * called multiple times with different algorithm types.
     *
     * @param aAlgorithm the algorithm type to be used.
     *
     * @throws NS_ERROR_INVALID_ARG if an unsupported algorithm
     *         type is passed.
     *
     * NOTE: This method or init must be called before any
     *       other method on this interface is called.
     */
    readonly initWithString: (aAlgorithm: IDLACString) => void;

    /**
     * @param aData a buffer to calculate the hash over
     *
     * @param aLen the length of the buffer |aData|
     *
     * @throws NS_ERROR_NOT_INITIALIZED If |init| has not been called.
     */
    readonly update: (aData: number[], aLen: number) => void;

    /**
     * Calculates and updates a new hash based on a given data stream.
     *
     * @param aStream an input stream to read from.
     *
     * @param aLen How much to read from the given |aStream|. Passing UINT32_MAX
     *        indicates that all data available will be used to update the hash.
     *
     * @throws NS_ERROR_NOT_INITIALIZED If |init| has not been called.
     *
     * @throws NS_ERROR_NOT_AVAILABLE If the requested amount of
     *         data to be calculated into the hash is not available.
     *
     */
    readonly updateFromStream: (aStream: (nsIInputStream | null), aLen: number) => void;

    /**
     * Completes this hash object and produces the actual hash data.
     *
     * @param aASCII If true then the returned value is a base64 encoded string.
     *        If false, then the returned value is binary data.
     *
     * @return a hash of the data that was read by this object.  This can
     *         be either binary data or base 64 encoded.
     *
     * @throws NS_ERROR_NOT_INITIALIZED If |init| has not been called.
     *
     * NOTE: This method may be called any time after |init|
     *       is called.  This call resets the object to its
     *       pre-init state.
     */
    readonly finish: (aASCII: boolean) => IDLACString;
  }

  export interface nsIDOMXULRelatedElementRef {
    readonly name: "nsIDOMXULRelatedElement";
    readonly number: "{9fbac05a-fb27-470d-8e5f-028b2dc54ad0}";
  }

  export interface nsIDOMXULRelatedElement extends nsISupports {

    /**
     * Retrun an element associated with the given element. It's implemented
     * by container elements having relation between their items. For example,
     * this interface is implemented by XUL tabs and XUL tabpanels elements
     * and used to get XUL tab element by linked tab panel and vice versa.
     */
    readonly getRelatedElement: (aElement: WebIDL.Node) => WebIDL.Element;
  }

  export interface nsINavHistoryResultRef {
    readonly name: "nsINavHistoryResult";
    readonly number: "{c2229ce3-2159-4001-859c-7013c52f7619}";
  }

  export interface nsINavHistoryResult extends nsISupports {

    /**
     * The result of a history/bookmark query.
     */
    /**
     * Sorts all nodes recursively by the given parameter, one of
     * nsINavHistoryQueryOptions.SORT_BY_*  This will update the corresponding
     * options for this result, so that re-using the current options/queries will
     * always give you the current view.
     */
    sortingMode: number;

    /**
     * Whether or not notifications on result changes are suppressed.
     * Initially set to false.
     *
     * Use this to avoid flickering and to improve performance when you
     * do temporary changes to the result structure (e.g. when searching for a
     * node recursively).
     */
    suppressNotifications: boolean;

    /**
     * Adds an observer for changes done in the result.
     *
     * @param aObserver
     *        a result observer.
     * @param aOwnsWeak
     *        If false, the result will keep an owning reference to the observer,
     *        which must be removed using removeObserver.
     *        If true, the result will keep a weak reference to the observer, which
     *        must implement nsISupportsWeakReference.
     *
     * @see nsINavHistoryResultObserver
     */
    readonly addObserver: (aObserver: (nsINavHistoryResultObserver | null), aOwnsWeak?: boolean) => void;

    /**
     * Removes an observer that was added by addObserver.
     *
     * @param aObserver
     *        a result observer that was added by addObserver.
     */
    readonly removeObserver: (aObserver: (nsINavHistoryResultObserver | null)) => void;

    /**
     * This is the root of the results. Remember that you need to open all
     * containers for their contents to be valid.
     *
     * When a result goes out of scope it will continue to observe changes till
     * it is cycle collected.  While the result waits to be collected it will stay
     * in memory, and continue to update itself, potentially causing unwanted
     * additional work.  When you close the root node the result will stop
     * observing changes, so it is good practice to close the root node when you
     * are done with a result, since that will avoid unwanted performance hits.
     */
    readonly root: (nsINavHistoryContainerResultNode | null);
  }

  export interface nsIAlertsServiceRef {
    readonly name: "nsIAlertsService";
    readonly number: "{f7a36392-d98b-4141-a7d7-4e46642684e3}";
  }

  export interface nsIAlertsService extends nsISupports {

    readonly showPersistentNotification: (aPersistentData: IDLAString, aAlert: (nsIAlertNotification | null), aAlertListener?: (nsIObserver | nsIObserverFunction | null)) => void;

    readonly showAlert: (aAlert: (nsIAlertNotification | null), aAlertListener?: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * Initializes and shows an |nsIAlertNotification| with the given parameters.
     *
     * @param aAlertListener Used for callbacks. May be null if the caller
     *                       doesn't care about callbacks.
     * @see nsIAlertNotification for descriptions of all other parameters.
     * @throws NS_ERROR_NOT_AVAILABLE If the notification cannot be displayed.
     *
     * The following arguments will be passed to the alertListener's observe()
     * method:
     *   subject - null
     *   topic   - "alertfinished" when the alert goes away
     *             "alertdisablecallback" when alerts should be disabled for the principal
     *             "alertsettingscallback" when alert settings should be opened
     *             "alertclickcallback" when the text is clicked
     *             "alertshow" when the alert is shown
     *   data    - the value of the cookie parameter passed to showAlertNotification.
     *
     * @note Depending on current circumstances (if the user's in a fullscreen
     *       application, for instance), the alert might not be displayed at all.
     *       In that case, if an alert listener is passed in it will receive the
     *       "alertfinished" notification immediately.
     */
    readonly showAlertNotification: (aImageURL: IDLAString, aTitle: IDLAString, aText: IDLAString, aTextClickable?: boolean, aCookie?: IDLAString, aAlertListener?: (nsIObserver | nsIObserverFunction | null), aName?: IDLAString, aDir?: IDLAString, aLang?: IDLAString, aData?: IDLAString, aPrincipal?: (nsIPrincipal | null), aInPrivateBrowsing?: boolean, aRequireInteraction?: boolean) => void;

    /**
     * Close alerts created by the service.
     *
     * @param aName          The name of the notification to close. If no name
     *                       is provided then only a notification created with
     *                       no name (if any) will be closed.
     */
    readonly closeAlert: (aName?: IDLAString, aPrincipal?: (nsIPrincipal | null)) => void;
  }

  export interface nsIHangDetailsRef {
    readonly name: "nsIHangDetails";
    readonly number: "{23d63fff-38d6-4003-9c57-2c90aca1180a}";
  }

  /**
   * A scriptable interface for getting information about a BHR detected hang.
   * This is the type of the subject of the "bhr-thread-hang" observer topic.
   */
  export interface nsIHangDetails extends nsISupports {

    /**
     * The hang was persisted to disk as a permahang, so we can clear the
     * permahang file once we submit this.
     */
    readonly wasPersisted: boolean;

    /**
     * The detected duration of the hang in milliseconds.
     */
    readonly duration: number;

    /**
     * The name of the thread which hung.
     */
    readonly thread: IDLACString;

    /**
     * The name of the runnable which hung if it hung on the main thread.
     */
    readonly runnableName: IDLACString;

    /**
     * The type of process which produced the hang. This should be either:
     * "default", "content", or "gpu".
     */
    readonly process: IDLACString;

    /**
     * The remote type of the content process which produced the hang.
     */
    readonly remoteType: IDLAString;

    /**
     * Returns the stack which was captured by BHR. The offset is encoded as a hex
     * string, as it can contain numbers larger than JS can hold losslessly.
     *
     * This value takes the following form:
     * [ [moduleIndex, offset], ... ]
     */
    readonly stack: IDLjsval;

    /**
     * Returns the modules which were captured by BHR.
     *
     * This value takes the following form:
     * [ ["fileName", "BreakpadId"], ... ]
     */
    readonly modules: IDLjsval;

    /**
     * The hang annotations which were captured when the hang occured. This
     * attribute is a JS object of key-value pairs.
     */
    readonly annotations: IDLjsval;
  }

  export interface nsIBrowserChildRef {
    readonly name: "nsIBrowserChild";
    readonly number: "{1fb79c27-e760-4088-b19c-1ce3673ec24e}";
  }

  export interface nsIBrowserChild extends nsISupports {

    readonly messageManager: WebIDL.ContentFrameMessageManager;

    webBrowserChrome: (nsIWebBrowserChrome3 | null);

    readonly remoteDropLinks: (links: (nsIDroppedLinkItem | null)[]) => void;

    readonly tabId: number;

    hasSiblings: boolean;

    /**
     * Tell the nsIBrowserChild that it should begin sending its nsIWebProgress
     * events to its nsIBrowserParent.
     *
     * This should be called once the frame script for the nsIBrowserChild has
     * loaded.
     */
    readonly beginSendingWebProgressEventsToParent: () => void;

    /**
     * Send a message from the BrowserChild to the BrowserParent that a
     * nsIWebNavigation navigation finished in the child.
     */
    readonly notifyNavigationFinished: () => void;
  }

  export interface nsIApplicationReputationCallbackRef {
    readonly name: "nsIApplicationReputationCallback";
    readonly number: "{9a228470-cfe5-11e2-8b8b-0800200c9a66}";
  }

  type nsIApplicationReputationCallbackFunction = (aShouldBlock: boolean, aStatus: number, aVerdict: number) => void;

  export interface nsIApplicationReputationCallback extends nsISupports {

    /**
     * Callback for the result of the application reputation query.
     * @param aStatus
     *        NS_OK if and only if the query succeeded. If it did, then
     *        shouldBlock is meaningful (otherwise it defaults to false). This
     *        may be NS_ERROR_FAILURE if the response cannot be parsed, or
     *        NS_ERROR_NOT_AVAILABLE if the service has been disabled or is not
     *        reachable.
     * @param aShouldBlock
     *        Whether or not the download should be blocked.
     * @param aVerdict
     *        Indicates the result of the lookup that determines whether the
     *        download should be blocked, according to the "VERDICT_" constants.
     *        This may be set to a value different than "VERDICT_SAFE" even if
     *        aShouldBlock is false, so you should always check aShouldBlock.
     */
    readonly onComplete: (aShouldBlock: boolean, aStatus: number, aVerdict: number) => void;
  }

  export interface nsISupportsPRInt32Ref {
    readonly name: "nsISupportsPRInt32";
    readonly number: "{e36c5250-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for 32-bit integers
   */
  export interface nsISupportsPRInt32 extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsICacheStorageVisitorRef {
    readonly name: "nsICacheStorageVisitor";
    readonly number: "{6cc7c253-93b6-482b-8e9d-1e04d8e9d655}";
  }

  export interface nsICacheStorageVisitor extends nsISupports {

    /**
     */
    readonly onCacheStorageInfo: (aEntryCount: number, aConsumption: number, aCapacity: number, aDiskDirectory: (nsIFile | null)) => void;

    /**
     */
    readonly onCacheEntryInfo: (aURI: (nsIURI | null), aIdEnhance: IDLACString, aDataSize: number, aFetchCount: number, aLastModifiedTime: number, aExpirationTime: number, aPinned: boolean, aInfo: (nsILoadContextInfo | null)) => void;

    /**
     */
    readonly onCacheEntryVisitCompleted: () => void;
  }

  export interface nsITooltipTextProviderRef {
    readonly name: "nsITooltipTextProvider";
    readonly number: "{b128a1e6-44f3-4331-8fbe-5af360ff21ee}";
  }

  /**
   * An interface implemented by a tooltip text provider service. This
   * service is called to discover what tooltip text is associated
   * with the node that the pointer is positioned over.
   *
   * Embedders may implement and register their own tooltip text provider
   * service if they wish to provide different tooltip text.
   *
   * The default service returns the text stored in the TITLE
   * attribute of the node or a containing parent.
   *
   * @note
   * The tooltip text provider service is registered with the contract
   * defined in NS_TOOLTIPTEXTPROVIDER_CONTRACTID.
   *
   * @see nsITooltipListener
   * @see nsIComponentManager
   * @see Node
   */
  export interface nsITooltipTextProvider extends nsISupports {

    /**
     * Called to obtain the tooltip text for a node.
     *
     * @arg aNode      The node to obtain the text from.
     * @arg aText      The tooltip text.
     * @arg aDirection The text direction (ltr or rtl) to use
     *
     * @return <CODE>PR_TRUE</CODE> if tooltip text is associated
     *         with the node and was returned in the aText argument;
     *         <CODE>PR_FALSE</CODE> otherwise.
     */
    readonly getNodeText: (aNode: WebIDL.Node, aText: Out<string>, aDirection: Out<string>) => boolean;
  }

  export interface nsIArrayBufferInputStreamRef {
    readonly name: "nsIArrayBufferInputStream";
    readonly number: "{3014dde6-aa1c-41db-87d0-48764a3710f6}";
  }

  /**
   * nsIArrayBufferInputStream
   *
   * Provides scriptable methods for initializing a nsIInputStream
   * implementation with an ArrayBuffer.
   */
  export interface nsIArrayBufferInputStream extends nsIInputStream {

    /**
     * SetData - assign an ArrayBuffer to the input stream.
     *
     * @param buffer    - stream data
     * @param byteOffset - stream data offset
     * @param byteLen - stream data length
     */
    readonly setData: (buffer: IDLjsval, byteOffset: number, byteLen: number) => void;
  }

  export interface nsIPaymentUIServiceRef {
    readonly name: "nsIPaymentUIService";
    readonly number: "{01f8bd55-9017-438b-85ec-7c15d2b35cdc}";
  }

  /**
   * nsIPaymentUIService is the interface used by Gecko to communicate with the
   * payment UI.
   * In general, the implementation of this interface should be a service that
   * manages all payment UI components and receives the requested payment actions
   * from Gecko and perform the corresponding UI behavior.
   */
  export interface nsIPaymentUIService extends nsISupports {

    /**
     *  Show the payment UI to users.
     *  The implementation gets the payment data through nsIPaymentRequestService
     *  by the passed in requestId, then shows the payment UI and start to interact
     *  with users.
     *  According to user's action, nsIPaymentRequestService's APIs respondPayment,
     *  changeShippingAddress, or changeShippingOtpion is possible to called in the
     *  implementation.
     *  @param requestId - the request identify of the payment request.
     *                     Notice that this requestId is an internal request Id
     *                     generated by Gecko
     */
    readonly showPayment: (requestId: IDLAString) => void;

    /**
     *  Abort the payment.
     *  The implementation must abort and close the showing payment UI then call
     *  nsIPaymentRequestService respondPayment with nsIPaymentAbortActionResponse
     *  to inform Gecko of the abort status.
     *  @param requestId - the request identify of the payment request.
     *                     Notice that this requestId is an internal request Id
     *                     generated by Gecko
     */
    readonly abortPayment: (requestId: IDLAString) => void;

    /**
     *  Complete the payment.
     *  The implementation should close the showing payment UI, then call
     *  nsIPaymentRequestService respondPayment with nsIPaymentCompleteActionResponse
     *  to inform Gecko of the complete status.
     *  @param requestId - the request identify of the payment request.
     *                     Notice that this requestId is an internal request Id
     *                     generated by Gecko
     */
    readonly completePayment: (requestId: IDLAString) => void;

    /**
     *  Update the payment data in the payment UI.
     *  The implementation should get the updated payment data through the
     *  nsIPaymentRequestService again, and update the UI.
     *  @param requestId - the request identify of the payment request.
     *                     Notice that this requestId is an internal request Id
     *                     generated by Gecko
     */
    readonly updatePayment: (requestId: IDLAString) => void;

    /**
     *  Close the payment UI for the specified PaymentRequest.
     *  The implementation should clean up the PaymentRequest data saved in the UI
     *  component and close the UI if the specified PaymentRequest is showing to
     *  the user.
     *  Notice when the method is called, that means the PaymentRequest is invalid
     *  in nsIPaymentRequestService.
     *  @param requestId - the request identify of the payment request.
     *                     Notice that this requestId is an internal request Id
     *                     generated by Gecko
     */
    readonly closePayment: (requestId: IDLAString) => void;
  }

  export interface nsIXPCComponents_InterfacesRef {
    readonly name: "nsIXPCComponents_Interfaces";
    readonly number: "{b8c31bba-79db-4a1d-930d-4cdd68713f9e}";
  }

  /**
   * interface of Components.interfaces
   * (interesting stuff only reflected into JavaScript)
   */
  export interface nsIXPCComponents_Interfaces extends nsISupports {
  }

  export interface nsISystemInfoRef {
    readonly name: "nsISystemInfo";
    readonly number: "{09a0502b-cedc-4cae-bf7c-35662dbd1249}";
  }

  export interface nsISystemInfo extends nsISupports {

    /**
     * Asynchronously get info about what types of disks we're using for the
     * profile and binary.
     * Note: only implemented on Windows, will return null elsewhere.
     */
    readonly diskInfo: IDLPromise;

    /**
     * Asynchronously get CountryCode info.
     * Note: only implemented on macOS and Windows, will return null elsewhere.
     */
    readonly countryCode: IDLPromise;

    /**
     * Asynchronously gets OS info on the system's install year.
     * Note: only implemented on Windows, will return null elsewhere.
     */
    readonly osInfo: IDLPromise;

    /**
     * Asynchronously gets process info that indicates if the process is running
     * under Wow64 and WowARM64.
     * Note: only implemented on Windows, will return null elsewhere.
     */
    readonly processInfo: IDLPromise;
  }

  export interface nsICSPEventListenerRef {
    readonly name: "nsICSPEventListener";
    readonly number: "{c3163b14-3a8f-46dd-a4af-bd04680364cd}";
  }

  type nsICSPEventListenerFunction = (aJSON: IDLAString) => void;

  export interface nsICSPEventListener extends nsISupports {

    readonly onCSPViolationEvent: (aJSON: IDLAString) => void;
  }

  export interface nsIINIParserRef {
    readonly name: "nsIINIParser";
    readonly number: "{7eb955f6-3e78-4d39-b72f-c1bf12a94bce}";
  }

  export interface nsIINIParser extends nsISupports {

    /**
     * Enumerates the [section]s available in the INI file.
     */
    readonly getSections: () => (nsIUTF8StringEnumerator | null);

    /**
     * Enumerates the keys available within a section.
     */
    readonly getKeys: (aSection: IDLAUTF8String) => (nsIUTF8StringEnumerator | null);

    /**
     * Get the value of a string for a particular section and key.
     */
    readonly getString: (aSection: IDLAUTF8String, aKey: IDLAUTF8String) => IDLAUTF8String;
  }

  export interface nsICycleCollectorHandlerRef {
    readonly name: "nsICycleCollectorHandler";
    readonly number: "{7f093367-1492-4b89-87af-c01dbc831246}";
  }

  /**
   * A set of interfaces for recording the cycle collector's work. An instance
   * of nsICycleCollectorListener can be configured to enable various
   * options, then passed to the cycle collector when it runs.
   * Note that additional logging options are available by setting environment
   * variables, as described at the top of nsCycleCollector.cpp.
   */
  /**
   * nsICycleCollectorHandler is the interface JS code should implement to
   * receive the results logged by an nsICycleCollectorListener
   * instance. Pass an instance of this to the logger's 'processNext' method
   * after the collection has run. This will describe the objects the cycle
   * collector visited, the edges it found, and the conclusions it reached
   * about the liveness of objects.
   *
   * In more detail:
   * - For each node in the graph:
   *   - a call is made to either |noteRefCountedObject| or |noteGCedObject|, to
   *     describe the node itself; and
   *   - for each edge starting at that node, a call is made to |noteEdge|.
   *
   * - Then, a series of calls are made to:
   *   - |describeRoot|, for reference-counted nodes that the CC has identified as
   *     being alive because there are unknown references to those nodes.
   *   - |describeGarbage|, for nodes the cycle collector has identified as garbage.
   *
   *   Any node not mentioned in a call to |describeRoot| or |describeGarbage| is
   *   neither a root nor garbage. The cycle collector was able to find all of the
   *   edges implied by the node's reference count.
   */
  export interface nsICycleCollectorHandler extends nsISupports {

    readonly noteRefCountedObject: (aAddress: IDLACString, aRefCount: number, aObjectDescription: IDLACString) => void;

    readonly noteGCedObject: (aAddress: IDLACString, aMarked: boolean, aObjectDescription: IDLACString, aCompartmentAddress: IDLACString) => void;

    readonly noteEdge: (aFromAddress: IDLACString, aToAddress: IDLACString, aEdgeName: IDLACString) => void;

    readonly describeRoot: (aAddress: IDLACString, aKnownEdges: number) => void;

    readonly describeGarbage: (aAddress: IDLACString) => void;
  }

  export interface nsIPrintSettingsRef {
    readonly name: "nsIPrintSettings";
    readonly number: "{ecc5cbad-57fc-4731-b0bd-09e865bd62ad}";

    /**
     * PrintSettings to be Saved Navigation Constants
     */
    kInitSaveOddEvenPages: 1;

    kInitSaveHeaderLeft: 2;

    kInitSaveHeaderCenter: 4;

    kInitSaveHeaderRight: 8;

    kInitSaveFooterLeft: 16;

    kInitSaveFooterCenter: 32;

    kInitSaveFooterRight: 64;

    kInitSaveBGColors: 128;

    kInitSaveBGImages: 256;

    kInitSavePaperSize: 512;

    kInitSaveResolution: 1024;

    kInitSaveDuplex: 2048;

    kInitSavePaperData: 8192;

    kInitSaveUnwriteableMargins: 16384;

    kInitSaveEdges: 32768;

    kInitSaveReversed: 65536;

    kInitSaveInColor: 131072;

    kInitSaveOrientation: 262144;

    kInitSavePrinterName: 1048576;

    kInitSavePrintToFile: 2097152;

    kInitSaveToFileName: 4194304;

    kInitSavePageDelay: 8388608;

    kInitSaveMargins: 16777216;

    kInitSaveNativeData: 33554432;

    kInitSaveShrinkToFit: 134217728;

    kInitSaveScaling: 268435456;

    kInitSaveAll: 4294967295;

    kPrintOddPages: 1;

    kPrintEvenPages: 2;

    kEnableSelectionRB: 4;

    kRangeAllPages: 0;

    kRangeSpecifiedPageRange: 1;

    kRangeSelection: 2;

    kJustLeft: 0;

    kJustCenter: 1;

    kJustRight: 2;

    /**
     * Page Size Type Constants
     */
    kPaperSizeNativeData: 0;

    kPaperSizeDefined: 1;

    /**
     * Page Size Unit Constants
     */
    kPaperSizeInches: 0;

    kPaperSizeMillimeters: 1;

    /**
     * Orientation Constants
     */
    kPortraitOrientation: 0;

    kLandscapeOrientation: 1;

    /**
     * Output file format
     */
    kOutputFormatNative: 0;

    kOutputFormatPS: 1;

    kOutputFormatPDF: 2;
  }

  /**
   * Simplified graphics interface for JS rendering.
   */
  export interface nsIPrintSettings extends nsISupports {

    /**
     * Set PrintOptions
     */
    readonly SetPrintOptions: (aType: number, aTurnOnOff: boolean) => void;

    /**
     * Get PrintOptions
     */
    readonly GetPrintOptions: (aType: number) => boolean;

    /**
     * Get PrintOptions Bit field
     */
    readonly GetPrintOptionsBits: () => number;

    /**
     * Set PrintOptions Bit field
     */
    readonly SetPrintOptionsBits: (bits: number) => void;

    /**
     * Get the page size in twips, considering the
     * orientation (portrait or landscape).
     */
    readonly GetEffectivePageSize: (aWidth: Out<number>, aHeight: Out<number>) => void;

    /**
     * Makes a new copy
     */
    readonly clone: () => (nsIPrintSettings | null);

    /**
     * Assigns the internal values from the "in" arg to the current object
     */
    readonly assign: (aPS: (nsIPrintSettings | null)) => void;

    startPageRange: number;

    endPageRange: number;

    /**
     * The edge measurements define the positioning of the headers
     * and footers on the page. They're measured as an offset from
     * the "unwriteable margin" (described below).
     */
    edgeTop: number;

    edgeLeft: number;

    edgeBottom: number;

    edgeRight: number;

    /**
     * The margins define the positioning of the content on the page.
     * They're treated as an offset from the "unwriteable margin"
     * (described below).
     */
    marginTop: number;

    marginLeft: number;

    marginBottom: number;

    marginRight: number;

    /**
     * The unwriteable margin defines the printable region of the paper, creating
     * an invisible border from which the edge and margin attributes are measured.
     */
    unwriteableMarginTop: number;

    unwriteableMarginLeft: number;

    unwriteableMarginBottom: number;

    unwriteableMarginRight: number;

    scaling: number;

    printBGColors: boolean;

    printBGImages: boolean;

    printRange: number;

    title: IDLAString;

    docURL: IDLAString;

    headerStrLeft: IDLAString;

    headerStrCenter: IDLAString;

    headerStrRight: IDLAString;

    footerStrLeft: IDLAString;

    footerStrCenter: IDLAString;

    footerStrRight: IDLAString;

    isCancelled: boolean;

    readonly saveOnCancel: boolean;

    printSilent: boolean;

    shrinkToFit: boolean;

    showPrintProgress: boolean;

    paperName: IDLAString;

    paperData: number;

    paperWidth: number;

    paperHeight: number;

    paperSizeUnit: number;

    printReversed: boolean;

    printInColor: boolean;

    orientation: number;

    numCopies: number;

    printerName: IDLAString;

    printToFile: boolean;

    toFileName: IDLAString;

    outputFormat: number;

    printPageDelay: number;

    resolution: number;

    duplex: number;

    /**
     * This attribute tracks whether the PS has been initialized
     * from a printer specified by the "printerName" attr.
     * If a different name is set into the "printerName"
     * attribute than the one it was initialized with the PS
     * will then get intialized from that printer.
     */
    isInitializedFromPrinter: boolean;

    /**
     * This attribute tracks whether the PS has been initialized
     * from prefs. If a different name is set into the "printerName"
     * attribute than the one it was initialized with the PS
     * will then get intialized from prefs again.
     */
    isInitializedFromPrefs: boolean;
  }

  export interface nsIControllerCommandRef {
    readonly name: "nsIControllerCommand";
    readonly number: "{0eae9a46-1dd2-11b2-aca0-9176f05fe9db}";
  }

  /**
   * nsIControllerCommand
   *
   * A generic command interface. You can register an nsIControllerCommand
   * with the nsIControllerCommandTable.
   */
  export interface nsIControllerCommand extends nsISupports {

    /**
     * Returns true if the command is currently enabled. An nsIControllerCommand
     * can implement more than one commands; say, a group of related commands
     * (e.g. delete left/delete right). Because of this, the command name is
     * passed to each method.
     *
     * @param aCommandName  the name of the command for which we want the enabled
     *                      state.
     * @param aCommandContext    a cookie held by the nsIControllerCommandTable,
     *                  allowing the command to get some context information.
     *                  The contents of this cookie are implementation-defined.
     */
    readonly isCommandEnabled: (aCommandName: string, aCommandContext: (nsISupports | null)) => boolean;

    readonly getCommandStateParams: (aCommandName: string, aParams: (nsICommandParams | null), aCommandContext: (nsISupports | null)) => void;

    /**
     * Execute the name command.
     *
     * @param aCommandName  the name of the command to execute.
     *
     * @param aCommandContext    a cookie held by the nsIControllerCommandTable,
     *                  allowing the command to get some context information.
     *                  The contents of this cookie are implementation-defined.
     */
    readonly doCommand: (aCommandName: string, aCommandContext: (nsISupports | null)) => void;

    readonly doCommandParams: (aCommandName: string, aParams: (nsICommandParams | null), aCommandContext: (nsISupports | null)) => void;
  }

  export interface nsIDOMMozBrowserFrameRef {
    readonly name: "nsIDOMMozBrowserFrame";
    readonly number: "{4cafe116-581b-4194-b0de-7f02378fc51d}";
  }

  export interface nsIDOMMozBrowserFrame extends nsISupports {

    /**
     * <iframe> element may have the mozbrowser attribute.
     *
     * The mozbrowser attribute has no effect unless the <iframe> element is
     * contained in a document privileged to create browser frames.
     *
     * An <iframe> element in a privileged document with the mozbrowser attribute
     * emits a variety of events when various things happen inside the frame.
     *
     * This will be documented eventually, but for more information at the moment,
     * see dom/browser-element/BrowserElement{Child,Parent}.js.
     *
     */
    mozbrowser: boolean;
  }

  export interface nsIScreenRef {
    readonly name: "nsIScreen";
    readonly number: "{826e80c8-d70f-42e2-8aa9-82c05f2a370a}";
  }

  export interface nsIScreen extends nsISupports {

    /**
     * These report screen dimensions in (screen-specific) device pixels
     */
    readonly GetRect: (left: Out<number>, top: Out<number>, width: Out<number>, height: Out<number>) => void;

    readonly GetAvailRect: (left: Out<number>, top: Out<number>, width: Out<number>, height: Out<number>) => void;

    /**
     * And these report in desktop pixels
     */
    readonly GetRectDisplayPix: (left: Out<number>, top: Out<number>, width: Out<number>, height: Out<number>) => void;

    readonly GetAvailRectDisplayPix: (left: Out<number>, top: Out<number>, width: Out<number>, height: Out<number>) => void;

    readonly pixelDepth: number;

    readonly colorDepth: number;

    /**
     * The number of device pixels per desktop pixel for this screen (for
     * hidpi configurations where there may be multiple device pixels per
     * desktop px and/or per CSS px).
     *
     * This seems poorly named (something like devicePixelsPerDesktopPixel
     * would be more accurate/explicit), but given that it is exposed to
     * front-end code and may also be used by add-ons, it's probably not
     * worth the disruption of changing it.
     *
     * Returns 1.0 if HiDPI mode is disabled or unsupported, or if the
     * host OS uses device pixels as its desktop pixel units (e.g. Windows 7 or
     * GTK/X11). Per-monitor DPI is available in Windows 8.1+, GTK/Wayland or
     * macOS.
     */
    readonly contentsScaleFactor: number;

    /**
     * The default number of device pixels per unscaled CSS pixel for this
     * screen. This is probably what contentsScaleFactor originally meant
     * to be, prior to confusion between CSS pixels and desktop pixel units.
     */
    readonly defaultCSSScaleFactor: number;

    /**
     * The DPI of the screen.
     */
    readonly dpi: number;
  }

  export interface nsIToolkitShellServiceRef {
    readonly name: "nsIToolkitShellService";
    readonly number: "{9246cad6-926a-4c17-88b0-ecba8078d143}";
  }

  export interface nsIToolkitShellService extends nsISupports {

    /**
     * Determines whether or not this application is the default for the operating
     * system. It is up to the application to determine how to answer this
     * question but it would typically involve checking if it is registered as the
     * default handler for web protocols and/or file types.
     */
    readonly isDefaultApplication: () => boolean;
  }

  export interface nsICookieRef {
    readonly name: "nsICookie";
    readonly number: "{adf0db5e-211e-45a3-be14-4486ac430a58}";

    SAMESITE_NONE: 0;

    SAMESITE_LAX: 1;

    SAMESITE_STRICT: 2;
  }

  export interface nsICookie extends nsISupports {

    /**
     * the name of the cookie
     */
    readonly name: IDLACString;

    /**
     * the cookie value
     */
    readonly value: IDLAUTF8String;

    /**
     * true if the cookie is a domain cookie, false otherwise
     */
    readonly isDomain: boolean;

    /**
     * the host (possibly fully qualified) of the cookie
     */
    readonly host: IDLAUTF8String;

    /**
     * the host (possibly fully qualified) of the cookie,
     * without a leading dot to represent if it is a
     * domain cookie.
     */
    readonly rawHost: IDLAUTF8String;

    /**
     * the path pertaining to the cookie
     */
    readonly path: IDLAUTF8String;

    /**
     * true if the cookie was transmitted over ssl, false otherwise
     */
    readonly isSecure: boolean;

    /**
     * @DEPRECATED use nsICookie.expiry and nsICookie.isSession instead.
     *
     * expiration time in seconds since midnight (00:00:00), January 1, 1970 UTC.
     * expires = 0 represents a session cookie.
     * expires = 1 represents an expiration time earlier than Jan 1, 1970.
     */
    readonly expires: number;

    /**
     * the actual expiry time of the cookie, in seconds
     * since midnight (00:00:00), January 1, 1970 UTC.
     *
     * this is distinct from nsICookie::expires, which
     * has different and obsolete semantics.
     */
    readonly expiry: number;

    /**
     * The origin attributes for this cookie
     */
    readonly originAttributes: IDLjsval;

    /**
     * true if the cookie is a session cookie.
     * note that expiry time will also be honored
     * for session cookies (see below); thus, whichever is
     * the more restrictive of the two will take effect.
     */
    readonly isSession: boolean;

    /**
     * true if the cookie is an http only cookie
     */
    readonly isHttpOnly: boolean;

    /**
     * the creation time of the cookie, in microseconds
     * since midnight (00:00:00), January 1, 1970 UTC.
     */
    readonly creationTime: number;

    /**
     * the last time the cookie was accessed (i.e. created,
     * modified, or read by the server), in microseconds
     * since midnight (00:00:00), January 1, 1970 UTC.
     *
     * note that this time may be approximate.
     */
    readonly lastAccessed: number;

    /**
     * the sameSite attribute; this controls the cookie behavior for cross-site
     * requests as per
     * https://tools.ietf.org/html/draft-west-first-party-cookies-07
     *
     * This should be one of:
     * - SAMESITE_NONE - the SameSite attribute is not present
     * - SAMESITE_LAX - the SameSite attribute is present, but not strict
     * - SAMESITE_STRICT - the SameSite attribute is present and strict
     */
    readonly sameSite: number;
  }

  export interface nsIXREDirProviderRef {
    readonly name: "nsIXREDirProvider";
    readonly number: "{f6ee3c0a-5119-47fc-b1a7-ace9e1111fff}";
  }

  export interface nsIXREDirProvider extends nsISupports {

    /**
     * Only intended to be used from xpcshell tests. Allows setting the local
     * and normal profile data directories. Calling this after something using
     * them has started up will cause problems.
     */
    readonly setUserDataDirectory: (aFile: (nsIFile | null), aLocal: boolean) => void;

    /**
     * Gets the hash for the current installation directory.
     */
    readonly getInstallHash: () => IDLAString;
  }

  export interface nsIContentPolicyRef {
    readonly name: "nsIContentPolicy";
    readonly number: "{caad4f1f-d047-46ac-ae9d-dc598e4fb91b}";

    /**
     * Indicates a unset or bogus policy type.
     */
    TYPE_INVALID: 0;

    /**
     * Gecko/Firefox developers: Avoid using TYPE_OTHER. Especially for
     * requests that are coming from webpages. Or requests in general which
     * you expect that security checks will be done on.
     * Always use a more specific type if one is available. And do not hesitate
     * to add more types as appropriate.
     * But if you are fairly sure that no one would care about your more specific
     * type, then it's ok to use TYPE_OTHER.
     *
     * Extension developers: Whenever it is reasonable, use one of the existing
     * content types. If none of the existing content types are right for
     * something you are doing, file a bug in the Core/DOM component that
     * includes a patch that adds your new content type to the end of the list of
     * TYPE_* constants here. But, don't start using your new content type until
     * your patch has been accepted, because it will be uncertain what exact
     * value and name your new content type will have; in that interim period,
     * use TYPE_OTHER. In your patch, document your new content type in the style
     * of the existing ones. In the bug you file, provide a more detailed
     * description of the new type of content you want Gecko to support, so that
     * the existing implementations of nsIContentPolicy can be properly modified
     * to deal with that new type of content.
     *
     * Implementations of nsIContentPolicy should treat this the same way they
     * treat unknown types, because existing users of TYPE_OTHER may be converted
     * to use new content types.
     *
     * Note that the TYPE_INTERNAL_* constants are never passed to content
     * policy implementations.  They are mapped to other TYPE_* constants, and
     * are only intended for internal usage inside Gecko.
     */
    TYPE_OTHER: 1;

    /**
     * Indicates an executable script (such as JavaScript).
     */
    TYPE_SCRIPT: 2;

    /**
     * Indicates an image (e.g., IMG elements).
     */
    TYPE_IMAGE: 3;

    /**
     * Indicates a stylesheet (e.g., STYLE elements).
     */
    TYPE_STYLESHEET: 4;

    /**
     * Indicates a generic object (plugin-handled content typically falls under
     * this category).
     */
    TYPE_OBJECT: 5;

    /**
     * Indicates a document at the top-level (i.e., in a browser).
     */
    TYPE_DOCUMENT: 6;

    /**
     * Indicates a document contained within another document (e.g., IFRAMEs,
     * FRAMES, and OBJECTs).
     */
    TYPE_SUBDOCUMENT: 7;

    /**
     * Indicates a timed refresh.
     *
     * shouldLoad will never get this, because it does not represent content
     * to be loaded (the actual load triggered by the refresh will go through
     * shouldLoad as expected).
     *
     * shouldProcess will get this for, e.g., META Refresh elements and HTTP
     * Refresh headers.
     */
    TYPE_REFRESH: 8;

    /**
     * Indicates an XBL binding request, triggered either by -moz-binding CSS
     * property.
     */
    TYPE_XBL: 9;

    /**
     * Indicates a ping triggered by a click on <A PING="..."> element.
     */
    TYPE_PING: 10;

    /**
     * Indicates an XMLHttpRequest. Also used for document.load and for EventSource.
     */
    TYPE_XMLHTTPREQUEST: 11;

    TYPE_DATAREQUEST: 11;

    /**
     * Indicates a request by a plugin.
     */
    TYPE_OBJECT_SUBREQUEST: 12;

    /**
     * Indicates a DTD loaded by an XML document.
     */
    TYPE_DTD: 13;

    /**
     * Indicates a font loaded via @font-face rule.
     */
    TYPE_FONT: 14;

    /**
     * Indicates a video or audio load.
     */
    TYPE_MEDIA: 15;

    /**
     * Indicates a WebSocket load.
     */
    TYPE_WEBSOCKET: 16;

    /**
     * Indicates a Content Security Policy report.
     */
    TYPE_CSP_REPORT: 17;

    /**
     * Indicates a style sheet transformation.
     */
    TYPE_XSLT: 18;

    /**
     * Indicates a beacon post.
     */
    TYPE_BEACON: 19;

    /**
     * Indicates a load initiated by the fetch() function from the Fetch
     * specification.
     */
    TYPE_FETCH: 20;

    /**
     * Indicates a <img srcset> or <picture> request.
     */
    TYPE_IMAGESET: 21;

    /**
     * Indicates a web manifest.
     */
    TYPE_WEB_MANIFEST: 22;

    /**
     * Indicates an internal constant for scripts loaded through script
     * elements.
     *
     * This will be mapped to TYPE_SCRIPT before being passed to content policy
     * implementations.
     */
    TYPE_INTERNAL_SCRIPT: 23;

    /**
     * Indicates an internal constant for scripts loaded through a dedicated
     * worker.
     *
     * This will be mapped to TYPE_SCRIPT before being passed to content policy
     * implementations.
     */
    TYPE_INTERNAL_WORKER: 24;

    /**
     * Indicates an internal constant for scripts loaded through a shared
     * worker.
     *
     * This will be mapped to TYPE_SCRIPT before being passed to content policy
     * implementations.
     */
    TYPE_INTERNAL_SHARED_WORKER: 25;

    /**
     * Indicates an internal constant for content loaded from embed elements.
     *
     * This will be mapped to TYPE_OBJECT.
     */
    TYPE_INTERNAL_EMBED: 26;

    /**
     * Indicates an internal constant for content loaded from object elements.
     *
     * This will be mapped to TYPE_OBJECT.
     */
    TYPE_INTERNAL_OBJECT: 27;

    /**
     * Indicates an internal constant for content loaded from frame elements.
     *
     * This will be mapped to TYPE_SUBDOCUMENT.
     */
    TYPE_INTERNAL_FRAME: 28;

    /**
     * Indicates an internal constant for content loaded from iframe elements.
     *
     * This will be mapped to TYPE_SUBDOCUMENT.
     */
    TYPE_INTERNAL_IFRAME: 29;

    /**
     * Indicates an internal constant for content loaded from audio elements.
     *
     * This will be mapped to TYPE_MEDIA.
     */
    TYPE_INTERNAL_AUDIO: 30;

    /**
     * Indicates an internal constant for content loaded from video elements.
     *
     * This will be mapped to TYPE_MEDIA.
     */
    TYPE_INTERNAL_VIDEO: 31;

    /**
     * Indicates an internal constant for content loaded from track elements.
     *
     * This will be mapped to TYPE_MEDIA.
     */
    TYPE_INTERNAL_TRACK: 32;

    /**
     * Indicates an internal constant for an XMLHttpRequest.
     *
     * This will be mapped to TYPE_XMLHTTPREQUEST.
     */
    TYPE_INTERNAL_XMLHTTPREQUEST: 33;

    /**
     * Indicates an internal constant for EventSource.
     *
     * This will be mapped to TYPE_DATAREQUEST.
     */
    TYPE_INTERNAL_EVENTSOURCE: 34;

    /**
     * Indicates an internal constant for scripts loaded through a service
     * worker.
     *
     * This will be mapped to TYPE_SCRIPT before being passed to content policy
     * implementations.
     */
    TYPE_INTERNAL_SERVICE_WORKER: 35;

    /**
     * Indicates an internal constant for *preloaded* scripts
     * loaded through script elements.
     *
     * This will be mapped to TYPE_SCRIPT before being passed
     * to content policy implementations.
     */
    TYPE_INTERNAL_SCRIPT_PRELOAD: 36;

    /**
     * Indicates an internal constant for normal images.
     *
     * This will be mapped to TYPE_IMAGE before being passed
     * to content policy implementations.
     */
    TYPE_INTERNAL_IMAGE: 37;

    /**
     * Indicates an internal constant for *preloaded* images.
     *
     * This will be mapped to TYPE_IMAGE before being passed
     * to content policy implementations.
     */
    TYPE_INTERNAL_IMAGE_PRELOAD: 38;

    /**
     * Indicates an internal constant for normal stylesheets.
     *
     * This will be mapped to TYPE_STYLESHEET before being passed
     * to content policy implementations.
     */
    TYPE_INTERNAL_STYLESHEET: 39;

    /**
     * Indicates an internal constant for *preloaded* stylesheets.
     *
     * This will be mapped to TYPE_STYLESHEET before being passed
     * to content policy implementations.
     */
    TYPE_INTERNAL_STYLESHEET_PRELOAD: 40;

    /**
     * Indicates an internal constant for favicon.
     *
     * This will be mapped to TYPE_IMAGE before being passed
     * to content policy implementations.
     */
    TYPE_INTERNAL_IMAGE_FAVICON: 41;

    /**
     * Indicates an importScripts() inside a worker script.
     *
     * This will be mapped to TYPE_SCRIPT before being passed to content policy
     * implementations.
     */
    TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS: 42;

    /**
     * Indicates an save-as link download from the front-end code.
     */
    TYPE_SAVEAS_DOWNLOAD: 43;

    /**
     * Indicates a speculative connection.
     */
    TYPE_SPECULATIVE: 44;

    /**
     * Indicates an internal constant for ES6 module scripts
     * loaded through script elements or an import statement.
     *
     * This will be mapped to TYPE_SCRIPT before being passed
     * to content policy implementations.
     */
    TYPE_INTERNAL_MODULE: 45;

    /**
     * Indicates an internal constant for *preloaded* ES6 module scripts
     * loaded through script elements or an import statement.
     *
     * This will be mapped to TYPE_SCRIPT before being passed
     * to content policy implementations.
     */
    TYPE_INTERNAL_MODULE_PRELOAD: 46;

    /**
     * Indicates a DTD loaded by an XML document the URI of which could
     * not be mapped to a known local DTD.
     */
    TYPE_INTERNAL_DTD: 47;

    /**
     * Indicates a TYPE_INTERNAL_DTD which will not be blocked no matter
     * what principal is being loaded from.
     */
    TYPE_INTERNAL_FORCE_ALLOWED_DTD: 48;

    /**
     * Returned from shouldLoad or shouldProcess if the load or process request
     * is rejected based on details of the request.
     */
    REJECT_REQUEST: -1;

    /**
     * Returned from shouldLoad or shouldProcess if the load/process is rejected
     * based solely on its type (of the above flags).
     *
     * NOTE that it is not meant to stop future requests for this type--only the
     * current request.
     */
    REJECT_TYPE: -2;

    /**
     * Returned from shouldLoad or shouldProcess if the load/process is rejected
     * based on the server it is hosted on or requested from (aContentLocation or
     * aRequestOrigin), e.g., if you block an IMAGE because it is served from
     * goatse.cx (even if you don't necessarily block other types from that
     * server/domain).
     *
     * NOTE that it is not meant to stop future requests for this server--only the
     * current request.
     */
    REJECT_SERVER: -3;

    /**
     * Returned from shouldLoad or shouldProcess if the load/process is rejected
     * based on some other criteria. Mozilla callers will handle this like
     * REJECT_REQUEST; third-party implementors may, for example, use this to
     * direct their own callers to consult the extra parameter for additional
     * details.
     */
    REJECT_OTHER: -4;

    /**
     * Returned from shouldLoad or shouldProcess if the load or process request
     * is not rejected.
     */
    ACCEPT: 1;
  }

  /**
   * Interface for content policy mechanism.  Implementations of this
   * interface can be used to control loading of various types of out-of-line
   * content, or processing of certain types of in-line content.
   *
   * WARNING: do not block the caller from shouldLoad or shouldProcess (e.g.,
   * by launching a dialog to prompt the user for something).
   */
  export interface nsIContentPolicy extends nsISupports {

    /**
     * Should the resource at this location be loaded?
     * ShouldLoad will be called before loading the resource at aContentLocation
     * to determine whether to start the load at all.
     *
     * @param aContentLocation  the location of the content being checked; must
     *                          not be null
     *
     * @param aLoadInfo         the loadinfo of the channel being evaluated.
     *
     * @param aMimeTypeGuess    OPTIONAL. a guess for the requested content's
     *                          MIME type, based on information available to
     *                          the request initiator (e.g., an OBJECT's type
     *                          attribute); does not reliably reflect the
     *                          actual MIME type of the requested content
     *
     * @return ACCEPT or REJECT_*
     *
     * @note shouldLoad can be called while the DOM and layout of the document
     * involved is in an inconsistent state.  This means that implementors of
     * this method MUST NOT do any of the following:
     * 1)  Modify the DOM in any way (e.g. setting attributes is a no-no).
     * 2)  Query any DOM properties that depend on layout (e.g. offset*
     *     properties).
     * 3)  Query any DOM properties that depend on style (e.g. computed style).
     * 4)  Query any DOM properties that depend on the current state of the DOM
     *     outside the "context" node (e.g. lengths of node lists).
     * 5)  [JavaScript implementations only] Access properties of any sort on any
     *     object without using XPCNativeWrapper (either explicitly or
     *     implicitly).  Due to various DOM0 things, this leads to item 4.
     * If you do any of these things in your shouldLoad implementation, expect
     * unpredictable behavior, possibly including crashes, content not showing
     * up, content showing up doubled, etc.  If you need to do any of the things
     * above, do them off timeout or event.
     */
    readonly shouldLoad: (aContentLocation: (nsIURI | null), aLoadInfo: (nsILoadInfo | null), aMimeTypeGuess: IDLACString) => number;

    /**
     * Should the resource be processed?
     * ShouldProcess will be called once all the information passed to it has
     * been determined about the resource, typically after part of the resource
     * has been loaded.
     *
     * @param aContentLocation  OPTIONAL; the location of the resource being
     *                          requested: MAY be, e.g., a post-redirection URI
     *                          for the resource.
     *
     * @param aLoadInfo         the loadinfo of the channel being evaluated.
     *
     * @param aMimeType         the MIME type of the requested resource (e.g.,
     *                          image/png), as reported by the networking library,
     *                          if available (may be empty if inappropriate for
     *                          the type, e.g., TYPE_REFRESH).
     *
     * @return ACCEPT or REJECT_*
     *
     * @note shouldProcess can be called while the DOM and layout of the document
     * involved is in an inconsistent state.  See the note on shouldLoad to see
     * what this means for implementors of this method.
     */
    readonly shouldProcess: (aContentLocation: (nsIURI | null), aLoadInfo: (nsILoadInfo | null), aMimeType: IDLACString) => number;
  }

  export interface imgIRequestRef {
    readonly name: "imgIRequest";
    readonly number: "{db0a945c-3883-424a-98d0-2ee0523b0255}";

    /**
     * Bits set in the return value from imageStatus
     * @name statusflags
     *
     * Meanings:
     *
     * STATUS_NONE: Nothing to report.
     *
     * STATUS_SIZE_AVAILABLE: We received enough image data
     * from the network or filesystem that we know the width
     * and height of the image, and have thus called SetSize()
     * on the container.
     *
     * STATUS_LOAD_COMPLETE: The data has been fully loaded
     * to memory, but not necessarily fully decoded.
     *
     * STATUS_ERROR: An error occurred loading the image.
     *
     * STATUS_FRAME_COMPLETE: The first frame has been
     * completely decoded.
     *
     * STATUS_DECODE_COMPLETE: The whole image has been decoded.
     *
     * STATUS_IS_ANIMATED: The image is animated.
     *
     * STATUS_HAS_TRANSPARENCY: The image is partially or completely transparent.
     */
    STATUS_NONE: 0;

    STATUS_SIZE_AVAILABLE: 1;

    STATUS_LOAD_COMPLETE: 2;

    STATUS_ERROR: 4;

    STATUS_FRAME_COMPLETE: 8;

    STATUS_DECODE_COMPLETE: 16;

    STATUS_IS_ANIMATED: 32;

    STATUS_HAS_TRANSPARENCY: 64;

    /**
     * CORS modes images can be loaded with.
     *
     * By default, all images are loaded with CORS_NONE and cannot be used
     * cross-origin in context like WebGL.
     *
     * If an HTML img element has the crossorigin attribute set, the imgIRequest
     * will be validated for cross-origin usage with CORS, and, if successful,
     * will have its CORS mode set to the relevant type.
     */
    CORS_NONE: 1;

    CORS_ANONYMOUS: 2;

    CORS_USE_CREDENTIALS: 3;

    /**
     * Request loading priority boost to requested category, each category
     * of request increases priority only one time.
     *
     * CATEGORY_FRAME_INIT: increase priority when the imgRequest is associated
     * with an nsImageFrame.
     *
     * CATEGORY_FRAME_STYLE: increase priority when the imgRequest is for a CSS
     * background-image, list-style-image, etc. on a ComputedStyle, and a frame
     * has been assigned this ComputedStyle.
     *
     * CATEGORY_SIZE_QUERY: increase priority when size decoding is necessary to
     * determine the layout size of an associated nsImageFrame.
     *
     * CATEGORY_DISPLAY: increase priority when the image is about to be displayed
     * in the viewport.
     */
    CATEGORY_FRAME_INIT: 1;

    CATEGORY_FRAME_STYLE: 2;

    CATEGORY_SIZE_QUERY: 4;

    CATEGORY_DISPLAY: 8;
  }

  /**
   * imgIRequest interface
   *
   * @author Stuart Parmenter <stuart@mozilla.com>
   * @version 0.1
   * @see imagelib2
   */
  export interface imgIRequest extends nsIRequest {

    /**
     * the image container...
     * @return the image object associated with the request.
     * @attention NEED DOCS
     */
    readonly image: (imgIContainer | null);

    /**
     * Producer ID for image containers created by this image.
     */
    readonly producerId: number;

    /**
     * Status flags of the STATUS_* variety.
     */
    readonly imageStatus: number;

    /**
     * The URI the image load was started with.  Note that this might not be the
     * actual URI for the image (e.g. if HTTP redirects happened during the
     * load).
     */
    readonly URI: (nsIURI | null);

    /**
     * The URI of the resource we ended up loading after all redirects, etc.
     */
    readonly finalURI: (nsIURI | null);

    readonly notificationObserver: (imgINotificationObserver | null);

    readonly mimeType: string;

    /**
     * Clone this request; the returned request will have aObserver as the
     * observer.  aObserver will be notified synchronously (before the clone()
     * call returns) with all the notifications that have already been dispatched
     * for this image load.
     */
    readonly clone: (aObserver: (imgINotificationObserver | null)) => (imgIRequest | null);

    /**
     * The principal gotten from the channel the image was loaded from.
     */
    readonly imagePrincipal: (nsIPrincipal | null);

    /**
     * true if the loading of the image required cross-origin redirects.
     */
    readonly hadCrossOriginRedirects: boolean;

    /**
     * Whether the request is multipart (ie, multipart/x-mixed-replace)
     */
    readonly multipart: boolean;

    /**
     * The CORS mode that this image was loaded with.
     */
    readonly CORSMode: number;

    /**
     * Cancels this request as in nsIRequest::Cancel(); further, also nulls out
     * decoderObserver so it gets no further notifications from us.
     *
     * NOTE: You should not use this in any new code; instead, use cancel(). Note
     * that cancel() is asynchronous, which means that some time after you call
     * it, the listener/observer will get an OnStopRequest(). This means that, if
     * you're the observer, you can't call cancel() from your destructor.
     */
    readonly cancelAndForgetObserver: (aStatus: number) => void;

    /**
     * Requests a synchronous decode for the image.
     *
     * imgIContainer has a startDecoding() method, but callers may want to request
     * a decode before the container has necessarily been instantiated. Calling
     * startDecoding() on the imgIRequest simply forwards along the request if the
     * container already exists, or calls it once the container becomes available
     * if it does not yet exist.
     */
    readonly startDecoding: (aFlags: number) => void;

    /**
     * Locks an image. If the image does not exist yet, locks it once it becomes
     * available. The lock persists for the lifetime of the imgIRequest (until
     * unlockImage is called) even if the underlying image changes.
     *
     * If you don't call unlockImage() by the time this imgIRequest goes away, it
     * will be called for you automatically.
     *
     * @see imgIContainer::lockImage for documentation of the underlying call.
     */
    readonly lockImage: () => void;

    /**
     * Unlocks an image.
     *
     * @see imgIContainer::unlockImage for documentation of the underlying call.
     */
    readonly unlockImage: () => void;

    /**
     * If this image is unlocked, discard the image's decoded data.  If the image
     * is locked or is already discarded, do nothing.
     */
    readonly requestDiscard: () => void;

    /**
     * If this request is for an animated image, the method creates a new
     * request which contains the current frame of the image.
     * Otherwise returns the same request.
     */
    readonly getStaticRequest: () => (imgIRequest | null);

    /**
     * Requests that the image animate (if it has an animation).
     *
     * @see Image::IncrementAnimationConsumers for documentation of the
     * underlying call.
     */
    readonly incrementAnimationConsumers: () => void;

    /**
     * Tell the image it can forget about a request that the image animate.
     *
     * @see Image::DecrementAnimationConsumers for documentation of the
     * underlying call.
     */
    readonly decrementAnimationConsumers: () => void;

    readonly boostPriority: (aCategory: number) => void;
  }

  export interface nsIOSPermissionRequestRef {
    readonly name: "nsIOSPermissionRequest";
    readonly number: "{95790842-75a0-430d-98bf-f5ce3788ea6d}";

    PERMISSION_STATE_NOTDETERMINED: 0;

    PERMISSION_STATE_RESTRICTED: 1;

    PERMISSION_STATE_DENIED: 2;

    PERMISSION_STATE_AUTHORIZED: 3;
  }

  export interface nsIOSPermissionRequest extends nsISupports {

    readonly getMediaCapturePermissionState: (aVideo: Out<number>, aAudio: Out<number>) => void;

    readonly getAudioCapturePermissionState: (aAudio: Out<number>) => void;

    readonly getVideoCapturePermissionState: (aVideo: Out<number>) => void;

    readonly getScreenCapturePermissionState: (aScreen: Out<number>) => void;

    readonly requestVideoCapturePermission: () => IDLPromise;

    readonly requestAudioCapturePermission: () => IDLPromise;

    readonly maybeRequestScreenCapturePermission: () => void;
  }

  export interface nsIBasicCardResponseDataRef {
    readonly name: "nsIBasicCardResponseData";
    readonly number: "{0d55a5e6-d185-44f0-b992-a8e1321e4bce}";
  }

  /**
   *  The basic card response data.
   *  Since PaymentAddress is an no constructor interface type, UI code can not
   *  easy create PaymentAddress by calling new PaymentAddress().
   *  Unfortunately, BasicCardResponse has a PaymentAddress attribute, billingAddress
   *  , it means UI can not create BsaicCardResponse by calling the init() with a
   *  given JSObject directly, because PaymentAddress creation in JS code is hard.
   *  To let UI code can create BasicCardResponse easier, nsIBasicCardResponse is
   *  provided for UI by passing the raw data of BasicCardResponse,
   */
  export interface nsIBasicCardResponseData extends nsIPaymentResponseData {

    /**
     *  The cardholder name.
     */
    readonly cardholderName: IDLAString;

    /**
     *  The card number.
     */
    readonly cardNumber: IDLAString;

    /**
     *  The expiry month.
     */
    readonly expiryMonth: IDLAString;

    /**
     *  The expiry year.
     */
    readonly expiryYear: IDLAString;

    /**
     *  The card security number.
     */
    readonly cardSecurityCode: IDLAString;

    /**
     *  The billing address.
     */
    readonly billingAddress: (nsIPaymentAddress | null);

    /**
     *  The initial method for nsIBasicCardResponseData.
     *  @param aCardholderName   - the cardholder name.
     *  @param aCardNumber       - the card number.
     *  @param aExpiryMonth      - the expiry month.
     *  @param aExpiryYear       - the expiry year.
     *  @param aCardSecurityCode - the card security code.
     *  @param aBillingAddreess  - the billing address.
     */
    readonly initData: (aCardholderName: IDLAString, aCardNumber: IDLAString, aExpiryMonth: IDLAString, aExpiryYear: IDLAString, aCardSecurityCode: IDLAString, billingAddress: (nsIPaymentAddress | null)) => void;
  }

  export interface nsIFormPOSTActionChannelRef {
    readonly name: "nsIFormPOSTActionChannel";
    readonly number: "{fc826b53-0db8-42b4-aa6a-5dd2cfca52a4}";
  }

  /**
   * nsIFormPOSTActionChannel
   *
   * Channel classes that want to be allowed for HTML form POST action must
   * implement this interface.
   */
  export interface nsIFormPOSTActionChannel extends nsIUploadChannel {
  }

  export interface mozIStorageResultSetRef {
    readonly name: "mozIStorageResultSet";
    readonly number: "{18dd7953-076d-4598-8105-3e32ad26ab24}";
  }

  export interface mozIStorageResultSet extends nsISupports {

    /**
     * Obtains the next row from the result set from the statement that was
     * executed.
     *
     * @returns the next row from the result set.  This will be null when there
     *          are no more results.
     */
    readonly getNextRow: () => (mozIStorageRow | null);
  }

  export interface nsIStreamListenerTeeRef {
    readonly name: "nsIStreamListenerTee";
    readonly number: "{62b27fc1-6e8c-4225-8ad0-b9d44252973a}";
  }

  /**
   * As data "flows" into a stream listener tee, it is copied to the output stream
   * and then forwarded to the real listener.
   */
  export interface nsIStreamListenerTee extends nsIStreamListener {

    /**
     * Initalize the tee.
     *
     * @param listener
     *    the original listener the tee will propagate onStartRequest,
     *    onDataAvailable and onStopRequest notifications to, exceptions from
     *    the listener will be propagated back to the channel
     * @param sink
     *    the stream the data coming from the channel will be written to,
     *    should be blocking
     * @param requestObserver
     *    optional parameter, listener that gets only onStartRequest and
     *    onStopRequest notifications; exceptions threw within this optional
     *    observer are also propagated to the channel, but exceptions from
     *    the original listener (listener parameter) are privileged
     */
    readonly init: (listener: (nsIStreamListener | null), sink: (nsIOutputStream | null), requestObserver?: (nsIRequestObserver | null)) => void;

    /**
     * Initalize the tee like above, but with the extra parameter to make it
     * possible to copy the output asynchronously
     * @param anEventTarget
     *    if set, this event-target is used to copy data to the output stream,
     *    giving an asynchronous tee
     */
    readonly initAsync: (listener: (nsIStreamListener | null), eventTarget: (nsIEventTarget | null), sink: (nsIOutputStream | null), requestObserver?: (nsIRequestObserver | null)) => void;
  }

  export interface nsITLSServerSocketRef {
    readonly name: "nsITLSServerSocket";
    readonly number: "{cc2c30f9-cfaa-4b8a-bd44-c24881981b74}";

    /**
     * Values for setRequestClientCertificate
     */
    REQUEST_NEVER: 0;

    REQUEST_FIRST_HANDSHAKE: 1;

    REQUEST_ALWAYS: 2;

    REQUIRE_FIRST_HANDSHAKE: 3;

    REQUIRE_ALWAYS: 4;
  }

  export interface nsITLSServerSocket extends nsIServerSocket {

    /**
     * serverCert
     *
     * The server's certificate that is presented to the client during the TLS
     * handshake.  This is required to be set before calling |asyncListen|.
     */
    serverCert: (nsIX509Cert | null);

    /**
     * setSessionTickets
     *
     * Whether the server should support session tickets.  Defaults to true.  This
     * should be set before calling |asyncListen| if you wish to change the
     * default.
     */
    readonly setSessionTickets: (aSessionTickets: boolean) => void;

    /**
     * setRequestClientCertificate
     *
     * Whether the server should request and/or require a client auth certificate
     * from the client.  Defaults to REQUEST_NEVER.  See the possible options
     * above.  This should be set before calling |asyncListen| if you wish to
     * change the default.
     */
    readonly setRequestClientCertificate: (aRequestClientCert: number) => void;

    /**
     * setVersionRange
     *
     * The server's TLS versions that is used by the TLS handshake.
     * This is required to be set before calling |asyncListen|.
     *
     * aMinVersion and aMaxVersion is a TLS version value from
     * |nsITLSClientStatus| constants.
     */
    readonly setVersionRange: (aMinVersion: number, aMaxVersion: number) => void;
  }

  export interface nsIWebNavigationInfoRef {
    readonly name: "nsIWebNavigationInfo";
    readonly number: "{62a93afb-93a1-465c-84c8-0432264229de}";

    /**
     * Returned by isTypeSupported to indicate lack of support for a type.
     * @note this is guaranteed not to change, so that boolean tests can be done
     * on the return value if isTypeSupported to detect whether a type is
     * supported at all.
     */
    UNSUPPORTED: 0;

    /**
     * Returned by isTypeSupported to indicate that a type is supported as an
     * image.
     */
    IMAGE: 1;

    /**
     * Returned by isTypeSupported to indicate that a type is supported via an
     * NPAPI ("Netscape 4 API") plug-in.  This is not the value returned for
     * "XPCOM plug-ins".
     */
    PLUGIN: 2;

    /**
     * @note Other return types may be added here in the future as they become
     * relevant.
     */
    /**
     * Returned by isTypeSupported to indicate that a type is supported via some
     * other means.
     */
    OTHER: 32768;
  }

  /**
   * The nsIWebNavigationInfo interface exposes a way to get information
   * on the capabilities of Gecko webnavigation objects.
   */
  export interface nsIWebNavigationInfo extends nsISupports {

    /**
     * Query whether aType is supported.
     * @param aType the MIME type in question.
     * @param aWebNav the nsIWebNavigation object for which the request
     *        is being made.  This is allowed to be null.  If it is non-null,
     *        the return value of this method may depend on the exact state of
     *        aWebNav and the values set through nsIWebBrowserSetup; otherwise
     *        the method will assume that the caller is interested in information
     *        about nsIWebNavigation objects in their default state.
     * @return an enum value indicating whether and how aType is supported.
     * @note This method may rescan plugins to ensure that they're properly
     *       registered for the types they support.
     */
    readonly isTypeSupported: (aType: IDLACString, aWebNav: (nsIWebNavigation | null)) => number;
  }

  export interface nsIXPCComponents_ClassesRef {
    readonly name: "nsIXPCComponents_Classes";
    readonly number: "{978ff520-d26c-11d2-9842-006008962422}";
  }

  /**
   * interface of Components.classes
   * (interesting stuff only reflected into JavaScript)
   */
  export interface nsIXPCComponents_Classes extends nsISupports {
  }

  export interface nsIAsyncStreamCopier2Ref {
    readonly name: "nsIAsyncStreamCopier2";
    readonly number: "{a5b2decf-4ede-4801-8b38-e5fe5db46bf2}";
  }

  export interface nsIAsyncStreamCopier2 extends nsIRequest {

    /**
     * Initialize the stream copier.
     *
     * If neither the source nor the sink are buffered, buffering will
     * be automatically added to the sink.
     *
     *
     * @param aSource
     *        contains the data to be copied.
     * @param aSink
     *        specifies the destination for the data.
     * @param aTarget
     *        specifies the thread on which the copy will occur.  a null value
     *        is permitted and will cause the copy to occur on an unspecified
     *        background thread.
     * @param aChunkSize
     *        specifies how many bytes to read/write at a time.  this controls
     *        the granularity of the copying.  it should match the segment size
     *        of the "buffered" streams involved.
     * @param aCloseSource
     *        true if aSource should be closed after copying (this is generally
     *        the desired behavior).
     * @param aCloseSink
     *        true if aSink should be closed after copying (this is generally
     *        the desired behavior).
     */
    readonly init: (aSource: (nsIInputStream | null), aSink: (nsIOutputStream | null), aTarget: (nsIEventTarget | null), aChunkSize: number, aCloseSource: boolean, aCloseSink: boolean) => void;

    /**
     * asyncCopy triggers the start of the copy.  The observer will be notified
     * when the copy completes.
     *
     * @param aObserver
     *        receives notifications.
     * @param aObserverContext
     *        passed to observer methods.
     */
    readonly asyncCopy: (aObserver: (nsIRequestObserver | null), aObserverContext: (nsISupports | null)) => void;
  }

  export enum nsIClassifiedChannel_ClassificationFlags {
    CLASSIFIED_FINGERPRINTING = 1,
    CLASSIFIED_FINGERPRINTING_CONTENT = 128,
    CLASSIFIED_CRYPTOMINING = 2,
    CLASSIFIED_CRYPTOMINING_CONTENT = 256,
    CLASSIFIED_TRACKING = 4,
    CLASSIFIED_TRACKING_AD = 8,
    CLASSIFIED_TRACKING_ANALYTICS = 16,
    CLASSIFIED_TRACKING_SOCIAL = 32,
    CLASSIFIED_TRACKING_CONTENT = 64,
    CLASSIFIED_SOCIALTRACKING = 512,
    CLASSIFIED_SOCIALTRACKING_FACEBOOK = 1024,
    CLASSIFIED_SOCIALTRACKING_LINKEDIN = 2048,
    CLASSIFIED_SOCIALTRACKING_TWITTER = 4096,
    CLASSIFIED_ANY_BASIC_TRACKING = 61,
    CLASSIFIED_ANY_STRICT_TRACKING = 253,
    CLASSIFIED_ANY_SOCIAL_TRACKING = 7680,
  }

  export interface nsIClassifiedChannelRef {
    readonly name: "nsIClassifiedChannel";
    readonly number: "{70cf6091-a1de-4aa8-8224-058f8964be31}";

    CLASSIFIED_FINGERPRINTING: 1;
    CLASSIFIED_FINGERPRINTING_CONTENT: 128;
    CLASSIFIED_CRYPTOMINING: 2;
    CLASSIFIED_CRYPTOMINING_CONTENT: 256;
    CLASSIFIED_TRACKING: 4;
    CLASSIFIED_TRACKING_AD: 8;
    CLASSIFIED_TRACKING_ANALYTICS: 16;
    CLASSIFIED_TRACKING_SOCIAL: 32;
    CLASSIFIED_TRACKING_CONTENT: 64;
    CLASSIFIED_SOCIALTRACKING: 512;
    CLASSIFIED_SOCIALTRACKING_FACEBOOK: 1024;
    CLASSIFIED_SOCIALTRACKING_LINKEDIN: 2048;
    CLASSIFIED_SOCIALTRACKING_TWITTER: 4096;
    CLASSIFIED_ANY_BASIC_TRACKING: 61;
    CLASSIFIED_ANY_STRICT_TRACKING: 253;
    CLASSIFIED_ANY_SOCIAL_TRACKING: 7680;
  }

  /**
   * nsIClassifiedChannel
   *
   * A channel may optionally implement this interface if it carries classified
   * result information of channel classifier. The information contains, for
   * example, the name of matched table and the name of matched provider.
   */
  export interface nsIClassifiedChannel extends nsISupports {

    /**
     * Sets matched info of the classified channel.
     *
     * @param aList
     *        Name of the Safe Browsing list that matched (e.g. goog-phish-shavar).
     * @param aProvider
     *        Name of the Safe Browsing provider that matched (e.g. google)
     * @param aFullHash
     *        Full hash of URL that matched Safe Browsing list.
     */
    readonly setMatchedInfo: (aList: IDLACString, aProvider: IDLACString, aFullHash: IDLACString) => void;

    /**
     * Name of the list that matched
     */
    readonly matchedList: IDLACString;

    /**
     * Name of provider that matched
     */
    readonly matchedProvider: IDLACString;

    /**
     * Full hash of URL that matched
     */
    readonly matchedFullHash: IDLACString;

    /**
     * Sets matched tracking info of the classified channel.
     *
     * @param aLists
     *        Name of the Tracking Protection list that matched (e.g. content-track-digest256).
     * @param aFullHash
     *        Full hash of URLs that matched Tracking Protection list.
     */
    readonly setMatchedTrackingInfo: (aLists: IDLACString[], aFullHashes: IDLACString[]) => void;

    /**
     * Name of the lists that matched
     */
    readonly matchedTrackingLists: IDLACString[];

    /**
     * Full hash of URLs that matched
     */
    readonly matchedTrackingFullHashes: IDLACString[];

    /**
     * Returns the classification flags if the channel has been processed by
     * URL-Classifier features and is considered first-party.
     */
    readonly firstPartyClassificationFlags: number;

    /**
     * Returns the classification flags if the channel has been processed by
     * URL-Classifier features and is considered third-party with the top
     * window URI.
     */
    readonly thirdPartyClassificationFlags: number;

    readonly classificationFlags: number;

    /**
     * Returns true if the channel has loaded a resource that is classified as
     * tracker.
     * This is a helper attribute which returns the same value of
     * (classificationFlags & CLASSIFIED_ANY_BASIC_TRACKING) or
     * (classificationFlags & CLASSIFIED_ANY_STRICT_TRACKING) or
     * (classificationFlags & CLASSIFIED_ANY_SOCIAL_TRACKING)
     *
     * Note that top-level channels could be marked as tracking
     * resource. In order to identify third-party tracking resources
     * specifically, use isThirdPartyTrackingResource().
     */
    readonly isTrackingResource: () => boolean;

    /**
     * Returns true  if the channel has been processed by URL-Classifier features
     * and is considered third-party with the top window URI, and if it has loaded
     * a resource that is classified as a tracker.
     *
     * This is a helper attribute which returns the same value of
     * (thirdPartyClassificationFlags & CLASSIFIED_ANY_BASIC_TRACKING) or
     * (thirdPartyClassificationFlags & CLASSIFIED_ANY_STRICT_TRACKING) or
     * (thirdPartyClassificationFlags & CLASSIFIED_ANY_SOCIAL_TRACKING)
     */
    readonly isThirdPartyTrackingResource: () => boolean;

    /**
     * Returns true if the channel has loaded a resource that is classified as
     * a social tracker.
     *
     * This is a helper attribute which returns the same value of
     * (classificationFlags & CLASSIFIED_ANY_SOCIAL_TRACKING)
     *
     * Note that top-level channels could be marked as tracking
     * resources. In order to identify third-party social tracking resources
     * specifically, check the flags manually or add a new helper here.
     */
    readonly isSocialTrackingResource: () => boolean;
  }

  export interface nsIBitsCallbackRef {
    readonly name: "nsIBitsCallback";
    readonly number: "{ea657e66-6bad-4e41-84d9-c6d107e9799d}";
  }

  export interface nsIBitsCallback extends nsISupports {

    /**
     * This callback interface is for use by the nsIBitsRequest interface for
     * returning results asynchronously to the caller.
     */
    readonly success: () => void;

    readonly failure: (errorType: number, errorAction: number, errorStage: number) => void;

    readonly failureNsresult: (errorType: number, errorAction: number, errorStage: number, errorCode: number) => void;

    readonly failureHresult: (errorType: number, errorAction: number, errorStage: number, errorCode: number) => void;

    readonly failureString: (errorType: number, errorAction: number, errorStage: number, errorMessage: IDLAUTF8String) => void;
  }

  export interface nsIPrefStatsCallbackRef {
    readonly name: "nsIPrefStatsCallback";
    readonly number: "{c3f0cedc-e244-4316-b33a-80306a1c35a1}";
  }

  type nsIPrefStatsCallbackFunction = (prefName: IDLACString, accessCount: number) => void;

  /**
   * A helper function for reading access statistics for preferences.
   * See nsIPrefService.readStats for more details.
   */
  export interface nsIPrefStatsCallback extends nsISupports {

    readonly visit: (prefName: IDLACString, accessCount: number) => void;
  }

  export interface nsIVersionComparatorRef {
    readonly name: "nsIVersionComparator";
    readonly number: "{e6cd620a-edbb-41d2-9e42-9a2ffc8107f3}";
  }

  /**
   * Version strings are dot-separated sequences of version-parts.
   *
   * A version-part consists of up to four parts, all of which are optional:
   *
   * <number-a><string-b><number-c><string-d (everything else)>
   *
   * A version-part may also consist of a single asterisk "*" which indicates
   * "infinity".
   *
   * Numbers are base-10, and are zero if left out.
   * Strings are compared bytewise.
   *
   * For additional backwards compatibility, if "string-b" is "+" then
   * "number-a" is incremented by 1 and "string-b" becomes "pre".
   *
   * 1.0pre1
   * < 1.0pre2
   *   < 1.0 == 1.0.0 == 1.0.0.0
   *     < 1.1pre == 1.1pre0 == 1.0+
   *       < 1.1pre1a
   *         < 1.1pre1
   *           < 1.1pre10a
   *             < 1.1pre10
   *
   * Although not required by this interface, it is recommended that
   * numbers remain within the limits of a signed char, i.e. -127 to 128.
   */
  export interface nsIVersionComparator extends nsISupports {

    /**
     * Compare two version strings
     * @param   A   The first version
     * @param   B   The second version
     * @returns < 0 if A < B
     *          = 0 if A == B
     *          > 0 if A > B
     */
    readonly compare: (A: IDLACString, B: IDLACString) => number;
  }

  export interface nsIMozIconURIRef {
    readonly name: "nsIMozIconURI";
    readonly number: "{f8fe5ef2-5f2b-43f3-857d-5b64d192c427}";
  }

  /**
   * nsIIconURI
   *
   * This interface derives from nsIURI, to provide additional information
   * about moz-icon URIs.
   *
   * What *is* a moz-icon URI you ask?  Well, it has the following syntax:
   *
   * moz-icon:[<valid-url> | //<file-with-extension> | //stock/<stock-icon>]?
   *            ['?'[<parameter-value-pairs>]]
   *
   * <valid-url> is a valid URL spec.
   *
   * <file-with-extension> is any filename with an extension, e.g. "dummy.html".
   * If the file you want an icon for isn't known to exist, you can use this
   * instead of a URL and just place a dummy file name with the extension or
   * content type you want.
   *
   * <stock-icon> is the name of a platform-dependant stock icon.
   *
   * Legal parameter value pairs are listed below:
   *
   *   Parameter:   size
   *   Values:      [<integer> | button | toolbar | toolbarsmall | menu |
   *                 dialog]
   *   Description: If integer, this is the desired size in square pixels of
   *                the icon
   *                Else, use the OS default for the specified keyword context.
   *
   *   Parameter:   state
   *   Values:      [normal | disabled]
   *   Description: The state of the icon.
   *
   *   Parameter:   contentType
   *   Values:      <mime-type>
   *   Description: The mime type we want an icon for. This is ignored by
   *                stock images.
   */
  export interface nsIMozIconURI extends nsIURI {

    readonly iconURL: (nsIURL | null);

    readonly imageSize: number;

    readonly stockIcon: IDLACString;

    readonly iconSize: IDLACString;

    readonly iconState: IDLACString;

    readonly contentType: IDLACString;

    readonly fileExtension: IDLACString;
  }

  export interface nsIRemoteWindowContextRef {
    readonly name: "nsIRemoteWindowContext";
    readonly number: "{94f4a92b-752e-4fd9-8345-11b069ca19f3}";
  }

  export interface nsIRemoteWindowContext extends nsISupports {

    readonly usePrivateBrowsing: boolean;

    readonly openURI: (aURI: (nsIURI | null)) => void;
  }

  export interface nsIX509CertValidityRef {
    readonly name: "nsIX509CertValidity";
    readonly number: "{e701dfd8-1dd1-11b2-a172-ffa6cc6156ad}";
  }

  /**
   * Information on the validity period of a X.509 certificate.
   */
  export interface nsIX509CertValidity extends nsISupports {

    /**
     *  The earliest point in time where
     *  a certificate is valid.
     */
    readonly notBefore: number;

    /**
     *  "notBefore" attribute formatted as a time string
     *  according to the environment locale,
     *  according to the environment time zone.
     */
    readonly notBeforeLocalTime: IDLAString;

    /**
     *  The day portion of "notBefore" formatted as a time string
     *  according to the environment locale,
     *  according to the environment time zone.
     */
    readonly notBeforeLocalDay: IDLAString;

    /**
     *  "notBefore" attribute formatted as a string
     *  according to the environment locale,
     *  displayed as GMT / UTC.
     */
    readonly notBeforeGMT: IDLAString;

    /**
     *  The latest point in time where
     *  a certificate is valid.
     */
    readonly notAfter: number;

    /**
     *  "notAfter" attribute formatted as a time string
     *  according to the environment locale,
     *  according to the environment time zone.
     */
    readonly notAfterLocalTime: IDLAString;

    /**
     *  The day portion of "notAfter" formatted as a time string
     *  according to the environment locale,
     *  according to the environment time zone.
     */
    readonly notAfterLocalDay: IDLAString;

    /**
     *  "notAfter" attribute formatted as a time string
     *  according to the environment locale,
     *  displayed as GMT / UTC.
     */
    readonly notAfterGMT: IDLAString;
  }

  export interface nsIProfileUnlockerRef {
    readonly name: "nsIProfileUnlocker";
    readonly number: "{08923af1-e7a3-4fae-ba02-128502193994}";

    ATTEMPT_QUIT: 0;

    FORCE_QUIT: 1;
  }

  export interface nsIProfileUnlocker extends nsISupports {

    /**
     * Try to unlock the specified profile by attempting or forcing the
     * process that currently holds the lock to quit.
     *
     * @param aSeverity either ATTEMPT_QUIT or FORCE_QUIT
     * @throws NS_ERROR_FAILURE if unlocking failed.
     */
    readonly unlock: (aSeverity: number) => void;
  }

  export interface nsIFinishReportingCallbackRef {
    readonly name: "nsIFinishReportingCallback";
    readonly number: "{548b3909-c04d-4ca6-8466-b8bee3837457}";
  }

  type nsIFinishReportingCallbackFunction = (data: (nsISupports | null)) => void;

  export interface nsIFinishReportingCallback extends nsISupports {

    readonly callback: (data: (nsISupports | null)) => void;
  }

  export interface nsIRedirectChannelRegistrarRef {
    readonly name: "nsIRedirectChannelRegistrar";
    readonly number: "{efa36ea2-5b07-46fc-9534-a5acb8b77b72}";
  }

  /**
   * Used on the chrome process as a service to join channel implementation
   * and parent IPC protocol side under a unique id.  Provides this way a generic
   * communication while redirecting to various protocols.
   *
   * See also nsIChildChannel and nsIParentChannel.
   */
  export interface nsIRedirectChannelRegistrar extends nsISupports {

    /**
     * Register the redirect target channel and obtain a unique ID for that
     * channel.
     *
     * Primarily used in ParentChannelListener::AsyncOnChannelRedirect to get
     * a channel id sent to the HttpChannelChild being redirected.
     */
    readonly registerChannel: (channel: (nsIChannel | null)) => number;

    /**
     * First, search for the channel registered under the id.  If found return
     * it.  Then, register under the same id the parent side of IPC protocol
     * to let it be later grabbed back by the originator of the redirect and
     * notifications from the real channel could be forwarded to this parent
     * channel.
     *
     * Primarily used in parent side of an IPC protocol implementation
     * in reaction to nsIChildChannel.connectParent(id) called from the child
     * process.
     */
    readonly linkChannels: (id: number, channel: (nsIParentChannel | null)) => (nsIChannel | null);

    /**
     * Returns back the channel previously registered under the ID with
     * registerChannel method.
     *
     * Primarilly used in chrome IPC side of protocols when attaching a redirect
     * target channel to an existing 'real' channel implementation.
     */
    readonly getRegisteredChannel: (id: number) => (nsIChannel | null);

    /**
     * Returns the stream listener that shall be attached to the redirect target
     * channel, all notification from the redirect target channel will be
     * forwarded to this stream listener.
     *
     * Primarilly used in ParentChannelListener::OnRedirectResult callback
     * to grab the created parent side of the channel and forward notifications
     * to it.
     */
    readonly getParentChannel: (id: number) => (nsIParentChannel | null);

    /**
     * To not force all channel implementations to support weak reference
     * consumers of this service must ensure release of registered channels them
     * self.  This releases both the real and parent channel registered under
     * the id.
     *
     * Primarilly used in ParentChannelListener::OnRedirectResult callback.
     */
    readonly deregisterChannels: (id: number) => void;
  }

  export interface nsIDNSServiceRef {
    readonly name: "nsIDNSService";
    readonly number: "{de5642c6-61fc-4fcf-9a47-03226b0d4e21}";

    /*************************************************************************
     * Listed below are the various flags that may be OR'd together to form
     * the aFlags parameter passed to asyncResolve() and resolve().
     */
    /**
     * if set, this flag suppresses the internal DNS lookup cache.
     */
    RESOLVE_BYPASS_CACHE: 1;

    /**
     * if set, the canonical name of the specified host will be queried.
     */
    RESOLVE_CANONICAL_NAME: 2;

    /**
     * if set, the query is given lower priority. Medium takes precedence
     * if both are used.
     */
    RESOLVE_PRIORITY_MEDIUM: 4;

    RESOLVE_PRIORITY_LOW: 8;

    /**
     * if set, indicates request is speculative. Speculative requests
     * return errors if prefetching is disabled by configuration.
     */
    RESOLVE_SPECULATE: 16;

    /**
     * If set, only IPv4 addresses will be returned from resolve/asyncResolve.
     */
    RESOLVE_DISABLE_IPV6: 32;

    /**
     * If set, only literals and cached entries will be returned from resolve/
     * asyncResolve.
     */
    RESOLVE_OFFLINE: 64;

    /**
     * If set, only IPv6 addresses will be returned from resolve/asyncResolve.
     */
    RESOLVE_DISABLE_IPV4: 128;

    /**
     * If set, allow name collision results (127.0.53.53) which are normally filtered.
     */
    RESOLVE_ALLOW_NAME_COLLISION: 256;

    /**
     * If set, do not use TRR for resolving the host name.
     */
    RESOLVE_DISABLE_TRR: 512;

    /**
     * if set (together with RESOLVE_BYPASS_CACHE), invalidate the DNS
     * existing cache entry first (if existing) then make a new resolve.
     */
    RESOLVE_REFRESH_CACHE: 1024;

    /**
     * This ure dns request types that are currently supported.
     * RESOLVE_TYPE_DEFAULT is standard A/AAAA lookup
     * The others (currently only TXT supported) are wireformat types
     */
    RESOLVE_TYPE_DEFAULT: 0;

    RESOLVE_TYPE_TXT: 16;
  }

  /**
   * nsIDNSService
   */
  export interface nsIDNSService extends nsISupports {

    /**
     * kicks off an asynchronous host lookup.
     *
     * @param aHostName
     *        the hostname or IP-address-literal to resolve.
     * @param aFlags
     *        a bitwise OR of the RESOLVE_ prefixed constants defined below.
     * @param aListener
     *        the listener to be notified when the result is available.
     * @param aListenerTarget
     *        optional parameter (may be null).  if non-null, this parameter
     *        specifies the nsIEventTarget of the thread on which the
     *        listener's onLookupComplete should be called.  however, if this
     *        parameter is null, then onLookupComplete will be called on an
     *        unspecified thread (possibly recursively).
     * @param aOriginAttributes
     *        the originAttribute for this resolving, the DNS cache will be
     *        separated according to this originAttributes. This attribute is
     *        optional to avoid breaking add-ons.
     *
     * @return An object that can be used to cancel the host lookup.
     */
    readonly asyncResolve: (aHostName: IDLAUTF8String, aFlags: number, aListener: (nsIDNSListener | null), aListenerTarget: (nsIEventTarget | null), aOriginAttributes?: IDLjsval) => (nsICancelable | null);

    /**
     * kicks off an asynchronous host lookup by type, e.g. TXT.
     *
     * @param aHostName
     *        the hostname or IP-address-literal to resolve.
     * @param aType
     *        one of RESOLVE_TYPE_*.
     * @param aFlags
     *        a bitwise OR of the RESOLVE_ prefixed constants defined below
     *        except RESOLVE_CANONICAL_NAME, RESOLVE_DISABLE_IPV6 and
     *        RESOLVE_DISABLE_IPV4.
     * @param aListener
     *        the listener to be notified when the result is available.
     * @param aListenerTarget
     *        optional parameter (may be null).  if non-null, this parameter
     *        specifies the nsIEventTarget of the thread on which the
     *        listener's onLookupComplete should be called.  however, if this
     *        parameter is null, then onLookupComplete will be called on an
     *        unspecified thread (possibly recursively).
     * @param aOriginAttributes
     *        the originAttribute for this resolving, the DNS cache will be
     *        separated according to this originAttributes.
     *
     * @return An object that can be used to cancel the host lookup.
     */
    readonly asyncResolveByType: (aHostName: IDLAUTF8String, aType: number, aFlags: number, aListener: (nsIDNSListener | null), aListenerTarget: (nsIEventTarget | null), aOriginAttributes: IDLjsval) => (nsICancelable | null);

    /**
     * Attempts to cancel a previously requested async DNS lookup
     *
     * @param aHostName
     *        the hostname or IP-address-literal to resolve.
     * @param aFlags
     *        a bitwise OR of the RESOLVE_ prefixed constants defined below.
     * @param aListener
     *        the original listener which was to be notified about the host lookup
     *        result - used to match request information to requestor.
     * @param aReason
     *        nsresult reason for the cancellation
     * @param aOriginAttributes
     *        the originAttribute for this resolving. This attribute is optional
     *        to avoid breaking add-ons.
     */
    readonly cancelAsyncResolve: (aHostName: IDLAUTF8String, aFlags: number, aListener: (nsIDNSListener | null), aReason: number, aOriginAttributes?: IDLjsval) => void;

    /**
     * Attempts to cancel a previously requested async DNS lookup
     *
     * @param aHostName
     *        the hostname or IP-address-literal to resolve.
     * @param  aType
     *        one of RESOLVE_TYPE_*.
     * @param aFlags
     *        a bitwise OR of the RESOLVE_ prefixed constants defined below
     *        except RESOLVE_CANONICAL_NAME, RESOLVE_DISABLE_IPV6 and
     *        RESOLVE_DISABLE_IPV4.
     * @param aListener
     *        the original listener which was to be notified about the host lookup
     *        result - used to match request information to requestor.
     * @param aReason
     *        nsresult reason for the cancellation
     * @param aOriginAttributes
     *        the originAttribute for this resolving. This attribute is optional
     *        to avoid breaking add-ons.
     *
     */
    readonly cancelAsyncResolveByType: (aHostName: IDLAUTF8String, aType: number, aFlags: number, aListener: (nsIDNSListener | null), aReason: number, aOriginAttributes: IDLjsval) => void;

    /**
     * called to synchronously resolve a hostname.
     *
     * Since this method may block the calling thread for a long period of
     * time, it may not be accessed from the main thread.
     *
     * @param aHostName
     *        the hostname or IP-address-literal to resolve.
     * @param aFlags
     *        a bitwise OR of the RESOLVE_ prefixed constants defined below.
     * @param aOriginAttributes
     *        the originAttribute for this resolving, the DNS cache will be
     *        separated according to this originAttributes. This attribute is
     *        optional to avoid breaking add-ons.
     *
     * @return DNS record corresponding to the given hostname.
     * @throws NS_ERROR_UNKNOWN_HOST if host could not be resolved.
     * @throws NS_ERROR_NOT_AVAILABLE if accessed from the main thread.
     */
    readonly resolve: (aHostName: IDLAUTF8String, aFlags: number, aOriginAttributes?: IDLjsval) => (nsIDNSRecord | null);

    /**
     * Clears the DNS cache.
     * @param aTrrToo
     *        If true we will clear TRR cached entries too. Since these
     *        are resolved remotely it's not necessary to clear them when
     *        the network status changes, but it's sometimes useful to do so
     *        for tests or other situations.
     */
    readonly clearCache: (aTrrToo: boolean) => void;

    /**
     * The method is used only for test purpose. We use this to recheck if
     * parental control is enabled or not.
     */
    readonly reloadParentalControlEnabled: () => void;

    /**
     * @return the hostname of the operating system.
     */
    readonly myHostName: IDLAUTF8String;
  }

  export interface nsIProfileMigratorRef {
    readonly name: "nsIProfileMigrator";
    readonly number: "{3df284a5-2258-4d46-a664-761ecdc04c22}";
  }

  /**
   * Migrate application settings from an outside source.
   *
   * @provider Application (Profile-migration code)
   * @client   Toolkit (Startup code)
   * @obtainable service, contractid("@mozilla.org/toolkit/profile-migrator;1")
   */
  export interface nsIProfileMigrator extends nsISupports {

    /**
     * Migrate data from an outside source, if possible.  Does nothing
     * otherwise.
     *
     * When this method is called, a default profile has been created;
     * XPCOM has been initialized such that compreg.dat is in the
     * profile; the directory service does *not* return a key for
     * NS_APP_USER_PROFILE_50_DIR or any of the keys depending on an active
     * profile. To figure out the directory of the "current" profile, use
     * aStartup.directory.
     *
     * If your migrator needs to access services that use the profile (to
     * set profile prefs or bookmarks, for example), use aStartup.doStartup.
     *
     * @param  aStartup nsIProfileStartup object to use during migration.
     * @param  aKey     optional key of a migrator to use to skip source selection.
     * @param  aProfileName optional name of the profile to use for migration.
     *
     * @note The startup code ignores COM exceptions thrown from this method.
     */
    readonly migrate: (aStartup: (nsIProfileStartup | null), aKey: IDLACString, aProfileName?: IDLAUTF8String) => void;
  }

  export interface nsIWellKnownOpportunisticUtilsRef {
    readonly name: "nsIWellKnownOpportunisticUtils";
    readonly number: "{b4f96c89-5238-450c-8bda-e12c26f1d150}";
  }

  export interface nsIWellKnownOpportunisticUtils extends nsISupports {

    readonly verify: (aJSON: IDLACString, aOrigin: IDLACString) => void;

    readonly valid: boolean;
  }

  export interface nsIURIWithSpecialOriginRef {
    readonly name: "nsIURIWithSpecialOrigin";
    readonly number: "{4f65569b-d6fc-4580-94d9-21e775658a2a}";
  }

  /**
   * nsIURIWithSpecialOrigin is implemented by URIs need to supply an origin that
   * does not match the spec. This is exclusively used in comm-central's Mailnews module.
   */
  export interface nsIURIWithSpecialOrigin extends nsISupports {

    /**
     * Special origin.
     */
    readonly origin: (nsIURI | null);
  }

  export interface nsIScriptableUnicodeConverterRef {
    readonly name: "nsIScriptableUnicodeConverter";
    readonly number: "{f36ee324-5c1c-437f-ba10-2b4db7a18031}";
  }

  /**
   * In new code, please use the WebIDL TextDecoder and TextEncoder
   * instead. They represent bytes as Uint8Array (or as view to such
   * array), which is the current best practice for representing bytes
   * in JavaScript.
   *
   * This interface converts between UTF-16 in JavaScript strings
   * and bytes transported as the unsigned value of each byte
   * transported in a code unit of the same numeric value in
   * a JavaScript string.
   *
   * @created         8/Jun/2000
   * @author          Makoto Kato [m_kato@ga2.so-net.ne.jp]
   */
  export interface nsIScriptableUnicodeConverter extends nsISupports {

    /**
     * Converts the data from Unicode to one Charset.
     * Returns the converted string. After converting, Finish should be called
     * and its return value appended to this return value.
     */
    readonly ConvertFromUnicode: (aSrc: IDLAString) => IDLACString;

    /**
     * Returns the terminator string.
     * Should be called after ConvertFromUnicode() and appended to that
     * function's return value.
     */
    readonly Finish: () => IDLACString;

    /**
     * Converts the data from one Charset to Unicode.
     */
    readonly ConvertToUnicode: (aSrc: IDLACString) => IDLAString;

    /**
     * Convert a unicode string to an array of bytes. Finish does not need to be
     * called.
     */
    readonly convertToByteArray: (aString: IDLAString, aLen?: Out<number>) => number[];

    /**
     * Converts a unicode string to an input stream. The bytes in the stream are
     * encoded according to the charset attribute.
     * The returned stream will be nonblocking.
     */
    readonly convertToInputStream: (aString: IDLAString) => (nsIInputStream | null);

    /**
     * Current character set.
     *
     * @throw NS_ERROR_UCONV_NOCONV
     *        The requested charset is not supported.
     */
    charset: IDLACString;

    /**
     * Meaningless
     */
    isInternal: boolean;
  }

  export interface nsIScriptErrorRef {
    readonly name: "nsIScriptError";
    readonly number: "{63eb4d3e-7d99-4150-b4f3-11314f9d82a9}";

    /** pseudo-flag for default case */
    errorFlag: 0;

    /** message is warning */
    warningFlag: 1;

    /** exception was thrown for this case - exception-aware hosts can ignore */
    exceptionFlag: 2;

    /** error or warning is due to strict option */
    strictFlag: 4;

    /** just a log message */
    infoFlag: 8;
  }

  export interface nsIScriptError extends nsIConsoleMessage {

    /**
     * The error message without any context/line number information.
     *
     * @note nsIConsoleMessage.message will return the error formatted
     *       with file/line information.
     */
    readonly errorMessage: IDLAString;

    readonly sourceName: IDLAString;

    readonly sourceLine: IDLAString;

    /**
     * Unique identifier within the process for the script source this error is
     * associated with, or zero.
     */
    readonly sourceId: number;

    readonly lineNumber: number;

    readonly columnNumber: number;

    readonly flags: number;

    /**
     * Categories I know about -
     * XUL javascript
     * content javascript (both of these from nsDocShell, currently)
     * system javascript (errors in JS components and other system JS)
     */
    readonly category: string;

    readonly outerWindowID: number;

    readonly innerWindowID: number;

    readonly isFromPrivateWindow: boolean;

    readonly isFromChromeContext: boolean;

    stack: IDLjsval;

    /**
     * The name of a template string, as found in js.msg, associated with the
     * error message.
     */
    errorMessageName: IDLAString;

    readonly notes: (nsIArray | null);

    /**
     * If we are recording or replaying, this value may identify the point
     * where the error was generated, otherwise zero.
     */
    timeWarpTarget: number;

    /**
     * If the ScriptError is a CSS parser error, this value will contain the
     * CSS selectors of the CSS ruleset where the error occured.
     */
    cssSelectors: IDLAString;

    readonly init: (message: IDLAString, sourceName: IDLAString, sourceLine: IDLAString, lineNumber: number, columnNumber: number, flags: number, category: string, fromPrivateWindow?: boolean, fromChromeContext?: boolean) => void;

    readonly initWithWindowID: (message: IDLAString, sourceName: IDLAString, sourceLine: IDLAString, lineNumber: number, columnNumber: number, flags: number, category: IDLACString, innerWindowID: number, fromChromeContext?: boolean) => void;

    readonly initWithSanitizedSource: (message: IDLAString, sourceName: IDLAString, sourceLine: IDLAString, lineNumber: number, columnNumber: number, flags: number, category: IDLACString, innerWindowID: number, fromChromeContext?: boolean) => void;

    readonly initWithSourceURI: (message: IDLAString, sourceURI: (nsIURI | null), sourceLine: IDLAString, lineNumber: number, columnNumber: number, flags: number, category: IDLACString, innerWindowID: number, fromChromeContext?: boolean) => void;

    readonly initSourceId: (sourceId: number) => void;
  }

  export interface nsIQuotaCallbackRef {
    readonly name: "nsIQuotaCallback";
    readonly number: "{a08a28e2-5a74-4c84-8070-ed45a07eb013}";
  }

  type nsIQuotaCallbackFunction = (aRequest: (nsIQuotaRequest | null)) => void;

  export interface nsIQuotaCallback extends nsISupports {

    readonly onComplete: (aRequest: (nsIQuotaRequest | null)) => void;
  }

  export interface nsILocalCertGetCallbackRef {
    readonly name: "nsILocalCertGetCallback";
    readonly number: "{cc09633e-7c70-4093-a9cf-79ab676ca8a9}";
  }

  export interface nsILocalCertGetCallback extends nsISupports {

    /**
     * Called with the result of the getOrCreateCert operation above.
     *
     * @param cert   Requested cert, or null if some error
     * @param result Result code from the get operation
     */
    readonly handleCert: (cert: (nsIX509Cert | null), result: number) => void;
  }

  export interface nsIInputStreamRef {
    readonly name: "nsIInputStream";
    readonly number: "{53cdbc97-c2d7-4e30-b2c3-45b2ee79db18}";
  }

  export interface nsIInputStream extends nsISupports {

    /**
     * nsIInputStream
     *
     * An interface describing a readable stream of data.  An input stream may be
     * "blocking" or "non-blocking" (see the IsNonBlocking method).  A blocking
     * input stream may suspend the calling thread in order to satisfy a call to
     * Close, Available, Read, or ReadSegments.  A non-blocking input stream, on
     * the other hand, must not block the calling thread of execution.
     *
     * NOTE: blocking input streams are often read on a background thread to avoid
     * locking up the main application thread.  For this reason, it is generally
     * the case that a blocking input stream should be implemented using thread-
     * safe AddRef and Release.
     */
    /**
     * Close the stream.  This method causes subsequent calls to Read and
     * ReadSegments to return 0 bytes read to indicate end-of-file.  Any
     * subsequent calls to Available should throw NS_BASE_STREAM_CLOSED.
     */
    readonly close: () => void;

    /**
     * Determine number of bytes available in the stream.  A non-blocking
     * stream that does not yet have any data to read should return 0 bytes
     * from this method (i.e., it must not throw the NS_BASE_STREAM_WOULD_BLOCK
     * exception).
     *
     * In addition to the number of bytes available in the stream, this method
     * also informs the caller of the current status of the stream.  A stream
     * that is closed will throw an exception when this method is called.  That
     * enables the caller to know the condition of the stream before attempting
     * to read from it.  If a stream is at end-of-file, but not closed, then
     * this method returns 0 bytes available.  (Note: some nsIInputStream
     * implementations automatically close when eof is reached; some do not).
     *
     * @return number of bytes currently available in the stream.
     *
     * @throws NS_BASE_STREAM_CLOSED if the stream is closed normally.
     * @throws <other-error> if the stream is closed due to some error
     *   condition
     */
    readonly available: () => number;

    /**
     * @return true if stream is non-blocking
     *
     * NOTE: reading from a blocking input stream will block the calling thread
     * until at least one byte of data can be extracted from the stream.
     *
     * NOTE: a non-blocking input stream may implement nsIAsyncInputStream to
     * provide consumers with a way to wait for the stream to have more data
     * once its read method is unable to return any data without blocking.
     */
    readonly isNonBlocking: () => boolean;
  }

  export interface nsILayoutHistoryStateRef {
    readonly name: "nsILayoutHistoryState";
    readonly number: "{aef27cb3-4df9-4eeb-b0b0-ac56cf861d04}";
  }

  export interface nsILayoutHistoryState extends nsISupports {

    /**
     * Whether this LayoutHistoryState contains any PresStates.
     */
    readonly hasStates: boolean;

    /**
     * Get the keys of all PresStates held by this LayoutHistoryState.
     * Note: Check hasStates first.
     */
    readonly getKeys: () => IDLACString[];

    readonly getPresState: (aKey: IDLACString, aScrollX: Out<number>, aScrollY: Out<number>, aAllowScrollOriginDowngrade: Out<boolean>, aRes: Out<number>) => void;

    /**
     * Constructs a new PresState object based on the supplied data
     * and adds it to the LayoutHistoryState.
     */
    readonly addNewPresState: (aKey: IDLACString, aScrollX: number, aScrollY: number, aAllowScrollOriginDowngrade: boolean, aRes: number) => void;
  }

  export interface nsIDOMGlobalPropertyInitializerRef {
    readonly name: "nsIDOMGlobalPropertyInitializer";
    readonly number: "{5842e275-797f-4afb-b7e0-e29f0cb312ae}";
  }

  export interface nsIDOMGlobalPropertyInitializer extends nsISupports {

    readonly init: (window: (mozIDOMWindow | null)) => IDLjsval;
  }

  export interface nsIPaymentMethodDataRef {
    readonly name: "nsIPaymentMethodData";
    readonly number: "{2fe296cc-d917-4820-b492-aa42df23f9b4}";
  }

  export interface nsIPaymentMethodData extends nsISupports {

    readonly supportedMethods: IDLAString;

    readonly data: IDLjsval;
  }

  export interface nsIContentPermissionRequestCallbackRef {
    readonly name: "nsIContentPermissionRequestCallback";
    readonly number: "{5fb5bb60-7069-11e4-9803-0800200c9a66}";
  }

  /**
   *  Interface provides the callback type.
   */
  export interface nsIContentPermissionRequestCallback extends nsISupports {

    /**
     * The callback of the visibility result.
     */
    readonly notifyVisibility: (isVisible: boolean) => void;
  }

  export interface nsIBFCacheEntryRef {
    readonly name: "nsIBFCacheEntry";
    readonly number: "{a576060e-c7df-4d81-aa8c-5b52bd6ad25d}";
  }

  /**
   * This interface lets you evict a document from the back/forward cache.
   */
  export interface nsIBFCacheEntry extends nsISupports {

    readonly RemoveFromBFCacheSync: () => void;

    readonly RemoveFromBFCacheAsync: () => void;
  }

  export enum nsIContentViewer_PrefersColorScheme {
    PREFERS_COLOR_SCHEME_LIGHT = 0,
    PREFERS_COLOR_SCHEME_DARK = 1,
    PREFERS_COLOR_SCHEME_NO_PREFERENCE = 2,
    PREFERS_COLOR_SCHEME_NONE = 3,
  }

  export interface nsIContentViewerRef {
    readonly name: "nsIContentViewer";
    readonly number: "{2da17016-7851-4a45-a7a8-00b360e01595}";

    PREFERS_COLOR_SCHEME_LIGHT: 0;
    PREFERS_COLOR_SCHEME_DARK: 1;
    PREFERS_COLOR_SCHEME_NO_PREFERENCE: 2;
    PREFERS_COLOR_SCHEME_NONE: 3;

    /**
     * aPermitUnloadFlags are passed to PermitUnload to indicate what action to take
     * if a beforeunload handler wants to prompt the user.  It is also used by
     * permitUnloadInternal to ensure we only prompt once.
     *
     * ePrompt: Prompt and return the user's choice (default).
     * eDontPromptAndDontUnload: Don't prompt and return false (unload not permitted)
     *                           if the document (or its children) asks us to prompt.
     * eDontPromptAndUnload: Don't prompt and return true (unload permitted) no matter what.
     */
    ePrompt: 0;

    eDontPromptAndDontUnload: 1;

    eDontPromptAndUnload: 2;

    /**
     * The 'aFlags' argument to setBoundsWithFlags is a set of these bits.
     */
    eDelayResize: 1;
  }

  export interface nsIContentViewer extends nsISupports {

    container: (nsIDocShell | null);

    readonly loadComplete: (aStatus: number) => void;

    /**
     * Overload PermitUnload method for C++ consumers with no aPermitUnloadFlags
     * argument.
     */
    /**
     * Checks if the document wants to prevent unloading by firing beforeunload on
     * the document, and if it does, takes action directed by aPermitUnloadFlags.
     * The result is returned.
     */
    readonly permitUnload: (aPermitUnloadFlags?: number) => boolean;

    /**
     * Exposes whether we're blocked in a call to permitUnload.
     */
    readonly inPermitUnload: boolean;

    /**
     * Exposes whether we're in the process of firing the beforeunload event.
     * In this case, the corresponding docshell will not allow navigation.
     */
    readonly beforeUnloadFiring: boolean;

    readonly pageHide: (isUnload: boolean) => void;

    /**
     * All users of a content viewer are responsible for calling both
     * close() and destroy(), in that order.
     *
     * close() should be called when the load of a new page for the next
     * content viewer begins, and destroy() should be called when the next
     * content viewer replaces this one.
     *
     * |historyEntry| sets the session history entry for the content viewer.  If
     * this is null, then Destroy() will be called on the document by close().
     * If it is non-null, the document will not be destroyed, and the following
     * actions will happen when destroy() is called (*):
     *  - Sanitize() will be called on the viewer's document
     *  - The content viewer will set the contentViewer property on the
     *    history entry, and release its reference (ownership reversal).
     *  - hide() will be called, and no further destruction will happen.
     *
     *  (*) unless the document is currently being printed, in which case
     *      it will never be saved in session history.
     *
     */
    readonly close: (historyEntry: (nsISHEntry | null)) => void;

    readonly destroy: () => void;

    readonly stop: () => void;

    /**
     * Returns the same thing as getDocument(), but for use from script
     * only.  C++ consumers should use getDocument().
     */
    readonly DOMDocument: WebIDL.Document;

    readonly move: (aX: number, aY: number) => void;

    readonly show: () => void;

    readonly hide: () => void;

    sticky: boolean;

    readonly requestWindowClose: () => boolean;

    /**
     * Attach the content viewer to its DOM window and docshell.
     * @param aState A state object that might be useful in attaching the DOM
     *               window.
     * @param aSHEntry The history entry that the content viewer was stored in.
     *                 The entry must have the docshells for all of the child
     *                 documents stored in its child shell list.
     */
    readonly open: (aState: (nsISupports | null), aSHEntry: (nsISHEntry | null)) => void;

    /**
     * Clears the current history entry.  This is used if we need to clear out
     * the saved presentation state.
     */
    readonly clearHistoryEntry: () => void;

    /**
     * Change the layout to view the document with page layout (like print preview), but
     * dynamic and editable (like Galley layout).
     */
    readonly setPageModeForTesting: (aPageMode: boolean, aPrintSettings: (nsIPrintSettings | null)) => void;

    /**
     * Get the history entry that this viewer will save itself into when
     * destroyed.  Can return null
     */
    readonly historyEntry: (nsISHEntry | null);

    /**
     * Indicates when we're in a state where content shouldn't be allowed to
     * trigger a tab-modal prompt (as opposed to a window-modal prompt) because
     * we're part way through some operation (eg beforeunload) that shouldn't be
     * rentrant if the user closes the tab while the prompt is showing.
     * See bug 613800.
     */
    readonly isTabModalPromptAllowed: boolean;

    /**
     * Returns whether this content viewer is in a hidden state.
     *
     * @note Only Gecko internal code should set the attribute!
     */
    isHidden: boolean;

    /** The amount by which to scale all text. Default is 1.0. */
    textZoom: number;

    /** The actual text zoom in effect, as modified by the system font scale. */
    readonly effectiveTextZoom: number;

    /** The amount by which to scale all lengths. Default is 1.0. */
    fullZoom: number;

    /**
     * The actual full zoom in effect, as modified by the device context.
     * For a requested full zoom, the device context may choose a slightly
     * different effectiveFullZoom to accomodate integer rounding of app units
     * per dev pixel. This property returns the actual zoom amount in use,
     * though it may not be good user experience to report that a requested zoom
     * of 90% is actually 89.1%, for example. This value is provided primarily to
     * support media queries of dppx values, because those queries are matched
     * against the actual native device pixel ratio and the actual full zoom.
     */
    readonly deviceFullZoom: number;

    /**
     * The value used to override devicePixelRatio and media queries dppx.
     * Default is 0.0, that means no overriding is done (only a positive value
     * is applied).
     */
    overrideDPPX: number;

    /** Disable entire author style level (including HTML presentation hints) */
    authorStyleDisabled: boolean;

    /**
     * XXX comm-central only: bug 829543. Not the Character Encoding menu in
     * browser!
     */
    forceCharacterSet: IDLACString;

    /**
     * XXX comm-central only: bug 829543.
     */
    hintCharacterSet: IDLACString;

    /**
     * XXX comm-central only: bug 829543.
     */
    hintCharacterSetSource: number;

    /**
     * Requests the size of the content to the container.
     */
    readonly getContentSize: (width: Out<number>, height: Out<number>) => void;

    /**
     * Returns the preferred width and height of the content, constrained to the
     * given maximum values. If either maxWidth or maxHeight is less than zero,
     * that dimension is not constrained.
     *
     * All input and output values are in device pixels, rather than CSS pixels.
     */
    readonly getContentSizeConstrained: (maxWidth: number, maxHeight: number, width: Out<number>, height: Out<number>) => void;

    /**
     * Instruct the refresh driver to discontinue painting until further
     * notice.
     */
    readonly pausePainting: () => void;

    /**
     * Instruct the refresh driver to resume painting after a previous call to
     * pausePainting().
     */
    readonly resumePainting: () => void;

    readonly emulateMedium: (aMediaType: IDLAString) => void;

    readonly stopEmulatingMedium: () => void;

    readonly emulatePrefersColorScheme: (aPrefersColorScheme: nsIContentViewer_PrefersColorScheme) => void;
  }

  export interface nsITransactionRef {
    readonly name: "nsITransaction";
    readonly number: "{58e330c1-7b48-11d2-98b9-00805f297d89}";
  }

  export interface nsITransaction extends nsISupports {

    /**
     * Executes the transaction.
     */
    readonly doTransaction: () => void;

    /**
     * Restores the state to what it was before the transaction was executed.
     */
    readonly undoTransaction: () => void;

    /**
     * Executes the transaction again. Can only be called on a transaction that
     * was previously undone.
     * <P>
     * In most cases, the redoTransaction() method will actually call the
     * doTransaction() method to execute the transaction again.
     */
    readonly redoTransaction: () => void;

    /**
     * The transaction's transient state. This attribute is checked by
     * the transaction manager after the transaction's Execute() method is called.
     * If the transient state is false, a reference to the transaction is
     * held by the transaction manager so that the transactions' undoTransaction()
     * and redoTransaction() methods can be called. If the transient state is
     * true, the transaction manager returns immediately after the transaction's
     * doTransaction() method is called, no references to the transaction are
     * maintained. Transient transactions cannot be undone or redone by the
     * transaction manager.
     */
    readonly isTransient: boolean;

    /**
     * Attempts to merge a transaction into "this" transaction. Both transactions
     * must be in their undo state, doTransaction() methods already called. The
     * transaction manager calls this method to coalesce a new transaction with
     * the transaction on the top of the undo stack.
     * This method returns a boolean value that indicates the merge result.
     * A true value indicates that the transactions were merged successfully,
     * a false value if the merge was not possible or failed. If true,
     * the transaction manager will Release() the new transacton instead of
     * pushing it on the undo stack.
     * @param aTransaction the previously executed transaction to merge.
     */
    readonly merge: (aTransaction: (nsITransaction | null)) => boolean;
  }

  export interface nsISupportsInterfacePointerRef {
    readonly name: "nsISupportsInterfacePointer";
    readonly number: "{995ea724-1dd1-11b2-9211-c21bdd3e7ed0}";
  }

  /**
   * Scriptable storage for other XPCOM objects
   */
  export interface nsISupportsInterfacePointer extends nsISupportsPrimitive {

    data: (nsISupports | null);

    readonly toString: () => string;
  }

  export interface nsIPaymentCanMakeActionResponseRef {
    readonly name: "nsIPaymentCanMakeActionResponse";
    readonly number: "{52fc3f9f-c0cb-4874-b3d4-ee4b6e9cbe9c}";
  }

  /**
   *  The response for canMakePayment action.
   */
  export interface nsIPaymentCanMakeActionResponse extends nsIPaymentActionResponse {

    /**
     *  The result of canMakePayment action.
     */
    readonly result: boolean;

    /**
     *  The initial method.
     *  @param aRequestId - the request identifier of the payment request.
     *  @param aResult - the canMakePayment result.
     */
    readonly init: (aRequestId: IDLAString, aResult: boolean) => void;
  }

  export interface nsIDBusHandlerAppRef {
    readonly name: "nsIDBusHandlerApp";
    readonly number: "{1ffc274b-4cbf-4bb5-a635-05ad2cbb6534}";
  }

  /**
   * nsIDBusHandlerApp represents local applications launched by DBus a message
   * invoking a method taking a single string argument descibing a URI
   */
  export interface nsIDBusHandlerApp extends nsIHandlerApp {

    /**
     * Service defines the dbus service that should handle this protocol.
     * If its not set,  NS_ERROR_FAILURE will be returned by LaunchWithURI
     */
    service: IDLAUTF8String;

    /**
     * Objpath defines the object path of the dbus service that should handle
     * this protocol. If its not set,  NS_ERROR_FAILURE will be returned
     * by LaunchWithURI
     */
    objectPath: IDLAUTF8String;

    /**
     * DBusInterface defines the interface of the dbus service that should
     * handle this protocol. If its not set,  NS_ERROR_FAILURE will be
     * returned by LaunchWithURI
     */
    dBusInterface: IDLAUTF8String;

    /**
     * Method defines the dbus method that should be invoked to handle this
     * protocol. If its not set,  NS_ERROR_FAILURE will be returned by
     * LaunchWithURI
     */
    method: IDLAUTF8String;
  }

  export interface nsIJSRAIIHelperRef {
    readonly name: "nsIJSRAIIHelper";
    readonly number: "{52e5a996-d0a9-4efc-a6fa-24489c532b19}";
  }

  export interface nsIJSRAIIHelper extends nsISupports {

    /**
     * JS doesn't do RAII very well. We can use this interface to make remembering
     * to destruct an object in a finally clause easier.
     */
    readonly destruct: () => void;
  }

  export interface nsIWebProgressListenerRef {
    readonly name: "nsIWebProgressListener";
    readonly number: "{a9df523b-efe2-421e-9d8e-3d7f807dda4c}";

    /**
     * State Transition Flags
     *
     * These flags indicate the various states that requests may transition
     * through as they are being loaded.  These flags are mutually exclusive.
     *
     * For any given request, onStateChange is called once with the STATE_START
     * flag, zero or more times with the STATE_TRANSFERRING flag or once with the
     * STATE_REDIRECTING flag, and then finally once with the STATE_STOP flag.
     * NOTE: For document requests, a second STATE_STOP is generated (see the
     * description of STATE_IS_WINDOW for more details).
     *
     * STATE_START
     *   This flag indicates the start of a request.  This flag is set when a
     *   request is initiated.  The request is complete when onStateChange is
     *   called for the same request with the STATE_STOP flag set.
     *
     * STATE_REDIRECTING
     *   This flag indicates that a request is being redirected.  The request
     *   passed to onStateChange is the request that is being redirected.  When a
     *   redirect occurs, a new request is generated automatically to process the
     *   new request.  Expect a corresponding STATE_START event for the new
     *   request, and a STATE_STOP for the redirected request.
     *
     * STATE_TRANSFERRING
     *   This flag indicates that data for a request is being transferred to an
     *   end consumer.  This flag indicates that the request has been targeted,
     *   and that the user may start seeing content corresponding to the request.
     *
     * STATE_NEGOTIATING
     *   This flag is not used.
     *
     * STATE_STOP
     *   This flag indicates the completion of a request.  The aStatus parameter
     *   to onStateChange indicates the final status of the request.
     */
    STATE_START: 1;

    STATE_REDIRECTING: 2;

    STATE_TRANSFERRING: 4;

    STATE_NEGOTIATING: 8;

    STATE_STOP: 16;

    /**
     * State Type Flags
     *
     * These flags further describe the entity for which the state transition is
     * occuring.  These flags are NOT mutually exclusive (i.e., an onStateChange
     * event may indicate some combination of these flags).
     *
     * STATE_IS_REQUEST
     *   This flag indicates that the state transition is for a request, which
     *   includes but is not limited to document requests.  (See below for a
     *   description of document requests.)  Other types of requests, such as
     *   requests for inline content (e.g., images and stylesheets) are
     *   considered normal requests.
     *
     * STATE_IS_DOCUMENT
     *   This flag indicates that the state transition is for a document request.
     *   This flag is set in addition to STATE_IS_REQUEST.  A document request
     *   supports the nsIChannel interface and its loadFlags attribute includes
     *   the nsIChannel::LOAD_DOCUMENT_URI flag.
     *
     *   A document request does not complete until all requests associated with
     *   the loading of its corresponding document have completed.  This includes
     *   other document requests (e.g., corresponding to HTML <iframe> elements).
     *   The document corresponding to a document request is available via the
     *   DOMWindow attribute of onStateChange's aWebProgress parameter.
     *
     * STATE_IS_NETWORK
     *   This flag indicates that the state transition corresponds to the start
     *   or stop of activity in the indicated nsIWebProgress instance.  This flag
     *   is accompanied by either STATE_START or STATE_STOP, and it may be
     *   combined with other State Type Flags.
     *
     *   Unlike STATE_IS_WINDOW, this flag is only set when activity within the
     *   nsIWebProgress instance being observed starts or stops.  If activity
     *   only occurs in a child nsIWebProgress instance, then this flag will be
     *   set to indicate the start and stop of that activity.
     *
     *   For example, in the case of navigation within a single frame of a HTML
     *   frameset, a nsIWebProgressListener instance attached to the
     *   nsIWebProgress of the frameset window will receive onStateChange calls
     *   with the STATE_IS_NETWORK flag set to indicate the start and stop of
     *   said navigation.  In other words, an observer of an outer window can
     *   determine when activity, that may be constrained to a child window or
     *   set of child windows, starts and stops.
     *
     * STATE_IS_WINDOW
     *   This flag indicates that the state transition corresponds to the start
     *   or stop of activity in the indicated nsIWebProgress instance.  This flag
     *   is accompanied by either STATE_START or STATE_STOP, and it may be
     *   combined with other State Type Flags.
     *
     *   This flag is similar to STATE_IS_DOCUMENT.  However, when a document
     *   request completes, two onStateChange calls with STATE_STOP are
     *   generated.  The document request is passed as aRequest to both calls.
     *   The first has STATE_IS_REQUEST and STATE_IS_DOCUMENT set, and the second
     *   has the STATE_IS_WINDOW flag set (and possibly the STATE_IS_NETWORK flag
     *   set as well -- see above for a description of when the STATE_IS_NETWORK
     *   flag may be set).  This second STATE_STOP event may be useful as a way
     *   to partition the work that occurs when a document request completes.
     *
     * STATE_IS_REDIRECTED_DOCUMENT
     *  Same as STATE_IS_DOCUMENT, but sent only after a redirect has occured.
     *  Introduced in order not to confuse existing code with extra state change
     *  events. See |nsDocLoader::OnStartRequest| for more info.
     */
    STATE_IS_REQUEST: 65536;

    STATE_IS_DOCUMENT: 131072;

    STATE_IS_NETWORK: 262144;

    STATE_IS_WINDOW: 524288;

    STATE_IS_REDIRECTED_DOCUMENT: 1048576;

    /**
     * State Modifier Flags
     *
     * These flags further describe the transition which is occuring.  These
     * flags are NOT mutually exclusive (i.e., an onStateChange event may
     * indicate some combination of these flags).
     *
     * STATE_RESTORING
     *   This flag indicates that the state transition corresponds to the start
     *   or stop of activity for restoring a previously-rendered presentation.
     *   As such, there is no actual network activity associated with this
     *   request, and any modifications made to the document or presentation
     *   when it was originally loaded will still be present.
     */
    STATE_RESTORING: 16777216;

    /**
     * State Security Flags
     *
     * These flags describe the security state reported by a call to the
     * onSecurityChange method.  These flags are mutually exclusive.
     *
     * STATE_IS_INSECURE
     *   This flag indicates that the data corresponding to the request
     *   was received over an insecure channel.
     *
     * STATE_IS_BROKEN
     *   This flag indicates an unknown security state.  This may mean that the
     *   request is being loaded as part of a page in which some content was
     *   received over an insecure channel.
     *
     * STATE_IS_SECURE
     *   This flag indicates that the data corresponding to the request was
     *   received over a secure channel.  The degree of security is expressed by
     *   STATE_SECURE_HIGH, STATE_SECURE_MED, or STATE_SECURE_LOW.
     */
    STATE_IS_INSECURE: 4;

    STATE_IS_BROKEN: 1;

    STATE_IS_SECURE: 2;

    /**
     * Mixed active content flags
     *
     * NOTE: IF YOU ARE ADDING MORE OF THESE FLAGS, MAKE SURE TO EDIT
     * nsSecureBrowserUIImpl::CheckForBlockedContent().
     *
     * May be set in addition to the State Security Flags, to indicate that
     * mixed active content has been encountered.
     *
     * STATE_BLOCKED_MIXED_ACTIVE_CONTENT
     *   Mixed active content has been blocked from loading.
     *
     * STATE_LOADED_MIXED_ACTIVE_CONTENT
     *   Mixed active content has been loaded. State should be STATE_IS_BROKEN.
     */
    STATE_BLOCKED_MIXED_ACTIVE_CONTENT: 16;

    STATE_LOADED_MIXED_ACTIVE_CONTENT: 32;

    /**
     * Mixed display content flags
     *
     * NOTE: IF YOU ARE ADDING MORE OF THESE FLAGS, MAKE SURE TO EDIT
     * nsSecureBrowserUIImpl::CheckForBlockedContent().
     *
     * May be set in addition to the State Security Flags, to indicate that
     * mixed display content has been encountered.
     *
     * STATE_BLOCKED_MIXED_DISPLAY_CONTENT
     *   Mixed display content has been blocked from loading.
     *
     * STATE_LOADED_MIXED_DISPLAY_CONTENT
     *   Mixed display content has been loaded. State should be STATE_IS_BROKEN.
     */
    STATE_BLOCKED_MIXED_DISPLAY_CONTENT: 256;

    STATE_LOADED_MIXED_DISPLAY_CONTENT: 512;

    /**
     * Diagnostic flags
     *
     * NOTE: IF YOU ARE ADDING MORE OF THESE FLAGS, MAKE SURE TO EDIT
     * nsSecureBrowserUIImpl::CheckForBlockedContent().
     *
     * May be set in addition to other security state flags to indicate that
     * some state is countered that deserves a warning or error, but does not
     * change the top level security state of the connection.
     *
     * STATE_CERT_DISTRUST_IMMINENT
     *   The certificate in use will be distrusted in the near future.
     */
    STATE_CERT_DISTRUST_IMMINENT: 65536;

    /**
     * State bits for EV == Extended Validation == High Assurance
     *
     * These flags describe the level of identity verification
     * in a call to the onSecurityChange method.
     *
     * STATE_IDENTITY_EV_TOPLEVEL
     *   The topmost document uses an EV cert.
     *   NOTE: Available since Gecko 1.9
     */
    STATE_IDENTITY_EV_TOPLEVEL: 1048576;

    /**
     * Broken state flags
     *
     * These flags describe the reason of the broken state.
     *
     * STATE_USES_SSL_3
     *   The topmost document uses SSL 3.0.
     *
     * STATE_USES_WEAK_CRYPTO
     *   The topmost document uses a weak cipher suite such as RC4.
     *
     * STATE_CERT_USER_OVERRIDDEN
     *   The user has added a security exception for the site.
     */
    STATE_USES_SSL_3: 16777216;

    STATE_USES_WEAK_CRYPTO: 33554432;

    STATE_CERT_USER_OVERRIDDEN: 67108864;

    /**
     * Content Blocking Event flags
     *
     * NOTE: IF YOU ARE ADDING MORE OF THESE FLAGS, MAKE SURE TO EDIT
     * nsSecureBrowserUIImpl::CheckForBlockedContent() AND UPDATE THE
     * CORRESPONDING LIST IN ContentBlockingController.java
     *
     * These flags describe the reason of cookie jar rejection.
     *
     * STATE_BLOCKED_TRACKING_CONTENT
     *   Tracking content has been blocked from loading.
     *
     * STATE_LOADED_LEVEL_1_TRACKING_CONTENT
     *   Tracking content from the Disconnect Level 1 list has been loaded.
     *
     * STATE_LOADED_LEVEL_2_TRACKING_CONTENT
     *   Tracking content from the Disconnect Level 2 list has been loaded.
     *
     * STATE_BLOCKED_FINGERPRINTING_CONTENT
     *   Fingerprinting content has been blocked from loading.
     *
     * STATE_LOADED_FINGERPRINTING_CONTENT
     *   Fingerprinting content has been loaded.
     *
     * STATE_BLOCKED_CRYPTOMINING_CONTENT
     *   Cryptomining content has been blocked from loading.
     *
     * STATE_LOADED_CRYPTOMINING_CONTENT
     *   Cryptomining content has been loaded.
     *
     * STATE_BLOCKED_UNSAFE_CONTENT
     *   Content which againts SafeBrowsing list has been blocked from loading.
     *
     * STATE_COOKIES_LOADED
     *   Performed a storage access check, which usually means something like a
     *   cookie or a storage item was loaded/stored on the current tab.
     *   Alternatively this could indicate that something in the current tab
     *   attempted to communicate with its same-origin counterparts in other
     *   tabs.
     *
     * STATE_COOKIES_LOADED_TRACKER
     *   Similar to STATE_COOKIES_LOADED, but only sent if the subject of the
     *   action was a third-party tracker when the active cookie policy imposes
     *   restrictions on such content.
     *
     * STATE_COOKIES_LOADED_SOCIALTRACKER
     *   Similar to STATE_COOKIES_LOADED, but only sent if the subject of the
     *   action was a third-party social tracker when the active cookie policy
     *   imposes restrictions on such content.
     *
     * STATE_COOKIES_BLOCKED_BY_PERMISSION
     *   Rejected for custom site permission.
     *
     * STATE_COOKIES_BLOCKED_TRACKER
     *   Rejected because the resource is a tracker and cookie policy doesn't
     *   allow its loading.
     *
     * STATE_COOKIES_BLOCKED_SOCIALTRACKER
     *   Rejected because the resource is a tracker from a social origin and
     *   cookie policy doesn't allow its loading.
     *
     * STATE_COOKIES_PARTITIONED_FOREIGN
     *   Rejected because the resource is a third-party and cookie policy forces
     *   third-party resources to be partitioned.
     *
     * STATE_COOKIES_BLOCKED_ALL
     *   Rejected because cookie policy blocks all cookies.
     *
     * STATE_COOKIES_BLOCKED_FOREIGN
     *   Rejected because cookie policy blocks 3rd party cookies.
     *
     * STATE_BLOCKED_SOCIALTRACKING_CONTENT
     *   SocialTracking content has been blocked from loading.
     *
     * STATE_LOADED_SOCIALTRACKING_CONTENT
     *   SocialTracking content has been loaded.
     */
    STATE_BLOCKED_TRACKING_CONTENT: 4096;

    STATE_LOADED_LEVEL_1_TRACKING_CONTENT: 8192;

    STATE_LOADED_LEVEL_2_TRACKING_CONTENT: 1048576;

    STATE_BLOCKED_FINGERPRINTING_CONTENT: 64;

    STATE_LOADED_FINGERPRINTING_CONTENT: 1024;

    STATE_BLOCKED_CRYPTOMINING_CONTENT: 2048;

    STATE_LOADED_CRYPTOMINING_CONTENT: 2097152;

    STATE_BLOCKED_UNSAFE_CONTENT: 16384;

    STATE_COOKIES_LOADED: 32768;

    STATE_COOKIES_LOADED_TRACKER: 262144;

    STATE_COOKIES_LOADED_SOCIALTRACKER: 524288;

    STATE_COOKIES_BLOCKED_BY_PERMISSION: 268435456;

    STATE_COOKIES_BLOCKED_TRACKER: 536870912;

    STATE_COOKIES_BLOCKED_SOCIALTRACKER: 16777216;

    STATE_COOKIES_BLOCKED_ALL: 1073741824;

    STATE_COOKIES_PARTITIONED_FOREIGN: 2147483648;

    STATE_COOKIES_BLOCKED_FOREIGN: 128;

    STATE_BLOCKED_SOCIALTRACKING_CONTENT: 65536;

    STATE_LOADED_SOCIALTRACKING_CONTENT: 131072;

    /**
       * Flags for onLocationChange
       *
       * LOCATION_CHANGE_SAME_DOCUMENT
       *   This flag is on when |aWebProgress| did not load a new document.
       *   For example, the location change is due to an anchor scroll or a
       *   pushState/popState/replaceState.
       *
       * LOCATION_CHANGE_ERROR_PAGE
       *   This flag is on when |aWebProgress| redirected from the requested
       *   contents to an internal page to show error status, such as
       *   <about:neterror>, <about:certerror> and so on.
       *
       *   Generally speaking, |aURI| and |aRequest| are the original data. DOM
       *   |window.location.href| is also the original location, while
       *   |document.documentURI| is the redirected location. Sometimes |aURI| is
       *   <about:blank> and |aRequest| is null when the original data does not
       +   remain.
       *
       *   |aWebProgress| does NOT set this flag when it did not try to load a new
       *   document. In this case, it should set LOCATION_CHANGE_SAME_DOCUMENT.
       *
       * LOCATION_CHANGE_RELOAD
       *   This flag is on when reloading the current page, either from
       *   location.reload() or the browser UI.
       */
    LOCATION_CHANGE_SAME_DOCUMENT: 1;

    LOCATION_CHANGE_ERROR_PAGE: 2;

    LOCATION_CHANGE_RELOAD: 4;
  }

  /**
   * The nsIWebProgressListener interface is implemented by clients wishing to
   * listen in on the progress associated with the loading of asynchronous
   * requests in the context of a nsIWebProgress instance as well as any child
   * nsIWebProgress instances.  nsIWebProgress.idl describes the parent-child
   * relationship of nsIWebProgress instances.
   */
  export interface nsIWebProgressListener extends nsISupports {

    /**
     * Notification indicating the state has changed for one of the requests
     * associated with aWebProgress.
     *
     * @param aWebProgress
     *        The nsIWebProgress instance that fired the notification
     * @param aRequest
     *        The nsIRequest that has changed state.
     * @param aStateFlags
     *        Flags indicating the new state.  This value is a combination of one
     *        of the State Transition Flags and one or more of the State Type
     *        Flags defined above.  Any undefined bits are reserved for future
     *        use.
     * @param aStatus
     *        Error status code associated with the state change.  This parameter
     *        should be ignored unless aStateFlags includes the STATE_STOP bit.
     *        The status code indicates success or failure of the request
     *        associated with the state change.  NOTE: aStatus may be a success
     *        code even for server generated errors, such as the HTTP 404 error.
     *        In such cases, the request itself should be queried for extended
     *        error information (e.g., for HTTP requests see nsIHttpChannel).
     */
    readonly onStateChange: (aWebProgress: (nsIWebProgress | null), aRequest: (nsIRequest | null), aStateFlags: number, aStatus: number) => void;

    /**
     * Notification that the progress has changed for one of the requests
     * associated with aWebProgress.  Progress totals are reset to zero when all
     * requests in aWebProgress complete (corresponding to onStateChange being
     * called with aStateFlags including the STATE_STOP and STATE_IS_WINDOW
     * flags).
     *
     * @param aWebProgress
     *        The nsIWebProgress instance that fired the notification.
     * @param aRequest
     *        The nsIRequest that has new progress.
     * @param aCurSelfProgress
     *        The current progress for aRequest.
     * @param aMaxSelfProgress
     *        The maximum progress for aRequest.
     * @param aCurTotalProgress
     *        The current progress for all requests associated with aWebProgress.
     * @param aMaxTotalProgress
     *        The total progress for all requests associated with aWebProgress.
     *
     * NOTE: If any progress value is unknown, or if its value would exceed the
     * maximum value of type long, then its value is replaced with -1.
     *
     * NOTE: If the object also implements nsIWebProgressListener2 and the caller
     * knows about that interface, this function will not be called. Instead,
     * nsIWebProgressListener2::onProgressChange64 will be called.
     */
    readonly onProgressChange: (aWebProgress: (nsIWebProgress | null), aRequest: (nsIRequest | null), aCurSelfProgress: number, aMaxSelfProgress: number, aCurTotalProgress: number, aMaxTotalProgress: number) => void;

    /**
     * Called when the location of the window being watched changes.  This is not
     * when a load is requested, but rather once it is verified that the load is
     * going to occur in the given window.  For instance, a load that starts in a
     * window might send progress and status messages for the new site, but it
     * will not send the onLocationChange until we are sure that we are loading
     * this new page here.
     *
     * @param aWebProgress
     *        The nsIWebProgress instance that fired the notification.
     * @param aRequest
     *        The associated nsIRequest.  This may be null in some cases.
     * @param aLocation
     *        The URI of the location that is being loaded.
     * @param aFlags
     *        This is a value which explains the situation or the reason why
     *        the location has changed.
     */
    readonly onLocationChange: (aWebProgress: (nsIWebProgress | null), aRequest: (nsIRequest | null), aLocation: (nsIURI | null), aFlags?: number) => void;

    /**
     * Notification that the status of a request has changed.  The status message
     * is intended to be displayed to the user (e.g., in the status bar of the
     * browser).
     *
     * @param aWebProgress
     *        The nsIWebProgress instance that fired the notification.
     * @param aRequest
     *        The nsIRequest that has new status.
     * @param aStatus
     *        This value is not an error code.  Instead, it is a numeric value
     *        that indicates the current status of the request.  This interface
     *        does not define the set of possible status codes.  NOTE: Some
     *        status values are defined by nsITransport and nsISocketTransport.
     * @param aMessage
     *        Localized text corresponding to aStatus.
     */
    readonly onStatusChange: (aWebProgress: (nsIWebProgress | null), aRequest: (nsIRequest | null), aStatus: number, aMessage: string) => void;

    /**
     * Notification called for security progress.  This method will be called on
     * security transitions (eg HTTP -> HTTPS, HTTPS -> HTTP, FOO -> HTTPS) and
     * after document load completion.  It might also be called if an error
     * occurs during network loading.
     *
     * @param aWebProgress
     *        The nsIWebProgress instance that fired the notification.
     * @param aRequest
     *        The nsIRequest that has new security state.
     * @param aState
     *        A value composed of the Security State Flags and the Security
     *        Strength Flags listed above.  Any undefined bits are reserved for
     *        future use.
     *
     * NOTE: These notifications will only occur if a security package is
     * installed.
     */
    readonly onSecurityChange: (aWebProgress: (nsIWebProgress | null), aRequest: (nsIRequest | null), aState: number) => void;

    /**
     * Notification called for content blocking events.  This method will be
     * called when content gets allowed/blocked for various reasons per the
     * Content Blocking rules.
     *
     * @param aWebProgress
     *        The nsIWebProgress instance that fired the notification.
     * @param aRequest
     *        The nsIRequest that has new security state.
     * @param aEvent
     *        A value composed of the Content Blocking Event Flags listed above.
     *        Any undefined bits are reserved for future use.
     */
    readonly onContentBlockingEvent: (aWebProgress: (nsIWebProgress | null), aRequest: (nsIRequest | null), aEvent: number) => void;
  }

  export interface nsISDBResultRef {
    readonly name: "nsISDBResult";
    readonly number: "{bca19e01-b34e-4a48-8875-2f4cb871febf}";
  }

  export interface nsISDBResult extends nsISupports {

    readonly getAsArray: () => number[];

    readonly getAsArrayBuffer: () => IDLjsval;
  }

  export interface nsIPaymentDetailsRef {
    readonly name: "nsIPaymentDetails";
    readonly number: "{73a5a3f1-45b9-4605-a6e6-7aa60daa9039}";
  }

  export interface nsIPaymentDetails extends nsISupports {

    readonly id: IDLAString;

    readonly totalItem: (nsIPaymentItem | null);

    readonly displayItems: (nsIArray | null);

    readonly shippingOptions: (nsIArray | null);

    readonly modifiers: (nsIArray | null);

    readonly error: IDLAString;

    readonly shippingAddressErrors: IDLjsval;

    readonly payerErrors: IDLjsval;

    readonly paymentMethodErrors: IDLjsval;
  }

  export interface nsIProcessSwitchRequestorRef {
    readonly name: "nsIProcessSwitchRequestor";
    readonly number: "{fce8497b-c57c-4557-b360-3efefc83eff5}";
  }

  /**
   * The nsIProcessSwitchRequestor interface allows clients to instruct
   * SessionStore.jsm that a channel setup has completed and a process switch
   * may be required. This works alongside the on-may-change-process observer
   * notification.
   * This interface must be used only from the XPCOM main thread.
   */
  export interface nsIProcessSwitchRequestor extends nsISupports {

    /**
     * The underlying channel object that was intercepted and that could trigger
     * a process.
     */
    readonly channel: (nsIChannel | null);

    /**
     * Instructs the callee to be loaded in a new process. Like 'redirectTo'
     * this can only be used on channels that have not yet called their
     * listener's OnStartRequest(). Can only be called during the
     * channel-on-may-change-process observer notification.
     *
     * @param aTabPromise   a promise which resolves to a nsIRemotTab object
     *                      which the load will proceed in.
     * @param aIdentifier   a 64-bit ID which will be provided to the
     *                      ChildProcessChannelListener.
     */
    readonly switchProcessTo: (aTabPromise: IDLPromise, aIdentifier: number) => void;

    /**
     * Used to determine if there is a Cross-Origin-Opener-Policy mismatch
     * that would require switching the channel to another process.
     * @throws NS_ERROR_NOT_AVAILABLE if we don't have a responseHead
     */
    readonly hasCrossOriginOpenerPolicyMismatch: () => boolean;

    /**
     * Returns a cached CrossOriginOpenerPolicy that is computed just before we
     * determine if there is a policy mismatch.
     * @throws NS_ERROR_NOT_AVAILABLE if it has not been computed yet
     */
    readonly crossOriginOpenerPolicy: nsILoadInfo_CrossOriginOpenerPolicy;
  }

  export interface mozIGeckoMediaPluginServiceRef {
    readonly name: "mozIGeckoMediaPluginService";
    readonly number: "{44d362ae-937a-4803-bee6-f2512a0149d1}";
  }

  export interface mozIGeckoMediaPluginService extends nsISupports {

    /**
     * The GMP thread. Callable from any thread.
     */
    readonly thread: (nsIThread | null);

    /**
     * Run through windows registered registered for pluginId, sending
     * 'PluginCrashed' chrome-only event
     */
    readonly RunPluginCrashCallbacks: (pluginId: number, pluginName: IDLACString) => void;
  }

  export interface nsIContentPrefCallback2Ref {
    readonly name: "nsIContentPrefCallback2";
    readonly number: "{1a12cf41-79e8-4d0f-9899-2f7b27c5d9a1}";

    COMPLETE_OK: 0;

    COMPLETE_ERROR: 1;
  }

  export interface nsIContentPrefCallback2 extends nsISupports {

    /**
     * The callback used by the above methods.
     */
    /**
     * For the retrieval methods, this is called once for each retrieved
     * preference.  It is not called for other methods.
     *
     * @param pref  The retrieved preference.
     */
    readonly handleResult: (pref: (nsIContentPref | null)) => void;

    /**
     * Called when an error occurs.  This may be called multiple times before
     * handleCompletion is called.
     *
     * @param error  A number in Components.results describing the error.
     */
    readonly handleError: (error: number) => void;

    /**
     * Called when the method finishes.  This will be called exactly once for
     * each method invocation, and afterward no other callback methods will be
     * called.
     *
     * @param reason  One of the COMPLETE_* values indicating the manner in which
     *                the method completed.
     */
    readonly handleCompletion: (reason: number) => void;
  }

  export interface nsILoginInfoRef {
    readonly name: "nsILoginInfo";
    readonly number: "{c41b7dff-6b9b-42fe-b78d-113051facb05}";
  }

  /**
   * An object containing information for a login stored by the
   * password manager.
   */
  export interface nsILoginInfo extends nsISupports {

    /**
     * A string to display to the user for the origin which includes the httpRealm,
     * where applicable.
     * e.g. "site.com", "site.com:1234", or "site.com (My Secure Realm)"
     */
    readonly displayOrigin: IDLAString;

    /**
     * The origin the login applies to.
     *
     * For example,
     * "https://site.com", "http://site.com:1234", "ftp://ftp.site.com".
     */
    origin: IDLAString;

    /**
     * The origin the login applies to, incorrectly called a hostname.
     * @deprecated in favor of `origin`
     */
    hostname: IDLAString;

    /**
     * The origin a form-based login was submitted to.
     *
     * For logins obtained from HTML forms, this field is the origin of the |action|
     * attribute from the |form| element. For
     * example "http://www.site.com". [Forms with no |action| attribute
     * default to submitting to their origin URL, so we store that.]
     *
     * For logins obtained from a HTTP or FTP protocol authentication,
     * this field is NULL.
     */
    formActionOrigin: IDLAString;

    /**
     * The origin a form-based login was submitted to, incorrectly referred to as a URL.
     * @deprecated in favor of `formActionOrigin`
     */
    formSubmitURL: IDLAString;

    /**
     * The HTTP Realm a login was requested for.
     *
     * When an HTTP server sends a 401 result, the WWW-Authenticate
     * header includes a realm to identify the "protection space." See
     * RFC2617. If the response sent has a missing or blank realm, the
     * hostname is used instead.
     *
     * For logins obtained from HTML forms, this field is NULL.
     */
    httpRealm: IDLAString;

    /**
     * The username for the login.
     */
    username: IDLAString;

    /**
     * The |name| attribute for the username input field.
     *
     * For logins obtained from a HTTP or FTP protocol authentication,
     * this field is an empty string.
     *
     * @note This attribute is currently saved but not used.
     */
    usernameField: IDLAString;

    /**
     * The password for the login.
     */
    password: IDLAString;

    /**
     * The |name| attribute for the password input field.
     *
     * For logins obtained from a HTTP or FTP protocol authentication,
     * this field is an empty string.
     *
     * @note This attribute is currently saved but not used.
     */
    passwordField: IDLAString;

    /**
     * Initialize a newly created nsLoginInfo object.
     *
     * The arguments are the fields for the new object.
     */
    readonly init: (aOrigin: IDLAString, aFormActionOrigin: IDLAString, aHttpRealm: IDLAString, aUsername: IDLAString, aPassword: IDLAString, aUsernameField?: IDLAString, aPasswordField?: IDLAString) => void;

    /**
     * Test for strict equality with another nsILoginInfo object.
     *
     * @param aLoginInfo
     *        The other object to test.
     */
    readonly equals: (aLoginInfo: (nsILoginInfo | null)) => boolean;

    /**
     * Test for loose equivalency with another nsILoginInfo object. The
     * passwordField and usernameField values are ignored, and the password
     * values may be optionally ignored. If one login's formSubmitURL is an
     * empty string (but not null), it will be treated as a wildcard. [The
     * blank value indicates the login was stored before bug 360493 was fixed.]
     *
     * @param aLoginInfo
     *        The other object to test.
     * @param ignorePassword
     *        If true, ignore the password when checking for match.
     */
    readonly matches: (aLoginInfo: (nsILoginInfo | null), ignorePassword: boolean) => boolean;

    /**
     * Create an identical copy of the login, duplicating all of the login's
     * nsILoginInfo and nsILoginMetaInfo properties.
     *
     * This allows code to be forwards-compatible, when additional properties
     * are added to nsILoginMetaInfo (or nsILoginInfo) in the future.
     */
    readonly clone: () => (nsILoginInfo | null);
  }

  export interface nsIINIParserFactoryRef {
    readonly name: "nsIINIParserFactory";
    readonly number: "{ccae7ea5-1218-4b51-aecb-c2d8ecd46af9}";
  }

  export interface nsIINIParserFactory extends nsISupports {

    /**
     * Create an iniparser instance from a local file.
     */
    readonly createINIParser: (aINIFile?: (nsIFile | null)) => (nsIINIParser | null);
  }

  export interface nsIPrefServiceRef {
    readonly name: "nsIPrefService";
    readonly number: "{1f84fd56-3956-40df-b86a-1ea01402ee96}";
  }

  /**
   * The nsIPrefService interface is the main entry point into the back end
   * preferences management library. The preference service is directly
   * responsible for the management of the preferences files and also facilitates
   * access to the preference branch object which allows the direct manipulation
   * of the preferences themselves.
   *
   * @see nsIPrefBranch
   */
  export interface nsIPrefService extends nsISupports {

    /**
     * Called to completely flush and re-initialize the preferences system.
     *
     * @throws Error The preference service failed to restart correctly.
     */
    readonly resetPrefs: () => void;

    /**
     * Called to reset all preferences with user set values back to the
     * application default values.
     */
    readonly resetUserPrefs: () => void;

    /**
     * Called to write current preferences state to a file.
     *
     * @param aFile The file to be written.
     *
     * @note
     * If nullptr is passed in for the aFile parameter the preference data is
     * written out to the current preferences file (usually prefs.js.)
     *
     * @throws Error File failed to write.
     *
     * @see readUserPrefsFromFile
     * @see nsIFile
     */
    readonly savePrefFile: (aFile: (nsIFile | null)) => void;

    /**
     * Call to get a Preferences "Branch" which accesses user preference data.
     * Using a Set method on this object will always create or set a user
     * preference value. When using a Get method a user set value will be
     * returned if one exists, otherwise a default value will be returned.
     *
     * @param aPrefRoot The preference "root" on which to base this "branch".
     *                  For example, if the root "browser.startup." is used, the
     *                  branch will be able to easily access the preferences
     *                  "browser.startup.page", "browser.startup.homepage", or
     *                  "browser.startup.homepage_override" by simply requesting
     *                  "page", "homepage", or "homepage_override". nullptr or ""
     *                  may be used to access to the entire preference "tree".
     *
     * @return nsIPrefBranch The object representing the requested branch.
     *
     * @see getDefaultBranch
     */
    readonly getBranch: (aPrefRoot: string) => (nsIPrefBranch | null);

    /**
     * Call to get a Preferences "Branch" which accesses only the default
     * preference data. Using a Set method on this object will always create or
     * set a default preference value. When using a Get method a default value
     * will always be returned.
     *
     * @param aPrefRoot The preference "root" on which to base this "branch".
     *                  For example, if the root "browser.startup." is used, the
     *                  branch will be able to easily access the preferences
     *                  "browser.startup.page", "browser.startup.homepage", or
     *                  "browser.startup.homepage_override" by simply requesting
     *                  "page", "homepage", or "homepage_override". nullptr or ""
     *                  may be used to access to the entire preference "tree".
     *
     * @note
     * Few consumers will want to create default branch objects. Many of the
     * branch methods do nothing on a default branch because the operations only
     * make sense when applied to user set preferences.
     *
     * @return nsIPrefBranch The object representing the requested default branch.
     *
     * @see getBranch
     */
    readonly getDefaultBranch: (aPrefRoot: string) => (nsIPrefBranch | null);

    /**
     * The preference service is 'dirty' if there are changes to user preferences
     * that have not been written to disk
     */
    readonly dirty: boolean;

    /**
     * Read in the preferences specified in a default preference file. This
     * method does not clear preferences that were already set, but it may
     * overwrite existing preferences.
     *
     * @param aFile The file to be read.
     *
     * @throws Error File failed to read or contained invalid data.
     * @note This method is intended for internal unit testing only!
     */
    readonly readDefaultPrefsFromFile: (aFile: (nsIFile | null)) => void;

    /**
     * Like readDefaultPrefsFromFile, but for a user prefs file.
     */
    readonly readUserPrefsFromFile: (aFile: (nsIFile | null)) => void;

    /**
     * Usage statistics for performance tests. This function takes a function
     * that is passed (preferenceName, accessCount) as arguments for every
     * recorded preference. You can use this function to build e.g. a JS object
     * holding that data.
     *
     * This is not implemented in non-debug builds and will throw an error.
     */
    readonly readStats: (callback: (nsIPrefStatsCallback | nsIPrefStatsCallbackFunction | null)) => void;

    /**
     * Reset usage statistics for performance tests.
     *
     * This is not implemented in non-debug builds and will throw an error.
     */
    readonly resetStats: () => void;
  }

  export interface nsIAlertsDoNotDisturbRef {
    readonly name: "nsIAlertsDoNotDisturb";
    readonly number: "{c5d63e3a-259d-45a8-b964-8377967cb4d2}";
  }

  export interface nsIAlertsDoNotDisturb extends nsISupports {

    /**
     * Toggles a manual Do Not Disturb mode for the service to reduce the amount
     * of disruption that alerts cause the user.
     * This may mean only displaying them in a notification tray/center or not
     * displaying them at all. If a system backend already supports a similar
     * feature controlled by the user, enabling this may not have any impact on
     * code to show an alert. e.g. on OS X, the system will take care not
     * disrupting a user if we simply create a notification like usual.
     */
    manualDoNotDisturb: boolean;
  }

  export interface nsIDocShellTreeOwnerRef {
    readonly name: "nsIDocShellTreeOwner";
    readonly number: "{0e3dc4b1-4cea-4a37-af71-79f0afd07574}";
  }

  export interface nsIDocShellTreeOwner extends nsISupports {

    /**
     * Called when a content shell is added to the docshell tree.  This is
     * _only_ called for "root" content shells (that is, ones whose parent is a
     * chrome shell).
     *
     * @param aContentShell the shell being added.
     * @param aPrimary whether the shell is primary.
     */
    readonly contentShellAdded: (aContentShell: (nsIDocShellTreeItem | null), aPrimary: boolean) => void;

    /**
     * Called when a content shell is removed from the docshell tree.  This is
     * _only_ called for "root" content shells (that is, ones whose parent is a
     * chrome shell).  Note that if aContentShell was never added,
     * contentShellRemoved should just do nothing.
     *
     * @param aContentShell the shell being removed.
     */
    readonly contentShellRemoved: (aContentShell: (nsIDocShellTreeItem | null)) => void;

    readonly primaryContentShell: (nsIDocShellTreeItem | null);

    readonly remoteTabAdded: (aTab: (nsIRemoteTab | null), aPrimary: boolean) => void;

    readonly remoteTabRemoved: (aTab: (nsIRemoteTab | null)) => void;

    readonly primaryRemoteTab: (nsIRemoteTab | null);

    readonly sizeShellTo: (shell: (nsIDocShellTreeItem | null), cx: number, cy: number) => void;

    readonly getPrimaryContentSize: (width: Out<number>, height: Out<number>) => void;

    readonly setPrimaryContentSize: (width: number, height: number) => void;

    readonly getRootShellSize: (width: Out<number>, height: Out<number>) => void;

    readonly setRootShellSize: (width: number, height: number) => void;

    readonly setPersistence: (aPersistPosition: boolean, aPersistSize: boolean, aPersistSizeMode: boolean) => void;

    readonly getPersistence: (aPersistPosition: Out<boolean>, aPersistSize: Out<boolean>, aPersistSizeMode: Out<boolean>) => void;

    readonly tabCount: number;

    readonly hasPrimaryContent: boolean;
  }

  export interface nsILocalHandlerAppRef {
    readonly name: "nsILocalHandlerApp";
    readonly number: "{d36b6329-52ae-4f45-80f4-b2536ae5f8b2}";
  }

  /**
   * nsILocalHandlerApp is a local OS-level executable
   */
  export interface nsILocalHandlerApp extends nsIHandlerApp {

    /**
     * Pointer to the executable file used to handle content
     */
    executable: (nsIFile | null);

    /**
     * Returns the current number of command line parameters.
     */
    readonly parameterCount: number;

    /**
     * Clears the current list of command line parameters.
     */
    readonly clearParameters: () => void;

    /**
     * Appends a command line parameter to the command line
     * parameter list.
     *
     * @param param the parameter to add.
     */
    readonly appendParameter: (param: IDLAString) => void;

    /**
     * Retrieves a specific command line parameter.
     *
     * @param param the index of the parameter to return.
     *
     * @return the parameter string.
     *
     * @throw NS_ERROR_INVALID_ARG if the index is out of range.
     */
    readonly getParameter: (parameterIndex: number) => IDLAString;

    /**
     * Checks to see if a parameter exists in the command line
     * parameter list.
     *
     * @param param the parameter to search for.
     *
     * @return TRUE if the parameter exists in the current list.
     */
    readonly parameterExists: (param: IDLAString) => boolean;
  }

  export interface IUrlClassifierUITelemetryRef {
    readonly name: "IUrlClassifierUITelemetry";
    readonly number: "{a6c62ce5-3a95-41bb-b0f1-8cd4f4ca00e3}";

    WARNING_MALWARE_PAGE_TOP: 1;

    WARNING_MALWARE_PAGE_TOP_WHY_BLOCKED: 2;

    WARNING_MALWARE_PAGE_TOP_GET_ME_OUT_OF_HERE: 3;

    WARNING_MALWARE_PAGE_TOP_IGNORE_WARNING: 4;

    WARNING_MALWARE_PAGE_FRAME: 5;

    WARNING_MALWARE_PAGE_FRAME_WHY_BLOCKED: 6;

    WARNING_MALWARE_PAGE_FRAME_GET_ME_OUT_OF_HERE: 7;

    WARNING_MALWARE_PAGE_FRAME_IGNORE_WARNING: 8;

    WARNING_PHISHING_PAGE_TOP: 9;

    WARNING_PHISHING_PAGE_TOP_WHY_BLOCKED: 10;

    WARNING_PHISHING_PAGE_TOP_GET_ME_OUT_OF_HERE: 11;

    WARNING_PHISHING_PAGE_TOP_IGNORE_WARNING: 12;

    WARNING_PHISHING_PAGE_FRAME: 13;

    WARNING_PHISHING_PAGE_FRAME_WHY_BLOCKED: 14;

    WARNING_PHISHING_PAGE_FRAME_GET_ME_OUT_OF_HERE: 15;

    WARNING_PHISHING_PAGE_FRAME_IGNORE_WARNING: 16;

    WARNING_UNWANTED_PAGE_TOP: 17;

    WARNING_UNWANTED_PAGE_TOP_WHY_BLOCKED: 18;

    WARNING_UNWANTED_PAGE_TOP_GET_ME_OUT_OF_HERE: 19;

    WARNING_UNWANTED_PAGE_TOP_IGNORE_WARNING: 20;

    WARNING_UNWANTED_PAGE_FRAME: 21;

    WARNING_UNWANTED_PAGE_FRAME_WHY_BLOCKED: 22;

    WARNING_UNWANTED_PAGE_FRAME_GET_ME_OUT_OF_HERE: 23;

    WARNING_UNWANTED_PAGE_FRAME_IGNORE_WARNING: 24;

    WARNING_HARMFUL_PAGE_TOP: 25;

    WARNING_HARMFUL_PAGE_TOP_WHY_BLOCKED: 26;

    WARNING_HARMFUL_PAGE_TOP_GET_ME_OUT_OF_HERE: 27;

    WARNING_HARMFUL_PAGE_TOP_IGNORE_WARNING: 28;

    WARNING_HARMFUL_PAGE_FRAME: 29;

    WARNING_HARMFUL_PAGE_FRAME_WHY_BLOCKED: 30;

    WARNING_HARMFUL_PAGE_FRAME_GET_ME_OUT_OF_HERE: 31;

    WARNING_HARMFUL_PAGE_FRAME_IGNORE_WARNING: 32;
  }

  export interface IUrlClassifierUITelemetry extends nsISupports {
  }

  export interface nsIAsyncShutdownClientRef {
    readonly name: "nsIAsyncShutdownClient";
    readonly number: "{d2031049-b990-43a2-95be-59f8a3ca5954}";
  }

  export interface nsIAsyncShutdownClient extends nsISupports {

    /**
     * A client for a nsIAsyncShutdownBarrier.
     */
    /**
     * The name of the barrier.
     */
    readonly name: IDLAString;

    /**
     * Add a blocker.
     *
     * After a `blocker` has been added with `addBlocker`, if it is not
     * removed with `removeBlocker`, this will, by design, eventually
     * CAUSE A CRASH.
     *
     * Calling `addBlocker` once nsIAsyncShutdownBarrier::wait() has been
     * called on the owning barrier returns an error.
     *
     * @param aBlocker The blocker to add. Once
     * nsIAsyncShutdownBarrier::wait() has been called, it will not
     * call its `aOnReady` callback until all blockers have been
     * removed, each  by a call to `removeBlocker`.
     * @param aFileName The filename of the callsite, as given by `__FILE__`.
     * @param aLineNumber The linenumber of the callsite, as given by `__LINE__`.
     * @param aStack Information on the stack that lead to this call. Generally
     * empty when called from C++.
     */
    readonly addBlocker: (aBlocker: (nsIAsyncShutdownBlocker | null), aFileName: IDLAString, aLineNumber: number, aStack: IDLAString) => void;

    /**
     * Remove a blocker.
     *
     * @param aBlocker A blocker previously added to this client through
     * `addBlocker`. Noop if the blocker has never been added or has been
     * removed already.
     */
    readonly removeBlocker: (aBlocker: (nsIAsyncShutdownBlocker | null)) => void;

    /**
     * The JS implementation of the client.
     *
     * It is strongly recommended that JS clients of this API use
     * `jsclient` instead of the `nsIAsyncShutdownClient`. See
     * AsyncShutdown.jsm for more information on the JS version of
     * this API.
     */
    readonly jsclient: IDLjsval;
  }

  export interface nsICommandLineValidatorRef {
    readonly name: "nsICommandLineValidator";
    readonly number: "{5ecaa593-7660-4a3a-957a-92d5770671c7}";
  }

  /**
   * Validates arguments on the command line of an XUL application.
   *
   * Each validator is registered in the category "command-line-validator".
   * The entries in this category are read in alphabetical order, and each
   * category value is treated as a service contractid implementing this
   * interface.
   *
   * By convention, validator with ordinary priority should begin with "m".
   *
   * Example:
   * Category               Entry          Value
   * command-line-validator b-browser      @mozilla.org/browser/clh;1
   * command-line-validator m-edit         @mozilla.org/composer/clh;1
   * command-line-validator m-irc          @mozilla.org/chatzilla/clh;1
   *
   */
  export interface nsICommandLineValidator extends nsISupports {

    /**
     * Process the command-line validators in the proper order, calling
     * "validate()" on each.
     *
     * @throws NS_ERROR_ABORT if any validator throws NS_ERROR_ABORT. All other
     *         errors thrown by validators will be silently ignored.
     */
    readonly validate: (aCommandLine: (nsICommandLine | null)) => void;
  }

  export interface nsINetUtilRef {
    readonly name: "nsINetUtil";
    readonly number: "{fe2625ec-b884-4df1-b39c-9e830e47aa94}";

    /** Escape every character with its %XX-escaped equivalent */
    ESCAPE_ALL: 0;

    /** Leave alphanumeric characters intact and %XX-escape all others */
    ESCAPE_XALPHAS: 1;

    /** Leave alphanumeric characters intact, convert spaces to '+',
          %XX-escape all others */
    ESCAPE_XPALPHAS: 2;

    /** Leave alphanumeric characters and forward slashes intact,
          %XX-escape all others */
    ESCAPE_URL_PATH: 4;

    /** %XX-escape URL scheme */
    ESCAPE_URL_SCHEME: 1;

    /** %XX-escape username in the URL */
    ESCAPE_URL_USERNAME: 2;

    /** %XX-escape password in the URL */
    ESCAPE_URL_PASSWORD: 4;

    /** %XX-escape URL host */
    ESCAPE_URL_HOST: 8;

    /** %XX-escape URL directory */
    ESCAPE_URL_DIRECTORY: 16;

    /** %XX-escape file basename in the URL */
    ESCAPE_URL_FILE_BASENAME: 32;

    /** %XX-escape file extension in the URL */
    ESCAPE_URL_FILE_EXTENSION: 64;

    /** %XX-escape URL parameters */
    ESCAPE_URL_PARAM: 128;

    /** %XX-escape URL query */
    ESCAPE_URL_QUERY: 256;

    /** %XX-escape URL ref */
    ESCAPE_URL_REF: 512;

    /** %XX-escape URL path - same as escaping directory, basename and extension */
    ESCAPE_URL_FILEPATH: 112;

    /** %XX-escape scheme, username, password, host, path, params, query and ref */
    ESCAPE_URL_MINIMAL: 1023;

    /** Force %XX-escaping of already escaped sequences */
    ESCAPE_URL_FORCED: 1024;

    /** Skip non-ascii octets, %XX-escape all others */
    ESCAPE_URL_ONLY_ASCII: 2048;

    /**
     * Skip graphic octets (0x20-0x7E) when escaping
     * Skips all ASCII octets (0x00-0x7F) when unescaping
     */
    ESCAPE_URL_ONLY_NONASCII: 4096;

    /** Force %XX-escape of colon */
    ESCAPE_URL_COLON: 16384;

    /** Skip C0 and DEL from unescaping */
    ESCAPE_URL_SKIP_CONTROL: 32768;
  }

  /**
   * nsINetUtil provides various network-related utility methods.
   */
  export interface nsINetUtil extends nsISupports {

    /**
     * Parse a Content-Type header value in strict mode.  This is a more
     * conservative parser that reject things that violate RFC 7231 section
     * 3.1.1.1.  This is typically useful for parsing Content-Type header values
     * that are used for HTTP requests, and those that are used to make security
     * decisions.
     *
     * @param aTypeHeader the header string to parse
     * @param [out] aCharset the charset parameter specified in the
     *              header, if any.
     * @param [out] aHadCharset whether a charset was explicitly specified.
     * @return the MIME type specified in the header, in lower-case.
     */
    readonly parseRequestContentType: (aTypeHeader: IDLAUTF8String, aCharset: Out<IDLAUTF8String>, aHadCharset: Out<boolean>) => IDLAUTF8String;

    /**
     * Parse a Content-Type header value in relaxed mode.  This is a more
     * permissive parser that ignores things that go against RFC 7231 section
     * 3.1.1.1.  This is typically useful for parsing Content-Type header values
     * received from web servers where we want to make a best effort attempt
     * at extracting a useful MIME type and charset.
     *
     * NOTE: DO NOT USE THIS if you're going to make security decisions
     * based on the result.
     *
     * @param aTypeHeader the header string to parse
     * @param [out] aCharset the charset parameter specified in the
     *              header, if any.
     * @param [out] aHadCharset whether a charset was explicitly specified.
     * @return the MIME type specified in the header, in lower-case.
     */
    readonly parseResponseContentType: (aTypeHeader: IDLAUTF8String, aCharset: Out<IDLAUTF8String>, aHadCharset: Out<boolean>) => IDLAUTF8String;

    /**
     * Test whether the given URI's handler has the given protocol flags.
     *
     * @param aURI the URI in question
     * @param aFlags the flags we're testing for.
     *
     * @return whether the protocol handler for aURI has all the flags
     *         in aFlags.
     */
    readonly protocolHasFlags: (aURI: (nsIURI | null), aFlag: number) => boolean;

    /**
     * Test whether the protocol handler for this URI or that for any of
     * its inner URIs has the given protocol flags.  This will QI aURI to
     * nsINestedURI and walk the nested URI chain.
     *
     * @param aURI the URI in question
     * @param aFlags the flags we're testing for.
     *
     * @return whether any of the protocol handlers involved have all the flags
     *         in aFlags.
     */
    readonly URIChainHasFlags: (aURI: (nsIURI | null), aFlags: number) => boolean;

    /**
     * escape a string with %00-style escaping
     */
    readonly escapeString: (aString: IDLACString, aEscapeType: number) => IDLACString;

    /**
     * %XX-Escape invalid chars in a URL segment.
     *
     * @param aStr the URL to be escaped
     * @param aFlags the URL segment type flags
     *
     * @return the escaped string (the string itself if escaping did not happen)
     *
     */
    readonly escapeURL: (aStr: IDLACString, aFlags: number) => IDLACString;

    /**
     * Expands URL escape sequences
     *
     * @param aStr the URL to be unescaped
     * @param aFlags only ESCAPE_URL_ONLY_NONASCII and ESCAPE_URL_SKIP_CONTROL
     *               are recognized.  If |aFlags| is 0 all escape sequences are
     *               unescaped
     * @return unescaped string
     */
    readonly unescapeString: (aStr: IDLAUTF8String, aFlags: number) => IDLACString;

    /**
     * Extract the charset parameter location and value from a content-type
     * header.
     *
     * @param aTypeHeader the header string to parse
     * @param [out] aCharset the charset parameter specified in the
     *              header, if any.
     * @param [out] aCharsetStart index of the start of the charset parameter
     *              (the ';' separating it from what came before) in aTypeHeader.
     *              If this function returns false, this argument will still be
     *              set, to the index of the location where a new charset should
     *              be inserted.
     * @param [out] aCharsetEnd index of the end of the charset parameter (the
     *              ';' separating it from what comes after, or the end
     *              of the string) in aTypeHeader.  If this function returns
     *              false, this argument will still be set, to the index of the
     *              location where a new charset should be inserted.
     *
     * @return whether a charset parameter was found.  This can be false even in
     * cases when parseContentType would claim to have a charset, if the type
     * that won out does not have a charset parameter specified.
     */
    readonly extractCharsetFromContentType: (aTypeHeader: IDLAUTF8String, aCharset: Out<IDLAUTF8String>, aCharsetStart: Out<number>, aCharsetEnd: Out<number>) => boolean;

    /**
     * This is test-only. Send an IPC message to let socket process send a
     * telemetry.
     */
    readonly socketProcessTelemetryPing: () => void;

    /**
     * This is a void method that is C++ implemented and always
     * returns NS_ERROR_NOT_IMPLEMENTED. To be used for testing.
     */
    readonly notImplemented: () => void;
  }

  export interface nsIOfflineCacheUpdateServiceRef {
    readonly name: "nsIOfflineCacheUpdateService";
    readonly number: "{44971e74-37e4-4140-8677-a4cf213a3f4b}";

    /**
     * Constants for the offline-app permission.
     *
     * XXX: This isn't a great place for this, but it's really the only
     * private offline-app-related interface
     */
    /**
     * Allow the domain to use offline APIs, and don't warn about excessive
     * usage.
     */
    ALLOW_NO_WARN: 3;
  }

  export interface nsIOfflineCacheUpdateService extends nsISupports {

    /**
     * Access to the list of cache updates that have been scheduled.
     */
    readonly numUpdates: number;

    readonly getUpdate: (index: number) => (nsIOfflineCacheUpdate | null);

    /**
     * Schedule a cache update for a given offline manifest.  If an
     * existing update is scheduled or running, that update will be returned.
     * Otherwise a new update will be scheduled.
     */
    readonly scheduleUpdate: (aManifestURI: (nsIURI | null), aDocumentURI: (nsIURI | null), aLoadingPrincipal: (nsIPrincipal | null), aWindow: (mozIDOMWindow | null)) => (nsIOfflineCacheUpdate | null);

    /**
     * Schedule a cache update for a given offline manifest using app cache
     * bound to the given appID flag.  If an existing update is scheduled or
     * running, that update will be returned. Otherwise a new update will be
     * scheduled.
     */
    readonly scheduleAppUpdate: (aManifestURI: (nsIURI | null), aDocumentURI: (nsIURI | null), aLoadingPrincipal: (nsIPrincipal | null), aProfileDir: (nsIFile | null)) => (nsIOfflineCacheUpdate | null);

    /**
     * Schedule a cache update for a manifest when the document finishes
     * loading.
     */
    readonly scheduleOnDocumentStop: (aManifestURI: (nsIURI | null), aDocumentURI: (nsIURI | null), aLoadingPrincipal: (nsIPrincipal | null), aDocument: WebIDL.Document) => void;

    /**
     * Schedule a check to see if an update is available.
     *
     * This will not update or make any changes to the appcache.
     * It only notifies the observer to indicate whether the manifest has
     * changed on the server (or not): a changed manifest means that an
     * update is available.
     *
     * For arguments see nsIOfflineCacheUpdate.initForUpdateCheck() method
     * description.
     */
    readonly checkForUpdate: (aManifestURI: (nsIURI | null), aLoadingPrincipal: (nsIPrincipal | null), aObserver: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * Checks whether a principal should have access to the offline
     * cache.
     * @param aPrincipal
     *        The principal to check.
     */
    readonly offlineAppAllowed: (aPrincipal: (nsIPrincipal | null)) => boolean;

    /**
     * Checks whether a document at the given URI should have access
     * to the offline cache.
     * @param aURI
     *        The URI to check
     */
    readonly offlineAppAllowedForURI: (aURI: (nsIURI | null)) => boolean;

    /**
     * Sets the "offline-app" permission for the principal.
     * In the single process model calls directly on permission manager.
     * In the multi process model dispatches to the parent process.
     */
    readonly allowOfflineApp: (aPrincipal: (nsIPrincipal | null)) => void;
  }

  export interface nsIPresentationDataChannelSessionTransportBuilderRef {
    readonly name: "nsIPresentationDataChannelSessionTransportBuilder";
    readonly number: "{8131c4e0-3a8c-4bc1-a92a-8431473d2fe8}";
  }

  /**
   * Builder for WebRTC data channel session transport
   */
  export interface nsIPresentationDataChannelSessionTransportBuilder extends nsIPresentationSessionTransportBuilder {

    /**
     * The following creation function will trigger |listener.onSessionTransport|
     * if the session transport is successfully built, |listener.onError| if some
     * error occurs during creating session transport. The |notifyConnected| of
     * |aControlChannel| should be called before calling
     * |buildDataChannelTransport|.
     */
    readonly buildDataChannelTransport: (aRole: number, aWindow: (mozIDOMWindow | null), aListener: (nsIPresentationSessionTransportBuilderListener | null)) => void;

    readonly onOffer: (offer: (nsIPresentationChannelDescription | null)) => void;

    readonly onAnswer: (answer: (nsIPresentationChannelDescription | null)) => void;

    readonly onIceCandidate: (candidate: IDLAString) => void;

    readonly notifyDisconnected: (reason: number) => void;
  }

  export interface nsIDownloadObserverRef {
    readonly name: "nsIDownloadObserver";
    readonly number: "{44b3153e-a54e-4077-a527-b0325e40924e}";
  }

  export interface nsIDownloadObserver extends nsISupports {

    /**
     * Called to signal a download that has completed.
     */
    readonly onDownloadComplete: (downloader: (nsIDownloader | null), request: (nsIRequest | null), ctxt: (nsISupports | null), status: number, result: (nsIFile | null)) => void;
  }

  export interface nsIAuthPrompt2Ref {
    readonly name: "nsIAuthPrompt2";
    readonly number: "{651395eb-8612-4876-8ac0-a88d4dce9e1e}";

    /** @name Security Levels */
    /**
     * The password will be sent unencrypted. No security provided.
     */
    LEVEL_NONE: 0;

    /**
     * Password will be sent encrypted, but the connection is otherwise
     * insecure.
     */
    LEVEL_PW_ENCRYPTED: 1;

    /**
     * The connection, both for password and data, is secure.
     */
    LEVEL_SECURE: 2;
  }

  /**
   * An interface allowing to prompt for a username and password. This interface
   * is usually acquired using getInterface on notification callbacks or similar.
   * It can be used to prompt users for authentication information, either
   * synchronously or asynchronously.
   */
  export interface nsIAuthPrompt2 extends nsISupports {

    /**
     * Requests a username and a password. Implementations will commonly show a
     * dialog with a username and password field, depending on flags also a
     * domain field.
     *
     * @param aChannel
     *        The channel that requires authentication.
     * @param level
     *        One of the level constants from above. See there for descriptions
     *        of the levels.
     * @param authInfo
     *        Authentication information object. The implementation should fill in
     *        this object with the information entered by the user before
     *        returning.
     *
     * @retval true
     *         Authentication can proceed using the values in the authInfo
     *         object.
     * @retval false
     *         Authentication should be cancelled, usually because the user did
     *         not provide username/password.
     *
     * @note   Exceptions thrown from this function will be treated like a
     *         return value of false.
     */
    readonly promptAuth: (aChannel: (nsIChannel | null), level: number, authInfo: (nsIAuthInformation | null)) => boolean;

    /**
     * Asynchronously prompt the user for a username and password.
     * This has largely the same semantics as promptUsernameAndPassword(),
     * but must return immediately after calling and return the entered
     * data in a callback.
     *
     * If the user closes the dialog using a cancel button or similar,
     * the callback's nsIAuthPromptCallback::onAuthCancelled method must be
     * called.
     * Calling nsICancelable::cancel on the returned object SHOULD close the
     * dialog and MUST call nsIAuthPromptCallback::onAuthCancelled on the provided
     * callback.
     *
     * This implementation may:
     *
     *  1) Coalesce identical prompts.  This means prompts that are guaranteed to
     *     want the same auth information from the user.  A single prompt will be
     *     shown; then the callbacks for all the coalesced prompts will be notified
     *     with the resulting auth information.
     *  2) Serialize prompts that are all in the same "context" (this might mean
     *     application-wide, for a given window, or something else depending on
     *     the user interface) so that the user is not deluged with prompts.
     *
     * @throw
     *     This method may throw any exception when the prompt fails to queue e.g
     *     because of out-of-memory error. It must not throw when the prompt
     *     could already be potentially shown to the user. In that case information
     *     about the failure has to come through the callback. This way we
     *     prevent multiple dialogs shown to the user because consumer may fall
     *     back to synchronous prompt on synchronous failure of this method.
     */
    readonly asyncPromptAuth: (aChannel: (nsIChannel | null), aCallback: (nsIAuthPromptCallback | null), aContext: (nsISupports | null), level: number, authInfo: (nsIAuthInformation | null)) => (nsICancelable | null);
  }

  export interface nsIMIMEHeaderParamRef {
    readonly name: "nsIMIMEHeaderParam";
    readonly number: "{9c9252a1-fdaf-40a2-9c2b-a3dc45e28dde}";
  }

  export interface nsIMIMEHeaderParam extends nsISupports {

    /**
     * Given the value of a single header field  (such as
     * Content-Disposition and Content-Type) and the name of a parameter
     * (e.g. filename, name, charset), returns the value of the parameter.
     * The value is obtained by decoding RFC 2231/5987-style encoding,
     * RFC 2047-style encoding, and converting to UniChar(UTF-16)
     * from charset specified in RFC 2231/2047 encoding, UTF-8,
     * <code>aFallbackCharset</code>, the locale charset as fallback if
     * <code>TryLocaleCharset</code> is set, and null-padding as last resort
     * if all else fails.
     *
     * <p>
     * This method internally invokes <code>getParameterInternal</code>,
     * However, it does not stop at decoding RFC 2231 (the task for
     * <code>getParameterInternal</code> but tries to cope
     * with several non-standard-compliant cases mentioned below.
     *
     * <p>
     * Note that a lot of MUAs put RFC 2047-encoded parameters. Unfortunately,
     * this includes Mozilla as of 2003-05-30. Even more standard-ignorant MUAs,
     * web servers and application servers put 'raw 8bit characters'. This will
     * try to cope with all these cases as gracefully as possible. Additionally,
     * it returns the language tag if the parameter is encoded per RFC 2231 and
     * includes lang.
     *
     * <p>
     * Note that GetParameterHTTP skips some of the workarounds used for
     * mail (MIME) header fields, and thus SHOULD be used from non-mail
     * code.
     *
     *
     * @param  aHeaderVal        a header string to get the value of a parameter
     *                           from.
     * @param  aParamName        the name of a MIME header parameter (e.g.
     *                           filename, name, charset). If empty,  returns
     *                           the first (possibly) _unnamed_ 'parameter'.
     * @param  aFallbackCharset  fallback charset to try if  the string after
     *                           RFC 2231/2047 decoding or the raw 8bit
     *                           string is not UTF-8
     * @param  aTryLocaleCharset If set, makes yet another attempt
     *                           with the locale charset.
     * @param  aLang             If non-null, assigns it to a pointer
     *                           to a string containing the value of language
     *                           obtained from RFC 2231 parsing. Caller has to
     *                           free it.
     * @return the value of <code>aParamName</code> in Unichar(UTF-16).
     */
    readonly getParameter: (aHeaderVal: IDLACString, aParamName: string, aFallbackCharset: IDLACString, aTryLocaleCharset: boolean, aLang: Out<string>) => IDLAString;

    /**
     * Like getParameter, but disabling encodings and workarounds specific to
     * MIME (as opposed to HTTP).
     */
    readonly getParameterHTTP: (aHeaderVal: IDLACString, aParamName: string, aFallbackCharset: IDLACString, aTryLocaleCharset: boolean, aLang: Out<string>) => IDLAString;

    /**
     * Given the value of a header field parameter using the encoding
     * defined in RFC 5987, decode the value into a Unicode string, and extract
     * the optional language parameter.
     *
     * <p>
     * This function is purposefully picky; it will abort for all (most?)
     * invalid inputs. This is by design. In particular, it does not support
     * any character encodings other than UTF-8, in order not to promote
     * non-interoperable usage.
     *
     * <p>
     * Code that parses HTTP header fields (as opposed to MIME header fields)
     * should use this function.
     *
     * @param  aParamVal         a header field parameter to decode.
     * @param  aLang             will be set to the language part (possibly
     *                           empty).
     * @return the decoded parameter value.
     */
    readonly decodeRFC5987Param: (aParamVal: IDLACString, aLang: Out<IDLACString>) => IDLAString;
  }

  export interface nsIIdentityKeyGenCallbackRef {
    readonly name: "nsIIdentityKeyGenCallback";
    readonly number: "{90f24ca2-2b05-4ca9-8aec-89d38e2f905a}";
  }

  type nsIIdentityKeyGenCallbackFunction = (rv: number, keyPair: (nsIIdentityKeyPair | null)) => void;

  export interface nsIIdentityKeyGenCallback extends nsISupports {

    /**
     * This interface provides a JavaScript callback object used to collect the
     * nsIIdentityServeKeyPair when the keygen operation is complete
     *
     * though there is discussion as to whether we need the nsresult,
     * we keep it so we can track deeper crypto errors.
     */
    readonly generateKeyPairFinished: (rv: number, keyPair: (nsIIdentityKeyPair | null)) => void;
  }

  export interface nsIMultiplexInputStreamRef {
    readonly name: "nsIMultiplexInputStream";
    readonly number: "{a076fd12-1dd1-11b2-b19a-d53b5dffaade}";
  }

  /**
   * The multiplex stream concatenates a list of input streams into a single
   * stream.
   */
  export interface nsIMultiplexInputStream extends nsISupports {

    /**
     * Number of streams in this multiplex-stream
     */
    readonly count: number;

    /**
     * Appends a stream to the end of the streams. The cursor of the stream
     * should be located at the beginning of the stream if the implementation
     * of this nsIMultiplexInputStream also is used as an nsISeekableStream.
     * @param stream  stream to append
     */
    readonly appendStream: (stream: (nsIInputStream | null)) => void;

    /**
     * Get stream at specified index.
     * @param index   return stream at this index, must be < count
     * @return        stream at specified index
     */
    readonly getStream: (index: number) => (nsIInputStream | null);
  }

  export interface mozIStorageAsyncStatementRef {
    readonly name: "mozIStorageAsyncStatement";
    readonly number: "{52e49370-3b2e-4a27-a3fc-79e20ad4056b}";
  }

  /**
   * An asynchronous SQL statement.  This differs from mozIStorageStatement by
   * only being usable for asynchronous execution.  (mozIStorageStatement can
   * be used for both synchronous and asynchronous purposes.)  This specialization
   * for asynchronous operation allows us to avoid needing to acquire
   * synchronization primitives also used by the asynchronous execution thread.
   * In contrast, mozIStorageStatement may need to acquire the primitives and
   * consequently can cause the main thread to lock for extended intervals while
   * the asynchronous thread performs some long-running operation.
   */
  export interface mozIStorageAsyncStatement extends mozIStorageBaseStatement {
  }

  export interface nsIInputStreamTeeRef {
    readonly name: "nsIInputStreamTee";
    readonly number: "{90a9d790-3bca-421e-a73b-98f68e13c917}";
  }

  /**
   * A nsIInputStreamTee is a wrapper for an input stream, that when read
   * reads the specified amount of data from its |source| and copies that
   * data to its |sink|.  |sink| must be a blocking output stream.
   */
  export interface nsIInputStreamTee extends nsIInputStream {

    source: (nsIInputStream | null);

    sink: (nsIOutputStream | null);

    /**
     * If |eventTarget| is set, copying to sink is done asynchronously using
     * the event-target (e.g. a thread). If |eventTarget| is not set, copying
     * to sink happens synchronously while reading from the source.
     */
    eventTarget: (nsIEventTarget | null);
  }

  export interface nsIConsoleAPIStorageRef {
    readonly name: "nsIConsoleAPIStorage";
    readonly number: "{9e32a7b6-c4d1-4d9a-87b9-1ef6b75c27a9}";
  }

  export interface nsIConsoleAPIStorage extends nsISupports {

    /**
     * Get the events array by inner window ID or all events from all windows.
     *
     * @param string [aId]
     *        Optional, the inner window ID for which you want to get the array of
     *        cached events.
     * @returns array
     *          The array of cached events for the given window. If no |aId| is
     *          given this function returns all of the cached events, from any
     *          window.
     */
    readonly getEvents: (aId?: IDLAString) => IDLjsval;

    /**
     * Record an event associated with the given window ID.
     *
     * @param string aId
     *        The ID of the inner window for which the event occurred or "jsm" for
     *        messages logged from JavaScript modules..
     * @param string aOuterId
     *        This ID is used as 3rd parameters for the console-api-log-event
     *        notification.
     * @param object aEvent
     *        A JavaScript object you want to store.
     */
    readonly recordEvent: (aId: IDLAString, aOuterId: IDLAString, aEvent: IDLjsval) => void;

    /**
     * Clear storage data for the given window.
     *
     * @param string [aId]
     *        Optional, the inner window ID for which you want to clear the
     *        messages. If this is not specified all of the cached messages are
     *        cleared, from all window objects.
     */
    readonly clearEvents: (aId?: IDLAString) => void;
  }

  export interface nsIDNSListenerRef {
    readonly name: "nsIDNSListener";
    readonly number: "{27d49bfe-280c-49e0-bbaa-f6200c232c3d}";
  }

  /**
   * nsIDNSListener
   */
  export interface nsIDNSListener extends nsISupports {

    /**
     * called when an asynchronous host lookup completes.
     *
     * @param aRequest
     *        the value returned from asyncResolve.
     * @param aRecord
     *        the DNS record corresponding to the hostname that was resolved.
     *        this parameter is null if there was an error.
     * @param aStatus
     *        if the lookup failed, this parameter gives the reason.
     */
    readonly onLookupComplete: (aRequest: (nsICancelable | null), aRecord: (nsIDNSRecord | null), aStatus: number) => void;

    /**
     * called when an asynchronous dns lookup by type completes.
     *
     * @param aRequest
     *        the value returned from asyncResolve.
     * @param aRecord
     *        a string returned by the dns server.
     * @param aStatus
     *        if the lookup failed, this parameter gives the reason.
     */
    readonly onLookupByTypeComplete: (aRequest: (nsICancelable | null), aResult: (nsIDNSByTypeRecord | null), aStatus: number) => void;
  }

  export interface nsIHandlerInfoRef {
    readonly name: "nsIHandlerInfo";
    readonly number: "{325e56a7-3762-4312-aec7-f1fcf84b4145}";

    saveToDisk: 0;

    /**
     * Used to indicate that we know nothing about what to do with this.  You
     * could consider this to be not initialized.
     */
    alwaysAsk: 1;

    useHelperApp: 2;

    handleInternally: 3;

    useSystemDefault: 4;
  }

  /**
   * nsIHandlerInfo gives access to the information about how a given protocol
   * scheme or MIME-type is handled.
   */
  export interface nsIHandlerInfo extends nsISupports {

    /**
     * The type of this handler info.  For MIME handlers, this is the MIME type.
     * For protocol handlers, it's the scheme.
     *
     * @return String representing the type.
     */
    readonly type: IDLACString;

    /**
     * A human readable description of the handler type
     */
    description: IDLAString;

    /**
     * The application the user has said they want associated with this content
     * type. This is not always guaranteed to be set!!
     */
    preferredApplicationHandler: (nsIHandlerApp | null);

    /**
     * Applications that can handle this content type.
     *
     * The list will include the preferred handler, if any.  Elements of this
     * array are nsIHandlerApp objects, and this attribute will always reference
     * an array, whether or not there are any possible handlers.  If there are
     * no possible handlers, the array will contain no elements, so just check
     * its length (nsIArray::length) to see if there are any possible handlers.
     */
    readonly possibleApplicationHandlers: (nsIMutableArray | null);

    /**
     * Indicates whether a default application handler exists,
     * i.e. whether launchWithFile with action = useSystemDefault is possible
     * and defaultDescription will contain usable information.
     */
    readonly hasDefaultHandler: boolean;

    /**
     * A pretty name description of the associated default application. Only
     * usable if hasDefaultHandler is true.
     */
    readonly defaultDescription: IDLAString;

    /**
     * Launches the application with the specified URI, in a way that
     * depends on the value of preferredAction. preferredAction must be
     * useHelperApp or useSystemDefault.
     *
     * @note Only the URI scheme is used to determine how to launch.  This is
     * essentially a pass-by-value operation.  This means that in the case of
     * a file: URI, the handler that is registered for file: will be launched
     * and our code will not make any decision based on the content-type or
     * extension, though the invoked file: handler is free to do so.
     *
     * @param aURI
     *        The URI to launch this application with
     *
     * @param aWindowContext
     *        The window to parent the dialog against, and, if a web handler
     *        is chosen, it is loaded in this window as well.  See
     *        nsIHandlerApp.launchWithURI for more details.
     *
     * @throw NS_ERROR_INVALID_ARG if preferredAction is not valid for this
     * call. Other exceptions may be thrown.
     */
    readonly launchWithURI: (aURI: (nsIURI | null), aWindowContext?: (nsIInterfaceRequestor | null)) => void;

    /**
     * preferredAction is how the user specified they would like to handle
     * this content type: save to disk, use specified helper app, use OS
     * default handler or handle using navigator; possible value constants
     * listed below
     */
    preferredAction: number;

    /**
     * alwaysAskBeforeHandling: if true, we should always give the user a
     * dialog asking how to dispose of this content.
     */
    alwaysAskBeforeHandling: boolean;
  }

  export interface nsIDNSByTypeRecordRef {
    readonly name: "nsIDNSByTypeRecord";
    readonly number: "{5d13241b-9d46-448a-90d8-77c418491026}";
  }

  export interface nsIDNSByTypeRecord extends nsISupports {

    readonly getRecordsAsOneString: () => IDLACString;
  }

  export interface nsISyncStreamListenerRef {
    readonly name: "nsISyncStreamListener";
    readonly number: "{7e1aa658-6e3f-4521-9946-9685a169f764}";
  }

  export interface nsISyncStreamListener extends nsIStreamListener {

    /**
     * Returns an input stream that when read will fetch data delivered to the
     * sync stream listener.  The nsIInputStream implementation will wait for
     * OnDataAvailable events before returning from Read.
     *
     * NOTE: Reading from the returned nsIInputStream may spin the current
     * thread's event queue, which could result in any event being processed.
     */
    readonly inputStream: (nsIInputStream | null);
  }

  export interface nsILoginManagerStorageRef {
    readonly name: "nsILoginManagerStorage";
    readonly number: "{5df81a93-25e6-4b45-a696-089479e15c7d}";
  }

  /**
   * NOTE: This interface is intended to be implemented by modules
   *       providing storage mechanisms for the login manager.
   *       Other code should use the login manager's interfaces
   *       (nsILoginManager), and should not call storage modules
   *       directly.
   */
  export interface nsILoginManagerStorage extends nsISupports {

    /**
     * Initialize the component.
     *
     * At present, other methods of this interface may be called before the
     * returned promise is resolved or rejected.
     *
     * @return {Promise}
     * @resolves When initialization is complete.
     * @rejects JavaScript exception.
     */
    readonly initialize: () => IDLPromise;

    /**
     * Ensures that all data has been written to disk and all files are closed.
     *
     * At present, this method is called by regression tests only.  Finalization
     * on shutdown is done by observers within the component.
     *
     * @return {Promise}
     * @resolves When finalization is complete.
     * @rejects JavaScript exception.
     */
    readonly terminate: () => IDLPromise;

    /**
     * Store a new login in the storage module.
     *
     * @param aLogin
     *        The login to be added.
     * @param aPreEncrypted
     *        Whether the login was already encrypted or not.
     * @param aPlaintextUsername
     *        The plaintext username, if the login was already encrypted.
     * @param aPlaintextPassword
     *        The plaintext password, if the login was already encrypted.
     * @return a clone of the login info with the guid set (even if it was not provided).
     *
     * Default values for the login's nsILoginMetaInfo properties will be
     * created. However, if the caller specifies non-default values, they will
     * be used instead.
     */
    readonly addLogin: (aLogin: (nsILoginInfo | null), aPreEncrypted?: boolean, aPlaintextUsername?: IDLjsval, aPlaintextPassword?: IDLjsval) => (nsILoginInfo | null);

    /**
     * Remove a login from the storage module.
     *
     * @param aLogin
     *        The login to be removed.
     *
     * The specified login must exactly match a stored login. However, the
     * values of any nsILoginMetaInfo properties are ignored.
     */
    readonly removeLogin: (aLogin: (nsILoginInfo | null)) => void;

    /**
     * Modify an existing login in the storage module.
     *
     * @param oldLogin
     *        The login to be modified.
     * @param newLoginData
     *        The new login values (either a nsILoginInfo or nsIProperyBag)
     *
     * If newLoginData is a nsILoginInfo, all of the old login's nsILoginInfo
     * properties are changed to the values from newLoginData (but the old
     * login's nsILoginMetaInfo properties are unmodified).
     *
     * If newLoginData is a nsIPropertyBag, only the specified properties
     * will be changed. The nsILoginMetaInfo properties of oldLogin can be
     * changed in this manner.
     *
     * If the propertybag contains an item named "timesUsedIncrement", the
     * login's timesUsed property will be incremented by the item's value.
     */
    readonly modifyLogin: (oldLogin: (nsILoginInfo | null), newLoginData: (nsISupports | null)) => void;

    /**
     * Remove all stored logins.
     *
     * The browser sanitization feature allows the user to clear any stored
     * passwords. This interface allows that to be done without getting each
     * login first (which might require knowing the master password).
     */
    readonly removeAllLogins: () => void;

    /**
     * Fetch all logins in the login manager. An array is always returned;
     * if there are no logins the array is empty.
     *
     * @return An array of nsILoginInfo objects.
     */
    readonly getAllLogins: () => (nsILoginInfo | null)[];

    /**
     * Fetch all logins in the login manager. An array is always returned;
     * if there are no logins the array is empty.
     *
     * @return An array of nsILoginInfo objects.
     */
    readonly getAllLoginsAsync: () => IDLPromise;

    /**
     * Asynchonously search for logins in the login manager. The Promise always
     * resolves to an array; if there are no logins the array is empty.
     *
     * @param {object} matchData
     *        The data used to search as a JS object. This does not follow the same
     *        requirements as findLogins for those fields. Wildcard matches are
     *        simply not specified.
     * @return A promise resolving to an array of nsILoginInfo objects.
     */
    readonly searchLoginsAsync: (matchData: IDLjsval) => IDLPromise;

    /**
     * Search for logins in the login manager. An array is always returned;
     * if there are no logins the array is empty.
     * @deprecated New code should use `searchLoginsAsync`.
     *             Only autocomplete, prompt, and test code still use this.
     *
     * @param matchData
     *        The data used to search. This does not follow the same
     *        requirements as findLogins for those fields. Wildcard matches are
     *        simply not specified.
     * @return An array of nsILoginInfo objects.
     */
    readonly searchLogins: (matchData: (nsIPropertyBag | null)) => (nsILoginInfo | null)[];

    /**
     * Search for logins matching the specified criteria. Called when looking
     * for logins that might be applicable to a form or authentication request.
     *
     * @param aOrigin
     *        The origin to restrict searches to. For example: "http://www.site.com".
     * @param aActionURL
     *        For form logins, this argument should be the origin to which the
     *        form will be submitted. For HTTP auth. logins, specify null.
     * @param aHttpRealm
     *        For protocol logins, this argument should be the HTTP Realm
     *        for which the login applies. This is obtained from the
     *        WWW-Authenticate header. See RFC2617. For form logins,
     *        specify null.
     * @return An array of nsILoginInfo objects.
     */
    readonly findLogins: (aOrigin: IDLAString, aActionOrigin: IDLAString, aHttpRealm: IDLAString) => (nsILoginInfo | null)[];

    /**
     * Search for logins matching the specified criteria, as with
     * findLogins(). This interface only returns the number of matching
     * logins (and not the logins themselves), which allows a caller to
     * check for logins without causing the user to be prompted for a master
     * password to decrypt the logins.
     *
     * @param aOrigin
     *        The origin to restrict searches to. Specify an empty string
     *        to match all origins. A null value will not match any logins, and
     *        will thus always return a count of 0.
     * @param aActionOrigin
     *        The origin to which a form login will be submitted. To match any
     *        form login, specify an empty string. To not match any form
     *        login, specify null.
     * @param aHttpRealm
     *        The HTTP Realm for which the login applies. To match logins for
     *        any realm, specify an empty string. To not match logins for any
     *        realm, specify null.
     */
    readonly countLogins: (aOrigin: IDLAString, aActionOrigin: IDLAString, aHttpRealm: IDLAString) => number;

    /**
     * True when a master password prompt is being shown.
     */
    readonly uiBusy: boolean;

    /**
     * True when the master password has already been entered, and so a caller
     * can ask for decrypted logins without triggering a prompt.
     */
    readonly isLoggedIn: boolean;
  }

  export interface nsIFileURLRef {
    readonly name: "nsIFileURL";
    readonly number: "{e91ac988-27c2-448b-b1a1-3822e1ef1987}";
  }

  /**
   * nsIFileURL provides access to the underlying nsIFile object corresponding to
   * an URL.  The URL scheme need not be file:, since other local protocols may
   * map URLs to files (e.g., resource:).
   */
  export interface nsIFileURL extends nsIURL {

    /**
     * Get the nsIFile corresponding to this URL.
     *
     *  - Returns a reference to an immutable object.  Callers must clone
     *    before attempting to modify the returned nsIFile object.  NOTE: this
     *    constraint might not be enforced at runtime, so beware!!
     */
    readonly file: (nsIFile | null);
  }

  export interface nsIUrlClassifierHashCompleterRef {
    readonly name: "nsIUrlClassifierHashCompleter";
    readonly number: "{231fb2ad-ea8a-4e63-a331-eafc3b434811}";
  }

  /**
   * Clients updating the url-classifier database have the option of sending
   * partial (32-bit) hashes of URL fragments to be blacklisted.  If the
   * url-classifier encounters one of these truncated hashes, it will ask an
   * nsIUrlClassifierCompleter instance to asynchronously provide the complete
   * hash, along with some associated metadata.
   * This is only ever used for testing and should absolutely be deleted (I
   * think).
   */
  export interface nsIUrlClassifierHashCompleter extends nsISupports {

    /**
     * Request a completed hash from the given gethash url.
     *
     * @param partialHash
     *        The 32-bit hash encountered by the url-classifier.
     * @param gethashUrl
     *        The gethash url to use.
     * @param tableName
     *        The table where we matched the partial hash.
     * @param callback
     *        An nsIUrlClassifierCompleterCallback instance.
     */
    readonly complete: (partialHash: IDLACString, gethashUrl: IDLACString, tableName: IDLACString, callback: (nsIUrlClassifierHashCompleterCallback | null)) => void;
  }

  export interface nsICommandManagerRef {
    readonly name: "nsICommandManager";
    readonly number: "{bb5a1730-d83b-4fa2-831b-35b9d5842e84}";
  }

  export interface nsICommandManager extends nsISupports {

    readonly addCommandObserver: (aCommandObserver: (nsIObserver | nsIObserverFunction | null), aCommandToObserve: string) => void;

    readonly removeCommandObserver: (aCommandObserver: (nsIObserver | nsIObserverFunction | null), aCommandObserved: string) => void;

    readonly isCommandSupported: (aCommandName: string, aTargetWindow: (mozIDOMWindowProxy | null)) => boolean;

    readonly isCommandEnabled: (aCommandName: string, aTargetWindow: (mozIDOMWindowProxy | null)) => boolean;

    readonly getCommandState: (aCommandName: string, aTargetWindow: (mozIDOMWindowProxy | null), aCommandParams: (nsICommandParams | null)) => void;

    readonly doCommand: (aCommandName: string, aCommandParams: (nsICommandParams | null), aTargetWindow: (mozIDOMWindowProxy | null)) => void;
  }

  export interface nsISecurityUITelemetryRef {
    readonly name: "nsISecurityUITelemetry";
    readonly number: "{5d1acf82-223a-46fb-a8f3-a1b16e2ceb04}";

    WARNING_ADDON_ASKING_PREVENTED: 1;

    WARNING_ADDON_ASKING_PREVENTED_CLICK_THROUGH: 2;

    WARNING_CONFIRM_ADDON_INSTALL: 3;

    WARNING_CONFIRM_ADDON_INSTALL_CLICK_THROUGH: 4;

    WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE: 9;

    WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE_CLICK_THROUGH: 10;

    WARNING_BAD_CERT_ADD_EXCEPTION_BASE: 30;

    WARNING_BAD_CERT_ADD_EXCEPTION_FLAG_UNTRUSTED: 1;

    WARNING_BAD_CERT_ADD_EXCEPTION_FLAG_DOMAIN: 2;

    WARNING_BAD_CERT_ADD_EXCEPTION_FLAG_TIME: 4;

    WARNING_BAD_CERT_CONFIRM_ADD_EXCEPTION_BASE: 38;

    WARNING_BAD_CERT_CONFIRM_ADD_EXCEPTION_FLAG_UNTRUSTED: 1;

    WARNING_BAD_CERT_CONFIRM_ADD_EXCEPTION_FLAG_DOMAIN: 2;

    WARNING_BAD_CERT_CONFIRM_ADD_EXCEPTION_FLAG_TIME: 4;

    WARNING_BAD_CERT_TOP_CLICK_VIEW_CERT: 71;

    WARNING_BAD_CERT_TOP_DONT_REMEMBER_EXCEPTION: 72;

    WARNING_BAD_CERT_TOP_ADD_EXCEPTION_BASE: 76;

    WARNING_BAD_CERT_TOP_ADD_EXCEPTION_FLAG_UNTRUSTED: 1;

    WARNING_BAD_CERT_TOP_ADD_EXCEPTION_FLAG_DOMAIN: 2;

    WARNING_BAD_CERT_TOP_ADD_EXCEPTION_FLAG_TIME: 4;

    WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_BASE: 84;

    WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_FLAG_UNTRUSTED: 1;

    WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_FLAG_DOMAIN: 2;

    WARNING_BAD_CERT_TOP_CONFIRM_ADD_EXCEPTION_FLAG_TIME: 4;
  }

  export interface nsISecurityUITelemetry extends nsISupports {
  }

  export interface nsIIOUtilRef {
    readonly name: "nsIIOUtil";
    readonly number: "{e8152f7f-4209-4c63-ad23-c3d2aa0c5a49}";
  }

  /**
   * nsIIOUtil provdes various xpcom/io-related utility methods.
   */
  export interface nsIIOUtil extends nsISupports {

    /**
     * Test whether an input stream is buffered.  See nsStreamUtils.h
     * documentation for NS_InputStreamIsBuffered for the definition of
     * "buffered" used here and for edge-case behavior.
     *
     * @throws NS_ERROR_INVALID_POINTER if null is passed in.
     */
    readonly inputStreamIsBuffered: (aStream: (nsIInputStream | null)) => boolean;

    /**
     * Test whether an output stream is buffered.  See nsStreamUtils.h
     * documentation for NS_OutputStreamIsBuffered for the definition of
     * "buffered" used here and for edge-case behavior.
     *
     * @throws NS_ERROR_INVALID_POINTER if null is passed in.
     */
    readonly outputStreamIsBuffered: (aStream: (nsIOutputStream | null)) => boolean;
  }

  export interface nsINativeFileWatcherServiceRef {
    readonly name: "nsINativeFileWatcherService";
    readonly number: "{b3a4e8d8-7dc8-47db-a8b4-83736d7ac1aa}";
  }

  /**
   * A service providing native implementations of path changes notification.
   */
  export interface nsINativeFileWatcherService extends nsISupports {

    /**
     * Watches the passed path for changes. If it's a directory, every file
     * it contains is watched. Recursively watches subdirectories. If the
     * resource is already being watched, does nothing. If the passed path
     * is a file, the behaviour is not specified.
     *
     * @param pathToWatch The path to watch for changes.
     * @param onChange
     *        The callback invoked whenever a change on a watched
     *        resource is detected.
     * @param onError
     *        The optional callback invoked whenever an error occurs.
     * @param onSuccess
     *        The optional callback invoked when the file watcher starts
     *        watching the resource for changes.
     */
    readonly addPath: (pathToWatch: IDLAString, onChange: (nsINativeFileWatcherCallback | nsINativeFileWatcherCallbackFunction | null), onError?: (nsINativeFileWatcherErrorCallback | nsINativeFileWatcherErrorCallbackFunction | null), onSuccess?: (nsINativeFileWatcherSuccessCallback | nsINativeFileWatcherSuccessCallbackFunction | null)) => void;

    /**
     * Removes the provided path from the watched resources. If the path
     * was not being watched or the callbacks were not registered, silently
     * ignores the request.
     * Please note that the file watcher only considers the onChange callbacks
     * when deciding to close a watch on a resource. If there are no more onChange
     * callbacks associated to the watch, it gets closed (even though it still has
     * some error callbacks associated).
     *
     * @param pathToUnwatch The path to un-watch.
     * @param onChange
     *        The registered callback invoked whenever a change on a watched
     *        resource is detected.
     * @param onError
     *        The optionally registered callback invoked whenever an error
     *        occurs.
     * @param onSuccess
     *        The optional callback invoked when the file watcher stops
     *        watching the resource for changes.
     */
    readonly removePath: (pathToUnwatch: IDLAString, onChange: (nsINativeFileWatcherCallback | nsINativeFileWatcherCallbackFunction | null), onError?: (nsINativeFileWatcherErrorCallback | nsINativeFileWatcherErrorCallbackFunction | null), onSuccess?: (nsINativeFileWatcherSuccessCallback | nsINativeFileWatcherSuccessCallbackFunction | null)) => void;
  }

  export interface nsIBasicCardChangeDetailsRef {
    readonly name: "nsIBasicCardChangeDetails";
    readonly number: "{5296f79e-15ea-40c3-8196-19cfa64d328c}";
  }

  /**
   *  The basic card change details.
   *  Since PaymentAddress is an no constructor interface type, UI code can not
   *  easy create PaymentAddress by calling new PaymentAddress().
   *  Unfortunately, BasicCardResponse has a PaymentAddress attribute, billingAddress
   *  , it means UI can not create BsaicCardChangeDetails by calling the init() with a
   *  given JSObject directly, because PaymentAddress creation in JS code is hard.
   *  To let UI code can create BasicCardResponse easier, nsIBasicCardResponse is
   *  provided for UI by passing the raw data of BasicCardResponse,
   */
  export interface nsIBasicCardChangeDetails extends nsIMethodChangeDetails {

    /**
     *  The billing address.
     */
    readonly billingAddress: (nsIPaymentAddress | null);

    /**
     *  The initial method for nsIBasicCardChangeDetails.
     *  @param aBillingAddreess  - the billing address.
     */
    readonly initData: (billingAddress: (nsIPaymentAddress | null)) => void;
  }

  export interface nsIURLDecorationAnnotationsServiceRef {
    readonly name: "nsIURLDecorationAnnotationsService";
    readonly number: "{937d0c66-6821-4e3f-9e04-50dbc2b2b476}";
  }

  /**
   * A service that monitors updates to the anti-tracking URL decoration
   * annotations from remote settings.
   */
  export interface nsIURLDecorationAnnotationsService extends nsISupports {

    /**
     * Ensures that the list is updated and resolves the returned promise when
     * the update is finished.
     *
     * The new list will be written to a space-separated list of tokens inside
     * the following string preference:
     *   privacy.restrict3rdpartystorage.url_decorations
     *
     * This preference will be kept up to date with future list updates from
     * the remote settings server.  This preference cannot be modified by any
     * external component and is managed by this service.
     */
    readonly ensureUpdated: () => IDLPromise;
  }

  export interface nsIHandleReportCallbackRef {
    readonly name: "nsIHandleReportCallback";
    readonly number: "{62ef0e1c-dbd6-11e3-aa75-3c970e9f4238}";
  }

  type nsIHandleReportCallbackFunction = (process: IDLACString, path: IDLAUTF8String, kind: number, units: number, amount: number, description: IDLAUTF8String, data: (nsISupports | null)) => void;

  export interface nsIHandleReportCallback extends nsISupports {

    readonly callback: (process: IDLACString, path: IDLAUTF8String, kind: number, units: number, amount: number, description: IDLAUTF8String, data: (nsISupports | null)) => void;
  }

  export interface nsIPluginHostRef {
    readonly name: "nsIPluginHost";
    readonly number: "{f938f5ba-7093-42cd-a559-af8039d99204}";

    FLAG_CLEAR_ALL: 0;

    FLAG_CLEAR_CACHE: 1;

    EXCLUDE_NONE: 0;

    EXCLUDE_DISABLED: 1;

    EXCLUDE_FAKE: 2;
  }

  export interface nsIPluginHost extends nsISupports {

    /**
     * Causes the plugins directory to be searched again for new plugin
     * libraries.
     */
    readonly reloadPlugins: () => void;

    readonly getPluginTags: () => (nsIPluginTag | null)[];

    readonly clearSiteData: (plugin: (nsIPluginTag | null), domain: IDLAUTF8String, flags: number, maxAge: number, callback: (nsIClearSiteDataCallback | nsIClearSiteDataCallbackFunction | null)) => void;

    readonly siteHasData: (plugin: (nsIPluginTag | null), domain: IDLAUTF8String) => boolean;

    /**
     * Get the "permission string" for the plugin.  This is a string that can be
     * passed to the permission manager to see whether the plugin is allowed to
     * run, for example.  This will typically be based on the plugin's "nice name"
     * and its blocklist state.
     *
     * @mimeType The MIME type we're interested in.
     * @excludeFlags Set of the EXCLUDE_* flags above, defaulting to EXCLUDE_NONE.
     */
    readonly getPermissionStringForType: (mimeType: IDLAUTF8String, excludeFlags?: number) => IDLACString;

    /**
     * Get the "permission string" for the plugin.  This is a string that can be
     * passed to the permission manager to see whether the plugin is allowed to
     * run, for example.  This will typically be based on the plugin's "nice name"
     * and its blocklist state.
     *
     * @tag The tage we're interested in
     * @excludeFlags Set of the EXCLUDE_* flags above, defaulting to EXCLUDE_NONE.
     */
    readonly getPermissionStringForTag: (tag: (nsIPluginTag | null), excludeFlags?: number) => IDLACString;

    /**
     * Get the nsIPluginTag for this MIME type. This method works with both
     * enabled and disabled/blocklisted plugins, but an enabled plugin will
     * always be returned if available.
     *
     * A fake plugin tag, if one exists and is available, will be returned in
     * preference to NPAPI plugin tags unless excluded by the excludeFlags.
     *
     * @mimeType The MIME type we're interested in.
     * @excludeFlags Set of the EXCLUDE_* flags above, defaulting to EXCLUDE_NONE.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if no plugin is available for this MIME
     *         type.
     */
    readonly getPluginTagForType: (mimeType: IDLAUTF8String, excludeFlags?: number) => (nsIPluginTag | null);

    /**
     * Get the nsIPluginTag enabled state for this MIME type.  See
     * nsIPluginTag.enabledState.
     *
     * @mimeType The MIME type we're interested in.
     * @excludeFlags Set of the EXCLUDE_* flags above, defaulting to EXCLUDE_NONE.
     */
    readonly getStateForType: (mimeType: IDLAUTF8String, excludeFlags?: number) => number;

    /**
     * Get the blocklist state for a MIME type.  See nsIPluginTag.blocklistState.
     *
     * @mimeType The MIME type we're interested in.
     * @excludeFlags Set of the EXCLUDE_* flags above, defaulting to EXCLUDE_NONE.
     */
    readonly getBlocklistStateForType: (aMimeType: IDLAUTF8String, excludeFlags?: number) => number;

    /**
     * Create a fake plugin tag, register it, and return it.  The argument is a
     * FakePluginTagInit dictionary.  See documentation in
     * FakePluginTagInit.webidl for what it should look like.  Will throw
     * NS_ERROR_UNEXPECTED if there is already a fake plugin registered with the
     * given handler URI.
     */
    readonly registerFakePlugin: (initDictionary: IDLjsval) => (nsIFakePluginTag | null);

    /**
     * Create a fake plugin tag without registering it.
     *
     * Only for use in tests.
     */
    readonly createFakePlugin: (initDictionary: IDLjsval) => (nsIFakePluginTag | null);

    /**
     * Get a reference to an existing fake plugin tag for the given MIME type, if
     * any.  Can return null.
     */
    readonly getFakePlugin: (mimeType: IDLAUTF8String) => (nsIFakePluginTag | null);

    /**
     * Unregister a fake plugin.  The argument can be the .handlerURI.spec of an
     * existing nsIFakePluginTag, or just a known handler URI string that was
     * passed in the FakePluginTagInit when registering.
     */
    readonly unregisterFakePlugin: (handlerURI: IDLAUTF8String) => void;
  }

  export enum nsIRemoteTab_NavigationType {
    NAVIGATE_BACK = 0,
    NAVIGATE_FORWARD = 1,
    NAVIGATE_INDEX = 2,
    NAVIGATE_URL = 3,
  }

  export interface nsIRemoteTabRef {
    readonly name: "nsIRemoteTab";
    readonly number: "{8e49f7b0-1f98-4939-bf91-e9c39cd56434}";

    NAVIGATE_BACK: 0;
    NAVIGATE_FORWARD: 1;
    NAVIGATE_INDEX: 2;
    NAVIGATE_URL: 3;
  }

  export interface nsIRemoteTab extends nsISupports {

    /**
     * Manages the docshell active state of the remote browser. Setting the
     * docShell to be active will also cause it to render layers and upload
     * them to the compositor. Setting the docShell as not active will clear
     * those layers.
     */
    docShellIsActive: boolean;

    /**
     * When set to true, this tells the child to paint and upload layers to
     * the compositor. When set to false, previous layers are cleared from
     * the compositor, but only if preserveLayers is also set to false.
     */
    renderLayers: boolean;

    /**
     * True if layers are being rendered and the compositor has reported
     * receiving them.
     */
    readonly hasLayers: boolean;

    /**
     * Adjusts the tab's active state in the process priority manager,
     * allowing its process to be given a lower priority.
     */
    readonly deprioritize: () => void;

    /**
     * As an optimisation, setting the docshell's active state to
     * inactive also triggers a layer invalidation to free up some
     * potentially unhelpful memory usage. Calling preserveLayers
     * will cause the layers to be preserved even for inactive
     * docshells.
     */
    readonly preserveLayers: (aPreserveLayers: boolean) => void;

    readonly tabId: number;

    readonly contentProcessId: number;

    /**
     * The OS level process Id of the related child process.
     */
    readonly osPid: number;

    /**
     * True if we've previously received layers for this tab when switching to
     * it.
     */
    readonly hasPresented: boolean;

    /**
     * Ensures that the content process which has this remote tab has all of the
     * permissions required to load a document with the given principal.
     */
    readonly transmitPermissionsForPrincipal: (aPrincipal: (nsIPrincipal | null)) => void;

    /**
     * True if any of the frames loaded in the tab have registered
     * an onbeforeunload event handler.
     */
    readonly hasBeforeUnload: boolean;

    /**
     * Notify APZ to start autoscrolling.
     * (aAnchorX, aAnchorY) are the coordinates of the autoscroll anchor,
     * in CSS coordinates relative to the screen. aScrollId and
     * aPresShellId identify the scroll frame that content chose to scroll.
     * Returns whether we were successfully able to notify APZ.
     * If this function returns true, APZ (which may live in another process)
     * may still reject the autoscroll, but it's then APZ's reponsibility
     * to notify content via an "autoscroll-rejected-by-apz" message.
     */
    readonly startApzAutoscroll: (aAnchorX: number, aAnchorY: number, aScrollId: number, aPresShellId: number) => boolean;

    /**
     * Notify APZ to stop autoscrolling.
     * aScrollId and aPresShellId identify the scroll frame that is being
     * autoscrolled.
     */
    readonly stopApzAutoscroll: (aScrollId: number, aPresShellId: number) => void;

    /**
     * Save a recording of the associated content process' behavior to the
     * specified filename. Returns whether the process is being recorded.
     */
    readonly saveRecording: (aFileName: IDLAString) => boolean;

    /**
     * Asynchronously retrieve a JSON string representing a log of the
     * content blocking events happened so far in the current tab from the
     * content process.
     *
     * This returns a Promise which resolves to a string on success, and is
     * rejected on failure.  For documentation on the string format, please
     * see nsISecureBrowserUI.contentBlockingLogJSON.
     */
    readonly getContentBlockingLog: () => IDLPromise;

    /**
     * Interrupt content scripts if possible/needed to allow chrome scripts in the
     * content process to run (in particular, to allow navigating through browser
     * history.
     */
    readonly maybeCancelContentJSExecution: (aNavigationType: nsIRemoteTab_NavigationType, aCancelContentJSOptions?: IDLjsval) => void;
  }

  export interface nsIPaymentRequestRef {
    readonly name: "nsIPaymentRequest";
    readonly number: "{2fa36783-d684-4487-b7a8-9def6ae3128f}";
  }

  export interface nsIPaymentRequest extends nsISupports {

    readonly topOuterWindowId: number;

    readonly topLevelPrincipal: (nsIPrincipal | null);

    readonly requestId: IDLAString;

    readonly completeStatus: IDLAString;

    readonly paymentMethods: (nsIArray | null);

    readonly paymentDetails: (nsIPaymentDetails | null);

    readonly paymentOptions: (nsIPaymentOptions | null);

    readonly shippingOption: IDLAString;
  }

  export interface nsICachingChannelRef {
    readonly name: "nsICachingChannel";
    readonly number: "{dd1d6122-5ecf-4fe4-8f0f-995e7ab3121a}";

    /**************************************************************************
     * Caching channel specific load flags:
     */
    /**
     * This load flag inhibits fetching from the net.  An error of
     * NS_ERROR_DOCUMENT_NOT_CACHED will be sent to the listener's
     * onStopRequest if network IO is necessary to complete the request.
     *
     * This flag can be used to find out whether fetching this URL would
     * cause validation of the cache entry via the network.
     *
     * Combining this flag with LOAD_BYPASS_LOCAL_CACHE will cause all
     * loads to fail.
     */
    LOAD_NO_NETWORK_IO: 67108864;

    /**
     * This load flag causes the offline cache to be checked when fetching
     * a request.  It will be set automatically if the browser is offline.
     *
     * This flag will not be transferred through a redirect.
     */
    LOAD_CHECK_OFFLINE_CACHE: 134217728;

    /**
     * This load flag causes the local cache to be skipped when fetching a
     * request.  Unlike LOAD_BYPASS_CACHE, it does not force an end-to-end load
     * (i.e., it does not affect proxy caches).
     */
    LOAD_BYPASS_LOCAL_CACHE: 268435456;

    /**
     * This load flag causes the local cache to be skipped if the request
     * would otherwise block waiting to access the cache.
     */
    LOAD_BYPASS_LOCAL_CACHE_IF_BUSY: 536870912;

    /**
     * This load flag inhibits fetching from the net if the data in the cache
     * has been evicted.  An error of NS_ERROR_DOCUMENT_NOT_CACHED will be sent
     * to the listener's onStopRequest in this case.  This flag is set
     * automatically when the application is offline.
     */
    LOAD_ONLY_FROM_CACHE: 1073741824;

    /**
     * This load flag controls what happens when a document would be loaded
     * from the cache to satisfy a call to AsyncOpen.  If this attribute is
     * set to TRUE, then the document will not be loaded from the cache.  A
     * stream listener can check nsICachingChannel::isFromCache to determine
     * if the AsyncOpen will actually result in data being streamed.
     *
     * If this flag has been set, and the request can be satisfied via the
     * cache, then the OnDataAvailable events will be skipped.  The listener
     * will only see OnStartRequest followed by OnStopRequest.
     */
    LOAD_ONLY_IF_MODIFIED: 2147483648;
  }

  /**
   * A channel may optionally implement this interface to allow clients
   * to affect its behavior with respect to how it uses the cache service.
   *
   * This interface provides:
   *   1) Support for "stream as file" semantics (for JAR and plugins).
   *   2) Support for "pinning" cached data in the cache (for printing and save-as).
   *   3) Support for uniquely identifying cached data in cases when the URL
   *      is insufficient (e.g., HTTP form submission).
   */
  export interface nsICachingChannel extends nsICacheInfoChannel {

    /**
     * Set/get the cache token... uniquely identifies the data in the cache.
     * Holding a reference to this token prevents the cached data from being
     * removed.
     *
     * A cache token retrieved from a particular instance of nsICachingChannel
     * could be set on another instance of nsICachingChannel provided the
     * underlying implementations are compatible.  The implementation of
     * nsICachingChannel would be expected to only read from the cache entry
     * identified by the cache token and not try to validate it.
     *
     * The cache token can be QI'd to a nsICacheEntryInfo if more detail
     * about the cache entry is needed (e.g., expiration time).
     */
    cacheToken: (nsISupports | null);

    /**
     * The same as above but accessing the offline app cache token if there
     * is any.
     *
     * @throws
     *      NS_ERROR_NOT_AVAILABLE when there is not offline cache token
     */
    offlineCacheToken: (nsISupports | null);

    /**
     * Instructs the channel to only store the metadata of the entry, and not
     * the content. When reading an existing entry, this automatically sets
     * LOAD_ONLY_IF_MODIFIED flag.
     * Must be called before asyncOpen().
     */
    cacheOnlyMetadata: boolean;

    /**
     * Tells the channel to use the pinning storage.
     */
    pin: boolean;

    /**
     * Overrides cache validation for a time specified in seconds.
     *
     * @param aSecondsToTheFuture
     *
     */
    readonly forceCacheEntryValidFor: (aSecondsToTheFuture: number) => void;
  }

  export interface nsIProgressEventSinkRef {
    readonly name: "nsIProgressEventSink";
    readonly number: "{87d55fba-cb7e-4f38-84c1-5c6c2b2a55e9}";
  }

  /**
   * nsIProgressEventSink
   *
   * This interface is used to asynchronously convey channel status and progress
   * information that is generally not critical to the processing of the channel.
   * The information is intended to be displayed to the user in some meaningful
   * way.
   *
   * An implementation of this interface can be passed to a channel via the
   * channel's notificationCallbacks attribute.  See nsIChannel for more info.
   *
   * The channel will begin passing notifications to the progress event sink
   * after its asyncOpen method has been called.  Notifications will cease once
   * the channel calls its listener's onStopRequest method or once the channel
   * is canceled (via nsIRequest::cancel).
   *
   * NOTE: This interface is actually not specific to channels and may be used
   * with other implementations of nsIRequest.
   */
  export interface nsIProgressEventSink extends nsISupports {

    /**
     * Called to notify the event sink that progress has occurred for the
     * given request.
     *
     * @param aRequest
     *        the request being observed (may QI to nsIChannel).
     * @param aContext
     *        if aRequest is a channel, then this parameter is the listener
     *        context passed to nsIChannel::asyncOpen.
     * @param aProgress
     *        numeric value in the range 0 to aProgressMax indicating the
     *        number of bytes transfered thus far.
     * @param aProgressMax
     *        numeric value indicating maximum number of bytes that will be
     *        transfered (or -1 if total is unknown).
     */
    readonly onProgress: (aRequest: (nsIRequest | null), aContext: (nsISupports | null), aProgress: number, aProgressMax: number) => void;

    /**
     * Called to notify the event sink with a status message for the given
     * request.
     *
     * @param aRequest
     *        the request being observed (may QI to nsIChannel).
     * @param aContext
     *        if aRequest is a channel, then this parameter is the listener
     *        context passed to nsIChannel::asyncOpen.
     * @param aStatus
     *        status code (not necessarily an error code) indicating the
     *        state of the channel (usually the state of the underlying
     *        transport).  see nsISocketTransport for socket specific status
     *        codes.
     * @param aStatusArg
     *        status code argument to be used with the string bundle service
     *        to convert the status message into localized, human readable
     *        text.  the meaning of this parameter is specific to the value
     *        of the status code.  for socket status codes, this parameter
     *        indicates the host:port associated with the status code.
     */
    readonly onStatus: (aRequest: (nsIRequest | null), aContext: (nsISupports | null), aStatus: number, aStatusArg: string) => void;
  }

  export interface nsILoadContextInfoFactoryRef {
    readonly name: "nsILoadContextInfoFactory";
    readonly number: "{c1c7023d-4318-4f99-8307-b5ccf0558793}";
  }

  /**
   * Since OriginAttributes struct limits the implementation of
   * nsILoadContextInfo (that needs to be thread safe) to C++,
   * we need a scriptable factory to create instances of that
   * interface from JS.
   */
  export interface nsILoadContextInfoFactory extends nsISupports {

    readonly default: (nsILoadContextInfo | null);

    readonly private: (nsILoadContextInfo | null);

    readonly anonymous: (nsILoadContextInfo | null);

    readonly custom: (aAnonymous: boolean, aOriginAttributes: IDLjsval) => (nsILoadContextInfo | null);

    readonly fromLoadContext: (aLoadContext: (nsILoadContext | null), aAnonymous: boolean) => (nsILoadContextInfo | null);

    readonly fromWindow: (aWindow: (nsIDOMWindow | null), aAnonymous: boolean) => (nsILoadContextInfo | null);
  }

  export interface nsISubstitutingProtocolHandlerRef {
    readonly name: "nsISubstitutingProtocolHandler";
    readonly number: "{154c64fd-a69e-4105-89f8-bd7dfe621372}";

    /**
     * Content script may access files in this package.
     */
    ALLOW_CONTENT_ACCESS: 1;

    /**
     * This substitution exposes nsIJARURI instead of a nsIFileURL.  By default
     * NewURI will always return a nsIFileURL even when the URL is jar:
     */
    RESOLVE_JAR_URI: 2;
  }

  /**
   * Protocol handler superinterface for a protocol which performs substitutions
   * from URIs of its scheme to URIs of another scheme.
   */
  export interface nsISubstitutingProtocolHandler extends nsIProtocolHandler {

    /**
     * Sets the substitution for the root key:
     *   resource://root/path ==> baseURI.resolve(path)
     *
     * A null baseURI removes the specified substitution.
     *
     * The root key will be converted to lower-case to conform to
     * case-insensitive URI hostname matching behavior.
     */
    readonly setSubstitution: (root: IDLACString, baseURI: (nsIURI | null)) => void;

    /**
     * Same as setSubstitution, but with specific flags.
     */
    readonly setSubstitutionWithFlags: (root: IDLACString, baseURI: (nsIURI | null), flags: number) => void;

    /**
     * Gets the substitution for the root key.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if none exists.
     */
    readonly getSubstitution: (root: IDLACString) => (nsIURI | null);

    /**
     * Returns TRUE if the substitution exists and FALSE otherwise.
     */
    readonly hasSubstitution: (root: IDLACString) => boolean;

    /**
     * Utility function to resolve a substituted URI.  A resolved URI is not
     * guaranteed to reference a resource that exists (ie. opening a channel to
     * the resolved URI may fail).
     *
     * @throws NS_ERROR_NOT_AVAILABLE if resURI.host() is an unknown root key.
     */
    readonly resolveURI: (resURI: (nsIURI | null)) => IDLAUTF8String;

    /**
     * Adds an observer that will be notified on the main thread whenever a
     * substitition is set or unset. Notifications are not sent for substitutions
     * that were set prior to the observer being added. Holds an owning reference
     * to the observer until removeObserver is called or the protocol handler is
     * destroyed.
     */
    readonly addObserver: (observer: (nsISubstitutionObserver | null)) => void;

    /**
     * Removes the observer.
     */
    readonly removeObserver: (observer: (nsISubstitutionObserver | null)) => void;
  }

  export interface nsIPK11TokenDBRef {
    readonly name: "nsIPK11TokenDB";
    readonly number: "{4ee28c82-1dd2-11b2-aabf-bb4017abe395}";
  }

  /**
   * The PK11 Token Database provides access to the PK11 modules
   * that are installed, and the tokens that are available.
   * Interfaces: nsIPK11TokenDB
   * Threading: ??
   */
  /**
   * nsIPK11TokenDB - Manages PK11 Tokens
   */
  export interface nsIPK11TokenDB extends nsISupports {

    readonly getInternalKeyToken: () => (nsIPK11Token | null);
  }

  export interface nsISocketProviderServiceRef {
    readonly name: "nsISocketProviderService";
    readonly number: "{8f8a23d0-5472-11d3-bbc8-0000861d1237}";
  }

  /**
   * nsISocketProviderService
   *
   * Provides a mapping between a socket type and its associated socket provider
   * instance.  One could also use the service manager directly.
   */
  export interface nsISocketProviderService extends nsISupports {

    readonly getSocketProvider: (socketType: string) => (nsISocketProvider | null);
  }

  export interface nsIContentPermissionTypeRef {
    readonly name: "nsIContentPermissionType";
    readonly number: "{ef4db3b8-ca9c-4b1d-8f81-fd88ec32af13}";
  }

  /**
   *  Interface provides the request type and its access.
   */
  export interface nsIContentPermissionType extends nsISupports {

    /**
     *  The type of the permission request, such as
     *  "geolocation".
     */
    readonly type: IDLACString;

    /**
     * The array of available options.
     */
    readonly options: (nsIArray | null);
  }

  export interface nsIMIMEInputStreamRef {
    readonly name: "nsIMIMEInputStream";
    readonly number: "{dcbce63c-1dd1-11b2-b94d-91f6d49a3161}";
  }

  /**
   * The MIME stream separates headers and a datastream. It also allows
   * automatic creation of the content-length header.
   */
  export interface nsIMIMEInputStream extends nsIInputStream {

    /**
     * Adds an additional header to the stream on the form "name: value". May
     * not be called once the stream has been started to be read.
     * @param name   name of the header
     * @param value  value of the header
     */
    readonly addHeader: (name: string, value: string) => void;

    /**
     * Visits all headers which have been added via addHeader.  Calling
     * addHeader while visiting request headers has undefined behavior.
     *
     * @param aVisitor
     *        The header visitor instance.
     */
    readonly visitHeaders: (visitor: (nsIHttpHeaderVisitor | nsIHttpHeaderVisitorFunction | null)) => void;

    /**
     * Sets data-stream. May not be called once the stream has been started
     * to be read.
     * The cursor of the new stream should be located at the beginning of the
     * stream if the implementation of the nsIMIMEInputStream also is used as
     * an nsISeekableStream.
     * @param stream  stream containing the data for the stream
     */
    readonly setData: (stream: (nsIInputStream | null)) => void;

    /**
     * Get the wrapped data stream
     */
    readonly data: (nsIInputStream | null);
  }

  export interface nsIBitsNewRequestCallbackRef {
    readonly name: "nsIBitsNewRequestCallback";
    readonly number: "{aa12e433-5b9f-452d-b5c9-840a9541328b}";
  }

  export interface nsIBitsNewRequestCallback extends nsISupports {

    /**
     * This callback interface is for use by the nsIBits interface for returning
     * results asynchronously to the caller.
     */
    readonly success: (request: (nsIBitsRequest | null)) => void;

    readonly failure: (errorType: number, errorAction: number, errorStage: number) => void;

    readonly failureNsresult: (errorType: number, errorAction: number, errorStage: number, errorCode: number) => void;

    readonly failureHresult: (errorType: number, errorAction: number, errorStage: number, errorCode: number) => void;

    readonly failureString: (errorType: number, errorAction: number, errorStage: number, errorMessage: IDLAUTF8String) => void;
  }

  export interface nsIXPCComponents_IDRef {
    readonly name: "nsIXPCComponents_ID";
    readonly number: "{7994a6e0-e028-11d3-8f5d-0010a4e73d9a}";
  }

  /**
   * interface of Components.ID
   * (interesting stuff only reflected into JavaScript)
   */
  export interface nsIXPCComponents_ID extends nsISupports {
  }

  export interface nsIInterceptedBodyCallbackRef {
    readonly name: "nsIInterceptedBodyCallback";
    readonly number: "{51039eb6-bea0-40c7-b523-ccab56cc4fde}";
  }

  /**
   * Interface allowing the nsIInterceptedChannel to callback when it is
   * done reading from the body stream.
   */
  export interface nsIInterceptedBodyCallback extends nsISupports {

    readonly bodyComplete: (aRv: number) => void;
  }

  export interface nsIDHCPClientRef {
    readonly name: "nsIDHCPClient";
    readonly number: "{aee75dc0-be1a-46b9-9e0c-31a6899c175c}";
  }

  /**
   * This interface allows the proxy code to access the DHCP Options in a platform-specific way
   */
  export interface nsIDHCPClient extends nsISupports {

    /**
     * returns the DHCP Option designated by the option parameter
     */
    readonly getOption: (option: number) => IDLACString;
  }

  export interface nsIWebHandlerAppRef {
    readonly name: "nsIWebHandlerApp";
    readonly number: "{7521a093-c498-45ce-b462-df7ba0d882f6}";
  }

  /**
   * nsIWebHandlerApp is a web-based handler, as speced by the WhatWG HTML5
   * draft.  Currently, only GET-based handlers are supported.  At some point,
   * we probably want to work with WhatWG to spec out and implement POST-based
   * handlers as well.
   */
  export interface nsIWebHandlerApp extends nsIHandlerApp {

    /**
     * Template used to construct the URI to GET.  Template is expected to have
     * a %s in it, and the escaped URI to be handled is inserted in place of
     * that %s, as per the HTML5 spec.
     */
    uriTemplate: IDLAUTF8String;
  }

  export interface imgIToolsRef {
    readonly name: "imgITools";
    readonly number: "{4c2383a4-931c-484d-8c4a-973590f66e3f}";
  }

  export interface imgITools extends nsISupports {

    /**
     * decodeImageFromBuffer
     * Caller provides an buffer, a buffer size and a mimetype. We read from
     * the stream and decompress it (according to the specified mime type) and
     * return the resulting imgIContainer.
     *
     * @param aBuffer
     *        Data in memory.
     * @param aSize
     *        Buffer size.
     * @param aMimeType
     *        Type of image in the stream.
     */
    readonly decodeImageFromBuffer: (aBuffer: string, aSize: number, aMimeType: IDLACString) => (imgIContainer | null);

    /**
     * decodeImageFromArrayBuffer
     * Caller provides an ArrayBuffer and a mimetype. We read from
     * the stream and decompress it (according to the specified mime type) and
     * return the resulting imgIContainer.
     *
     * @param aArrayBuffer
     *        An ArrayBuffer.
     * @param aMimeType
     *        Type of image in the stream.
     */
    readonly decodeImageFromArrayBuffer: (aArrayBuffer: IDLjsval, aMimeType: IDLACString) => (imgIContainer | null);

    /**
     * decodeImageFromChannelAsync
     * See decodeImage. The main difference between this method and decodeImage
     * is that here the operation is done async on a thread from the decode
     * pool. When the operation is completed, the callback is executed with the
     * result.
     *
     * @param aURI
     *        The original URI of the image
     * @param aChannel
     *        Channel to the image to be decoded.
     * @param aCallback
     *        The callback is executed when the imgContainer is fully created.
     * @param aObserver
     *        Optional observer for the decoded image, the caller should make
     *        sure the observer is kept alive as long as necessary, as ImageLib
     *        does not keep a strong reference to the observer.
     */
    readonly decodeImageFromChannelAsync: (aURI: (nsIURI | null), aChannel: (nsIChannel | null), aCallback: (imgIContainerCallback | imgIContainerCallbackFunction | null), aObserver: (imgINotificationObserver | null)) => void;

    /**
     * decodeImageAsync
     * See decodeImage. The main difference between this method and decodeImage
     * is that here the operation is done async on a thread from the decode
     * pool. When the operation is completed, the callback is executed with the
     * result.
     *
     * @param aStream
     *        An input stream for an encoded image file.
     * @param aMimeType
     *        Type of image in the stream.
     * @param aCallback
     *        The callback is executed when the imgContainer is fully created.
     * @param aEventTarget
     *        This eventTarget is used to execute aCallback
     */
    readonly decodeImageAsync: (aStream: (nsIInputStream | null), aMimeType: IDLACString, aCallback: (imgIContainerCallback | imgIContainerCallbackFunction | null), aEventTarget: (nsIEventTarget | null)) => void;

    /**
     * encodeImage
     * Caller provides an image container, and the mime type it should be
     * encoded to. We return an input stream for the encoded image data.
     *
     * @param aContainer
     *        An image container.
     * @param aMimeType
     *        Type of encoded image desired (eg "image/png").
     * @param outputOptions
     *        Encoder-specific output options.
     */
    readonly encodeImage: (aContainer: (imgIContainer | null), aMimeType: IDLACString, outputOptions?: IDLAString) => (nsIInputStream | null);

    /**
     * encodeScaledImage
     * Caller provides an image container, and the mime type it should be
     * encoded to. We return an input stream for the encoded image data.
     * The encoded image is scaled to the specified dimensions.
     *
     * @param aContainer
     *        An image container.
     * @param aMimeType
     *        Type of encoded image desired (eg "image/png").
     * @param aWidth, aHeight
     *        The size (in pixels) desired for the resulting image. Specify 0 to
     *        use the given image's width or height. Values must be >= 0.
     * @param outputOptions
     *        Encoder-specific output options.
     */
    readonly encodeScaledImage: (aContainer: (imgIContainer | null), aMimeType: IDLACString, aWidth: number, aHeight: number, outputOptions?: IDLAString) => (nsIInputStream | null);

    /**
     * getImgLoaderForDocument
     * Retrieve an image loader that reflects the privacy status of the given
     * document.
     *
     * @param doc
     *        A document. Must not be null.
     */
    readonly getImgLoaderForDocument: (doc: WebIDL.Document) => (imgILoader | null);

    /**
     * getImgLoaderForDocument
     * Retrieve an image cache that reflects the privacy status of the given
     * document.
     *
     * @param doc
     *        A document. Null is allowed, but must _only_ be passed
     *        when there is no way to obtain a relevant document for
     *        the current context in which a cache is desired.
     */
    readonly getImgCacheForDocument: (doc: WebIDL.Document) => (imgICache | null);

    /**
     * encodeCroppedImage
     * Caller provides an image container, and the mime type it should be
     * encoded to. We return an input stream for the encoded image data.
     * The encoded image is cropped to the specified dimensions.
     *
     * The given offset and size must not exceed the image bounds.
     *
     * @param aContainer
     *        An image container.
     * @param aMimeType
     *        Type of encoded image desired (eg "image/png").
     * @param aOffsetX, aOffsetY
     *        The crop offset (in pixels). Values must be >= 0.
     * @param aWidth, aHeight
     *        The size (in pixels) desired for the resulting image. Specify 0 to
     *        use the given image's width or height. Values must be >= 0.
     * @param outputOptions
     *        Encoder-specific output options.
     */
    readonly encodeCroppedImage: (aContainer: (imgIContainer | null), aMimeType: IDLACString, aOffsetX: number, aOffsetY: number, aWidth: number, aHeight: number, outputOptions?: IDLAString) => (nsIInputStream | null);

    /**
     * Create a wrapper around a scripted notification observer (ordinarily
     * imgINotificationObserver cannot be implemented from scripts).
     *
     * @param aObserver The scripted observer to wrap
     */
    readonly createScriptedObserver: (aObserver: (imgIScriptedNotificationObserver | null)) => (imgINotificationObserver | null);
  }

  export interface nsIExpatSinkRef {
    readonly name: "nsIExpatSink";
    readonly number: "{01f681af-0f22-4725-a914-0d396114daf0}";
  }

  /**
   * This interface should be implemented by any content sink that wants
   * to get output from expat and do something with it; in other words,
   * by any sink that handles some sort of XML dialect.
   */
  export interface nsIExpatSink extends nsISupports {

    /**
     * Called to handle the opening tag of an element.
     * @param aName the fully qualified tagname of the element
     * @param aAtts the array of attribute names and values.  There are
     *        aAttsCount/2 names and aAttsCount/2 values, so the total number of
     *        elements in the array is aAttsCount.  The names and values
     *        alternate.  Thus, if we number attributes starting with 0,
     *        aAtts[2*k] is the name of the k-th attribute and aAtts[2*k+1] is
     *        the value of that attribute  Both explicitly specified attributes
     *        and attributes that are defined to have default values in a DTD are
     *        present in aAtts.
     * @param aAttsCount the number of elements in aAtts.
     * @param aLineNumber the line number of the start tag in the data stream.
     * @param aColumnNumber the column number of the start tag in the data stream.
     */
    readonly HandleStartElement: (aName: string, aAtts: string[], aAttsCount: number, aLineNumber: number, aColumnNumber: number) => void;

    /**
     * Called to handle the closing tag of an element.
     * @param aName the fully qualified tagname of the element
     */
    readonly HandleEndElement: (aName: string) => void;

    /**
     * Called to handle a comment
     * @param aCommentText the text of the comment (not including the
     *        "<!--" and "-->")
     */
    readonly HandleComment: (aCommentText: string) => void;

    /**
     * Called to handle a CDATA section
     * @param aData the text in the CDATA section.  This is null-terminated.
     * @param aLength the length of the aData string
     */
    readonly HandleCDataSection: (aData: string, aLength: number) => void;

    /**
     * Called to handle the doctype declaration
     */
    readonly HandleDoctypeDecl: (aSubset: IDLAString, aName: IDLAString, aSystemId: IDLAString, aPublicId: IDLAString, aCatalogData: (nsISupports | null)) => void;

    /**
     * Called to handle character data.  Note that this does NOT get
     * called for the contents of CDATA sections.
     * @param aData the data to handle.  aData is NOT NULL-TERMINATED.
     * @param aLength the length of the aData string
     */
    readonly HandleCharacterData: (aData: string, aLength: number) => void;

    /**
     * Called to handle a processing instruction
     * @param aTarget the PI target (e.g. xml-stylesheet)
     * @param aData all the rest of the data in the PI
     */
    readonly HandleProcessingInstruction: (aTarget: string, aData: string) => void;

    /**
     * Handle the XML Declaration.
     *
     * @param aVersion    The version string, can be null if not specified.
     * @param aEncoding   The encoding string, can be null if not specified.
     * @param aStandalone -1, 0, or 1 indicating respectively that there was no
     *                    standalone parameter in the declaration, that it was
     *                    given as no, or that it was given as yes.
     */
    readonly HandleXMLDeclaration: (aVersion: string, aEncoding: string, aStandalone: number) => void;

    /**
     * Ask the content sink if the expat driver should log an error to the console.
     *
     * @param aErrorText  Error message to pass to content sink.
     * @param aSourceText Source text of the document we're parsing.
     * @param aError      Script error object with line number & column number
     *
     * @retval True if the expat driver should report the error.
     */
    readonly ReportError: (aErrorText: string, aSourceText: string, aError: (nsIScriptError | null)) => boolean;
  }

  export interface nsIBinaryInputStreamRef {
    readonly name: "nsIBinaryInputStream";
    readonly number: "{899b826b-2eb3-469c-8b31-4c29f5d341a6}";
  }

  /**
   * This interface allows consumption of primitive data types from a "binary
   * stream" containing untagged, big-endian binary data, i.e. as produced by an
   * implementation of nsIBinaryOutputStream.  This might be used, for example,
   * to implement network protocols or to read from architecture-neutral disk
   * files, i.e. ones that can be read and written by both big-endian and
   * little-endian platforms.
   *
   * @See nsIBinaryOutputStream
   */
  export interface nsIBinaryInputStream extends nsIInputStream {

    readonly setInputStream: (aInputStream: (nsIInputStream | null)) => void;

    /**
     * Read 8-bits from the stream.
     *
     * @return that byte to be treated as a boolean.
     */
    readonly readBoolean: () => boolean;

    readonly read8: () => number;

    readonly read16: () => number;

    readonly read32: () => number;

    readonly read64: () => number;

    readonly readFloat: () => number;

    readonly readDouble: () => number;

    /**
     * Read an 8-bit pascal style string from the stream.
     * 32-bit length field, followed by length 8-bit chars.
     */
    readonly readCString: () => IDLACString;

    /**
     * Read an 16-bit pascal style string from the stream.
     * 32-bit length field, followed by length PRUnichars.
     */
    readonly readString: () => IDLAString;

    /**
     * Read an opaque byte array from the stream.
     *
     * @param aLength the number of bytes that must be read.
     *
     * @throws NS_ERROR_FAILURE if it can't read aLength bytes
     */
    readonly readBytes: (aLength: number) => string;

    /**
     * Read an opaque byte array from the stream, storing the results
     * as an array of PRUint8s.
     *
     * @param aLength the number of bytes that must be read.
     *
     * @throws NS_ERROR_FAILURE if it can't read aLength bytes
     */
    readonly readByteArray: (aLength: number) => number[];

    /**
     * Read opaque bytes from the stream, storing the results in an ArrayBuffer.
     *
     * @param aLength the number of bytes that must be read
     * @param aArrayBuffer the arraybuffer in which to store the results
     * Note: passing view.buffer, where view is an ArrayBufferView of an
     *       ArrayBuffer, is not valid unless view.byteOffset == 0.
     *
     * @return The number of bytes actually read into aArrayBuffer.
     */
    readonly readArrayBuffer: (aLength: number, aArrayBuffer: IDLjsval) => number;
  }

  export interface rrIControlRef {
    readonly name: "rrIControl";
    readonly number: "{c296e7c3-8a27-4fd0-94c2-b6e5126909ba}";
  }

  export interface rrIControl extends nsISupports {

    readonly Initialize: (recordingChildId: IDLjsval) => void;

    readonly ConnectDebugger: (replayDebugger: IDLjsval) => void;

    readonly ManifestFinished: (rootId: number, forkId: number, response: IDLjsval) => void;

    readonly PingResponse: (rootId: number, forkId: number, pingId: number, progress: number) => void;

    readonly BeforeSaveRecording: () => void;

    readonly AfterSaveRecording: () => void;

    readonly ChildCrashed: (rootId: number, forkId: number) => void;
  }

  export interface nsIDirIndexParserRef {
    readonly name: "nsIDirIndexParser";
    readonly number: "{38e3066c-1dd2-11b2-9b59-8be515c1ee3f}";
  }

  /**
   * A parser for application/http-index-format
   */
  export interface nsIDirIndexParser extends nsIStreamListener {

    /**
     * The interface to use as a callback for new entries
     */
    listener: (nsIDirIndexListener | null);

    /**
     * The comment given, if any
     * This result is only valid _after_ OnStopRequest has occurred,
     * because it can occur anywhere in the datastream
     */
    readonly comment: string;

    /**
     * The encoding to use
     */
    encoding: string;
  }

  export interface mozIStorageValueArrayRef {
    readonly name: "mozIStorageValueArray";
    readonly number: "{6e6306f4-ffa7-40f5-96ca-36159ce8f431}";

    /**
     * These type values are returned by getTypeOfIndex
     * to indicate what type of value is present at
     * a given column.
     */
    VALUE_TYPE_NULL: 0;

    VALUE_TYPE_INTEGER: 1;

    VALUE_TYPE_FLOAT: 2;

    VALUE_TYPE_TEXT: 3;

    VALUE_TYPE_BLOB: 4;
  }

  /**
   * mozIStorageValueArray wraps an array of SQL values, such as a single database
   * row.
   */
  export interface mozIStorageValueArray extends nsISupports {

    /**
     * numEntries
     *
     * number of entries in the array (each corresponding to a column
     * in the database row)
     */
    readonly numEntries: number;

    /**
     * Returns the type of the value at the given column index;
     * one of VALUE_TYPE_NULL, VALUE_TYPE_INTEGER, VALUE_TYPE_FLOAT,
     * VALUE_TYPE_TEXT, VALUE_TYPE_BLOB.
     */
    readonly getTypeOfIndex: (aIndex: number) => number;

    /**
     * Obtain a value for the given entry (column) index.
     * Due to SQLite's type conversion rules, any of these are valid
     * for any column regardless of the column's data type.  However,
     * if the specific type matters, getTypeOfIndex should be used
     * first to identify the column type, and then the appropriate
     * get method should be called.
     *
     * If you ask for a string value for a NULL column, you will get an empty
     * string with IsVoid set to distinguish it from an explicitly set empty
     * string.
     */
    readonly getInt32: (aIndex: number) => number;

    readonly getInt64: (aIndex: number) => number;

    readonly getDouble: (aIndex: number) => number;

    readonly getUTF8String: (aIndex: number) => IDLAUTF8String;

    readonly getString: (aIndex: number) => IDLAString;

    readonly getBlob: (aIndex: number, aDataSize: Out<number>) => void;

    readonly getBlobAsString: (aIndex: number) => IDLAString;

    readonly getBlobAsUTF8String: (aIndex: number) => IDLAUTF8String;

    readonly getIsNull: (aIndex: number) => boolean;
  }

  export interface nsIPrivacyTransitionObserverRef {
    readonly name: "nsIPrivacyTransitionObserver";
    readonly number: "{b4b1449d-0ef0-47f5-b62e-adc57fd49702}";
  }

  type nsIPrivacyTransitionObserverFunction = (enabled: boolean) => void;

  export interface nsIPrivacyTransitionObserver extends nsISupports {

    readonly privateModeChanged: (enabled: boolean) => void;
  }

  export interface nsIProtocolProxyService2Ref {
    readonly name: "nsIProtocolProxyService2";
    readonly number: "{b2e5b2c0-e21e-4845-b336-be6d60a38951}";
  }

  /**
   * An extension of nsIProtocolProxyService
   */
  export interface nsIProtocolProxyService2 extends nsIProtocolProxyService {

    /**
     * Call this method to cause the PAC file (if any is configured) to be
     * reloaded.  The PAC file is loaded asynchronously.
     */
    readonly reloadPAC: () => void;

    /**
     * This method is identical to asyncResolve() except:
     *  - it only accepts an nsIChannel, not an nsIURI;
     *  - it may execute the callback function immediately (i.e from the stack
     *    of asyncResolve2()) if it is immediately ready to run.
     *    The nsICancelable return value will be null in that case.
     */
    readonly asyncResolve2: (aChannel: (nsIChannel | null), aFlags: number, aCallback: (nsIProtocolProxyCallback | null), aMainThreadTarget?: (nsIEventTarget | null)) => (nsICancelable | null);
  }

  export interface nsISupportsPRTimeRef {
    readonly name: "nsISupportsPRTime";
    readonly number: "{e2563630-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for NSPR date/time values
   */
  export interface nsISupportsPRTime extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsICacheSessionRef {
    readonly name: "nsICacheSession";
    readonly number: "{1dd7708c-de48-4ffe-b5aa-cd218c762887}";
  }

  export interface nsICacheSession extends nsISupports {

    /**
     * Expired entries will be doomed or evicted if this attribute is set to
     * true.  If false, expired entries will be returned (useful for offline-
     * mode and clients, such as HTTP, that can update the valid lifetime of
     * cached content).  This attribute defaults to true.
     */
    doomEntriesIfExpired: boolean;

    /**
     * When set, entries created with this session will be placed to a cache
     * based at this directory.  Use when storing entries to a different
     * profile than the active profile of the the current running application
     * process.
     */
    profileDirectory: (nsIFile | null);

    /**
     * A cache session can only give out one descriptor with WRITE access
     * to a given cache entry at a time.  Until the client calls MarkValid on
     * its descriptor, other attempts to open the same cache entry will block.
     */
    /**
     * Synchronous cache access. This method fails if it is called on the main
     * thread. Use asyncOpenCacheEntry() instead. This returns a unique
     * descriptor each time it is called, even if the same key is specified.
     * When called by multiple threads for write access, only one writable
     * descriptor will be granted.  If 'blockingMode' is set to false, it will
     * return NS_ERROR_CACHE_WAIT_FOR_VALIDATION rather than block when another
     * descriptor has been given WRITE access but hasn't validated the entry yet.
     */
    readonly openCacheEntry: (key: IDLACString, accessRequested: number, blockingMode: boolean) => (nsICacheEntryDescriptor | null);

    /**
     * Asynchronous cache access. Does not block the calling thread. Instead,
     * the listener will be notified when the descriptor is available. If
     * 'noWait' is set to true, the listener will be notified immediately with
     * status NS_ERROR_CACHE_WAIT_FOR_VALIDATION rather than queuing the request
     * when another descriptor has been given WRITE access but hasn't validated
     * the entry yet.
     */
    readonly asyncOpenCacheEntry: (key: IDLACString, accessRequested: number, listener: (nsICacheListener | null), noWait?: boolean) => void;

    /**
     * Evict all entries for this session's clientID according to its storagePolicy.
     */
    readonly evictEntries: () => void;

    /**
     * Return whether any of the cache devices implied by the session storage policy
     * are currently enabled for instantiation if they don't already exist.
     */
    readonly isStorageEnabled: () => boolean;

    /**
     * Asynchronously doom an entry specified by the key. Listener will be
     * notified about the status of the operation. Null may be passed if caller
     * doesn't care about the result.
     */
    readonly doomEntry: (key: IDLACString, listener: (nsICacheListener | null)) => void;

    /**
     * Private entries will be doomed when the last private browsing session
     * finishes.
     */
    isPrivate: boolean;
  }

  export interface nsIFTPChannelRef {
    readonly name: "nsIFTPChannel";
    readonly number: "{07f0d5cd-1fd5-4aa3-b6fc-665bdc5dbf9f}";
  }

  /**
   * This interface may be used to determine if a channel is a FTP channel.
   */
  export interface nsIFTPChannel extends nsISupports {

    lastModifiedTime: number;
  }

  export interface nsIBidiKeyboardRef {
    readonly name: "nsIBidiKeyboard";
    readonly number: "{288dae24-76e2-43a3-befe-9d9fabe8014e}";
  }

  export interface nsIBidiKeyboard extends nsISupports {

    /**
     * Inspects the installed keyboards and resets the bidi keyboard state
     */
    readonly reset: () => void;

    /**
     * Determines if the current keyboard language is right-to-left
     * @throws NS_ERROR_FAILURE if no right-to-left keyboards are installed
     */
    readonly isLangRTL: () => boolean;

    /**
     * Determines whether the system has at least one keyboard of each direction
     * installed.
     *
     * @throws NS_ERROR_NOT_IMPLEMENTED if the widget layer does not provide this
     * information.
     */
    readonly haveBidiKeyboards: boolean;
  }

  export interface nsIFocusManagerRef {
    readonly name: "nsIFocusManager";
    readonly number: "{86e1f1e1-365d-493b-b52a-a649f3f311dc}";

    FLAG_RAISE: 1;

    /**
     * Do not scroll the element to focus into view. If FLAG_BYELEMENTFOCUS is
     * set too, the latter is ignored.
     */
    FLAG_NOSCROLL: 2;

    /**
     * If attempting to change focus in a window that is not focused, do not
     * switch focus to that window. Instead, just update the focus within that
     * window and leave the application focus as is. This flag will have no
     * effect if a child window is focused and an attempt is made to adjust the
     * focus in an ancestor, as the frame must be switched in this case.
     */
    FLAG_NOSWITCHFRAME: 4;

    /**
     * This flag is only used when passed to moveFocus. If set, focus is never
     * moved to the parent frame of the starting element's document, instead
     * iterating around to the beginning of that document again. Child frames
     * are navigated as normal.
     */
    FLAG_NOPARENTFRAME: 8;

    /**
     * Focus is changing due to a mouse operation, for instance the mouse was
     * clicked on an element.
     */
    FLAG_BYMOUSE: 4096;

    /**
     * Focus is changing due to a key operation, for instance pressing the tab
     * key. This flag would normally be passed when MOVEFOCUS_FORWARD or
     * MOVEFOCUS_BACKWARD is used.
     */
    FLAG_BYKEY: 8192;

    /**
     * Focus is changing due to a call to MoveFocus. This flag will be implied
     * when MoveFocus is called except when one of the other mechanisms (mouse
     * or key) is specified, or when the type is MOVEFOCUS_ROOT or
     * MOVEFOCUS_CARET.
     */
    FLAG_BYMOVEFOCUS: 16384;

    /**
     * Always show the focus ring or other indicator of focus, regardless of
     * other state.
     */
    FLAG_SHOWRING: 1048576;

    /**
     * Focus is changing due to a touch operation that generated a mouse event.
     * Normally used in conjunction with FLAG_BYMOUSE.
     */
    FLAG_BYTOUCH: 2097152;

    /**
     * Focus is changing due to a Element.focus() call.
     * This is used to distinguish the Element.focus() call from other focus
     * functionalities since we need to factor scroll-margin and scroll-padding
     * values into the position where we scroll to the element by the
     * Element.focus() call.
     * NOTE: This flag is ignored if FLAG_NOSCROLL is set too.
     */
    FLAG_BYELEMENTFOCUS: 4194304;

    FLAG_BYLONGPRESS: 8388608;

    /** move focus forward one element, used when pressing TAB */
    MOVEFOCUS_FORWARD: 1;

    /** move focus backward one element, used when pressing Shift+TAB */
    MOVEFOCUS_BACKWARD: 2;

    /** move focus forward to the next frame document, used when pressing F6 */
    MOVEFOCUS_FORWARDDOC: 3;

    /** move focus forward to the previous frame document, used when pressing Shift+F6 */
    MOVEFOCUS_BACKWARDDOC: 4;

    /** move focus to the first focusable element */
    MOVEFOCUS_FIRST: 5;

    /** move focus to the last focusable element */
    MOVEFOCUS_LAST: 6;

    /** move focus to the root element in the document */
    MOVEFOCUS_ROOT: 7;

    /** move focus to a link at the position of the caret. This is a special value used to
     *  focus links as the caret moves over them in caret browsing mode.
     */
    MOVEFOCUS_CARET: 8;

    /** move focus to the first focusable document */
    MOVEFOCUS_FIRSTDOC: 9;

    /** move focus to the last focusable document */
    MOVEFOCUS_LASTDOC: 10;
  }

  /**
   * The focus manager deals with all focus related behaviour. Only one element
   * in the entire application may have the focus at a time; this element
   * receives any keyboard events. While there is only one application-wide
   * focused element, each nsIDOMWindow maintains a reference to the element
   * that would be focused if the window was active.
   *
   * If the window's reference is to a frame element (iframe, browser,
   * editor), then the child window contains the element that is currently
   * focused. If the window's reference is to a root element, then the root is
   * focused. If a window's reference is null, then no element is focused, yet
   * the window is still focused.
   *
   * The blur event is fired on an element when it loses the application focus.
   * After this blur event, if the focus is moving away from a document, two
   * additional blur events are fired on the old document and window containing
   * the focus respectively.
   *
   * When a new document is focused, two focus events are fired on the new
   * document and window respectively. Then the focus event is fired on an
   * element when it gains the application focus.
   *
   * A special case is that the root element may be focused, yet does not
   * receive the element focus and blur events. Instead a focus outline may be
   * drawn around the document.
   *
   * Blur and focus events do not bubble as per the W3C DOM Events spec.
   */
  export interface nsIFocusManager extends nsISupports {

    /**
     * The most active (frontmost) window, or null if no window that is part of
     * the application is active. Setting the activeWindow raises it, and
     * focuses the current child window's current element, if any. Setting this
     * to null or to a non-top-level window throws an NS_ERROR_INVALID_ARG
     * exception.
     */
    activeWindow: (mozIDOMWindowProxy | null);

    /**
     * The child window within the activeWindow that is focused. This will
     * always be activeWindow, a child window of activeWindow or null if no
     * child window is focused. Setting the focusedWindow changes the focused
     * window and raises the toplevel window it is in. If the current focus
     * within the new focusedWindow is a frame element, then the focusedWindow
     * will actually be set to the child window and the current element within
     * that set as the focused element. This process repeats downwards until a
     * non-frame element is found.
     */
    focusedWindow: (mozIDOMWindowProxy | null);

    /**
     * The element that is currently focused. This will always be an element
     * within the document loaded in focusedWindow or null if no element in that
     * document is focused.
     */
    readonly focusedElement: WebIDL.Element;

    /**
     * Returns the method that was used to focus the element in window. This
     * will either be 0, FLAG_BYMOUSE or FLAG_BYKEY. If window is null, then
     * the current focusedWindow will be used by default. This has the result
     * of retrieving the method that was used to focus the currently focused
     * element.
     */
    readonly getLastFocusMethod: (window: (mozIDOMWindowProxy | null)) => number;

    /**
     * Changes the focused element reference within the window containing
     * aElement to aElement or potentially redirects it to an anonymous
     * descendant of it (e.g., for `<input type="number">` the focus is redirected
     * to its descendant `<input type="text">`).
     */
    readonly setFocus: (aElement: WebIDL.Element, aFlags: number) => void;

    /**
     * Move the focus to another element. If aStartElement is specified, then
     * movement is done relative to aStartElement. If aStartElement is null,
     * then movement is done relative to the currently focused element. If no
     * element is focused, focus the first focusable element within the
     * document (or the last focusable element if aType is MOVEFOCUS_END). This
     * method is equivalent to setting the focusedElement to the new element.
     *
     * Specifying aStartElement and using MOVEFOCUS_LAST is not currently
     * implemented.
     *
     * If no element is found, and aType is either MOVEFOCUS_ROOT or
     * MOVEFOCUS_CARET, then the focus is cleared. If aType is any other value,
     * the focus is not changed.
     *
     * Returns the element that was focused (see setFocus). The return value
     * may be null if focus was moved into a child process.
     */
    readonly moveFocus: (aWindow: (mozIDOMWindowProxy | null), aStartElement: WebIDL.Element, aType: number, aFlags: number) => WebIDL.Element;

    /**
     * Clears the focused element within aWindow. If the current focusedWindow
     * is a descendant of aWindow, sets the current focusedWindow to aWindow.
     *
     * @throws NS_ERROR_INVALID_ARG if aWindow is null
     */
    readonly clearFocus: (aWindow: (mozIDOMWindowProxy | null)) => void;

    /**
     * Returns the currently focused element within aWindow. If aWindow is equal
     * to the current value of focusedWindow, then the returned element will be
     * the application-wide focused element (the value of focusedElement). The
     * return value will be null if no element is focused.
     *
     * If aDeep is true, then child frames are traversed and the return value
     * may be the element within a child descendant window that is focused. If
     * aDeep if false, then the return value will be the frame element if the
     * focus is in a child frame.
     *
     * aFocusedWindow will be set to the currently focused descendant window of
     * aWindow, or to aWindow if aDeep is false. This will be set even if no
     * element is focused.
     *
     * @throws NS_ERROR_INVALID_ARG if aWindow is null
     */
    readonly getFocusedElementForWindow: (aWindow: (mozIDOMWindowProxy | null), aDeep: boolean, aFocusedWindow: Out<(mozIDOMWindowProxy | null)>) => WebIDL.Element;

    /**
     * Moves the selection caret within aWindow to the current focus.
     */
    readonly moveCaretToFocus: (aWindow: (mozIDOMWindowProxy | null)) => void;

    /***
     * Check if given element (or potentially a descendant, see setFocus) is
     * focusable.
     */
    readonly elementIsFocusable: (aElement: WebIDL.Element, aFlags: number) => boolean;
  }

  export interface nsIAuthPromptCallbackRef {
    readonly name: "nsIAuthPromptCallback";
    readonly number: "{bdc387d7-2d29-4cac-92f1-dd75d786631d}";
  }

  /**
   * Interface for callback methods for the asynchronous nsIAuthPrompt2 method.
   * Callers MUST call exactly one method if nsIAuthPrompt2::promptPasswordAsync
   * returns successfully. They MUST NOT call any method on this interface before
   * promptPasswordAsync returns.
   */
  export interface nsIAuthPromptCallback extends nsISupports {

    /**
     * Authentication information is available.
     *
     * @param aContext
     *        The context as passed to promptPasswordAsync
     * @param aAuthInfo
     *        Authentication information. Must be the same object that was passed
     *        to promptPasswordAsync.
     *
     * @note  Any exceptions thrown from this method should be ignored.
     */
    readonly onAuthAvailable: (aContext: (nsISupports | null), aAuthInfo: (nsIAuthInformation | null)) => void;

    /**
     * Notification that the prompt was cancelled.
     *
     * @param aContext
     *        The context that was passed to promptPasswordAsync.
     * @param userCancel
     *        If false, this prompt was cancelled by calling the
     *        the cancel method on the nsICancelable; otherwise,
     *        it was cancelled by the user.
     */
    readonly onAuthCancelled: (aContext: (nsISupports | null), userCancel: boolean) => void;
  }

  export interface nsIRandomAccessIteratorRef {
    readonly name: "nsIRandomAccessIterator";
    readonly number: "{9bd6fdb0-1dd1-11b2-9101-d15375968230}";
  }

  /**
   * ...
   */
  export interface nsIRandomAccessIterator extends nsISupports {

    /**
     * Retrieve (and |AddRef()|) the element this iterator currently points to.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @result a new reference to the element this iterator currently points to (if any)
     */
    readonly getElement: () => (nsISupports | null);

    /**
     * Retrieve (and |AddRef()|) an element at some offset from where this iterator currently points.
     * The offset may be negative.  |getElementAt(0)| is equivalent to |getElement()|.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anOffset a |0|-based offset from the position to which this iterator currently points
     * @result a new reference to the indicated element (if any)
     */
    readonly getElementAt: (anOffset: number) => (nsISupports | null);

    /**
     * Put |anElementToPut| into the underlying container or sequence at the position currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    readonly putElement: (anElementToPut: (nsISupports | null)) => void;

    /**
     * Put |anElementToPut| into the underlying container or sequence at the position |anOffset| away from that currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     * |putElementAt(0, obj)| is equivalent to |putElement(obj)|.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anOffset a |0|-based offset from the position to which this iterator currently points
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    readonly putElementAt: (anOffset: number, anElementToPut: (nsISupports | null)) => void;

    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    readonly stepForward: () => void;

    /**
     * Move this iterator by |anOffset| positions in the underlying container or sequence.
     * |anOffset| may be negative.  |stepForwardBy(1)| is equivalent to |stepForward()|.
     * |stepForwardBy(0)| is a no-op.
     *
     * @param anOffset a |0|-based offset from the position to which this iterator currently points
     */
    readonly stepForwardBy: (anOffset: number) => void;

    /**
     * Move this iterator to the previous position in the underlying container or sequence.
     */
    readonly stepBackward: () => void;

    /**
     * Move this iterator backwards by |anOffset| positions in the underlying container or sequence.
     * |anOffset| may be negative.  |stepBackwardBy(1)| is equivalent to |stepBackward()|.
     * |stepBackwardBy(n)| is equivalent to |stepForwardBy(-n)|.  |stepBackwardBy(0)| is a no-op.
     *
     * @param anOffset a |0|-based offset from the position to which this iterator currently points
     */
    readonly stepBackwardBy: (anOffset: number) => void;

    /**
     * Test if |anotherIterator| points to the same position in the underlying container or sequence.
     *
     * The result is undefined if |anotherIterator| was not created by or for the same underlying container or sequence.
     *
     * @param anotherIterator another iterator to compare against, created by or for the same underlying container or sequence
     * @result true if |anotherIterator| points to the same position in the underlying container or sequence
     */
    readonly isEqualTo: (anotherIterator: (nsISupports | null)) => boolean;

    /**
     * Create a new iterator pointing to the same position in the underlying container or sequence to which this iterator currently points.
     * The returned iterator is suitable for use in a subsequent call to |isEqualTo()| against this iterator.
     *
     * @result a new iterator pointing at the same position in the same underlying container or sequence as this iterator
     */
    readonly clone: () => (nsISupports | null);
  }

  export interface nsIHttpHeaderVisitorRef {
    readonly name: "nsIHttpHeaderVisitor";
    readonly number: "{35412859-b9d9-423c-8866-2d4559fdd2be}";
  }

  type nsIHttpHeaderVisitorFunction = (aHeader: IDLACString, aValue: IDLACString) => void;

  /**
   * Implement this interface to visit http headers.
   */
  export interface nsIHttpHeaderVisitor extends nsISupports {

    /**
     * Called by the nsIHttpChannel implementation when visiting request and
     * response headers.
     *
     * @param aHeader
     *        the header being visited.
     * @param aValue
     *        the header value (possibly a comma delimited list).
     *
     * @throw any exception to terminate enumeration
     */
    readonly visitHeader: (aHeader: IDLACString, aValue: IDLACString) => void;
  }

  export interface nsIFTPEventSinkRef {
    readonly name: "nsIFTPEventSink";
    readonly number: "{455d4234-0330-43d2-bbfb-99afbecbfeb0}";
  }

  /**
   * This interface may be defined as a notification callback on the FTP
   * channel.  It allows a consumer to receive a log of the FTP control
   * connection conversation.
   */
  export interface nsIFTPEventSink extends nsISupports {

    /**
     * XXX document this method!  (see bug 328915)
     */
    readonly OnFTPControlLog: (server: boolean, msg: string) => void;
  }

  export interface nsIWebBrowserChrome3Ref {
    readonly name: "nsIWebBrowserChrome3";
    readonly number: "{542b6625-35a9-426a-8257-c12a345383b0}";
  }

  /**
   * nsIWebBrowserChrome3 is an extension to nsIWebBrowserChrome.
   */
  export interface nsIWebBrowserChrome3 extends nsIWebBrowserChrome {

    /**
     * Determines the appropriate target for a link.
     *
     * @param originalTarget
     *        The original link target.
     * @param linkURI
     *        Link destination URI.
     * @param aDOMNode
     *        Link DOM node.
     * @param isAppTab
     *        Whether or not the link is in an app tab.
     * @returns A new link target, if appropriate.
     *          Otherwise returns originalTarget.
     */
    readonly onBeforeLinkTraversal: (originalTarget: IDLAString, linkURI: (nsIURI | null), linkNode: WebIDL.Node, isAppTab: boolean) => IDLAString;

    /**
     * Determines whether a load should continue.
     *
     * @param aDocShell
     *        The docshell performing the load.
     * @param aURI
     *        The URI being loaded.
     * @param aReferrerInfo
     *        The referrerInfo of the load.
     * @param aHasPostData
     *        True if the load which is being asked about has associated post data
     *        which would be discarded if the load was redirected across process
     *        boundaries.
     * @param aTriggeringPrincipal
     *        The principal that initiated the load of aURI.
     * @param aCsp
     *        The CSP to be used for that load. That is the CSP that e.g. upgrades
     *        the load to HTTPS in case upgrade-insecure-requests is set.
     */
    readonly shouldLoadURI: (aDocShell: (nsIDocShell | null), aURI: (nsIURI | null), aReferrerInfo: (nsIReferrerInfo | null), aHasPostData: boolean, aTriggeringPrincipal: (nsIPrincipal | null), aCsp: (nsIContentSecurityPolicy | null)) => boolean;

    readonly shouldLoadURIInThisProcess: (aURI: (nsIURI | null)) => boolean;

    /**
     * Attempts to load the currently loaded page into a fresh process to increase
     * available memory.
     *
     * @param aDocShell
     *        The docshell performing the load.
     * @param aCsp
     *        The CSP to be used for reloading the top-level load. That is the CSP
     *        of the document that initially triggered the new document load.
     */
    readonly reloadInFreshProcess: (aDocShell: (nsIDocShell | null), aURI: (nsIURI | null), aReferrerInfo: (nsIReferrerInfo | null), aTriggeringPrincipal: (nsIPrincipal | null), aLoadFlags: number, aCsp: (nsIContentSecurityPolicy | null)) => boolean;
  }

  export interface nsIPropertyRef {
    readonly name: "nsIProperty";
    readonly number: "{6dcf9030-a49f-11d5-910d-0010a4e73d9a}";
  }

  export interface nsIProperty extends nsISupports {

    /**
     * Get the name of the property.
     */
    readonly name: IDLAString;

    /**
     * Get the value of the property.
     */
    readonly value: (nsIVariant | null);
  }

  export interface nsIIdleServiceRef {
    readonly name: "nsIIdleService";
    readonly number: "{cc52f19a-63ae-4a1c-9cc3-e79eace0b471}";
  }

  /**
   * This interface lets you monitor how long the user has been 'idle',
   * i.e. not used their mouse or keyboard. You can get the idle time directly,
   * but in most cases you will want to register an observer for a predefined
   * interval. The observer will get an 'idle' notification when the user is idle
   * for that interval (or longer), and receive an 'active' notification when the
   * user starts using their computer again.
   */
  export interface nsIIdleService extends nsISupports {

    /**
     * The amount of time in milliseconds that has passed
     * since the last user activity.
     *
     * If we do not have a valid idle time to report, 0 is returned
     * (this can happen if the user never interacted with the browser
     * at all, and if we are also unable to poll for idle time manually).
     */
    readonly idleTime: number;

    /**
     * Add an observer to be notified when the user idles for some period of
     * time, and when they get back from that.
     *
     * @param observer the observer to be notified
     * @param time the amount of time in seconds the user should be idle before
     *             the observer should be notified.
     *
     * @note
     * The subject of the notification the observer will get is always the
     * nsIIdleService itself.
     * When the user goes idle, the observer topic is "idle" and when he gets
     * back, the observer topic is "active".
     * The data param for the notification contains the current user idle time.
     *
     * @note
     * You can add the same observer twice.
     * @note
     * Most implementations need to poll the OS for idle info themselves,
     * meaning your notifications could arrive with a delay up to the length
     * of the polling interval in that implementation.
     * Current implementations use a delay of 5 seconds.
     */
    readonly addIdleObserver: (observer: (nsIObserver | nsIObserverFunction | null), time: number) => void;

    /**
     * Remove an observer registered with addIdleObserver.
     * @param observer the observer that needs to be removed.
     * @param time the amount of time they were listening for.
     * @note
     * Removing an observer will remove it once, for the idle time you specify.
     * If you have added an observer multiple times, you will need to remove it
     * just as many times.
     */
    readonly removeIdleObserver: (observer: (nsIObserver | nsIObserverFunction | null), time: number) => void;

    /**
     * If true, the idle service is temporarily disabled, and all idle events
     * will be ignored.
     *
     * This should only be used in automation.
     */
    disabled: boolean;
  }

  export interface nsISDBCloseCallbackRef {
    readonly name: "nsISDBCloseCallback";
    readonly number: "{e0821d43-62b9-40fe-99f8-ff9ab3184cbf}";
  }

  type nsISDBCloseCallbackFunction = (aConnection: (nsISDBConnection | null)) => void;

  export interface nsISDBCloseCallback extends nsISupports {

    readonly onClose: (aConnection: (nsISDBConnection | null)) => void;
  }

  export interface nsIUrlClassifierHashCompleterCallbackRef {
    readonly name: "nsIUrlClassifierHashCompleterCallback";
    readonly number: "{da16de40-df26-414d-bde7-c4faf4504868}";
  }

  /**
   * This interface is implemented by nsIUrlClassifierHashCompleter clients.
   */
  export interface nsIUrlClassifierHashCompleterCallback extends nsISupports {

    /**
     * A complete hash has been found that matches the partial hash.
     * This method may be called 0-n times for a given
     * nsIUrlClassifierCompleter::complete() call.
     *
     * @param hash
     *        The 256-bit hash that was discovered.
     * @param table
     *        The name of the table that this hash belongs to.
     * @param chunkId
     *        The database chunk that this hash belongs to.
     */
    readonly completionV2: (hash: IDLACString, table: IDLACString, chunkId: number) => void;

    /**
     * This will be called when a fullhash response is received and parsed
     * no matter if any full hash has been found.
     *
     * @param partialHash
     *        The hash that was sent for completion.
     * @param table
     *        The name of the table that this hash belongs to.
     * @param negativeCacheDuration
     *        The negative cache duration in millisecond.
     * @param fullHashes
     *        Array of fullhashes that match the prefix.
     */
    readonly completionV4: (partialHash: IDLACString, table: IDLACString, negativeCacheDuration: number, fullHashes: (nsIArray | null)) => void;

    /**
     * The completion is complete.  This method is called once per
     * nsIUrlClassifierCompleter::complete() call, after all completion()
     * calls are finished.
     *
     * @param status
     *        NS_OK if the request completed successfully, or an error code.
     */
    readonly completionFinished: (status: number) => void;
  }

  export interface nsICacheDeviceInfoRef {
    readonly name: "nsICacheDeviceInfo";
    readonly number: "{31d1c294-1dd2-11b2-be3a-c79230dca297}";
  }

  export interface nsICacheDeviceInfo extends nsISupports {

    /**
     * Get a human readable description of the cache device.
     */
    readonly description: IDLACString;

    /**
     * Get a usage report, statistics, miscellaneous data about
     * the cache device.
     */
    readonly usageReport: IDLACString;

    /**
     * Get the number of stored cache entries.
     */
    readonly entryCount: number;

    /**
     * Get the total size of the stored cache entries.
     */
    readonly totalSize: number;

    /**
     * Get the upper limit of the size of the data the cache can store.
     */
    readonly maximumSize: number;
  }

  export interface nsIXULStoreRef {
    readonly name: "nsIXULStore";
    readonly number: "{987c4b35-c426-4dd7-ad49-3c9fa4c65d20}";
  }

  /**
   * The XUL store is used to store information related to a XUL document/application.
   * Typically it is used to store the persisted state for the document, such as
   * window location, toolbars that are open and nodes that are open and closed in a tree.
   *
   * If MOZ_NEW_XULSTORE is enabled:
   * XULStore.jsm wraps this API in useful abstractions for JS consumers.
   * XULStore.h provides a more idiomatic API for C++ consumers.
   * You should use those APIs unless you have good reasons to use this one.
   *
   * If MOZ_NEW_XULSTORE is disabled:
   * The data is serialized to [profile directory]/xulstore.json
   */
  export interface nsIXULStore extends nsISupports {

    /**
     * Sets a value for a specified node's attribute, except in
     * the case below (following the original XULDocument::persist):
     * If the value is empty and if calling `hasValue` with the node's
     * document and ID and `attr` would return true, then the
     * value instead gets removed from the store (see Bug 1476680).
     *
     * @param node - DOM node
     * @param attr - attribute to store
     */
    readonly persist: (aNode: WebIDL.Node, attr: IDLAString) => void;

    /**
     * Sets a value in the store.
     *
     * @param doc - document URI
     * @param id - identifier of the node
     * @param attr - attribute to store
     * @param value - value of the attribute
     */
    readonly setValue: (doc: IDLAString, id: IDLAString, attr: IDLAString, value: IDLAString) => void;

    /**
     * Returns true if the store contains a value for attr.
     *
     * @param doc - URI of the document
     * @param id - identifier of the node
     * @param attr - attribute
     */
    readonly hasValue: (doc: IDLAString, id: IDLAString, attr: IDLAString) => boolean;

    /**
     * Retrieves a value in the store, or an empty string if it does not exist.
     *
     * @param doc - document URI
     * @param id - identifier of the node
     * @param attr - attribute to retrieve
     *
     * @returns the value of the attribute
     */
    readonly getValue: (doc: IDLAString, id: IDLAString, attr: IDLAString) => IDLAString;

    /**
     * Removes a value in the store.
     *
     * @param doc - document URI
     * @param id - identifier of the node
     * @param attr - attribute to remove
     */
    readonly removeValue: (doc: IDLAString, id: IDLAString, attr: IDLAString) => void;

    /**
     * Removes all values related to the given document.
     *
     * @param doc - document URI
     */
    readonly removeDocument: (doc: IDLAString) => void;

    /**
     * Iterates over all of the ids associated with a given document uri that
     * have stored data.
     *
     * @param doc - document URI
     */
    readonly getIDsEnumerator: (doc: IDLAString) => (nsIStringEnumerator | null);

    /**
     * Iterates over all of the attributes associated with a given document uri
     * and id that have stored data.
     *
     * @param doc - document URI
     * @param id - identifier of the node
     */
    readonly getAttributeEnumerator: (doc: IDLAString, id: IDLAString) => (nsIStringEnumerator | null);
  }

  export interface nsISelectionListenerRef {
    readonly name: "nsISelectionListener";
    readonly number: "{45686299-ae2b-46bc-9502-c56c35691ab9}";

    NO_REASON: 0;

    DRAG_REASON: 1;

    MOUSEDOWN_REASON: 2;

    MOUSEUP_REASON: 4;

    KEYPRESS_REASON: 8;

    SELECTALL_REASON: 16;

    COLLAPSETOSTART_REASON: 32;

    COLLAPSETOEND_REASON: 64;

    IME_REASON: 128;
  }

  export interface nsISelectionListener extends nsISupports {

    readonly notifySelectionChanged: (doc: WebIDL.Document, sel: WebIDL.Selection, reason: number) => void;
  }

  export interface nsIURILoaderRef {
    readonly name: "nsIURILoader";
    readonly number: "{8762c4e7-be35-4958-9b81-a05685bb516d}";

    /**
     * @name Flags for opening URIs.
     */
    /**
     * Should the content be displayed in a container that prefers the
     * content-type, or will any container do.
     */
    IS_CONTENT_PREFERRED: 1;

    /**
     * If this flag is set, only the listener of the specified window context will
     * be considered for content handling; if it refuses the load, an error will
     * be indicated.
     */
    DONT_RETARGET: 2;

    /**
     * If this flag is set, it means that aChannel has been redirected from
     * another process, and should be reopened using CompleteRedirectSetup rather
     * than AsyncOpen.
     */
    REDIRECTED_CHANNEL: 4;
  }

  /**
   * The uri dispatcher is responsible for taking uri's, determining
   * the content and routing the opened url to the correct content
   * handler.
   *
   * When you encounter a url you want to open, you typically call
   * openURI, passing it the content listener for the window the uri is
   * originating from. The uri dispatcher opens the url to discover the
   * content type. It then gives the content listener first crack at
   * handling the content. If it doesn't want it, the dispatcher tries
   * to hand it off one of the registered content listeners. This allows
   * running applications the chance to jump in and handle the content.
   *
   * If that also fails, then the uri dispatcher goes to the registry
   * looking for the preferred content handler for the content type
   * of the uri. The content handler may create an app instance
   * or it may hand the contents off to a platform specific plugin
   * or helper app. Or it may hand the url off to an OS registered
   * application.
   */
  export interface nsIURILoader extends nsISupports {

    /**
     * As applications such as messenger and the browser are instantiated,
     * they register content listener's with the uri dispatcher corresponding
     * to content windows within that application.
     *
     * Note to self: we may want to optimize things a bit more by requiring
     * the content types the registered content listener cares about.
     *
     * @param aContentListener
     *        The listener to register. This listener must implement
     *        nsISupportsWeakReference.
     *
     * @see the nsIURILoader class description
     */
    readonly registerContentListener: (aContentListener: (nsIURIContentListener | null)) => void;

    readonly unRegisterContentListener: (aContentListener: (nsIURIContentListener | null)) => void;

    /**
     * OpenURI requires the following parameters.....
     * @param aChannel
     *        The channel that should be opened. This must not be asyncOpen'd yet!
     *        If a loadgroup is set on the channel, it will get replaced with a
     *        different one.
     * @param aFlags
     *        Combination (bitwise OR) of the flags specified above. 0 indicates
     *        default handling.
     * @param aWindowContext
     *        If you are running the url from a doc shell or a web shell, this is
     *        your window context. If you have a content listener you want to
     *        give first crack to, the uri loader needs to be able to get it
     *        from the window context. We will also be using the window context
     *        to get at the progress event sink interface.
     *        <b>Must not be null!</b>
     */
    readonly openURI: (aChannel: (nsIChannel | null), aFlags: number, aWindowContext: (nsIInterfaceRequestor | null)) => void;

    /**
     * Loads data from a channel. This differs from openURI in that the channel
     * may already be opened, and that it returns a stream listener into which the
     * caller should pump data. The caller is responsible for opening the channel
     * and pumping the channel's data into the returned stream listener.
     *
     * Note: If the channel already has a loadgroup, it will be replaced with the
     * window context's load group, or null if the context doesn't have one.
     *
     * If the window context's nsIURIContentListener refuses the load immediately
     * (e.g. in nsIURIContentListener::onStartURIOpen), this method will return
     * NS_ERROR_WONT_HANDLE_CONTENT. At that point, the caller should probably
     * cancel the channel if it's already open (this method will not cancel the
     * channel).
     *
     * If flags include DONT_RETARGET, and the content listener refuses the load
     * during onStartRequest (e.g. in canHandleContent/isPreferred), then the
     * returned stream listener's onStartRequest method will return
     * NS_ERROR_WONT_HANDLE_CONTENT.
     *
     * @param aChannel
     *        The channel that should be loaded. The channel may already be
     *        opened. It must not be closed (i.e. this must be called before the
     *        channel calls onStopRequest on its stream listener).
     * @param aFlags
     *        Combination (bitwise OR) of the flags specified above. 0 indicates
     *        default handling.
     * @param aWindowContext
     *        If you are running the url from a doc shell or a web shell, this is
     *        your window context. If you have a content listener you want to
     *        give first crack to, the uri loader needs to be able to get it
     *        from the window context. We will also be using the window context
     *        to get at the progress event sink interface.
     *        <b>Must not be null!</b>
     */
    readonly openChannel: (aChannel: (nsIChannel | null), aFlags: number, aWindowContext: (nsIInterfaceRequestor | null)) => (nsIStreamListener | null);

    /**
     * Stops an in progress load
     */
    readonly stop: (aLoadCookie: (nsISupports | null)) => void;
  }

  export interface nsIDownloaderRef {
    readonly name: "nsIDownloader";
    readonly number: "{fafe41a9-a531-4d6d-89bc-588a6522fb4e}";
  }

  /**
   * nsIDownloader
   *
   * A downloader is a special implementation of a nsIStreamListener that will
   * make the contents of the stream available as a file.  This may utilize the
   * disk cache as an optimization to avoid an extra copy of the data on disk.
   * The resulting file is valid from the time the downloader completes until
   * the last reference to the downloader is released.
   */
  export interface nsIDownloader extends nsIStreamListener {

    /**
     * Initialize this downloader
     *
     * @param observer
     *        the observer to be notified when the download completes.
     * @param downloadLocation
     *        the location where the stream contents should be written.
     *        if null, the downloader will select a location and the
     *        resulting file will be deleted (or otherwise made invalid)
     *        when the downloader object is destroyed.  if an explicit
     *        download location is specified then the resulting file will
     *        not be deleted, and it will be the callers responsibility
     *        to keep track of the file, etc.
     */
    readonly init: (observer: (nsIDownloadObserver | null), downloadLocation: (nsIFile | null)) => void;
  }

  export interface nsIServerSocketRef {
    readonly name: "nsIServerSocket";
    readonly number: "{7a9c39cb-a13f-4eef-9bdf-a74301628742}";

    /**
     * @name Server Socket Flags
     * These flags define various socket options.
     * @{
     */
    LoopbackOnly: 1;

    KeepWhenOffline: 2;
  }

  /**
   * nsIServerSocket
   *
   * An interface to a server socket that can accept incoming connections.
   */
  export interface nsIServerSocket extends nsISupports {

    /** @} */
    /**
     * init
     *
     * This method initializes a server socket.
     *
     * @param aPort
     *        The port of the server socket.  Pass -1 to indicate no preference,
     *        and a port will be selected automatically.
     * @param aLoopbackOnly
     *        If true, the server socket will only respond to connections on the
     *        local loopback interface.  Otherwise, it will accept connections
     *        from any interface.  To specify a particular network interface,
     *        use initWithAddress.
     * @param aBackLog
     *        The maximum length the queue of pending connections may grow to.
     *        This parameter may be silently limited by the operating system.
     *        Pass -1 to use the default value.
     */
    readonly init: (aPort: number, aLoopbackOnly: boolean, aBackLog: number) => void;

    /**
     * the same as init(), but initializes an IPv6 server socket
     */
    readonly initIPv6: (aPort: number, aLoopbackOnly: boolean, aBackLog: number) => void;

    /**
     * initSpecialConnection
     *
     * This method initializes a server socket and offers the ability to have
     * that socket not get terminated if Gecko is set offline.
     *
     * @param aPort
     *        The port of the server socket.  Pass -1 to indicate no preference,
     *        and a port will be selected automatically.
     * @param aFlags
     *        Flags for the socket.
     * @param aBackLog
     *        The maximum length the queue of pending connections may grow to.
     *        This parameter may be silently limited by the operating system.
     *        Pass -1 to use the default value.
     */
    readonly initSpecialConnection: (aPort: number, aFlags: number, aBackLog: number) => void;

    /**
     * initWithFilename
     *
     * This method initializes a Unix domain or "local" server socket. Such
     * a socket has a name in the filesystem, like an ordinary file. To
     * connect, a client supplies the socket's filename, and the usual
     * permission checks on socket apply.
     *
     * This makes Unix domain sockets useful for communication between the
     * programs being run by a specific user on a single machine: the
     * operating system takes care of authentication, and the user's home
     * directory or profile directory provide natural per-user rendezvous
     * points.
     *
     * Since Unix domain sockets are always local to the machine, they are
     * not affected by the nsIIOService's 'offline' flag.
     *
     * The system-level socket API may impose restrictions on the length of
     * the filename that are stricter than those of the underlying
     * filesystem. If the file name is too long, this returns
     * NS_ERROR_FILE_NAME_TOO_LONG.
     *
     * All components of the path prefix of |aPath| must name directories;
     * otherwise, this returns NS_ERROR_FILE_NOT_DIRECTORY.
     *
     * This call requires execute permission on all directories containing
     * the one in which the socket is to be created, and write and execute
     * permission on the directory itself. Otherwise, this returns
     * NS_ERROR_CONNECTION_REFUSED.
     *
     * This call creates the socket's directory entry. There must not be
     * any existing entry with the given name. If there is, this returns
     * NS_ERROR_SOCKET_ADDRESS_IN_USE.
     *
     * On systems that don't support Unix domain sockets at all, this
     * returns NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED.
     *
     * @param aPath nsIFile
     *        The file name at which the socket should be created.
     *
     * @param aPermissions unsigned long
     *        Unix-style permission bits to be applied to the new socket.
     *
     * Note about permissions: Linux's unix(7) man page claims that some
     * BSD-derived systems ignore permissions on UNIX-domain sockets;
     * NetBSD's bind(2) man page agrees, but says it does check now (dated
     * 2005). POSIX has required 'connect' to fail if write permission on
     * the socket itself is not granted since 2003 (Issue 6). NetBSD says
     * that the permissions on the containing directory (execute) have
     * always applied, so creating sockets in appropriately protected
     * directories should be secure on both old and new systems.
     */
    readonly initWithFilename: (aPath: (nsIFile | null), aPermissions: number, aBacklog: number) => void;

    /**
     * initWithAbstractAddress
     *
     * This mehtod is a flavor of initWithFilename method. This initializes
     * a UNIX domain socket that uses abstract socket address.
     * This socket type is only supported on Linux and Android.
     *
     * On systems that don't support this type's UNIX domain sockets at all,
     * this returns NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED.
     *
     * @param aName
     *        The abstract socket address which the socket should be created.
     * @param aBacklog
     *        The maximum length the queue of pending connections may grow to.
     */
    readonly initWithAbstractAddress: (aName: IDLAUTF8String, aBacklog: number) => void;

    /**
     * close
     *
     * This method closes a server socket.  This does not affect already
     * connected client sockets (i.e., the nsISocketTransport instances
     * created from this server socket).  This will cause the onStopListening
     * event to asynchronously fire with a status of NS_BINDING_ABORTED.
     */
    readonly close: () => void;

    /**
     * asyncListen
     *
     * This method puts the server socket in the listening state.  It will
     * asynchronously listen for and accept client connections.  The listener
     * will be notified once for each client connection that is accepted.  The
     * listener's onSocketAccepted method will be called on the same thread
     * that called asyncListen (the calling thread must have a nsIEventTarget).
     *
     * The listener will be passed a reference to an already connected socket
     * transport (nsISocketTransport).  See below for more details.
     *
     * @param aListener
     *        The listener to be notified when client connections are accepted.
     */
    readonly asyncListen: (aListener: (nsIServerSocketListener | null)) => void;

    /**
     * Returns the port of this server socket.
     */
    readonly port: number;
  }

  export interface nsIHttpUpgradeListenerRef {
    readonly name: "nsIHttpUpgradeListener";
    readonly number: "{5b515449-ab64-4dba-b3cd-da8fc2f83064}";
  }

  /**
   * The callback interface for nsIHttpChannelInternal::HTTPUpgrade()
   */
  export interface nsIHttpUpgradeListener extends nsISupports {

    readonly onTransportAvailable: (aTransport: (nsISocketTransport | null), aSocketIn: (nsIAsyncInputStream | null), aSocketOut: (nsIAsyncOutputStream | null)) => void;

    readonly onUpgradeFailed: (aErrorCode: number) => void;
  }

  export interface nsIWebBrowserFindRef {
    readonly name: "nsIWebBrowserFind";
    readonly number: "{e4920136-b3e0-49e0-b1cd-6c783d2591a8}";
  }

  /**
   * nsIWebBrowserFind
   *
   * Searches for text in a web browser.
   *
   * Get one by doing a GetInterface on an nsIWebBrowser.
   *
   * By default, the implementation will search the focussed frame, or
   * if there is no focussed frame, the web browser content area. It
   * does not by default search subframes or iframes. To change this
   * behaviour, and to explicitly set the frame to search,
   * QueryInterface to nsIWebBrowserFindInFrames.
   */
  export interface nsIWebBrowserFind extends nsISupports {

    /**
     * findNext
     *
     * Finds, highlights, and scrolls into view the next occurrence of the
     * search string, using the current search settings. Fails if the
     * search string is empty.
     *
     * @return  Whether an occurrence was found
     */
    readonly findNext: () => boolean;

    /**
     * searchString
     *
     * The string to search for. This must be non-empty to search.
     */
    searchString: IDLAString;

    /**
     * findBackwards
     *
     * Whether to find backwards (towards the beginning of the document).
     * Default is false (search forward).
     */
    findBackwards: boolean;

    /**
     * wrapFind
     *
     * Whether the search wraps around to the start (or end) of the document
     * if no match was found between the current position and the end (or
     * beginning). Works correctly when searching backwards. Default is
     * false.
     */
    wrapFind: boolean;

    /**
     * entireWord
     *
     * Whether to match entire words only. Default is false.
     */
    entireWord: boolean;

    /**
     * matchCase
     *
     * Whether to match case (case sensitive) when searching. Default is false.
     */
    matchCase: boolean;

    /**
     * matchDiacritics
     *
     * Whether to match diacritics when searching. Default is false.
     */
    matchDiacritics: boolean;

    /**
     * searchFrames
     *
     * Whether to search through all frames in the content area. Default is true.
     *
     * Note that you can control whether the search propagates into child or
     * parent frames explicitly using nsIWebBrowserFindInFrames, but if one,
     * but not both, of searchSubframes and searchParentFrames are set, this
     * returns false.
     */
    searchFrames: boolean;
  }

  export interface imgIContainerDebugRef {
    readonly name: "imgIContainerDebug";
    readonly number: "{52cbb839-6e63-4a70-b21a-1db4ca706c49}";
  }

  /**
   * This interface is used in debug builds (and only there) in
   * order to let automatic tests running JavaScript access
   * internal state of imgContainers. This lets us test
   * things like animation.
   */
  export interface imgIContainerDebug extends nsISupports {

    /**
     * The # of frames this imgContainer has been notified about.
     * That is equal to the # of times the animation timer has
     * fired, and is usually equal to the # of frames actually
     * drawn (but actual drawing might be disabled).
     */
    readonly framesNotified: number;
  }

  export interface nsIFormatConverterRef {
    readonly name: "nsIFormatConverter";
    readonly number: "{948a0023-e3a7-11d2-96cf-0060b0fb9956}";
  }

  export interface nsIFormatConverter extends nsISupports {

    /**
     * Get the list of the "input" data flavors (mime types as nsISupportsCString),
     * in otherwords, the flavors that this converter can convert "from" (the
     * incoming data to the converter).
     */
    readonly getInputDataFlavors: () => IDLACString[];

    /**
     * Get the list of the "output" data flavors (mime types as nsISupportsCString),
     * in otherwords, the flavors that this converter can convert "to" (the
     * outgoing data to the converter).
     *
     * @param  aDataFlavorList fills list with supported flavors
     */
    readonly getOutputDataFlavors: () => IDLACString[];

    /**
     * Determines whether a conversion from one flavor to another is supported
     *
     * @param  aFromFormatConverter flavor to convert from
     * @param  aFromFormatConverter flavor to convert to
     */
    readonly canConvert: (aFromDataFlavor: string, aToDataFlavor: string) => boolean;

    /**
     * Converts from one flavor to another.
     *
     * @param  aFromFormatConverter flavor to convert from
     * @param  aFromFormatConverter flavor to convert to (destination own the memory)
     * @returns returns NS_OK if it was converted
     */
    readonly convert: (aFromDataFlavor: string, aFromData: (nsISupports | null), aToDataFlavor: string, aToData: Out<(nsISupports | null)>) => void;
  }

  export interface nsIPrefBranchRef {
    readonly name: "nsIPrefBranch";
    readonly number: "{55d25e49-793f-4727-a69f-de8b15f4b985}";

    /**
     * Values describing the basic preference types.
     *
     * @see getPrefType
     */
    PREF_INVALID: 0;

    PREF_STRING: 32;

    PREF_INT: 64;

    PREF_BOOL: 128;
  }

  /**
   * The nsIPrefBranch interface is used to manipulate the preferences data. This
   * object may be obtained from the preferences service (nsIPrefService) and
   * used to get and set default and/or user preferences across the application.
   *
   * This object is created with a "root" value which describes the base point in
   * the preferences "tree" from which this "branch" stems. Preferences are
   * accessed off of this root by using just the final portion of the preference.
   * For example, if this object is created with the root "browser.startup.",
   * the preferences "browser.startup.page", "browser.startup.homepage",
   * and "browser.startup.homepage_override" can be accessed by simply passing
   * "page", "homepage", or "homepage_override" to the various Get/Set methods.
   *
   * @see nsIPrefService
   */
  export interface nsIPrefBranch extends nsISupports {

    /**
     * Called to get the root on which this branch is based, such as
     * "browser.startup."
     */
    readonly root: IDLACString;

    /**
     * Called to determine the type of a specific preference.
     *
     * @param aPrefName The preference to get the type of.
     *
     * @return long     A value representing the type of the preference. This
     *                  value will be PREF_STRING, PREF_INT, or PREF_BOOL.
     */
    readonly getPrefType: (aPrefName: string) => number;

    /**
     * Called to get the state of an individual boolean preference.
     *
     * @param aPrefName The boolean preference to get the state of.
     * @param aDefaultValue The value to return if the preference is not set.
     *
     * @return boolean  The value of the requested boolean preference.
     *
     * @see setBoolPref
     */
    readonly getBoolPref: (aPrefName: string, aDefaultValue?: boolean) => boolean;

    /**
       * Called to set the state of an individual boolean preference.
       *
       * @param aPrefName The boolean preference to set the state of.
       * @param aValue    The boolean value to set the preference to.
       *
       * @throws Error if setting failed or the preference has a default
                 value of a type other than boolean.
       *
       * @see getBoolPref
       */
    readonly setBoolPref: (aPrefName: string, aValue: boolean) => void;

    /**
     * Called to get the state of an individual floating-point preference.
     * "Floating point" preferences are really string preferences that
     * are converted to floating point numbers.
     *
     * @param aPrefName The floating point preference to get the state of.
     * @param aDefaultValue The value to return if the preference is not set.
     *
     * @return float  The value of the requested floating point preference.
     *
     * @see setCharPref
     */
    readonly getFloatPref: (aPrefName: string, aDefaultValue?: number) => number;

    /**
     * Called to get the state of an individual ascii string preference.
     *
     * @param aPrefName The string preference to retrieve.
     * @param aDefaultValue The string to return if the preference is not set.
     *
     * @return ACString   The value of the requested string preference.
     *
     * @see setCharPref
     */
    readonly getCharPref: (aPrefName: string, aDefaultValue?: IDLACString) => IDLACString;

    /**
       * Called to set the state of an individual ascii string preference.
       *
       * @param aPrefName The string preference to set.
       * @param aValue    The string value to set the preference to.
       *
       * @throws Error if setting failed or the preference has a default
                 value of a type other than string.
       *
       * @see getCharPref
       */
    readonly setCharPref: (aPrefName: string, aValue: IDLACString) => void;

    /**
     * Called to get the state of an individual unicode string preference.
     *
     * @param aPrefName The string preference to retrieve.
     * @param aDefaultValue The string to return if the preference is not set.
     *
     * @return AUTF8String   The value of the requested string preference.
     *
     * @see setStringPref
     */
    readonly getStringPref: (aPrefName: string, aDefaultValue?: IDLAUTF8String) => IDLAUTF8String;

    /**
       * Called to set the state of an individual unicode string preference.
       *
       * @param aPrefName The string preference to set.
       * @param aValue    The string value to set the preference to.
       *
       * @throws Error if setting failed or the preference has a default
                 value of a type other than string.
       *
       * @see getStringPref
       */
    readonly setStringPref: (aPrefName: string, aValue: IDLAUTF8String) => void;

    /**
     * Called to get the state of an individual integer preference.
     *
     * @param aPrefName The integer preference to get the value of.
     * @param aDefaultValue The value to return if the preference is not set.
     *
     * @return long     The value of the requested integer preference.
     *
     * @see setIntPref
     */
    readonly getIntPref: (aPrefName: string, aDefaultValue?: number) => number;

    /**
       * Called to set the state of an individual integer preference.
       *
       * @param aPrefName The integer preference to set the value of.
       * @param aValue    The integer value to set the preference to.
       *
       * @throws Error if setting failed or the preference has a default
                 value of a type other than integer.
       *
       * @see getIntPref
       */
    readonly setIntPref: (aPrefName: string, aValue: number) => void;

    /**
     * Called to clear a user set value from a specific preference. This will, in
     * effect, reset the value to the default value. If no default value exists
     * the preference will cease to exist.
     *
     * @param aPrefName The preference to be cleared.
     *
     * @note
     * This method does nothing if this object is a default branch.
     */
    readonly clearUserPref: (aPrefName: string) => void;

    /**
     * Called to lock a specific preference. Locking a preference will cause the
     * preference service to always return the default value regardless of
     * whether there is a user set value or not.
     *
     * @param aPrefName The preference to be locked.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the default branch.
     *
     * @throws Error The preference does not exist or an error occurred.
     *
     * @see unlockPref
     */
    readonly lockPref: (aPrefName: string) => void;

    /**
     * Called to check if a specific preference has a user value associated to
     * it.
     *
     * @param aPrefName The preference to be tested.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the user branch.
     *
     * @note
     * If a preference was manually set to a value that equals the default value,
     * then the preference no longer has a user set value, i.e. it is
     * considered reset to its default value.
     * In particular, this method will return false for such a preference and
     * the preference will not be saved to a file by nsIPrefService.savePrefFile.
     *
     * @return boolean  true  The preference has a user set value.
     *                  false The preference only has a default value.
     */
    readonly prefHasUserValue: (aPrefName: string) => boolean;

    /**
     * Called to check if a specific preference is locked. If a preference is
     * locked calling its Get method will always return the default value.
     *
     * @param aPrefName The preference to be tested.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the default branch.
     *
     * @return boolean  true  The preference is locked.
     *                  false The preference is not locked.
     *
     * @see lockPref
     * @see unlockPref
     */
    readonly prefIsLocked: (aPrefName: string) => boolean;

    /**
     * Called to unlock a specific preference. Unlocking a previously locked
     * preference allows the preference service to once again return the user set
     * value of the preference.
     *
     * @param aPrefName The preference to be unlocked.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the default branch.
     *
     * @throws Error The preference does not exist or an error occurred.
     *
     * @see lockPref
     */
    readonly unlockPref: (aPrefName: string) => void;

    /**
     * Called to remove all of the preferences referenced by this branch.
     *
     * @param aStartingAt The point on the branch at which to start the deleting
     *                    preferences. Pass in "" to remove all preferences
     *                    referenced by this branch.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on both.
     *
     * @throws Error The preference(s) do not exist or an error occurred.
     */
    readonly deleteBranch: (aStartingAt: string) => void;

    /**
     * Returns an array of strings representing the child preferences of the
     * root of this branch.
     *
     * @param aStartingAt The point on the branch at which to start enumerating
     *                    the child preferences. Pass in "" to enumerate all
     *                    preferences referenced by this branch.
     * @return            The array of child preferences.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on both.
     *
     * @throws Error The preference(s) do not exist or an error occurred.
     */
    readonly getChildList: (aStartingAt: string) => IDLACString[];

    /**
     * Called to reset all of the preferences referenced by this branch to their
     * default values.
     *
     * @param aStartingAt The point on the branch at which to start the resetting
     *                    preferences to their default values. Pass in "" to
     *                    reset all preferences referenced by this branch.
     *
     * @note
     * This method can be called on either a default or user branch but, in
     * effect, always operates on the user branch.
     *
     * @throws Error The preference(s) do not exist or an error occurred.
     */
    readonly resetBranch: (aStartingAt: string) => void;

    /**
     * Add a preference change observer. On preference changes, the following
     * arguments will be passed to the nsIObserver.observe() method:
     *   aSubject - The nsIPrefBranch object (this)
     *   aTopic   - The string defined by NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
     *   aData    - The name of the preference which has changed, relative to
     *              the |root| of the aSubject branch.
     *
     * aSubject.get*Pref(aData) will get the new value of the modified
     * preference. For example, if your observer is registered with
     * addObserver("bar.", ...) on a branch with root "foo.", modifying
     * the preference "foo.bar.baz" will trigger the observer, and aData
     * parameter will be "bar.baz".
     *
     * @param aDomain   The preference on which to listen for changes. This can
     *                  be the name of an entire branch to observe.
     *                  e.g. Holding the "root" prefbranch and calling
     *                  addObserver("foo.bar.", ...) will observe changes to
     *                  foo.bar.baz and foo.bar.bzip
     * @param aObserver The object to be notified if the preference changes.
     * @param aHoldWeak true  Hold a weak reference to |aObserver|. The object
     *                        must implement the nsISupportsWeakReference
     *                        interface or this will fail.
     *                  false Hold a strong reference to |aObserver|.
     *
     * @note
     * Registering as a preference observer can open an object to potential
     * cyclical references which will cause memory leaks. These cycles generally
     * occur because an object both registers itself as an observer (causing the
     * branch to hold a reference to the observer) and holds a reference to the
     * branch object for the purpose of getting/setting preference values. There
     * are 3 approaches which have been implemented in an attempt to avoid these
     * situations.
     * 1) The nsPrefBranch object supports nsISupportsWeakReference. Any consumer
     *    may hold a weak reference to it instead of a strong one.
     * 2) The nsPrefBranch object listens for xpcom-shutdown and frees all of the
     *    objects currently in its observer list. This ensures that long lived
     *    objects (services for example) will be freed correctly.
     * 3) The observer can request to be held as a weak reference when it is
     *    registered. This insures that shorter lived objects (say one tied to an
     *    open window) will not fall into the cyclical reference trap.
     *
     * @note
     * The list of registered observers may be changed during the dispatch of
     * nsPref:changed notification. However, the observers are not guaranteed
     * to be notified in any particular order, so you can't be sure whether the
     * added/removed observer will be called during the notification when it
     * is added/removed.
     *
     * @note
     * It is possible to change preferences during the notification.
     *
     * @note
     * It is not safe to change observers during this callback in Gecko
     * releases before 1.9. If you want a safe way to remove a pref observer,
     * please use an nsITimer.
     *
     * @see nsIObserver
     * @see removeObserver
     */
    readonly addObserver: (aDomain: IDLACString, aObserver: (nsIObserver | nsIObserverFunction | null), aHoldWeak?: boolean) => void;

    /**
     * Remove a preference change observer.
     *
     * @param aDomain   The preference which is being observed for changes.
     * @param aObserver An observer previously registered with addObserver().
     *
     * @note
     * Note that you must call removeObserver() on the same nsIPrefBranch
     * instance on which you called addObserver() in order to remove aObserver;
     * otherwise, the observer will not be removed.
     *
     * @see nsIObserver
     * @see addObserver
     */
    readonly removeObserver: (aDomain: IDLACString, aObserver: (nsIObserver | nsIObserverFunction | null)) => void;
  }

  export interface nsIDirIndexRef {
    readonly name: "nsIDirIndex";
    readonly number: "{23bbabd0-1dd2-11b2-86b7-aad68ae7d7e0}";

    /**
     * Entry's type is unknown
     */
    TYPE_UNKNOWN: 0;

    /**
     * Entry is a directory
     */
    TYPE_DIRECTORY: 1;

    /**
     * Entry is a file
     */
    TYPE_FILE: 2;

    /**
     * Entry is a symlink
     */
    TYPE_SYMLINK: 3;
  }

  /** A class holding information about a directory index.
   * These have no reference back to their original source -
   * changing these attributes won't affect the directory
   */
  export interface nsIDirIndex extends nsISupports {

    /**
     * The type of the entry - one of the constants above
     */
    type: number;

    /**
     * The content type - may be null if it is unknown.
     * Unspecified for directories
     */
    contentType: IDLACString;

    /**
     * The fully qualified filename, expressed as a uri
     *
     * This is encoded with the encoding specified in
     * the nsIDirIndexParser, and is also escaped.
     */
    location: IDLACString;

    /**
     * A description for the filename, which should be
     * displayed by a viewer
     */
    description: IDLAString;

    /**
     * File size, with -1 meaning "unknown"
     */
    size: number;

    /**
     * Last-modified time in seconds-since-epoch.
     * -1 means unknown - this is valid, because there were no
     * ftp servers in 1969
     */
    lastModified: number;
  }

  export interface nsIGIOMimeAppRef {
    readonly name: "nsIGIOMimeApp";
    readonly number: "{ca6bad0c-8a48-48ac-82c7-27bb8f510fbe}";

    EXPECTS_URIS: 0;

    EXPECTS_PATHS: 1;

    EXPECTS_URIS_FOR_NON_FILES: 2;
  }

  export interface nsIGIOMimeApp extends nsIHandlerApp {

    readonly id: IDLAUTF8String;

    readonly command: IDLAUTF8String;

    readonly expectsURIs: number;

    readonly supportedURISchemes: (nsIUTF8StringEnumerator | null);

    readonly setAsDefaultForMimeType: (mimeType: IDLAUTF8String) => void;

    readonly setAsDefaultForFileExtensions: (extensions: IDLAUTF8String) => void;

    readonly setAsDefaultForURIScheme: (uriScheme: IDLAUTF8String) => void;
  }

  export interface nsIASN1SequenceRef {
    readonly name: "nsIASN1Sequence";
    readonly number: "{b6b957e6-1dd1-11b2-89d7-e30624f50b00}";
  }

  /**
   * This represents a sequence of ASN.1 objects,
   * where ASN.1 is "Abstract Syntax Notation number One".
   *
   * Overview of how this ASN1 interface is intended to
   * work.
   *
   * First off, the nsIASN1Sequence is any type in ASN1
   * that consists of sub-elements (ie SEQUENCE, SET)
   * nsIASN1Printable Items are all the other types that
   * can be viewed by themselves without interpreting further.
   * Examples would include INTEGER, UTF-8 STRING, OID.
   * These are not intended to directly reflect the numberous
   * types that exist in ASN1, but merely an interface to ease
   * producing a tree display the ASN1 structure of any DER
   * object.
   *
   * The additional state information carried in this interface
   * makes it fit for being used as the data structure
   * when working with visual reprenstation of ASN.1 objects
   * in a human user interface, like in a tree widget
   * where open/close state of nodes must be remembered.
   */
  export interface nsIASN1Sequence extends nsIASN1Object {

    /**
     *  The array of objects stored in the sequence.
     */
    ASN1Objects: (nsIMutableArray | null);

    /**
     *  Whether the node at this position in the ASN.1 data structure
     *  sequence contains sub elements understood by the
     *  application.
     */
    isValidContainer: boolean;

    /**
     *  Whether the contained objects should be shown or hidden.
     *  A UI implementation can use this flag to store the current
     *  expansion state when shown in a tree widget.
     */
    isExpanded: boolean;
  }

  export interface nsISupportsPRInt64Ref {
    readonly name: "nsISupportsPRInt64";
    readonly number: "{e3cb0ff0-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for 64-bit integers
   */
  export interface nsISupportsPRInt64 extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsIWebSocketEventListenerRef {
    readonly name: "nsIWebSocketEventListener";
    readonly number: "{e7c005ab-e694-489b-b741-96db43ffb16f}";

    TYPE_STRING: 0;

    TYPE_BLOB: 1;

    TYPE_ARRAYBUFFER: 2;
  }

  export interface nsIWebSocketEventListener extends nsISupports {

    readonly webSocketCreated: (aWebSocketSerialID: number, aURI: IDLAString, aProtocols: IDLACString) => void;

    readonly webSocketOpened: (aWebSocketSerialID: number, aEffectiveURI: IDLAString, aProtocols: IDLACString, aExtensions: IDLACString, aHttpChannelId: number) => void;

    readonly webSocketMessageAvailable: (aWebSocketSerialID: number, aMessage: IDLACString, aType: number) => void;

    readonly webSocketClosed: (aWebSocketSerialID: number, aWasClean: boolean, aCode: number, aReason: IDLAString) => void;

    readonly frameReceived: (aWebSocketSerialID: number, aFrame: (nsIWebSocketFrame | null)) => void;

    readonly frameSent: (aWebSocketSerialID: number, aFrame: (nsIWebSocketFrame | null)) => void;
  }

  export interface nsITabSourceRef {
    readonly name: "nsITabSource";
    readonly number: "{0feba7f2-800d-4fe5-b28d-e3f17a7a7322}";
  }

  export interface nsITabSource extends nsISupports {

    readonly getTabToStream: () => (mozIDOMWindowProxy | null);

    readonly notifyStreamStart: (window: (mozIDOMWindowProxy | null)) => void;

    readonly notifyStreamStop: (window: (mozIDOMWindowProxy | null)) => void;
  }

  export interface nsITokenPasswordDialogsRef {
    readonly name: "nsITokenPasswordDialogs";
    readonly number: "{87dbd64a-4466-474e-95f5-1ad1cee5702c}";
  }

  /**
   *  This is the interface for setting and changing password
   *  on a PKCS11 token.
   */
  export interface nsITokenPasswordDialogs extends nsISupports {

    /**
     * Brings up a dialog to set the password on a token.
     *
     * @param ctx A user interface context.
     * @param token {nsIPK11Token} The token.
     * @return true if the user canceled the dialog, false otherwise.
     */
    readonly setPassword: (ctx: (nsIInterfaceRequestor | null), token: (nsIPK11Token | null)) => boolean;
  }

  export interface nsIFileMetadataRef {
    readonly name: "nsIFileMetadata";
    readonly number: "{07f679e4-9601-4bd1-b510-cd3852edb881}";
  }

  /**
   * An interface that allows you to get some metadata like file size and
   * file last modified time. These methods and attributes can throw
   * NS_BASE_STREAM_WOULD_BLOCK in case the informations are not available yet.
   * If this happens, consider the use of nsIAsyncFileMetadata.
   *
   * If using nsIAsyncFileMetadata, you should retrieve any data via this
   * interface before taking any action that might consume the underlying stream.
   * For example, once Available(), Read(), or nsIAsyncInputStream::AsyncWait()
   * are invoked, these methods may return NS_BASE_STREAM_CLOSED.  This will
   * happen when using IPCBlobInputStream with an underlying file stream, for
   * example.
   */
  export interface nsIFileMetadata extends nsISupports {

    /**
     * File size in bytes.
     */
    readonly size: number;

    /**
     * File last modified time in milliseconds from midnight (00:00:00),
     * January 1, 1970 Greenwich Mean Time (GMT).
     */
    readonly lastModified: number;
  }

  export interface nsITellableStreamRef {
    readonly name: "nsITellableStream";
    readonly number: "{ee942946-4538-45d2-bf05-ffdbf5932621}";
  }

  export interface nsITellableStream extends nsISupports {

    /**
     *  tell
     *
     *  This method reports the current offset, in bytes, from the start of the
     *  stream.
     *
     *   @throws NS_BASE_STREAM_CLOSED if called on a closed stream.
     */
    readonly tell: () => number;
  }

  export interface nsIRemoteWebProgressRef {
    readonly name: "nsIRemoteWebProgress";
    readonly number: "{2104bfce-bbbe-4111-aa29-cd7c91d1023b}";
  }

  export interface nsIRemoteWebProgress extends nsIWebProgress {

    /**
     * Initialize the web progress.
     *
     * @param aManager The RemoteWebProgressManager for this remote nsIWebProgress.
     * @param aIsTopLevel Whether or not this is a top-level web progress.
     */
    readonly init: (aManager: (nsIWebProgress | null), aIsTopLevel: boolean) => void;

    /**
     * Update the RemoteWebProgress with values from the content process.
     *
     * @param aOuterWindowID The outer window ID.
     * @param aInnerWindowID The inner window ID.
     * @param aLoadType The load type.
     * @param aIsLoadingDocument Whether or not a document is being loaded.
     */
    readonly update: (aOuterWindowID: number, aInnerWindowID: number, aLoadType: number, aIsLoadingDocument: boolean) => void;
  }

  export interface nsIModuleRef {
    readonly name: "nsIModule";
    readonly number: "{7392d032-5371-11d3-994e-00805fd26fee}";
  }

  /**
   * The nsIModule interface.
   */
  export interface nsIModule extends nsISupports {

    /**
     * One time registration callback
     *
     * When the nsIModule is discovered, this method will be
     * called so that any setup registration can be preformed.
     *
     * @param aCompMgr  : The global component manager
     * @param aLocation : The location of the nsIModule on disk
     * @param aLoaderStr: Opaque loader specific string
     * @param aType     : Loader Type being used to load this module
     */
    readonly registerSelf: (aCompMgr: (nsIComponentManager | null), aLocation: (nsIFile | null), aLoaderStr: string, aType: string) => void;

    /**
     * One time unregistration callback
     *
     * When the nsIModule is being unregistered, this method will be
     * called so that any unregistration can be preformed
     *
     * @param aCompMgr   : The global component manager
     * @param aLocation  : The location of the nsIModule on disk
     * @param aLoaderStr : Opaque loader specific string
     *
     */
    readonly unregisterSelf: (aCompMgr: (nsIComponentManager | null), aLocation: (nsIFile | null), aLoaderStr: string) => void;

    /**
     * Module load management
     *
     * @param aCompMgr  : The global component manager
     *
     * @return indicates to the caller if the module can be unloaded.
     * 		Returning PR_TRUE isn't a guarantee that the module will be
     *		unloaded. It constitues only willingness of the module to be
     *		unloaded.  It is very important to ensure that no outstanding
     *       references to the module's code/data exist before returning
     *       PR_TRUE.
     *		Returning PR_FALSE guaratees that the module won't be unloaded.
     */
    readonly canUnload: (aCompMgr: (nsIComponentManager | null)) => boolean;
  }

  export interface nsIStringBundleServiceRef {
    readonly name: "nsIStringBundleService";
    readonly number: "{d85a17c0-aa7c-11d2-9b8c-00805f8a16d9}";
  }

  export interface nsIStringBundleService extends nsISupports {

    readonly createBundle: (aURLSpec: string) => (nsIStringBundle | null);

    /**
     * Formats a message string from a status code and status arguments.
     * @param aStatus - The status code. This is mapped into a string ID and
     *            and used in the string lookup process (see nsIErrorService).
     * @param aStatusArg - The status message argument(s). Multiple arguments
     *            can be separated by newline ('\n') characters.
     * @return the formatted message
     */
    readonly formatStatusMessage: (aStatus: number, aStatusArg: string) => IDLAString;

    /**
     * flushes the string bundle cache - useful when the locale changes or
     * when we need to get some extra memory back
     *
     * at some point, we might want to make this flush all the bundles,
     * because any bundles that are floating around when the locale changes
     * will suddenly contain bad data
     *
     */
    readonly flushBundles: () => void;
  }

  export interface nsIGZFileWriterRef {
    readonly name: "nsIGZFileWriter";
    readonly number: "{6bd5642c-1b90-4499-ba4b-199f27efaba5}";
  }

  /**
   * A simple interface for writing to a .gz file.
   *
   * Note that the file that this interface produces has a different format than
   * what you'd get if you compressed your data as a gzip stream and dumped the
   * result to a file.
   *
   * The standard gunzip tool cannot decompress a raw gzip stream, but can handle
   * the files produced by this interface.
   */
  export interface nsIGZFileWriter extends nsISupports {

    /**
     * Initialize this object.  We'll write our gzip'ed data to the given file,
     * overwriting its contents if the file exists.
     *
     * init() will return an error if called twice.  It's an error to call any
     * other method on this interface without first calling init().
     */
    readonly init: (file: (nsIFile | null)) => void;

    /**
     * Write the given string to the file.
     */
    readonly write: (str: IDLAUTF8String) => void;

    /**
     * Close this nsIGZFileWriter.  Classes implementing nsIGZFileWriter will run
     * this method when the underlying object is destroyed, so it's not strictly
     * necessary to explicitly call it from your code.
     *
     * It's an error to call this method twice, and it's an error to call write()
     * after finish() has been called.
     */
    readonly finish: () => void;
  }

  export interface nsIInputStreamCallbackRef {
    readonly name: "nsIInputStreamCallback";
    readonly number: "{d1f28e94-3a6e-4050-a5f5-2e81b1fc2a43}";
  }

  type nsIInputStreamCallbackFunction = (aStream: (nsIAsyncInputStream | null)) => void;

  export interface nsIInputStreamCallback extends nsISupports {

    /**
     * This is a companion interface for nsIAsyncInputStream::asyncWait.
     */
    /**
     * Called to indicate that the stream is either readable or closed.
     *
     * @param aStream
     *        The stream whose asyncWait method was called.
     */
    readonly onInputStreamReady: (aStream: (nsIAsyncInputStream | null)) => void;
  }

  export interface nsIIncrementalDownloadRef {
    readonly name: "nsIIncrementalDownload";
    readonly number: "{6687823f-56c4-461d-93a1-7f6cb7dfbfba}";
  }

  /**
   * An incremental download object attempts to fetch a file piecemeal over time
   * in an effort to minimize network bandwidth usage.
   *
   * Canceling a background download does not cause the file on disk to be
   * deleted.
   */
  export interface nsIIncrementalDownload extends nsIRequest {

    /**
     * Initialize the incremental download object.  If the destination file
     * already exists, then only the remaining portion of the file will be
     * fetched.
     *
     * NOTE: The downloader will create the destination file if it does not
     * already exist.  It will create the file with the permissions 0600 if
     * needed.  To affect the permissions of the file, consumers of this
     * interface may create an empty file at the specified destination prior to
     * starting the incremental download.
     *
     * NOTE: Since this class may create a temporary file at the specified
     * destination, it is advisable for the consumer of this interface to specify
     * a file name for the destination that would not tempt the user into
     * double-clicking it.  For example, it might be wise to append a file
     * extension like ".part" to the end of the destination to protect users from
     * accidentally running "blah.exe" before it is a complete file.
     *
     * @param uri
     *        The URI to fetch.
     * @param destination
     *        The location where the file is to be stored.
     * @param chunkSize
     *        The size of the chunks to fetch.  A non-positive value results in
     *        the default chunk size being used.
     * @param intervalInSeconds
     *        The amount of time to wait between fetching chunks.  Pass a
     *        negative to use the default interval, or 0 to fetch the remaining
     *        part of the file in one chunk.
     */
    readonly init: (uri: (nsIURI | null), destination: (nsIFile | null), chunkSize: number, intervalInSeconds: number) => void;

    /**
     * The URI being fetched.
     */
    readonly URI: (nsIURI | null);

    /**
     * The URI being fetched after any redirects have been followed.  This
     * attribute is set just prior to calling OnStartRequest on the observer
     * passed to the start method.
     */
    readonly finalURI: (nsIURI | null);

    /**
     * The file where the download is being written.
     */
    readonly destination: (nsIFile | null);

    /**
     * The total number of bytes for the requested file.  This attribute is set
     * just prior to calling OnStartRequest on the observer passed to the start
     * method.
     *
     * This attribute has a value of -1 if the total size is unknown.
     */
    readonly totalSize: number;

    /**
     * The current number of bytes downloaded so far.  This attribute is set just
     * prior to calling OnStartRequest on the observer passed to the start
     * method.
     *
     * This attribute has a value of -1 if the current size is unknown.
     */
    readonly currentSize: number;

    /**
     * Start the incremental download.
     *
     * @param observer
     *        An observer to be notified of various events.  OnStartRequest is
     *        called when finalURI and totalSize have been determined or when an
     *        error occurs.  OnStopRequest is called when the file is completely
     *        downloaded or when an error occurs.  If this object implements
     *        nsIProgressEventSink, then its OnProgress method will be called as
     *        data is written to the destination file.  If this object implements
     *        nsIInterfaceRequestor, then it will be assigned as the underlying
     *        channel's notification callbacks, which allows it to provide a
     *        nsIAuthPrompt implementation if needed by the channel, for example.
     * @param ctxt
     *        User defined object forwarded to the observer's methods.
     */
    readonly start: (observer: (nsIRequestObserver | null), ctxt: (nsISupports | null)) => void;
  }

  export interface nsIPaymentDetailsModifierRef {
    readonly name: "nsIPaymentDetailsModifier";
    readonly number: "{74259861-c318-40e8-b3d5-518e701bed80}";
  }

  export interface nsIPaymentDetailsModifier extends nsISupports {

    readonly supportedMethods: IDLAString;

    readonly total: (nsIPaymentItem | null);

    readonly additionalDisplayItems: (nsIArray | null);

    readonly data: IDLjsval;
  }

  export interface nsIMutableRef {
    readonly name: "nsIMutable";
    readonly number: "{321578d0-03c1-4d95-8821-021ac612d18d}";
  }

  /**
   * nsIMutable defines an interface to be implemented by objects which
   * can be made immutable.
   */
  export interface nsIMutable extends nsISupports {

    /**
     * Control whether or not this object can be modified.  If the flag is
     * false, no modification is allowed.  Once the flag has been set to false,
     * it cannot be reset back to true -- attempts to do so throw
     * NS_ERROR_INVALID_ARG.
     */
    mutable: boolean;
  }

  export interface nsIHttpAuthManagerRef {
    readonly name: "nsIHttpAuthManager";
    readonly number: "{54f90444-c52b-4d2d-8916-c59a2bb25938}";
  }

  /**
   * nsIHttpAuthManager
   *
   * This service provides access to cached HTTP authentication
   * user credentials (domain, username, password) for sites
   * visited during the current browser session.
   *
   * This interface exists to provide other HTTP stacks with the
   * ability to share HTTP authentication credentials with Necko.
   * This is currently used by the Java plugin (version 1.5 and
   * higher) to avoid duplicate authentication prompts when the
   * Java client fetches content from a HTTP site that the user
   * has already logged into.
   */
  export interface nsIHttpAuthManager extends nsISupports {

    /**
     * Lookup auth identity.
     *
     * @param aScheme
     *        the URL scheme (e.g., "http").  NOTE: for proxy authentication,
     *        this should be "http" (this includes authentication for CONNECT
     *        tunneling).
     * @param aHost
     *        the host of the server issuing a challenge (ASCII only).
     * @param aPort
     *        the port of the server issuing a challenge.
     * @param aAuthType
     *        optional string identifying auth type used (e.g., "basic")
     * @param aRealm
     *        optional string identifying auth realm.
     * @param aPath
     *        optional string identifying auth path. empty for proxy auth.
     * @param aUserDomain
     *        return value containing user domain.
     * @param aUserName
     *        return value containing user name.
     * @param aUserPassword
     *        return value containing user password.
     * @param aIsPrivate
     *        whether to look up a private or public identity (they are
     *        stored separately, for use by private browsing)
     * @param aPrincipal
     *        the principal from which to derive information about which
     *        app/mozbrowser is in use for this request
     */
    readonly getAuthIdentity: (aScheme: IDLACString, aHost: IDLACString, aPort: number, aAuthType: IDLACString, aRealm: IDLACString, aPath: IDLACString, aUserDomain: Out<IDLAString>, aUserName: Out<IDLAString>, aUserPassword: Out<IDLAString>, aIsPrivate?: boolean, aPrincipal?: (nsIPrincipal | null)) => void;

    /**
     * Store auth identity.
     *
     * @param aScheme
     *        the URL scheme (e.g., "http").  NOTE: for proxy authentication,
     *        this should be "http" (this includes authentication for CONNECT
     *        tunneling).
     * @param aHost
     *        the host of the server issuing a challenge (ASCII only).
     * @param aPort
     *        the port of the server issuing a challenge.
     * @param aAuthType
     *        optional string identifying auth type used (e.g., "basic")
     * @param aRealm
     *        optional string identifying auth realm.
     * @param aPath
     *        optional string identifying auth path. empty for proxy auth.
     * @param aUserDomain
     *        optional string containing user domain.
     * @param aUserName
     *        optional string containing user name.
     * @param aUserPassword
     *        optional string containing user password.
     * @param aIsPrivate
     *        whether to store a private or public identity (they are
     *        stored separately, for use by private browsing)
     * @param aPrincipal
     *        the principal from which to derive information about which
     *        app/mozbrowser is in use for this request
     */
    readonly setAuthIdentity: (aScheme: IDLACString, aHost: IDLACString, aPort: number, aAuthType: IDLACString, aRealm: IDLACString, aPath: IDLACString, aUserDomain: IDLAString, aUserName: IDLAString, aUserPassword: IDLAString, aIsPrivate?: boolean, aPrincipal?: (nsIPrincipal | null)) => void;

    /**
     * Clear all auth cache.
     */
    readonly clearAll: () => void;
  }


  export interface nsISupportsRef {
    readonly name: "nsISupports";
    readonly number: "{00000000-0000-0000-c000-000000000046}";
  }

  export interface nsINativeAppSupportRef {
    readonly name: "nsINativeAppSupport";
    readonly number: "{5fdf8480-1f98-11d4-8077-00600811a9c3}";
  }

  export interface nsINativeAppSupport extends nsISupports {

    readonly start: () => boolean;

    readonly enable: () => void;

    readonly onLastWindowClosing: () => void;

    readonly ReOpen: () => void;
  }

  export interface nsIKeyValueEnumeratorCallbackRef {
    readonly name: "nsIKeyValueEnumeratorCallback";
    readonly number: "{b7ea2183-880b-4424-ab24-5aa1555b775d}";
  }

  export interface nsIKeyValueEnumeratorCallback extends nsISupports {

    /**
     * A callback for the nsIKeyValueDatabase.enumerate() method.
     *
     * The result is an nsIKeyValueEnumerator.
     */
    readonly resolve: (enumerator: (nsIKeyValueEnumerator | null)) => void;

    readonly reject: (message: IDLAUTF8String) => void;
  }

  export interface nsIImageLoadingContentRef {
    readonly name: "nsIImageLoadingContent";
    readonly number: "{0357123d-9224-4d12-a47e-868c32689777}";

    /**
     * Request types.  Image loading content nodes attempt to do atomic
     * image changes when the image url is changed.  This means that
     * when the url changes the new image load will start, but the old
     * image will remain the "current" request until the new image is
     * fully loaded.  At that point, the old "current" request will be
     * discarded and the "pending" request will become "current".
     */
    UNKNOWN_REQUEST: -1;

    CURRENT_REQUEST: 0;

    PENDING_REQUEST: 1;
  }

  /**
   * This interface represents a content node that loads images.  The interface
   * exists to allow getting information on the images that the content node
   * loads and to allow registration of observers for the image loads.
   *
   * Implementors of this interface should handle all the mechanics of actually
   * loading an image -- getting the URI, checking with content policies and
   * the security manager to see whether loading the URI is allowed, performing
   * the load, firing any DOM events as needed.
   *
   * An implementation of this interface may support the concepts of a
   * "current" image and a "pending" image.  If it does, a request to change
   * the currently loaded image will start a "pending" request which will
   * become current only when the image is loaded.  It is the responsibility of
   * observers to check which request they are getting notifications for.
   *
   * Please make sure to update the MozImageLoadingContent WebIDL
   * mixin to mirror this interface when changing it.
   */
  export interface nsIImageLoadingContent extends imgINotificationObserver {
  }

  export interface nsISocketTransportServiceRef {
    readonly name: "nsISocketTransportService";
    readonly number: "{ad56b25f-e6bb-4db3-9f7b-5b7db33fd2b1}";
  }

  export interface nsISocketTransportService extends nsISupports {

    /**
     * Creates a transport for a specified host and port.
     *
     * @param aSocketTypes
     *        array of socket type strings.  Empty array if using default
     *        socket type.
     * @param aHost
     *        specifies the target hostname or IP address literal of the peer
     *        for this socket.
     * @param aPort
     *        specifies the target port of the peer for this socket.
     * @param aProxyInfo
     *        specifies the transport-layer proxy type to use.  null if no
     *        proxy.  used for communicating information about proxies like
     *        SOCKS (which are transparent to upper protocols).
     *
     * @see nsIProxiedProtocolHandler
     * @see nsIProtocolProxyService::GetProxyInfo
     *
     * NOTE: this function can be called from any thread
     */
    readonly createTransport: (aSocketTypes: IDLACString[], aHost: IDLAUTF8String, aPort: number, aProxyInfo: (nsIProxyInfo | null)) => (nsISocketTransport | null);

    /**
     * Create a transport built on a Unix domain socket, connecting to the
     * given filename.
     *
     * Since Unix domain sockets are always local to the machine, they are
     * not affected by the nsIIOService's 'offline' flag.
     *
     * On systems that don't support Unix domain sockets at all, this
     * returns NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED.
     *
     * The system-level socket API may impose restrictions on the length of
     * the filename that are stricter than those of the underlying
     * filesystem. If the file name is too long, this returns
     * NS_ERROR_FILE_NAME_TOO_LONG.
     *
     * The |aPath| parameter must specify an existing directory entry.
     * Otherwise, this returns NS_ERROR_FILE_NOT_FOUND.
     *
     * The program must have search permission on all components of the
     * path prefix of |aPath|, and read and write permission on |aPath|
     * itself. Without such permission, this returns
     * NS_ERROR_CONNECTION_REFUSED.
     *
     * The |aPath| parameter must refer to a unix-domain socket. Otherwise,
     * this returns NS_ERROR_CONNECTION_REFUSED. (POSIX specifies
     * ECONNREFUSED when "the target address was not listening for
     * connections", and this is what Linux returns.)
     *
     * @param aPath
     *        The file name of the Unix domain socket to which we should
     *        connect.
     */
    readonly createUnixDomainTransport: (aPath: (nsIFile | null)) => (nsISocketTransport | null);

    /**
     * Create a transport built on a Unix domain socket that uses abstract
     * address name.
     *
     * If abstract socket address isn't supported on System, this returns
     * NS_ERROR_SOCKET_ADDRESS_NOT_SUPPORTED.
     *
     * @param aName
     *        The name of abstract socket adress of the Unix domain socket to
     *        which we should connect.
     */
    readonly createUnixDomainAbstractAddressTransport: (aName: IDLACString) => (nsISocketTransport | null);
  }

  export interface nsIPaymentCurrencyAmountRef {
    readonly name: "nsIPaymentCurrencyAmount";
    readonly number: "{d22a6f5f-767b-4fea-bf92-68b0b8003eba}";
  }

  export interface nsIPaymentCurrencyAmount extends nsISupports {

    readonly currency: IDLAString;

    readonly value: IDLAString;
  }

  export interface nsIEventListenerChangeRef {
    readonly name: "nsIEventListenerChange";
    readonly number: "{07222b02-da12-4cf4-b2f7-761da007a8d8}";
  }

  /**
   * Contains an event target along with a count of event listener changes
   * affecting accessibility.
   */
  export interface nsIEventListenerChange extends nsISupports {

    readonly target: WebIDL.EventTarget;
  }

  export interface nsIKeyObjectRef {
    readonly name: "nsIKeyObject";
    readonly number: "{ee2dc516-ba7b-4e77-89fe-c43b886ef715}";

    SYM_KEY: 1;

    HMAC: 257;
  }

  export interface nsIKeyObject extends nsISupports {

    readonly getType: () => number;
  }

  export interface nsILoginReputationVerdictTypeRef {
    readonly name: "nsILoginReputationVerdictType";
    readonly number: "{6219f9da-297e-446d-8d47-ccdd8e72a1d5}";

    UNSPECIFIED: 0;

    SAFE: 1;

    LOW_REPUTATION: 2;

    PHISHING: 3;
  }

  export interface nsILoginReputationVerdictType extends nsISupports {
  }

  export interface nsIPresentationDeviceManagerRef {
    readonly name: "nsIPresentationDeviceManager";
    readonly number: "{beb61db5-3d5f-454f-a15a-dbfa0337c569}";
  }

  export interface nsIPresentationDeviceManager extends nsISupports {

    readonly deviceAvailable: boolean;

    readonly addDeviceProvider: (provider: (nsIPresentationDeviceProvider | null)) => void;

    readonly removeDeviceProvider: (provider: (nsIPresentationDeviceProvider | null)) => void;

    readonly forceDiscovery: () => void;

    readonly getAvailableDevices: (presentationUrls?: (nsIArray | null)) => (nsIArray | null);
  }

  export interface nsIContentSnifferRef {
    readonly name: "nsIContentSniffer";
    readonly number: "{a5772d1b-fc63-495e-a169-96e8d3311af0}";
  }

  /**
   * Content sniffer interface. Components implementing this interface can
   * determine a MIME type from a chunk of bytes.
   */
  export interface nsIContentSniffer extends nsISupports {

    /**
     * Given a chunk of data, determines a MIME type. Information from the given
     * request may be used in order to make a better decision.
     *
     * @param aRequest The request where this data came from. May be null.
     * @param aData Data to check
     * @param aLength Length of the data
     *
     * @return The content type
     *
     * @throw NS_ERROR_NOT_AVAILABLE if no MIME type could be determined.
     *
     * @note Implementations should consider the request read-only. Especially,
     * they should not attempt to set the content type property that subclasses of
     * nsIRequest might offer.
     */
    readonly getMIMETypeFromContent: (aRequest: (nsIRequest | null), aData: number[], aLength: number) => IDLACString;
  }

  export interface nsIPushQuotaManagerRef {
    readonly name: "nsIPushQuotaManager";
    readonly number: "{a2555e70-46f8-4b52-bf02-d978b979d143}";
  }

  export interface nsIPushQuotaManager extends nsISupports {

    /**
     * Informs the quota manager that a notification
     * for the given origin has been shown. Used to
     * determine if push quota should be relaxed.
     */
    readonly notificationForOriginShown: (origin: string) => void;

    /**
     * Informs the quota manager that a notification
     * for the given origin has been closed. Used to
     * determine if push quota should be relaxed.
     */
    readonly notificationForOriginClosed: (origin: string) => void;
  }

  export interface nsIFileMetadataCallbackRef {
    readonly name: "nsIFileMetadataCallback";
    readonly number: "{d01c7ead-7ba3-4726-b399-618ec8ec7057}";
  }

  type nsIFileMetadataCallbackFunction = (aObject: (nsIAsyncFileMetadata | null)) => void;

  export interface nsIFileMetadataCallback extends nsISupports {

    /**
     * This is a companion interface for
     * nsIAsyncFileMetadata::asyncFileMetadataWait.
     */
    /**
     * Called to indicate that the nsIFileMetadata object is ready.
     */
    readonly onFileMetadataReady: (aObject: (nsIAsyncFileMetadata | null)) => void;
  }

  export interface nsIAboutModuleRef {
    readonly name: "nsIAboutModule";
    readonly number: "{c0c19db9-1b5a-4ac5-b656-ed6f8149fa48}";

    /**
     * A flag that indicates whether a URI should be run with content
     * privileges. If it is, the about: protocol handler will enforce that
     * the principal of channels created for it be based on their
     * originalURI or URI (depending on the channel flags), by setting
     * their "owner" to null.
     * If content needs to be able to link to this URI, specify
     * URI_CONTENT_LINKABLE as well.
     */
    URI_SAFE_FOR_UNTRUSTED_CONTENT: 1;

    /**
     * A flag that indicates whether script should be enabled for the
     * given about: URI even if it's disabled in general.
     */
    ALLOW_SCRIPT: 2;

    /**
     * A flag that indicates whether this about: URI doesn't want to be listed
     * in about:about, especially if it's not useful without a query string.
     */
    HIDE_FROM_ABOUTABOUT: 4;

    /**
     * A flag that indicates whether this about: URI wants Indexed DB enabled.
     */
    ENABLE_INDEXED_DB: 8;

    /**
     * A flag that indicates that this URI can be loaded in a child process
     */
    URI_CAN_LOAD_IN_CHILD: 16;

    /**
     * A flag that indicates that this URI must be loaded in a child process
     */
    URI_MUST_LOAD_IN_CHILD: 32;

    /**
     * Obsolete. This flag no longer has any effect and will be removed in future.
     */
    MAKE_UNLINKABLE: 64;

    /**
     * A flag that indicates that this URI should be linkable from content.
     * Ignored unless URI_SAFE_FOR_UNTRUSTED_CONTENT is also specified.
     *
     * When adding a new about module with this flag make sure to also update
     * IsSafeToLinkForUntrustedContent() in nsAboutProtocolHandler.cpp
     */
    MAKE_LINKABLE: 128;

    /**
     * A flag that indicates that this URI can be loaded in the privileged
     * activity stream content process if said process is enabled. Ignored unless
     * URI_MUST_LOAD_IN_CHILD is also specified.
     */
    URI_CAN_LOAD_IN_PRIVILEGEDABOUT_PROCESS: 256;

    /**
     * A flag that indicates that this URI must be loaded in an extension process (if available).
     */
    URI_MUST_LOAD_IN_EXTENSION_PROCESS: 512;
  }

  export interface nsIAboutModule extends nsISupports {

    /**
     * Constructs a new channel for the about protocol module.
     *
     * @param aURI the uri of the new channel
     * @param aLoadInfo the loadinfo of the new channel
     */
    readonly newChannel: (aURI: (nsIURI | null), aLoadInfo: (nsILoadInfo | null)) => (nsIChannel | null);

    /**
     * A method to get the flags that apply to a given about: URI.  The URI
     * passed in is guaranteed to be one of the URIs that this module
     * registered to deal with.
     */
    readonly getURIFlags: (aURI: (nsIURI | null)) => number;
  }

  export interface nsIBrowserUsageRef {
    readonly name: "nsIBrowserUsage";
    readonly number: "{2703b5ed-a41f-42be-8764-b795eb67ed25}";
  }

  export interface nsIBrowserUsage extends nsISupports {

    /**
     * Returns the number of unique domains (eTLD+1) visited in the past
     * 24 hours by the user.
     */
    readonly getUniqueDomainsVisitedInPast24Hours: () => number;
  }

  export interface nsIPrincipalRef {
    readonly name: "nsIPrincipal";
    readonly number: "{f75f502d-79fd-48be-a079-e5a7b8f80c8b}";
  }

  export interface nsIPrincipal extends nsISerializable {

    /**
     * Returns whether the other principal is equivalent to this principal.
     * Principals are considered equal if they are the same principal, or
     * they have the same origin.
     */
    readonly equals: (other: (nsIPrincipal | null)) => boolean;

    /**
     * Like equals, but takes document.domain changes into account.
     */
    readonly equalsConsideringDomain: (other: (nsIPrincipal | null)) => boolean;

    /**
     * The principal URI to which this principal pertains.  This is
     * generally the document URI.
     */
    readonly URI: (nsIURI | null);

    /**
     * Returns whether the other principal is equal to or weaker than this
     * principal. Principals are equal if they are the same object or they
     * have the same origin.
     *
     * Thus a principal always subsumes itself.
     *
     * The system principal subsumes itself and all other principals.
     *
     * A null principal (corresponding to an unknown, hence assumed minimally
     * privileged, security context) is not equal to any other principal
     * (including other null principals), and therefore does not subsume
     * anything but itself.
     */
    readonly subsumes: (other: (nsIPrincipal | null)) => boolean;

    /**
     * Same as the previous method, subsumes(), but takes document.domain into
     * account.
     */
    readonly subsumesConsideringDomain: (other: (nsIPrincipal | null)) => boolean;

    /**
     * Same as the subsumesConsideringDomain(), but ignores the first party
     * domain in its originAttributes.
     */
    readonly subsumesConsideringDomainIgnoringFPD: (other: (nsIPrincipal | null)) => boolean;

    /**
     * Checks whether this principal is allowed to load the network resource
     * located at the given URI under the same-origin policy. This means that
     * content principals are only allowed to load resources from the same
     * domain, the system principal is allowed to load anything, and null
     * principals can only load URIs where they are the principal. This is
     * changed by the optional flag allowIfInheritsPrincipal (which defaults to
     * false) which allows URIs that inherit their loader's principal.
     *
     * If the load is allowed this function does nothing. If the load is not
     * allowed the function throws NS_ERROR_DOM_BAD_URI.
     *
     * NOTE: Other policies might override this, such as the Access-Control
     *       specification.
     * NOTE: The 'domain' attribute has no effect on the behaviour of this
     *       function.
     *
     *
     * @param uri    The URI about to be loaded.
     * @param allowIfInheritsPrincipal   If true, the load is allowed if the
     *                                   loadee inherits the principal of the
     *                                   loader.
     * @throws NS_ERROR_DOM_BAD_URI if the load is not allowed.
     */
    readonly checkMayLoad: (uri: (nsIURI | null), allowIfInheritsPrincipal: boolean) => void;

    /**
     * Like checkMayLoad, but if returning an error will also report that error
     * to the console, using the provided window id.  The window id may be 0 to
     * report to just the browser console, not web consoles.
     */
    readonly checkMayLoadWithReporting: (uri: (nsIURI | null), allowIfInheritsPrincipal: boolean, innerWindowID: number) => void;

    /**
     * Checks if the provided URI is concidered third-party to the
     * URI of the principal.
     * Returns true if the URI is third-party.
     *
     * @param uri - The URI to check
     */
    readonly isThirdPartyURI: (uri: (nsIURI | null)) => boolean;

    /**
     * Checks if the provided principal is concidered third-party to the
     * URI of the Principal.
     * Returns true if the principal is third-party.
     *
     * @param principal - The principal to check
     */
    readonly isThirdPartyPrincipal: (principal: (nsIPrincipal | null)) => boolean;

    /**
     * A dictionary of the non-default origin attributes associated with this
     * nsIPrincipal.
     *
     * Attributes are tokens that are taken into account when determining whether
     * two principals are same-origin - if any attributes differ, the principals
     * are cross-origin, even if the scheme, host, and port are the same.
     * Attributes should also be considered for all security and bucketing decisions,
     * even those which make non-standard comparisons (like cookies, which ignore
     * scheme, or quotas, which ignore subdomains).
     *
     * If you're looking for an easy-to-use canonical stringification of the origin
     * attributes, see |originSuffix| below.
     */
    readonly originAttributes: IDLjsval;

    /**
     * A canonical representation of the origin for this principal. This
     * consists of a base string (which, for content principals, is of the
     * format scheme://host:port), concatenated with |originAttributes| (see
     * below).
     *
     * We maintain the invariant that principalA.equals(principalB) if and only
     * if principalA.origin == principalB.origin.
     */
    readonly origin: IDLACString;

    /**
     * Checks if the Principal's URI Scheme matches with the parameter
     *
     * @param scheme    The scheme to be checked
     */
    readonly schemeIs: (scheme: string) => boolean;

    readonly IsURIInPrefList: (pref: string) => boolean;

    readonly IsSameOrigin: (otherURI: (nsIURI | null), aIsPrivateWin: boolean) => boolean;

    /**
     * Implementation of
     * https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy
     *
     * The value returned by this method feeds into the the Secure Context
     * algorithm that determins the value of Window.isSecureContext and
     * WorkerGlobalScope.isSecureContext.
     *
     * This method returns false instead of throwing upon errors.
     */
    readonly isOriginPotentiallyTrustworthy: boolean;

    /**
     * Returns the Flags of the Principals
     * associated AboutModule, in case there is one.
     */
    readonly GetAboutModuleFlags: () => number;

    /**
     * The base part of |origin| without the concatenation with |originSuffix|.
     * This doesn't have the important invariants described above with |origin|,
     * and as such should only be used for legacy situations.
     */
    readonly originNoSuffix: IDLACString;

    /**
     * A string of the form !key1=value1&key2=value2, where each pair represents
     * an attribute with a non-default value. If all attributes have default
     * values, this is the empty string.
     *
     * The value of .originSuffix is automatically serialized into .origin, so any
     * consumers using that are automatically origin-attribute-aware. Consumers with
     * special requirements must inspect and compare .originSuffix manually.
     */
    readonly originSuffix: IDLAUTF8String;

    /**
     * A canonical representation of the site-origin for this principal.
     * This string has the same format as |origin| (see above). Two principals
     * with differing |siteOrigin| values will never compare equal, even when
     * considering domain mutations.
     *
     * For most principals, |siteOrigin| matches |origin| precisely. Only
     * principals which allow mutating |domain|, such as ContentPrincipal,
     * override the default implementation in BasePrincipal.
     *
     * TODO(nika): Use this in DocGroup.
     */
    readonly siteOrigin: IDLACString;

    /**
     * The base domain of the principal URI to which this principal pertains
     * (generally the document URI), handling null principals and
     * non-hierarchical schemes correctly.
     */
    readonly baseDomain: IDLACString;

    /**
     * Gets the ID of the add-on this principal belongs to.
     */
    readonly addonId: IDLAString;

    readonly addonPolicy: (nsISupports | null);

    /**
     * Gets the id of the user context this principal is inside.  If this
     * principal is inside the default userContext, this returns
     * nsIScriptSecurityManager::DEFAULT_USER_CONTEXT_ID.
     */
    readonly userContextId: number;

    /**
     * Gets the id of the private browsing state of the context containing
     * this principal. If the principal has a private browsing value of 0, it
     * is not in private browsing.
     */
    readonly privateBrowsingId: number;

    /**
     * Returns true iff the principal is inside an isolated mozbrowser element.
     * <xul:browser> is not considered to be a mozbrowser element.
     * <iframe mozbrowser noisolation> does not count as isolated since
     * isolation is disabled.  Isolation can only be disabled if the
     * containing document is chrome.
     */
    readonly isInIsolatedMozBrowserElement: boolean;

    /**
     * Returns true iff this is a null principal (corresponding to an
     * unknown, hence assumed minimally privileged, security context).
     */
    readonly isNullPrincipal: boolean;

    /**
     * Returns true iff this principal corresponds to a principal origin.
     */
    readonly isContentPrincipal: boolean;

    /**
     * Returns true iff this is an expanded principal.
     */
    readonly isExpandedPrincipal: boolean;

    /**
     * Returns true iff this is the system principal.  C++ callers should use
     * IsSystemPrincipal() instead of this scriptable accessor.
     */
    readonly isSystemPrincipal: boolean;

    /**
     * Faster and nicer version callable from C++.  Callers must include
     * BasePrincipal.h, where it's implemented.
     */
    /**
     * Returns true iff the principal is either an addon principal or
     * an expanded principal, which contains at least one addon principal.
     */
    readonly isAddonOrExpandedAddonPrincipal: boolean;

    readonly isOnion: boolean;
  }

  export interface nsICrashReporterRef {
    readonly name: "nsICrashReporter";
    readonly number: "{4b74c39a-cf69-4a8a-8e63-169d81ad1ecf}";
  }

  /**
   * Provides access to crash reporting functionality.
   *
   * @status UNSTABLE - This interface is not frozen and will probably change in
   *                    future releases.
   */
  export interface nsICrashReporter extends nsISupports {

    /**
     * Get the enabled status of the crash reporter.
     */
    readonly enabled: boolean;

    /**
     * Get or set the URL to which crash reports will be submitted.
     * Only https and http URLs are allowed, as the submission is handled
     * by OS-native networking libraries.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting is not initialized
     * @throw NS_ERROR_INVALID_ARG on set if a non-http(s) URL is assigned
     * @throw NS_ERROR_FAILURE on get if no URL is set
     */
    serverURL: (nsIURL | null);

    /**
     * Get or set the path on the local system to which minidumps will be
     * written when a crash happens.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting is not initialized
     */
    minidumpPath: (nsIFile | null);

    /**
     * Get the minidump file corresponding to the specified ID.
     *
     * @param id
     *        ID of the crash. Likely a UUID.
     *
     * @return The minidump file associated with the ID.
     *
     * @throw NS_ERROR_FILE_NOT_FOUND if the minidump could not be found
     */
    readonly getMinidumpForID: (id: IDLAString) => (nsIFile | null);

    /**
     * Get the extra file corresponding to the specified ID.
     *
     * @param id
     *        ID of the crash. Likely a UUID.
     *
     * @return The extra file associated with the ID.
     *
     * @throw NS_ERROR_FILE_NOT_FOUND if the extra file could not be found
     */
    readonly getExtraFileForID: (id: IDLAString) => (nsIFile | null);

    /**
     * Add some extra data to be submitted with a crash report.
     *
     * @param key
     *        Name of a known crash annotation constant.
     * @param data
     *        Data to be added.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting not initialized
     * @throw NS_ERROR_INVALID_ARG if key contains an invalid value or data
     *                             contains invalid characters.  Invalid
     *                             character for data is '\0'.
     */
    readonly annotateCrashReport: (key: IDLAUTF8String, data: IDLAUTF8String) => void;

    /**
     * Remove a crash report annotation.
     *
     * @param key
     *        Name of a known crash annotation constant.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting not initialized
     * @throw NS_ERROR_INVALID_ARG if key contains an invalid value.
     */
    readonly removeCrashReportAnnotation: (key: IDLAUTF8String) => void;

    /**
       * Checks if an annotation is whitelisted for inclusion in the crash ping.
       *
       * @param key
       *        Name of a known crash annotation constant.
       *
       * @return True if the specified value is a valid annotation and can be
                 included in the crash ping, false otherwise.
       * @throw NS_ERROR_INVALID_ARG if key contains an invalid value.
       */
    readonly isAnnotationWhitelistedForPing: (value: IDLACString) => boolean;

    /**
     * Append some data to the "Notes" field, to be submitted with a crash report.
     * Unlike annotateCrashReport, this method will append to existing data.
     *
     * @param data
     *        Data to be added.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting not initialized
     * @throw NS_ERROR_INVALID_ARG if data contains invalid characters.
     *                             The only invalid character is '\0'.
     */
    readonly appendAppNotesToCrashReport: (data: IDLACString) => void;

    /**
     * Register a given memory range to be included in the crash report.
     *
     * @param ptr
     *        The starting address for the bytes.
     * @param size
     *        The number of bytes to include.
     *
     * @throw NS_ERROR_NOT_INITIALIZED if crash reporting not initialized
     * @throw NS_ERROR_NOT_IMPLEMENTED if unavailable on the current OS
     */
    readonly registerAppMemory: (ptr: number, size: number) => void;

    /**
     * User preference for submitting crash reports.
     */
    submitReports: boolean;

    /**
     * Cause the crash reporter to re-evaluate where crash events should go.
     *
     * This should be called during application startup and whenever profiles
     * change.
     */
    readonly UpdateCrashEventsDir: () => void;

    /**
     * Save an anonymized memory report file for inclusion in a future crash
     * report in this session.
     *
     * @throws NS_ERROR_NOT_INITIALIZED if crash reporting is disabled.
     */
    readonly saveMemoryReport: () => void;

    /**
     * Set the telemetry session ID which is recorded in crash metadata. This is
     * saved in the crash manager and telemetry but is not submitted as a
     * crash-stats annotation.
     */
    readonly setTelemetrySessionId: (id: IDLAUTF8String) => void;
  }

  export interface nsIChromeRegistryRef {
    readonly name: "nsIChromeRegistry";
    readonly number: "{249fb5ad-ae29-4e2c-a728-ba5cf464d188}";

    NONE: 0;

    PARTIAL: 1;

    FULL: 2;
  }

  export interface nsIChromeRegistry extends nsISupports {

    /**
     * Resolve a chrome URL to an loadable URI using the information in the
     * registry. Does not modify aChromeURL.
     *
     * Chrome URLs are allowed to be specified in "shorthand", leaving the
     * "file" portion off. In that case, the URL is expanded to:
     *
     *   chrome://package/provider/package.ext
     *
     * where "ext" is:
     *
     *   "xul" for a "content" package,
     *   "css" for a "skin" package, and
     *   "dtd" for a "locale" package.
     *
     * @param aChromeURL the URL that is to be converted.
     */
    readonly convertChromeURL: (aChromeURL: (nsIURI | null)) => (nsIURI | null);

    /**
     * refresh the chrome list at runtime, looking for new packages/etc
     */
    readonly checkForNewChrome: () => void;
  }

  export interface nsILoadContextInfoRef {
    readonly name: "nsILoadContextInfo";
    readonly number: "{555e2f8a-a1f6-41dd-88ca-ed4ed6b98a22}";
  }

  /**
   * Helper interface to carry informatin about the load context
   * encapsulating origin attributes and IsAnonymous, IsPrivite properties.
   * It shall be used where nsILoadContext cannot be used or is not
   * available.
   */
  export interface nsILoadContextInfo extends nsISupports {

    /**
     * Whether the context is in a Private Browsing mode
     */
    readonly isPrivate: boolean;

    /**
     * Whether the load is initiated as anonymous
     */
    readonly isAnonymous: boolean;

    /**
     * OriginAttributes hiding all the security context attributes
     */
    readonly originAttributes: IDLjsval;
  }

  export interface nsIX509CertRef {
    readonly name: "nsIX509Cert";
    readonly number: "{bdc3979a-5422-4cd5-8589-696b6e96ea83}";

    /**
     *  Constants to classify the type of a certificate.
     */
    UNKNOWN_CERT: 0;

    CA_CERT: 1;

    USER_CERT: 2;

    EMAIL_CERT: 4;

    SERVER_CERT: 8;

    ANY_CERT: 65535;
  }

  /**
   * This represents a X.509 certificate.
   *
   * NOTE: Service workers persist x.509 certs in object form on disk.  If you
   *       change this uuid you probably need a hack in nsBinaryInputStream to
   *       read the old uuid.  If you change the format of the object
   *       serialization then more complex changes will be needed.
   */
  export interface nsIX509Cert extends nsISupports {

    /**
     *  The primary email address of the certificate, if present.
     */
    readonly emailAddress: IDLAString;

    /**
     * Did this certificate ship with the platform as a built-in root?
     */
    readonly isBuiltInRoot: boolean;

    /**
     *  Obtain a list of all email addresses
     *  contained in the certificate.
     *
     *  @return An array of email addresses.
     */
    readonly getEmailAddresses: () => IDLAString[];

    /**
     *  Check whether a given address is contained in the certificate.
     *  The comparison will convert the email address to lowercase.
     *  The behaviour for non ASCII characters is undefined.
     *
     *  @param aEmailAddress The address to search for.
     *
     *  @return True if the address is contained in the certificate.
     */
    readonly containsEmailAddress: (aEmailAddress: IDLAString) => boolean;

    /**
     *  The subject owning the certificate.
     */
    readonly subjectName: IDLAString;

    /**
     *  The subject alternative names of the certificate.
     *  It's a comma separated string of subject alt names.
     */
    readonly subjectAltNames: IDLAString;

    /**
     *  The subject's common name.
     */
    readonly commonName: IDLAString;

    /**
     *  The subject's organization.
     */
    readonly organization: IDLAString;

    /**
     *  The subject's organizational unit.
     */
    readonly organizationalUnit: IDLAString;

    /**
     *  The fingerprint of the certificate's DER encoding,
     *  calculated using the SHA-256 algorithm.
     */
    readonly sha256Fingerprint: IDLAString;

    /**
     *  The fingerprint of the certificate's DER encoding,
     *  calculated using the SHA1 algorithm.
     */
    readonly sha1Fingerprint: IDLAString;

    /**
     *  A human readable name identifying the hardware or
     *  software token the certificate is stored on.
     */
    readonly tokenName: IDLAString;

    /**
     *  The subject identifying the issuer certificate.
     */
    readonly issuerName: IDLAString;

    /**
     *  The serial number the issuer assigned to this certificate.
     */
    readonly serialNumber: IDLAString;

    /**
     *  The issuer subject's common name.
     */
    readonly issuerCommonName: IDLAString;

    /**
     *  The issuer subject's organization.
     */
    readonly issuerOrganization: IDLAString;

    /**
     *  The issuer subject's organizational unit.
     */
    readonly issuerOrganizationUnit: IDLAString;

    /**
     *  This certificate's validity period.
     */
    readonly validity: (nsIX509CertValidity | null);

    /**
     *  A unique identifier of this certificate within the local storage.
     */
    readonly dbKey: IDLACString;

    /**
     *  A human readable identifier to label this certificate.
     */
    readonly displayName: IDLAString;

    /**
     * Type of this certificate
     */
    readonly certType: number;

    /**
     *  True if the certificate is self-signed. CA issued
     *  certificates are always self-signed.
     */
    readonly isSelfSigned: boolean;

    /**
     * A comma separated list of localized strings representing the contents of
     * the certificate's key usage extension, if present. The empty string if the
     * certificate doesn't have the key usage extension, or has an empty extension.
     */
    readonly keyUsages: IDLAString;

    /**
     *  This is the attribute which describes the ASN1 layout
     *  of the certificate.  This can be used when doing a
     *  "pretty print" of the certificate's ASN1 structure.
     */
    readonly ASN1Structure: (nsIASN1Object | null);

    /**
     *  Obtain a raw binary encoding of this certificate
     *  in DER format.
     *
     *  @return The bytes representing the DER encoded certificate.
     */
    readonly getRawDER: () => number[];

    /**
     *  Obtain a base 64 string representation of this certificate
     *  in DER format.
     *
     *  @return The DER encoded certificate as a string.
     */
    readonly getBase64DERString: () => IDLACString;

    /**
     *  Test whether two certificate instances represent the
     *  same certificate.
     *
     *  @return Whether the certificates are equal
     */
    readonly equals: (other: (nsIX509Cert | null)) => boolean;

    /**
     * The base64 encoding of the DER encoded public key info using the specified
     * digest.
     */
    readonly sha256SubjectPublicKeyInfoDigest: IDLACString;

    /**
     * Either delete the certificate from all cert databases,
     * or mark it as untrusted.
     */
    readonly markForPermDeletion: () => void;
  }

  export interface nsIURISetSpecRef {
    readonly name: "nsIURISetSpec";
    readonly number: "{1fc53257-898b-4c5e-b69c-05bc84b4cd8f}";
  }

  export interface nsIURISetSpec extends nsISupports {

    /**
     * This setter is different from all other setters because it may be used to
     * initialize the object. We define it separately allowing mutator implementors
     * to define it separately, while the rest of the setters may be simply
     * forwarded to the mutable URI.
     */
    readonly setSpec: (aSpec: IDLAUTF8String) => (nsIURIMutator | null);
  }

  export interface nsISlowScriptDebugRef {
    readonly name: "nsISlowScriptDebug";
    readonly number: "{f75d4164-3aa7-4395-ba44-a5f95b2e8427}";
  }

  export interface nsISlowScriptDebug extends nsISupports {

    activationHandler: (nsISlowScriptDebugCallback | null);

    remoteActivationHandler: (nsISlowScriptDebugRemoteCallback | null);
  }

  export interface nsILocalCertCallbackRef {
    readonly name: "nsILocalCertCallback";
    readonly number: "{518124e9-55e6-4e23-97c0-4995b3a1bec6}";
  }

  export interface nsILocalCertCallback extends nsISupports {

    /**
     * Called with the result of the removeCert operation above.
     *
     * @param result Result code from the operation
     */
    readonly handleResult: (result: number) => void;
  }

  export interface nsIBinaryOutputStreamRef {
    readonly name: "nsIBinaryOutputStream";
    readonly number: "{204ee610-8765-11d3-90cf-0040056a906e}";
  }

  /**
   * This interface allows writing of primitive data types (integers,
   * floating-point values, booleans, etc.) to a stream in a binary, untagged,
   * fixed-endianness format.  This might be used, for example, to implement
   * network protocols or to produce architecture-neutral binary disk files,
   * i.e. ones that can be read and written by both big-endian and little-endian
   * platforms.  Output is written in big-endian order (high-order byte first),
   * as this is traditional network order.
   *
   * @See nsIBinaryInputStream
   */
  export interface nsIBinaryOutputStream extends nsIOutputStream {

    readonly setOutputStream: (aOutputStream: (nsIOutputStream | null)) => void;

    /**
     * Write a boolean as an 8-bit char to the stream.
     */
    readonly writeBoolean: (aBoolean: boolean) => void;

    readonly write8: (aByte: number) => void;

    readonly write16: (a16: number) => void;

    readonly write32: (a32: number) => void;

    readonly write64: (a64: number) => void;

    readonly writeFloat: (aFloat: number) => void;

    readonly writeDouble: (aDouble: number) => void;

    /**
     * Write an 8-bit pascal style string to the stream.
     * 32-bit length field, followed by length 8-bit chars.
     */
    readonly writeStringZ: (aString: string) => void;

    /**
     * Write a 16-bit pascal style string to the stream.
     * 32-bit length field, followed by length PRUnichars.
     */
    readonly writeWStringZ: (aString: string) => void;

    /**
     * Write an 8-bit pascal style string (UTF8-encoded) to the stream.
     * 32-bit length field, followed by length 8-bit chars.
     */
    readonly writeUtf8Z: (aString: string) => void;

    /**
     * Write an opaque byte array to the stream.
     */
    readonly writeBytes: (aString: string, aLength?: number) => void;

    /**
     * Write an opaque byte array to the stream.
     */
    readonly writeByteArray: (aBytes: number[]) => void;
  }

  export interface nsIEventTargetRef {
    readonly name: "nsIEventTarget";
    readonly number: "{a03b8b63-af8b-4164-b0e5-c41e8b2b7cfa}";

    /**
     * This flag specifies the default mode of event dispatch, whereby the event
     * is simply queued for later processing.  When this flag is specified,
     * dispatch returns immediately after the event is queued.
     */
    DISPATCH_NORMAL: 0;

    /**
     * This flag specifies the synchronous mode of event dispatch, in which the
     * dispatch method does not return until the event has been processed.
     *
     * NOTE: passing this flag to dispatch may have the side-effect of causing
     * other events on the current thread to be processed while waiting for the
     * given event to be processed.
     */
    DISPATCH_SYNC: 1;

    /**
     * This flag specifies that the dispatch is occurring from a running event
     * that was dispatched to the same event target, and that event is about to
     * finish.
     *
     * A thread pool can use this as an optimization hint to not spin up
     * another thread, since the current thread is about to become idle.
     *
     * These events are always async.
     */
    DISPATCH_AT_END: 2;

    /**
     * This flag specifies that the dispatched event may block the thread on
     * which it executes, usually by doing some sort of I/O.  This information
     * may be used by the event target to execute the job on a thread
     * specifically dedicated to doing I/O, leaving other threads available for
     * CPU-intensive work.
     */
    DISPATCH_EVENT_MAY_BLOCK: 4;
  }

  export interface nsIEventTarget extends nsISupports {

    readonly isOnCurrentThread: () => boolean;

    /**
     * Version of Dispatch to expose to JS, which doesn't require an alreadyAddRefed<>
     * (it will be converted to that internally)
     *
     * @param event
     *   The (raw) event to dispatch.
     * @param flags
     *   The flags modifying event dispatch.  The flags are described in detail
     *   below.
     *
     * @throws NS_ERROR_INVALID_ARG
     *   Indicates that event is null.
     * @throws NS_ERROR_UNEXPECTED
     *   Indicates that the thread is shutting down and has finished processing
     * events, so this event would never run and has not been dispatched.
     */
    readonly dispatch: (event: (nsIRunnable | nsIRunnableFunction | null), flags: number) => void;
  }

  export interface mozIThirdPartyUtilRef {
    readonly name: "mozIThirdPartyUtil";
    readonly number: "{fd82700e-ffb4-4932-b7d6-08f0b5697dda}";
  }

  /**
   * Utility functions for determining whether a given URI, channel, or window
   * hierarchy is third party with respect to a known URI.
   */
  export interface mozIThirdPartyUtil extends nsISupports {

    /**
     * isThirdPartyURI
     *
     * Determine whether two URIs are third party with respect to each other.
     * This is determined by computing the base domain for both URIs. If they can
     * be determined, and the base domains match, the request is defined as first
     * party. If it cannot be determined because one or both URIs do not have a
     * base domain (for instance, in the case of IP addresses, host aliases such
     * as 'localhost', or a file:// URI), an exact string comparison on host is
     * performed.
     *
     * For example, the URI "http://mail.google.com/" is not third party with
     * respect to "http://images.google.com/", but "http://mail.yahoo.com/" and
     * "http://192.168.1.1/" are.
     *
     * @return true if aFirstURI is third party with respect to aSecondURI.
     *
     * @throws if either URI is null, has a malformed host, or has an empty host
     *         and is not a file:// URI.
     */
    readonly isThirdPartyURI: (aFirstURI: (nsIURI | null), aSecondURI: (nsIURI | null)) => boolean;

    /**
     * isThirdPartyWindow
     *
     * Determine whether the given window hierarchy is third party. This is done
     * as follows:
     *
     * 1) Obtain the URI of the principal associated with 'aWindow'. Call this the
     *    'bottom URI'.
     * 2) If 'aURI' is provided, determine if it is third party with respect to
     *    the bottom URI. If so, return.
     * 3) Find the same-type parent window, if there is one, and its URI.
     *    Determine whether it is third party with respect to the bottom URI. If
     *    so, return.
     *
     * Therefore, each level in the window hierarchy is tested. (This means that
     * nested iframes with different base domains, even though the bottommost and
     * topmost URIs might be equal, will be considered third party.)
     *
     * @param aWindow
     *        The bottommost window in the hierarchy.
     * @param aURI
     *        A URI to test against. If null, the URI of the principal
     *        associated with 'aWindow' will be used.
     *
     * For example, if 'aURI' is "http://mail.google.com/", 'aWindow' has a URI
     * of "http://google.com/", and its parent is the topmost content window with
     * a URI of "http://mozilla.com", the result will be true.
     *
     * @return true if 'aURI' is third party with respect to any of the URIs
     *         associated with aWindow and its same-type parents.
     *
     * @throws if aWindow is null; the same-type parent of any window in the
     *         hierarchy cannot be determined; or the URI associated with any
     *         window in the hierarchy is null, has a malformed host, or has an
     *         empty host and is not a file:// URI.
     *
     * @see isThirdPartyURI
     */
    readonly isThirdPartyWindow: (aWindow: (mozIDOMWindowProxy | null), aURI?: (nsIURI | null)) => boolean;

    /**
     * isThirdPartyChannel
     *
     * Determine whether the given channel and its content window hierarchy is
     * third party. This is done as follows:
     *
     * 1) If 'aChannel' is an nsIHttpChannel and has the
     *    'forceAllowThirdPartyCookie' property set, then:
     *    a) If 'aURI' is null, return false.
     *    b) Otherwise, find the URI of the channel, determine whether it is
     *       foreign with respect to 'aURI', and return.
     * 2) Find the URI of the channel and determine whether it is third party with
     *    respect to the URI of the channel. If so, return.
     * 3) Obtain the bottommost nsIDOMWindow, and its same-type parent if it
     *    exists, from the channel's notification callbacks. Then:
     *    a) If the parent is the same as the bottommost window, and the channel
     *       has the LOAD_DOCUMENT_URI flag set, return false. This represents the
     *       case where a toplevel load is occurring and the window's URI has not
     *       yet been updated. (We have already checked that 'aURI' is not foreign
     *       with respect to the channel URI.)
     *    b) Otherwise, return the result of isThirdPartyWindow with arguments
     *       of the channel's bottommost window and the channel URI, respectively.
     *
     * Therefore, both the channel's URI and each level in the window hierarchy
     * associated with the channel is tested.
     *
     * @param aChannel
     *        The channel associated with the load.
     * @param aURI
     *        A URI to test against. If null, the URI of the channel will be used.
     *
     * For example, if 'aURI' is "http://mail.google.com/", 'aChannel' has a URI
     * of "http://google.com/", and its parent is the topmost content window with
     * a URI of "http://mozilla.com", the result will be true.
     *
     * @return true if aURI is third party with respect to the channel URI or any
     *         of the URIs associated with the same-type window hierarchy of the
     *         channel.
     *
     * @throws if 'aChannel' is null; the channel has no notification callbacks or
     *         an associated window; or isThirdPartyWindow throws.
     *
     * @see isThirdPartyWindow
     */
    readonly isThirdPartyChannel: (aChannel: (nsIChannel | null), aURI?: (nsIURI | null)) => boolean;

    /**
     * getBaseDomain
     *
     * Get the base domain for aHostURI; e.g. for "www.bbc.co.uk", this would be
     * "bbc.co.uk". Only properly-formed URI's are tolerated, though a trailing
     * dot may be present. If aHostURI is an IP address, an alias such as
     * 'localhost', an eTLD such as 'co.uk', or the empty string, aBaseDomain will
     * be the exact host. The result of this function should only be used in exact
     * string comparisons, since substring comparisons will not be valid for the
     * special cases elided above.
     *
     * @param aHostURI
     *        The URI to analyze.
     *
     * @return the base domain.
     */
    readonly getBaseDomain: (aHostURI: (nsIURI | null)) => IDLAUTF8String;

    /**
     * NOTE: Long term, this method won't be needed once bug 922464 is fixed which
     * will make it possible to parse all URI's off the main thread.
     *
     * getBaseDomainFromSchemeHost
     *
     * Get the base domain for aScheme and aHost. Otherwise identical to
     * getBaseDomain().
     *
     * @param aScheme
     *        The scheme to analyze.
     *
     * @param aAsciiHost
     *        The host to analyze.
     *
     * @return the base domain.
     */
    readonly getBaseDomainFromSchemeHost: (aScheme: IDLAUTF8String, aAsciiHost: IDLAUTF8String) => IDLAUTF8String;

    /**
     * getURIFromWindow
     *
     * Returns the URI associated with the script object principal for the
     * window.
     */
    readonly getURIFromWindow: (aWindow: (mozIDOMWindowProxy | null)) => (nsIURI | null);

    /**
     * getPrincipalFromWindow
     *
     * Returns the script object principal for the window.
     */
    readonly getPrincipalFromWindow: (aWindow: (mozIDOMWindowProxy | null)) => (nsIPrincipal | null);
  }

  export interface nsIPrivateBrowsingChannelRef {
    readonly name: "nsIPrivateBrowsingChannel";
    readonly number: "{df702bb0-55b8-11e2-bcfd-0800200c9a66}";
  }

  /**
   * This interface is implemented by channels which support overriding the
   * privacy state of the channel.
   *
   * This interface must be used only from the XPCOM main thread.
   */
  export interface nsIPrivateBrowsingChannel extends nsISupports {

    /**
     * Determine whether the channel is tied to a private browsing window.
     *
     * This value can be set only before the channel is opened.  Setting it
     * after that does not have any effect.  This value overrides the privacy
     * state of the channel, which means that if you call this method, then
     * the loadGroup and load context will no longer be consulted when we
     * need to know the private mode status for a channel.
     *
     * Note that this value is only meant to be used when the channel's privacy
     * status cannot be obtained from the loadGroup or load context (for
     * example, when the channel is not associated with any loadGroup or load
     * context.)  Setting this value directly should be avoided if possible.
     *
     * Implementations must enforce the ordering semantics of this function by
     * raising errors if setPrivate is called on a channel which has a loadGroup
     * and/or callbacks that implement nsILoadContext, or if the loadGroup
     * or notificationCallbacks are set after setPrivate has been called.
     *
     * @param aPrivate whether the channel should be opened in private mode.
     */
    readonly setPrivate: (aPrivate: boolean) => void;

    /**
     * States whether the channel is in private browsing mode. This may either
     * happen because the channel is opened from a private mode context or
     * when the mode is explicitly set with ::setPrivate().
     *
     * This attribute is equivalent to NS_UsePrivateBrowsing(), but scriptable.
     */
    readonly isChannelPrivate: boolean;
  }

  export interface nsIWritablePropertyBag2Ref {
    readonly name: "nsIWritablePropertyBag2";
    readonly number: "{9cfd1587-360e-4957-a58f-4c2b1c5e7ed9}";
  }

  export interface nsIWritablePropertyBag2 extends nsIPropertyBag2 {

    readonly setPropertyAsInt32: (prop: IDLAString, value: number) => void;

    readonly setPropertyAsUint32: (prop: IDLAString, value: number) => void;

    readonly setPropertyAsInt64: (prop: IDLAString, value: number) => void;

    readonly setPropertyAsUint64: (prop: IDLAString, value: number) => void;

    readonly setPropertyAsDouble: (prop: IDLAString, value: number) => void;

    readonly setPropertyAsAString: (prop: IDLAString, value: IDLAString) => void;

    readonly setPropertyAsACString: (prop: IDLAString, value: IDLACString) => void;

    readonly setPropertyAsAUTF8String: (prop: IDLAString, value: IDLAUTF8String) => void;

    readonly setPropertyAsBool: (prop: IDLAString, value: boolean) => void;

    readonly setPropertyAsInterface: (prop: IDLAString, value: (nsISupports | null)) => void;
  }

  export interface nsIBufferedInputStreamRef {
    readonly name: "nsIBufferedInputStream";
    readonly number: "{616f5b48-da09-11d3-8cda-0060b0fc14a3}";
  }

  /**
   * An input stream that reads ahead and keeps a buffer coming from another input
   * stream so that fewer accesses to the underlying stream are necessary.
   */
  export interface nsIBufferedInputStream extends nsIInputStream {

    /**
     * @param fillFromStream - add buffering to this stream
     * @param bufferSize     - specifies the maximum buffer size
     */
    readonly init: (fillFromStream: (nsIInputStream | null), bufferSize: number) => void;

    /**
     * Get the wrapped data stream
     */
    readonly data: (nsIInputStream | null);
  }

  export interface nsISiteHSTSStateRef {
    readonly name: "nsISiteHSTSState";
    readonly number: "{9ff16e40-1029-496c-95c2-bc819872b216}";
  }

  export interface nsISiteHSTSState extends nsISiteSecurityState {
  }

  export interface mozIGeckoMediaPluginChromeServiceRef {
    readonly name: "mozIGeckoMediaPluginChromeService";
    readonly number: "{32d35d21-181f-4630-8caa-a431e2ebad72}";
  }

  export interface mozIGeckoMediaPluginChromeService extends nsISupports {

    /**
     * Add a directory to scan for gecko media plugins.
     * @note Main-thread API.
     */
    readonly addPluginDirectory: (directory: IDLAString) => void;

    /**
     * Remove a directory for gecko media plugins.
     * @note Main-thread API.
     */
    readonly removePluginDirectory: (directory: IDLAString) => void;

    /**
     * Remove a directory for gecko media plugins and delete it from disk.
     * If |defer| is true, wait until the plugin is unused before removing.
     * @note Main-thread API.
     */
    readonly removeAndDeletePluginDirectory: (directory: IDLAString, defer?: boolean) => void;

    /**
     * Clears storage data associated with the site and the originAttributes
     * pattern in JSON format.
     */
    readonly forgetThisSite: (site: IDLAString, aPattern: IDLAString) => void;

    /**
     * Returns true if the given node id is allowed to store things
     * persistently on disk. Private Browsing and local content are not
     * allowed to store persistent data.
     */
    readonly isPersistentStorageAllowed: (nodeId: IDLACString) => boolean;

    /**
     * Returns the directory to use as the base for storing data about GMPs.
     */
    readonly getStorageDir: () => (nsIFile | null);
  }

  export interface mozIIPCBlobInputStreamRef {
    readonly name: "mozIIPCBlobInputStream";
    readonly number: "{4125585f-b0c2-4964-a83c-4b0d99f26d49}";
  }

  export interface mozIIPCBlobInputStream extends nsISupports {
  }

  export interface nsIApplicationReputationServiceRef {
    readonly name: "nsIApplicationReputationService";
    readonly number: "{c9f03479-fd68-4393-acb2-c88d4f563174}";

    /**
     * Indicates the reason for the application reputation block.
     */
    VERDICT_SAFE: 0;

    VERDICT_DANGEROUS: 1;

    VERDICT_UNCOMMON: 2;

    VERDICT_POTENTIALLY_UNWANTED: 3;

    VERDICT_DANGEROUS_HOST: 4;
  }

  export interface nsIApplicationReputationService extends nsISupports {

    /**
     * Start querying the application reputation service.
     *
     * @param aQuery
     *        The nsIApplicationReputationQuery containing metadata of the
     *        downloaded file.
     *
     * @param aCallback
     *        The callback for receiving the results of the query.
     *
     * @remarks aCallback may not be null.  onComplete is guaranteed to be called
     *          on aCallback. This function may not be called more than once with
     *          the same query object. If any of the attributes of aQuery have
     *          not been set or have been set with empty data (with the exception
     *          of sourceURI), then a valid request can still be constructed and
     *          will solicit a valid response, but won't produce any useful
     *          information.
     */
    readonly queryReputation: (aQuery: (nsIApplicationReputationQuery | null), aCallback: (nsIApplicationReputationCallback | nsIApplicationReputationCallbackFunction | null)) => void;
  }

  export interface nsIPushSubscriptionRef {
    readonly name: "nsIPushSubscription";
    readonly number: "{1de32d5c-ea88-4c9e-9626-b032bd87f415}";
  }

  /**
   * A push subscription, passed as an argument to a subscription callback.
   * Similar to the `PushSubscription` WebIDL interface.
   */
  export interface nsIPushSubscription extends nsISupports {

    readonly endpoint: IDLAString;

    readonly pushCount: number;

    readonly lastPush: number;

    readonly quota: number;

    readonly isSystemSubscription: boolean;

    readonly p256dhPrivateKey: IDLjsval;

    readonly quotaApplies: () => boolean;

    readonly isExpired: () => boolean;

    readonly getKey: (name: IDLAString) => number[];
  }

  export interface nsISecurityReporterRef {
    readonly name: "nsISecurityReporter";
    readonly number: "{8a997c9a-bea1-11e5-a1fa-be6abc8e7f8b}";
  }

  export interface nsISecurityReporter extends nsISupports {

    readonly reportTLSError: (aSecurityInfo: (nsITransportSecurityInfo | null), aHostname: IDLAUTF8String, aPort: number) => void;
  }

  export interface nsIStreamConverterServiceRef {
    readonly name: "nsIStreamConverterService";
    readonly number: "{f2b1ab53-f0bd-4adb-9365-e59b1701a258}";
  }

  /**
   * The nsIStreamConverterService is a higher level stream converter factory
   * responsible for locating and creating stream converters
   * (nsIStreamConverter).
   *
   * This service retrieves an interface that can convert data from a particular
   * MIME type, to a particular MIME type. It is responsible for any intermediary
   * conversion required in order to get from X to Z, assuming direct conversion
   * is not possible.
   *
   * @author Jud Valeski
   * @see nsIStreamConverter
   */
  export interface nsIStreamConverterService extends nsISupports {

    /**
     * Tests whether conversion between the two specified types is possible.
     * This is cheaper than calling convert()/asyncConvertData(); it is not
     * necessary to call this function before calling one of those, though.
     */
    readonly canConvert: (aFromType: string, aToType: string) => boolean;

    /**
     * Returns the content type that will be returned from a converter
     * created with aFromType and  * /*.
     * Can fail if no converters support this conversion, or if the
     * output type isn't known in advance.
     */
    readonly convertedType: (aFromType: IDLACString) => IDLACString;

    /**
     * <b>SYNCHRONOUS VERSION</b>
     * Converts a stream of one type, to a stream of another type.
     *
     * Use this method when you have a stream you want to convert.
     *
     * @param aFromStream   The stream representing the original/raw data.
     * @param aFromType     The MIME type of aFromStream.
     * @param aToType       The MIME type of the returned stream.
     * @param aContext      Either an opaque context, or a converter specific
     *                      context (implementation specific).
     * @return              The converted stream. NOTE: The returned stream
     *                      may not already be converted. An efficient stream
     *                      converter implementation will convert data on
     *                      demand rather than buffering the converted data
     *                      until it is used.
     */
    readonly convert: (aFromStream: (nsIInputStream | null), aFromType: string, aToType: string, aContext: (nsISupports | null)) => (nsIInputStream | null);

    /**
     * <b>ASYNCHRONOUS VERSION</b>
     * Retrieves a nsIStreamListener that receives the original/raw data via its
     * nsIStreamListener::OnDataAvailable() callback, then converts and pushes
     * the data to aListener.
     *
     * Use this method when you want to proxy (and convert) nsIStreamListener
     * callbacks asynchronously.
     *
     * @param aFromType     The MIME type of the original/raw data.
     * @param aToType       The MIME type of the converted data.
     * @param aListener     The listener that receives the converted data.
     * @param aCtxt         Either an opaque context, or a converter specific
     *                      context (implementation specific).
     * @return              A nsIStreamListener that receives data via its
     *                      OnDataAvailable() method.
     */
    readonly asyncConvertData: (aFromType: string, aToType: string, aListener: (nsIStreamListener | null), aContext: (nsISupports | null)) => (nsIStreamListener | null);
  }

  export interface nsIComponentManagerRef {
    readonly name: "nsIComponentManager";
    readonly number: "{d604ffc3-1ba3-4f6c-b65f-1ed4199364c3}";
  }

  export interface nsIComponentManager extends nsISupports {

    /**
     * addBootstrappedManifestLocation
     *
     * Adds a bootstrapped manifest location on runtime.
     *
     * @param aLocation : A directory where chrome.manifest resides,
     *                    or an XPI with it on the root.
     */
    readonly addBootstrappedManifestLocation: (aLocation: (nsIFile | null)) => void;

    /**
     * removeBootstrappedManifestLocation
     *
     * Removes a bootstrapped manifest location on runtime.
     *
     * @param aLocation : A directory where chrome.manifest resides,
     *                    or an XPI with it on the root.
     */
    readonly removeBootstrappedManifestLocation: (aLocation: (nsIFile | null)) => void;

    /**
     * getManifestLocations
     *
     * Get an array of nsIURIs of all registered and builtin manifest locations.
     */
    readonly getManifestLocations: () => (nsIArray | null);

    /**
     * Returns a list of JSM URLs which are used to create components. This
     * should only be used in automation.
     */
    readonly getComponentJSMs: () => (nsIUTF8StringEnumerator | null);
  }

  export interface nsIFetchTelemetryDataCallbackRef {
    readonly name: "nsIFetchTelemetryDataCallback";
    readonly number: "{3d3b9075-5549-4244-9c08-b64fefa1dd60}";
  }

  type nsIFetchTelemetryDataCallbackFunction = () => void;

  export interface nsIFetchTelemetryDataCallback extends nsISupports {

    readonly complete: () => void;
  }

  export interface nsIStreamTransportServiceRef {
    readonly name: "nsIStreamTransportService";
    readonly number: "{5e0adf7d-9785-45c3-a193-04f25a75da8f}";
  }

  /**
   * This service read/writes a stream on a background thread.
   *
   * Note: instead of using this interface, probably you want to use
   * NS_MakeAsyncNonBlockingInputStream.
   *
   * Use this service to transform any blocking stream (e.g., file stream)
   * into a fully asynchronous stream that can be read/written without
   * blocking the main thread.
   */
  export interface nsIStreamTransportService extends nsISupports {

    /**
     * CreateInputTransport
     *
     * @param aStream
     *        The input stream that will be read on a background thread.
     *        This stream must implement "blocking" stream semantics.
     * @param aCloseWhenDone
     *        Specify this flag to have the input stream closed once its
     *        contents have been completely read.
     *
     * @return nsITransport instance.
     */
    readonly createInputTransport: (aStream: (nsIInputStream | null), aCloseWhenDone: boolean) => (nsITransport | null);
  }

  export interface nsIMIMEInfoRef {
    readonly name: "nsIMIMEInfo";
    readonly number: "{1c21acef-c7a1-40c6-9d40-a20480ee53a1}";
  }

  /**
   * nsIMIMEInfo extends nsIHandlerInfo with a bunch of information specific to
   * MIME content-types. There is a one-to-many relationship between MIME types
   * and file extensions. This means that a MIMEInfo object may have multiple
   * file extensions associated with it.  However, the reverse is not true.
   *
   * MIMEInfo objects are generally retrieved from the MIME Service
   * @see nsIMIMEService
   */
  export interface nsIMIMEInfo extends nsIHandlerInfo {

    /**
     * Gives you an array of file types associated with this type.
     *
     * @return Number of elements in the array.
     * @return Array of extensions.
     */
    readonly getFileExtensions: () => (nsIUTF8StringEnumerator | null);

    /**
     * Set File Extensions. Input is a comma delimited list of extensions.
     */
    readonly setFileExtensions: (aExtensions: IDLAUTF8String) => void;

    /**
     * Returns whether or not the given extension is
     * associated with this MIME info.
     *
     * @return TRUE if the association exists.
     */
    readonly extensionExists: (aExtension: IDLAUTF8String) => boolean;

    /**
     * Append a given extension to the set of extensions
     */
    readonly appendExtension: (aExtension: IDLAUTF8String) => void;

    /**
     * Returns the first extension association in
     * the internal set of extensions.
     *
     * @return The first extension.
     */
    primaryExtension: IDLAUTF8String;

    /**
     * The MIME type of this MIMEInfo.
     *
     * @return String representing the MIME type.
     *
     * @deprecated  use nsIHandlerInfo::type instead.
     */
    readonly MIMEType: IDLACString;

    /**
     * Returns whether or not these two nsIMIMEInfos are logically
     * equivalent.
     *
     * @returns PR_TRUE if the two are considered equal
     */
    readonly equals: (aMIMEInfo: (nsIMIMEInfo | null)) => boolean;

    /**
     * Returns a list of nsILocalHandlerApp objects containing
     * handlers associated with this mimeinfo. Implemented per
     * platform using information in this object to generate the
     * best list. Typically used for an "open with" style user
     * option.
     *
     * @return nsIArray of nsILocalHandlerApp
     */
    readonly possibleLocalHandlers: (nsIArray | null);

    /**
     * Launches the application with the specified file, in a way that
     * depends on the value of preferredAction. preferredAction must be
     * useHelperApp or useSystemDefault.
     *
     * @param aFile The file to launch this application with.
     *
     * @throw NS_ERROR_INVALID_ARG if action is not valid for this function.
     * Other exceptions may be thrown.
     */
    readonly launchWithFile: (aFile: (nsIFile | null)) => void;
  }

  export interface nsICacheInfoChannelRef {
    readonly name: "nsICacheInfoChannel";
    readonly number: "{72c34415-c6eb-48af-851f-772fa9ee5972}";
  }

  export interface nsICacheInfoChannel extends nsISupports {

    /**
     * Get the number of times the cache entry has been opened. This attribute is
     * equivalent to nsICachingChannel.cacheToken.fetchCount.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the cache entry or the alternate data
     *         cache entry cannot be read.
     */
    readonly cacheTokenFetchCount: number;

    /**
     * Get expiration time from cache token. This attribute is equivalent to
     * nsICachingChannel.cacheToken.expirationTime.
     */
    readonly cacheTokenExpirationTime: number;

    /**
     * Set/get charset of cache entry. Accessing this attribute is equivalent to
     * calling nsICachingChannel.cacheToken.getMetaDataElement("charset") and
     * nsICachingChannel.cacheToken.setMetaDataElement("charset").
     */
    cacheTokenCachedCharset: IDLACString;

    /**
     * TRUE if this channel's data is being loaded from the cache.  This value
     * is undefined before the channel fires its OnStartRequest notification
     * and after the channel fires its OnStopRequest notification.
     */
    readonly isFromCache: () => boolean;

    /**
     * Returns true if the channel raced the cache and network requests.
     * In order to determine if the response is coming from the cache or the
     * network, the consumer can check isFromCache().
     * The method can only be called after the channel fires its OnStartRequest
     * notification.
     */
    readonly isRacing: () => boolean;

    /**
     * The unique ID of the corresponding nsICacheEntry from which the response is
     * retrieved. By comparing the returned value, we can judge whether the data
     * of two distinct nsICacheInfoChannels is from the same nsICacheEntry. This
     * scenario could be useful when verifying whether the alternative data from
     * one nsICacheInfochannel matches the main data from another one.
     *
     * Note: NS_ERROR_NOT_AVAILABLE is thrown when a nsICacheInfoChannel has no
     * valid corresponding nsICacheEntry.
     */
    readonly getCacheEntryId: () => number;

    /**
     * Set/get the cache key. This integer uniquely identifies the data in
     * the cache for this channel.
     *
     * A cache key retrieved from a particular instance of nsICacheInfoChannel
     * could be set on another instance of nsICacheInfoChannel provided the
     * underlying implementations are compatible and provided the new
     * channel instance was created with the same URI.  The implementation of
     * nsICacheInfoChannel would be expected to use the cache entry identified
     * by the cache token.  Depending on the value of nsIRequest::loadFlags,
     * the cache entry may be validated, overwritten, or simply read.
     *
     * The cache key may be 0 indicating that the URI of the channel is
     * sufficient to locate the same cache entry.  Setting a 0 cache key
     * is likewise valid.
     */
    cacheKey: number;

    /**
     * Tells the channel to behave as if the LOAD_FROM_CACHE flag has been set,
     * but without affecting the loads for the entire loadGroup in case of this
     * channel being the default load group's channel.
     */
    allowStaleCacheContent: boolean;

    /**
     * Tells the priority for LOAD_CACHE is raised over LOAD_BYPASS_CACHE or
     * LOAD_BYPASS_LOCAL_CACHE in case those flags are set at the same time.
     */
    preferCacheLoadOverBypass: boolean;

    /**
     * Calling this method instructs the channel to serve the alternative data
     * if that was previously saved in the cache, otherwise it will serve the
     * real data.
     * @param type
     *        a string identifying the alt-data format
     * @param contentType
     *        the contentType for which the preference applies.
     *        an empty contentType means the preference applies for ANY contentType
     * @param deliverAltData
     *        if false, also if alt-data is available, the channel will deliver
     *        the original data.
     *
     * The method may be called several times, with different type and contentType.
     *
     * Must be called before AsyncOpen.
     */
    readonly preferAlternativeDataType: (type: IDLACString, contentType: IDLACString, deliverAltData: boolean) => void;

    /**
     * Holds the type of the alternative data representation that the channel
     * is returning.
     * Is empty string if no alternative data representation was requested, or
     * if the requested representation wasn't found in the cache.
     * Can only be called during or after OnStartRequest.
     */
    readonly alternativeDataType: IDLACString;

    /**
     * If preferAlternativeDataType() has been called passing deliverAltData
     * equal to false, this method will expose the alt-data inputStream if
     * aviable.
     */
    readonly getAltDataInputStream: (type: IDLACString, aReceiver: (nsIInputStreamReceiver | null)) => void;

    /**
     * Sometimes when the channel is delivering alt-data, we may want to somehow
     * access the original content too. This method asynchronously opens the
     * input stream and delivers it to the receiver.
     */
    readonly getOriginalInputStream: (aReceiver: (nsIInputStreamReceiver | null)) => void;

    /**
     * Opens and returns an output stream that a consumer may use to save an
     * alternate representation of the data.
     * Must be called after the OnStopRequest that delivered the real data.
     * The consumer may choose to replace the saved alt representation.
     * Opening the output stream will fail if there are any open input streams
     * reading the already saved alt representation. After successfully opening
     * an output stream, if there is an error before the entire alt data can be
     * written successfully, the client must signal failure by passing an error
     * code to CloseWithStatus().
     *
     * @param type
     *        type of the alternative data representation
     * @param predictedSize
     *        Predicted size of the data that will be written. It's used to decide
     *        whether the resulting entry would exceed size limit, in which case
     *        an error is thrown. If the size isn't known in advance, -1 should be
     *        passed.
     */
    readonly openAlternativeOutputStream: (type: IDLACString, predictedSize: number) => (nsIAsyncOutputStream | null);
  }

  export interface nsIKeyValueDatabaseRef {
    readonly name: "nsIKeyValueDatabase";
    readonly number: "{c449398e-174c-425b-8195-da6aa0ccd9a5}";
  }

  /**
   * A key/value database.
   *
   * All methods are asynchronous and take a callback as their first argument.
   * The types of the callbacks vary, but they can all be implemented in JS
   * via an object literal with the relevant methods.
   */
  export interface nsIKeyValueDatabase extends nsISupports {

    /**
     * Write the specified key/value pair to the database.
     */
    readonly put: (callback: (nsIKeyValueVoidCallback | null), key: IDLAUTF8String, value: (nsIVariant | null)) => void;

    /**
     * Write multiple key/value pairs to the database.
     *
     * It supports two types of write:
     *   * Put a key/value pair into the database. It takes a nsIKeyValuePair
     *     where its key and value follow the same types as the put() method.
     *   * Delete a key/value pair from database. It takes a nsIkeyValuePair
     *     where its value property must be null or undefined.
     *
     * This features the "all-or-nothing" semantics, i.e. if any error occurs
     * during the call, it will rollback the previous writes and terminate the
     * call. In addition, writeMany should be more efficient than calling "put"
     * or "delete" for every single key/value pair since it does all the writes
     * in a single transaction.
     *
     * Note:
     *   * If there are multiple values with the same key in the specified
     *     pairs, only the last value will be stored in the database.
     *   * Deleting a key that is not in the database will be silently ignored.
     *   * If the same key gets put and deleted for multiple times, the final
     *     state of that key is subject to the ordering of the put(s) and delete(s).
     */
    readonly writeMany: (callback: (nsIKeyValueVoidCallback | null), pairs: (nsIKeyValuePair | null)[]) => void;

    /**
     * Retrieve the value of the specified key from the database.
     *
     * If the key/value pair doesn't exist in the database, and you specify
     * a default value, then the default value will be returned.  Otherwise,
     * the callback's resolve() method will be called with a variant
     * of type VTYPE_EMPTY, which translates to the JS `null` value.
     */
    readonly get: (callback: (nsIKeyValueVariantCallback | null), key: IDLAUTF8String, defaultValue?: (nsIVariant | null)) => void;

    /**
     * Determine whether or not the key exists in the database.
     */
    readonly has: (callback: (nsIKeyValueVariantCallback | null), key: IDLAUTF8String) => void;

    /**
     * Remove the key/value pair with the given key from the database.
     *
     * If the given key doesn't exist in the database, this operation doesn't
     * fail; or rather, it fails silently, calling the resolve() method
     * of its callback rather than reject().  If you want to know whether
     * or not a key exists when deleting it, call the has() method first.
     */
    readonly delete: (callback: (nsIKeyValueVoidCallback | null), key: IDLAUTF8String) => void;

    /**
     * Clear all the key/value pairs from the database.
     */
    readonly clear: (callback: (nsIKeyValueVoidCallback | null)) => void;

    /**
     * Enumerate key/value pairs, starting with the first key equal to
     * or greater than the "from" key (inclusive) and ending with the last key
     * less than the "to" key (exclusive) sorted lexicographically.
     *
     * If either key is omitted, the range extends to the first and/or last key
     * in the database.
     */
    readonly enumerate: (callback: (nsIKeyValueEnumeratorCallback | null), fromKey?: IDLAUTF8String, toKey?: IDLAUTF8String) => void;
  }

  export interface nsITransactionManagerRef {
    readonly name: "nsITransactionManager";
    readonly number: "{c77763df-0fb9-41a8-8074-8e882f605755}";
  }

  export interface nsITransactionManager extends nsISupports {

    /**
     * The nsITransactionManager interface.
     * <P>
     * This interface is implemented by an object that wants to
     * manage/track transactions.
     */
    /**
     * Calls a transaction's doTransaction() method, then pushes it on the
     * undo stack.
     * <P>
     * This method calls the transaction's AddRef() method.
     * The transaction's Release() method will be called when the undo or redo
     * stack is pruned or when the transaction manager is destroyed.
     * @param aTransaction the transaction to do.
     */
    readonly doTransaction: (aTransaction: (nsITransaction | null)) => void;

    /**
     * Pops the topmost transaction on the undo stack, calls its
     * undoTransaction() method, then pushes it on the redo stack.
     */
    readonly undoTransaction: () => void;

    /**
     * Pops the topmost transaction on the redo stack, calls its
     * redoTransaction() method, then pushes it on the undo stack.
     */
    readonly redoTransaction: () => void;

    /**
     * Clears the undo and redo stacks.
     */
    readonly clear: () => void;

    /**
     * Clears the undo stack only.
     */
    readonly clearUndoStack: () => void;

    /**
     * Clears the redo stack only.
     */
    readonly clearRedoStack: () => void;

    /**
     * Turns on the transaction manager's batch mode, forcing all transactions
     * executed by the transaction manager's doTransaction() method to be
     * aggregated together until EndBatch() is called.  This mode allows an
     * application to execute and group together several independent transactions
     * so they can be undone with a single call to undoTransaction().
     * @param aData An arbitrary nsISupports object that is associated with the
     * batch. Can be retrieved from the undo or redo stacks.
     */
    readonly beginBatch: (aData: (nsISupports | null)) => void;

    /**
     * Turns off the transaction manager's batch mode.
     * @param aAllowEmpty If true, a batch containing no children will be
     * pushed onto the undo stack. Otherwise, ending a batch with no
     * children will result in no transactions being pushed on the undo stack.
     */
    readonly endBatch: (aAllowEmpty: boolean) => void;

    /**
     * The number of items on the undo stack.
     */
    readonly numberOfUndoItems: number;

    /**
     * The number of items on the redo stack.
     */
    readonly numberOfRedoItems: number;

    /**
     * Sets the maximum number of transaction items the transaction manager will
     * maintain at any time. This is commonly referred to as the number of levels
     * of undo.
     * @param aMaxCount A value of -1 means no limit. A value of zero means the
     * transaction manager will execute each transaction, then immediately release
     * all references it has to the transaction without pushing it on the undo
     * stack. A value greater than zero indicates the max number of transactions
     * that can exist at any time on both the undo and redo stacks. This method
     * will prune the necessary number of transactions on the undo and redo
     * stacks if the value specified is less than the number of items that exist
     * on both the undo and redo stacks.
     */
    maxTransactionCount: number;

    /**
     * Combines the transaction at the top of the undo stack (if any) with the
     * preceding undo transaction (if any) into a batch transaction. Thus,
     * a call to undoTransaction() will undo both transactions.
     */
    readonly batchTopUndo: () => void;

    /**
     * Removes the transaction at the top of the undo stack (if any) without
     * transacting.
     */
    readonly removeTopUndo: () => void;

    /**
     * Returns an AddRef'd pointer to the transaction at the top of the
     * undo stack. Callers should be aware that this method could return
     * return a null in some implementations if there is a batch at the top
     * of the undo stack.
     */
    readonly peekUndoStack: () => (nsITransaction | null);

    /**
     * Returns an AddRef'd pointer to the transaction at the top of the
     * redo stack. Callers should be aware that this method could return
     * return a null in some implementations if there is a batch at the top
     * of the redo stack.
     */
    readonly peekRedoStack: () => (nsITransaction | null);

    /**
     * Adds a listener to the transaction manager's notification list. Listeners
     * are notified whenever a transaction is done, undone, or redone.
     * <P>
     * The listener's AddRef() method is called.
     * @param aListener the lister to add.
     */
    readonly AddListener: (aListener: (nsITransactionListener | null)) => void;

    /**
     * Removes a listener from the transaction manager's notification list.
     * <P>
     * The listener's Release() method is called.
     * @param aListener the lister to remove.
     */
    readonly RemoveListener: (aListener: (nsITransactionListener | null)) => void;
  }

  export interface mozIMozIntlRef {
    readonly name: "mozIMozIntl";
    readonly number: "{7f63279a-1a29-4ae6-9e7a-dc9684a23530}";
  }

  /**
   * This is a set of APIs that are of general usefulness for user interface
   * internationalization.
   *
   * They're all in various stages of the standardization process through
   * ECMA402, so they are exposed to privileged content only but are written
   * in the way to allow for easy migration to standard Intl object once
   * the appropriate stage of the ECMA402 is achieved.
   *
   * The exact structure of the code is a little bit complex because of that:
   *
   * 1) The core is in SpiderMonkey together with other Intl APIs
   *
   * This allows us to write the code once, stick to the spec language
   * of the proposal, reuse our ICU bindings in Spidermonkey and use
   * the code to inform us on refining the spec proposal for the given API itself.
   *
   * 2) The MozIntlHelper API exposes the SpiderMonkey APIs
   *
   * This helper API allows attaching the new APIs on any regular object.
   *
   * 3) The MozIntl API provides the access to those APIs
   *
   * This API exposes the actual functionality and wraps around the MozIntlHelper
   * lazily retrieving and setting the accessors.
   * On top of that, the API also binds additional functionality like using
   * current application locale by default, and fetching OS regional preferences
   * for date time format.
   */
  export interface mozIMozIntl extends nsISupports {

    readonly getCalendarInfo: (locales?: IDLjsval) => IDLjsval;

    readonly getDisplayNames: (locales?: IDLjsval, options?: IDLjsval) => IDLjsval;

    readonly getLocaleInfo: (locales?: IDLjsval) => IDLjsval;

    /**
     * Returns a list of locale codes for a given type.
     * At the moment only type="region" is supported.
     *
     * Example:
     *   let codes = getAvailableLocaleDisplayNames("region");
     *   codes === ["ar", "ae", "af", ...]
     */
    readonly getAvailableLocaleDisplayNames: (type: IDLjsval) => IDLjsval;

    /**
     * Returns a list of language names formatted for display.
     *
     * Example:
     *   let langs = getLanguageDisplayNames(["pl"], ["fr", "de", "en"]);
     *   langs === ["Francuski", "Niemiecki", "Angielski"]
     */
    readonly getLanguageDisplayNames: (locales: IDLjsval, langCodes: IDLjsval) => IDLjsval;

    /**
     * Returns a list of region names formatted for display.
     *
     * Example:
     *   let regs = getRegionDisplayNames(["pl"], ["US", "CA", "MX"]);
     *   regs === ["Stany Zjednoczone", "Kanada", "Meksyk"]
     */
    readonly getRegionDisplayNames: (locales: IDLjsval, regionCodes: IDLjsval) => IDLjsval;

    /**
     * Returns a list of locale names formatted for display.
     *
     * Example:
     *   let locs = getLocaleDisplayNames(["pl"], ["sr-RU", "es-MX", "fr-CA"]);
     *   locs === ["Serbski (Rosja)", "Hiszpaski (Meksyk)", "Francuski (Kanada)"]
     */
    readonly getLocaleDisplayNames: (locales: IDLjsval, localeCodes: IDLjsval) => IDLjsval;

    readonly DateTimeFormat: IDLjsval;

    readonly NumberFormat: IDLjsval;

    readonly Collator: IDLjsval;

    readonly PluralRules: IDLjsval;

    readonly RelativeTimeFormat: IDLjsval;
  }

  export interface nsIObjectLoadingContentRef {
    readonly name: "nsIObjectLoadingContent";
    readonly number: "{2eb3195e-3eea-4083-bb1d-d2d70fa35ccb}";

    /**
     * See notes in nsObjectLoadingContent.h
     */
    TYPE_LOADING: 0;

    TYPE_IMAGE: 1;

    TYPE_PLUGIN: 2;

    TYPE_FAKE_PLUGIN: 3;

    TYPE_DOCUMENT: 4;

    TYPE_NULL: 5;

    PLUGIN_ACTIVE: 255;

    PLUGIN_UNSUPPORTED: 0;

    PLUGIN_ALTERNATE: 1;

    PLUGIN_DISABLED: 2;

    PLUGIN_BLOCKLISTED: 3;

    PLUGIN_OUTDATED: 4;

    PLUGIN_CRASHED: 5;

    PLUGIN_SUPPRESSED: 6;

    PLUGIN_USER_DISABLED: 7;

    PLUGIN_CLICK_TO_PLAY: 8;

    PLUGIN_VULNERABLE_UPDATABLE: 9;

    PLUGIN_VULNERABLE_NO_UPDATE: 10;

    PLUGIN_CLICK_TO_PLAY_QUIET: 11;

    PLUGIN_PERMISSION_PROMPT_ACTION_QUIET: 8;
  }

  /**
   * This interface represents a content node that loads objects.
   *
   * Please make sure to update the MozObjectLoadingContent WebIDL
   * mixin to mirror this interface when changing it.
   */
  export interface nsIObjectLoadingContent extends nsISupports {

    /**
     * The actual mime type (the one we got back from the network
     * request) for the element.
     */
    readonly actualType: IDLACString;

    /**
     * Gets the type of the content that's currently loaded. See
     * the constants above for the list of possible values.
     */
    readonly displayedType: number;

    /**
     * Gets the content type that corresponds to the give MIME type.  See the
     * constants above for the list of possible values.  If nothing else fits,
     * TYPE_NULL will be returned.
     */
    readonly getContentTypeForMIMEType: (aMimeType: IDLAUTF8String) => number;

    /**
     * Forces a re-evaluation and reload of the tag, optionally invalidating its
     * click-to-play state.  This can be used when the MIME type that provides a
     * type has changed, for instance, to force the tag to re-evalulate the
     * handler to use.
     */
    readonly reload: (aClearActivation: boolean) => void;

    /**
     * This attribute will return true if the current content type has been
     * activated, either explicitly or by passing checks that would have it be
     * click-to-play.
     */
    readonly activated: boolean;

    /**
     * The URL of the data/src loaded in the object. This may be null (i.e.
     * an <embed> with no src).
     */
    readonly srcURI: (nsIURI | null);

    /**
     * Disable the use of fake plugins and reload the tag if necessary.
     */
    readonly skipFakePlugins: () => void;
  }

  export interface nsIMessageSenderRef {
    readonly name: "nsIMessageSender";
    readonly number: "{bb5d79e4-e73c-45e7-9651-4d718f4b994c}";
  }

  export interface nsIMessageSender extends nsISupports {
  }

  export interface nsIPermissionRef {
    readonly name: "nsIPermission";
    readonly number: "{bb409a51-2371-4fea-9dc9-b7286a458b8c}";
  }

  /**
   * This interface defines a "permission" object,
   * used to specify allowed/blocked objects from
   * user-specified sites (cookies, images etc).
   */
  export interface nsIPermission extends nsISupports {

    /**
     * The principal for which this permission applies.
     */
    readonly principal: (nsIPrincipal | null);

    /**
     * a case-sensitive ASCII string, indicating the type of permission
     * (e.g., "cookie", "image", etc).
     * This string is specified by the consumer when adding a permission
     * via nsIPermissionManager.
     * @see nsIPermissionManager
     */
    readonly type: IDLACString;

    /**
     * The permission (see nsIPermissionManager.idl for allowed values)
     */
    readonly capability: number;

    /**
     * The expiration type of the permission (session, time-based or none).
     * Constants are EXPIRE_*, defined in nsIPermissionManager.
     * @see nsIPermissionManager
     */
    readonly expireType: number;

    /**
     * The expiration time of the permission (milliseconds since Jan 1 1970
     * 0:00:00).
     */
    readonly expireTime: number;

    /**
     * The last modification time of the permission (milliseconds since Jan 1 1970
     * 0:00:00).
     */
    readonly modificationTime: number;

    /**
     * Test whether a principal would be affected by this permission.
     *
     * @param principal  the principal to test
     * @param exactHost  If true, only the specific host will be matched,
     *                   @see nsIPermissionManager::testExactPermission.
     *                   If false, subdomains will also be searched,
     *                   @see nsIPermissionManager::testPermission.
     */
    readonly matches: (principal: (nsIPrincipal | null), exactHost: boolean) => boolean;

    /**
     * Test whether a URI would be affected by this permission.
     * NOTE: This performs matches with default origin attribute values.
     *
     * @param uri        the uri to test
     * @param exactHost  If true, only the specific host will be matched,
     *                   @see nsIPermissionManager::testExactPermission.
     *                   If false, subdomains will also be searched,
     *                   @see nsIPermissionManager::testPermission.
     */
    readonly matchesURI: (uri: (nsIURI | null), exactHost: boolean) => boolean;
  }

  export interface nsIBufferedOutputStreamRef {
    readonly name: "nsIBufferedOutputStream";
    readonly number: "{6476378a-da09-11d3-8cda-0060b0fc14a3}";
  }

  /**
   * An output stream that stores up data to write out to another output stream
   * and does the entire write only when the buffer is full, so that fewer writes
   * to the underlying output stream are necessary.
   */
  export interface nsIBufferedOutputStream extends nsIOutputStream {

    /**
     * @param sinkToStream - add buffering to this stream
     * @param bufferSize   - specifies the maximum buffer size
     */
    readonly init: (sinkToStream: (nsIOutputStream | null), bufferSize: number) => void;

    /**
     * Get the wrapped data stream
     */
    readonly data: (nsIOutputStream | null);
  }

  export interface nsIServiceWorkerManagerListenerRef {
    readonly name: "nsIServiceWorkerManagerListener";
    readonly number: "{9e523e7c-ad6f-4df0-8077-c74aebbc679d}";
  }

  export interface nsIServiceWorkerManagerListener extends nsISupports {

    readonly onRegister: (aInfo: (nsIServiceWorkerRegistrationInfo | null)) => void;

    readonly onUnregister: (aInfo: (nsIServiceWorkerRegistrationInfo | null)) => void;
  }

  export interface nsIServiceWorkerManagerRef {
    readonly name: "nsIServiceWorkerManager";
    readonly number: "{7404c8e8-4d47-4449-8ed1-47d1261d4e33}";
  }

  export interface nsIServiceWorkerManager extends nsISupports {

    /**
     * Unregister an existing ServiceWorker registration for `aScope`.
     * It keeps aCallback alive until the operation is concluded.
     */
    readonly unregister: (aPrincipal: (nsIPrincipal | null), aCallback: (nsIServiceWorkerUnregisterCallback | null), aScope: IDLAString) => void;

    readonly getRegistrationByPrincipal: (aPrincipal: (nsIPrincipal | null), aScope: IDLAString) => (nsIServiceWorkerRegistrationInfo | null);

    readonly getScopeForUrl: (aPrincipal: (nsIPrincipal | null), aPath: IDLAString) => IDLAString;

    readonly getAllRegistrations: () => (nsIArray | null);

    readonly removeRegistrationsByOriginAttributes: (aOriginAttributes: IDLAString) => void;

    readonly propagateSoftUpdate: (aOriginAttributes: IDLjsval, aScope: IDLAString) => void;

    readonly propagateUnregister: (aPrincipal: (nsIPrincipal | null), aCallback: (nsIServiceWorkerUnregisterCallback | null), aScope: IDLAString) => void;

    readonly sendNotificationClickEvent: (aOriginSuffix: IDLACString, scope: IDLACString, aID: IDLAString, aTitle: IDLAString, aDir: IDLAString, aLang: IDLAString, aBody: IDLAString, aTag: IDLAString, aIcon: IDLAString, aData: IDLAString, aBehavior: IDLAString) => void;

    readonly sendNotificationCloseEvent: (aOriginSuffix: IDLACString, scope: IDLACString, aID: IDLAString, aTitle: IDLAString, aDir: IDLAString, aLang: IDLAString, aBody: IDLAString, aTag: IDLAString, aIcon: IDLAString, aData: IDLAString, aBehavior: IDLAString) => void;

    readonly sendPushEvent: (aOriginAttributes: IDLACString, aScope: IDLACString, aDataBytes?: number[]) => void;

    readonly sendPushSubscriptionChangeEvent: (aOriginAttributes: IDLACString, scope: IDLACString) => void;

    readonly addListener: (aListener: (nsIServiceWorkerManagerListener | null)) => void;

    readonly removeListener: (aListener: (nsIServiceWorkerManagerListener | null)) => void;

    readonly isParentInterceptEnabled: () => boolean;
  }

  export interface nsIUDPSocketRef {
    readonly name: "nsIUDPSocket";
    readonly number: "{d423bf4e-4499-40cf-bc03-153e2bf206d1}";
  }

  /**
   * nsIUDPSocket
   *
   * An interface to a UDP socket that can accept incoming connections.
   */
  export interface nsIUDPSocket extends nsISupports {

    /**
     * init
     *
     * This method initializes a UDP socket.
     *
     * @param aPort
     *        The port of the UDP socket.  Pass -1 to indicate no preference,
     *        and a port will be selected automatically.
     * @param aLoopbackOnly
     *        If true, the UDP socket will only respond to connections on the
     *        local loopback interface.  Otherwise, it will accept connections
     *        from any interface.  To specify a particular network interface,
     *        use initWithAddress.
     * @param aPrincipal
     *        The principal connected to this socket.
     * @param aAddressReuse
     *        If true, the socket is allowed to be bound to an address that is
     *        already in use. Default is true.
     */
    readonly init: (aPort: number, aLoopbackOnly: boolean, aPrincipal: (nsIPrincipal | null), aAddressReuse?: boolean) => void;

    readonly init2: (aAddr: IDLAUTF8String, aPort: number, aPrincipal: (nsIPrincipal | null), aAddressReuse?: boolean) => void;

    /**
     * close
     *
     * This method closes a UDP socket.  This does not affect already
     * connected client sockets (i.e., the nsISocketTransport instances
     * created from this UDP socket).  This will cause the onStopListening
     * event to asynchronously fire with a status of NS_BINDING_ABORTED.
     */
    readonly close: () => void;

    /**
     * asyncListen
     *
     * This method puts the UDP socket in the listening state.  It will
     * asynchronously listen for and accept client connections.  The listener
     * will be notified once for each client connection that is accepted.  The
     * listener's onSocketAccepted method will be called on the same thread
     * that called asyncListen (the calling thread must have a nsIEventTarget).
     *
     * The listener will be passed a reference to an already connected socket
     * transport (nsISocketTransport).  See below for more details.
     *
     * @param aListener
     *        The listener to be notified when client connections are accepted.
     */
    readonly asyncListen: (aListener: (nsIUDPSocketListener | null)) => void;

    /**
     * Returns the local address of this UDP socket
     */
    readonly localAddr: (nsINetAddr | null);

    /**
     * Returns the port of this UDP socket.
     */
    readonly port: number;

    /**
     * send
     *
     * Send out the datagram to specified remote host and port.
     * DNS lookup will be triggered.
     *
     * @param host The remote host name.
     * @param port The remote port.
     * @param data The buffer containing the data to be written.
     * @return number of bytes written. (0 or length of data)
     */
    readonly send: (host: IDLAUTF8String, port: number, data: number[]) => number;

    /**
     * sendWithAddr
     *
     * Send out the datagram to specified remote host and port.
     *
     * @param addr The remote host address.
     * @param data The buffer containing the data to be written.
     * @return number of bytes written. (0 or length of data)
     */
    readonly sendWithAddr: (addr: (nsINetAddr | null), data: number[]) => number;

    /**
     * sendBinaryStream
     *
     * Send out the datagram to specified remote address and port.
     *
     * @param host The remote host name.
     * @param port The remote port.
     * @param stream The input stream to be sent. This must be a buffered stream implementation.
     */
    readonly sendBinaryStream: (host: IDLAUTF8String, port: number, stream: (nsIInputStream | null)) => void;

    /**
     * joinMulticast
     *
     * Join the multicast group specified by |addr|.  You are then able to
     * receive future datagrams addressed to the group.
     *
     * @param addr
     *        The multicast group address.
     * @param iface
     *        The local address of the interface on which to join the group.  If
     *        this is not specified, the OS may join the group on all interfaces
     *        or only the primary interface.
     */
    readonly joinMulticast: (addr: IDLAUTF8String, iface?: IDLAUTF8String) => void;

    /**
     * leaveMulticast
     *
     * Leave the multicast group specified by |addr|.  You will no longer
     * receive future datagrams addressed to the group.
     *
     * @param addr
     *        The multicast group address.
     * @param iface
     *        The local address of the interface on which to leave the group.
     *        If this is not specified, the OS may leave the group on all
     *        interfaces or only the primary interface.
     */
    readonly leaveMulticast: (addr: IDLAUTF8String, iface?: IDLAUTF8String) => void;

    /**
     * multicastLoopback
     *
     * Whether multicast datagrams sent via this socket should be looped back to
     * this host (assuming this host has joined the relevant group).  Defaults
     * to true.
     * Note: This is currently write-only.
     */
    multicastLoopback: boolean;

    /**
     * multicastInterface
     *
     * The interface that should be used for sending future multicast datagrams.
     * Note: This is currently write-only.
     */
    multicastInterface: IDLAUTF8String;
  }

  export interface nsIOpenURIInFrameParamsRef {
    readonly name: "nsIOpenURIInFrameParams";
    readonly number: "{e774db14-79ac-4156-a7a3-aa3fd0a22c10}";
  }

  export interface nsIOpenURIInFrameParams extends nsISupports {

    referrerInfo: (nsIReferrerInfo | null);

    readonly isPrivate: boolean;

    triggeringPrincipal: (nsIPrincipal | null);

    csp: (nsIContentSecurityPolicy | null);

    readonly openerBrowser: WebIDL.Element;

    readonly openerOriginAttributes: IDLjsval;
  }

  export interface nsIHelperAppLauncherDialogRef {
    readonly name: "nsIHelperAppLauncherDialog";
    readonly number: "{bfc739f3-8d75-4034-a6f8-1039a5996bad}";

    /**
     * This request is passed to the helper app dialog because Gecko can not
     * handle content of this type.
     */
    REASON_CANTHANDLE: 0;

    /**
     * The server requested external handling.
     */
    REASON_SERVERREQUEST: 1;

    /**
     * Gecko detected that the type sent by the server (e.g. text/plain) does
     * not match the actual type.
     */
    REASON_TYPESNIFFED: 2;
  }

  /**
   * This interface is used to display a confirmation dialog before
   * launching a "helper app" to handle content not handled by
   * Mozilla.
   *
   * Usage:  Clients (of which there is one: the nsIExternalHelperAppService
   * implementation in mozilla/uriloader/exthandler) create an instance of
   * this interface (using the contract ID) and then call the show() method.
   *
   * The dialog is shown non-modally.  The implementation of the dialog
   * will access methods of the nsIHelperAppLauncher passed in to show()
   * in order to cause a "save to disk" or "open using" action.
   */
  export interface nsIHelperAppLauncherDialog extends nsISupports {

    /**
     * Show confirmation dialog for launching application (or "save to
     * disk") for content specified by aLauncher.
     *
     * @param aLauncher
     *        A nsIHelperAppLauncher to be invoked when a file is selected.
     * @param aWindowContext
     *        Window associated with action.
     * @param aReason
     *        One of the constants from above. It indicates why the dialog is
     *        shown. Implementors should treat unknown reasons like
     *        REASON_CANTHANDLE.
     */
    readonly show: (aLauncher: (nsIHelperAppLauncher | null), aWindowContext: (nsIInterfaceRequestor | null), aReason: number) => void;

    /**
     * Async invoke a save-to-file dialog instead of the full fledged helper app
     * dialog. When the file is chosen (or the dialog is closed), the callback
     * in aLauncher (aLauncher.saveDestinationAvailable) is called with the
     * selected file.
     *
     * @param aLauncher
     *        A nsIHelperAppLauncher to be invoked when a file is selected.
     * @param aWindowContext
     *        Window associated with action.
     * @param aDefaultFileName
     *        Default file name to provide (can be null)
     * @param aSuggestedFileExtension
     *        Sugested file extension
     * @param aForcePrompt
     *        Set to true to force prompting the user for thet file
     *        name/location, otherwise perferences may control if the user is
     *        prompted.
     */
    readonly promptForSaveToFileAsync: (aLauncher: (nsIHelperAppLauncher | null), aWindowContext: (nsIInterfaceRequestor | null), aDefaultFileName: string, aSuggestedFileExtension: string, aForcePrompt: boolean) => void;
  }

  export interface nsIIDNServiceRef {
    readonly name: "nsIIDNService";
    readonly number: "{a592a60e-3621-4f19-a318-2bf233cfad3e}";
  }

  /**
   * nsIIDNService interface.
   *
   * IDN (Internationalized Domain Name) support. Provides facilities
   * for manipulating IDN hostnames according to the specification set
   * forth by the IETF.
   *
   * IDN effort:
   * http://www.ietf.org/html.characters/idn-charter.html
   * http://www.i-dns.net
   *
   * IDNA specification:
   * http://search.ietf.org/internet-drafts/draft-ietf-idn-idna-06.txt
   */
  export interface nsIIDNService extends nsISupports {

    /**
     * Prepares the input hostname according to IDNA ToASCII operation,
     * the input hostname is assumed to be UTF8-encoded.
     */
    readonly convertUTF8toACE: (input: IDLAUTF8String) => IDLACString;

    /**
     * This is the ToUnicode operation as specified in the IDNA proposal,
     * with an additional step to encode the result in UTF-8.
     * It takes an ACE-encoded hostname and performs ToUnicode to it, then
     * encodes the resulting string into UTF8.
     */
    readonly convertACEtoUTF8: (input: IDLACString) => IDLAUTF8String;

    /**
     * Checks if the input string is ACE encoded or not.
     */
    readonly isACE: (input: IDLACString) => boolean;

    /**
     * Performs the unicode normalization needed for hostnames in IDN,
     * for callers that want early normalization.
     */
    readonly normalize: (input: IDLAUTF8String) => IDLAUTF8String;

    /**
     * Normalizes and converts a host to UTF-8 if the host is in the IDN
     * whitelist, otherwise converts it to ACE. This is useful for display
     * purposes and to ensure an encoding consistent with nsIURI::GetHost().
     * If the result is ASCII or ACE encoded, |isASCII| will be true.
     */
    readonly convertToDisplayIDN: (input: IDLAUTF8String, isASCII: Out<boolean>) => IDLAUTF8String;
  }

  export interface nsIPropertyBag2Ref {
    readonly name: "nsIPropertyBag2";
    readonly number: "{625cfd1e-da1e-4417-9ee9-dbc8e0b3fd79}";
  }

  export interface nsIPropertyBag2 extends nsIPropertyBag {

    readonly getPropertyAsInt32: (prop: IDLAString) => number;

    readonly getPropertyAsUint32: (prop: IDLAString) => number;

    readonly getPropertyAsInt64: (prop: IDLAString) => number;

    readonly getPropertyAsUint64: (prop: IDLAString) => number;

    readonly getPropertyAsDouble: (prop: IDLAString) => number;

    readonly getPropertyAsAString: (prop: IDLAString) => IDLAString;

    readonly getPropertyAsACString: (prop: IDLAString) => IDLACString;

    readonly getPropertyAsAUTF8String: (prop: IDLAString) => IDLAUTF8String;

    readonly getPropertyAsBool: (prop: IDLAString) => boolean;

    /**
     * This method returns null if the value does not exist,
     * or exists but is null.
     */
    readonly get: (prop: IDLAString) => (nsIVariant | null);

    /**
     * Check for the existence of a key.
     */
    readonly hasKey: (prop: IDLAString) => boolean;
  }

  export interface nsIPowerManagerServiceRef {
    readonly name: "nsIPowerManagerService";
    readonly number: "{ba7ca4c1-9d92-4425-a83b-85dd7fa953f7}";
  }

  /**
   * For use with non-content code.
   */
  export interface nsIPowerManagerService extends nsISupports {

    readonly addWakeLockListener: (aListener: (nsIDOMMozWakeLockListener | nsIDOMMozWakeLockListenerFunction | null)) => void;

    readonly removeWakeLockListener: (aListener: (nsIDOMMozWakeLockListener | nsIDOMMozWakeLockListenerFunction | null)) => void;

    readonly getWakeLockState: (aTopic: IDLAString) => IDLAString;

    /**
     * Return a wake lock (MozWakeLock) object of aTopic associated with aWindow.
     * A wake lock without associated window, e.g. used in chrome, is
     * always considered invisible.
     */
    readonly newWakeLock: (aTopic: IDLAString, aWindow?: (mozIDOMWindow | null)) => (nsIWakeLock | null);
  }

  export interface nsISerializationHelperRef {
    readonly name: "nsISerializationHelper";
    readonly number: "{31654c0f-35f3-44c6-b31e-37a11516e6bc}";
  }

  export interface nsISerializationHelper extends nsISupports {

    /**
     * Serialize the object to a base64 string. This string can be later passed
     * as an input to deserializeObject method.
     */
    readonly serializeToString: (serializable: (nsISerializable | null)) => IDLACString;

    /**
     * Takes base64 encoded string that cointains serialization of a single
     * object. Most commonly, input is result of previous call to
     * serializeToString.
     */
    readonly deserializeObject: (input: IDLACString) => (nsISupports | null);
  }

  export interface nsISupportsStringRef {
    readonly name: "nsISupportsString";
    readonly number: "{d79dc970-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for Unicode strings
   */
  export interface nsISupportsString extends nsISupportsPrimitive {

    data: IDLAString;

    readonly toString: () => string;
  }

  export interface nsIWindowMediatorRef {
    readonly name: "nsIWindowMediator";
    readonly number: "{df0da056-357d-427f-bafd-e6cbf19c9381}";

    zLevelTop: 1;

    zLevelBottom: 2;

    zLevelBelow: 3;
  }

  export interface nsIWindowMediator extends nsISupports {

    /** Return an enumerator which iterates over all windows of type aWindowType
     * from the oldest window to the youngest.
     * @param  aWindowType the returned enumerator will enumerate only
     *                     windows of this type. ("type" is the
     *                     |windowtype| attribute of the XML <window> element.)
     *                     If null, all windows will be enumerated.
     * @return an enumerator of nsIDOMWindows.  Note that windows close
     *         asynchronously in many cases, so windows returned from this
     *         enumerator can have .closed set to true.  Caveat enumerator!
     */
    readonly getEnumerator: (aWindowType: string) => (nsISimpleEnumerator | null);

    /** Identical to getEnumerator except:
     * @return an enumerator of nsIAppWindows
     */
    readonly getAppWindowEnumerator: (aWindowType: string) => (nsISimpleEnumerator | null);

    /** Return an enumerator which iterates over all windows of type aWindowType
     * in their z (front-to-back) order. Note this interface makes
     * no requirement that a window couldn't be revisited if windows
     * are re-ordered while z-order enumerators are active.
     * @param  aWindowType the returned enumerator will enumerate only
     *                     windows of this type. ("type" is the
     *                     |windowtype| attribute of the XML <window> element.)
     *                     If null, all windows will be enumerated.
     * @param  aFrontToBack if true, the enumerator enumerates windows in order
     *                      from front to back. back to front if false.
     * @return an enumerator of nsIAppWindows
     */
    readonly getZOrderAppWindowEnumerator: (aWindowType: string, aFrontToBack: boolean) => (nsISimpleEnumerator | null);

    /** This is a shortcut for simply fetching the first window in
     * front to back order.
     * @param  aWindowType return the topmost window of this type.
     *                     ("type" is the |windowtype| attribute of
     *                     the XML <window> element.)
     *                     If null, return the topmost window of any type.
     * @return the topmost window
     */
    readonly getMostRecentWindow: (aWindowType: string) => (mozIDOMWindowProxy | null);

    /** This is a shortcut for getMostRecentWindow('navigator:browser'), but
     * it also tries 'navigator:geckoview' if that fails.
     *
     * @return the topmost browser window
     */
    readonly getMostRecentBrowserWindow: () => (mozIDOMWindowProxy | null);

    /**
     * Same as getMostRecentWindow, but ignores private browsing
     * windows.
     */
    readonly getMostRecentNonPBWindow: (aWindowType: string) => (mozIDOMWindowProxy | null);

    /**
     * Return the outer window with the given ID, if any.  Can return null.
     */
    readonly getOuterWindowWithId: (aOuterWindowID: number) => (mozIDOMWindowProxy | null);

    /**
     * Return the inner window with the given current window ID, if any.
     * Can return null if no inner window with the ID exists or if it's not
     * a current inner anymore.
     */
    readonly getCurrentInnerWindowWithId: (aInnerWindowID: number) => (mozIDOMWindow | null);

    /** Register a listener for window status changes.
     * keeps strong ref? (to be decided)
     * @param aListener the listener to register
     */
    readonly addListener: (aListener: (nsIWindowMediatorListener | null)) => void;

    /** Unregister a listener of window status changes.
     * @param aListener the listener to unregister
     */
    readonly removeListener: (aListener: (nsIWindowMediatorListener | null)) => void;
  }

  export interface nsIEditorMailSupportRef {
    readonly name: "nsIEditorMailSupport";
    readonly number: "{fdf23301-4a94-11d3-9ce4-9960496c41bc}";
  }

  export interface nsIEditorMailSupport extends nsISupports {

    /** Insert a string as quoted text
     * (whose representation is dependant on the editor type),
     * replacing the selected text (if any),
     * including, if possible, a "cite" attribute.
     * @param aQuotedText  The actual text to be quoted
     * @param aCitation    The "mid" URL of the source message
     * @param aInsertHTML  Insert as html?  (vs plaintext)
     * @return             The node which was inserted
     */
    readonly insertAsCitedQuotation: (aQuotedText: IDLAString, aCitation: IDLAString, aInsertHTML: boolean) => WebIDL.Node;

    /**
     * Rewrap the selected part of the document, re-quoting if necessary.
     * @param aRespectNewlines  Try to maintain newlines in the original?
     */
    readonly rewrap: (aRespectNewlines: boolean) => void;
  }

  export interface nsIClipboardOwnerRef {
    readonly name: "nsIClipboardOwner";
    readonly number: "{5a31c7a1-e122-11d2-9a57-000064657374}";
  }

  export interface nsIClipboardOwner extends nsISupports {

    /**
     * Notifies the owner of the clipboard transferable that the
     * transferable is being removed from the clipboard
     *
     * @param  aTransferable The transferable
     * @result NS_Ok if no errors
     */
    readonly LosingOwnership: (aTransferable: (nsITransferable | null)) => void;
  }

  export interface nsIHttpPushListenerRef {
    readonly name: "nsIHttpPushListener";
    readonly number: "{0d6ce59c-ad5d-4520-b4d3-09664868f279}";
  }

  /**
   * nsIHttpPushListener
   *
   * Used for triggering when a HTTP/2 push is received.
   *
   */
  export interface nsIHttpPushListener extends nsISupports {

    /**
     * When provided as a notificationCallback to an httpChannel, this.onPush()
     * will be invoked when there is a >= Http2 push to that
     * channel. The push may be in progress.
     *
     * The consumer must start the new channel in the usual way by calling
     * pushChannel.AsyncOpen with a nsIStreamListener object that
     * will receive the normal sequence of OnStartRequest(),
     * 0 to N OnDataAvailable(), and onStopRequest().
     *
     * The new channel can be canceled after the AsyncOpen if it is not wanted.
     *
     * @param associatedChannel
     *        the monitor channel that was recieved on
     * @param pushChannel
     *        a channel to the resource which is being pushed
     */
    readonly onPush: (associatedChannel: (nsIHttpChannel | null), pushChannel: (nsIHttpChannel | null)) => void;
  }

  export interface nsIRunnablePriorityRef {
    readonly name: "nsIRunnablePriority";
    readonly number: "{e75aa42a-80a9-11e6-afb5-e89d87348e2c}";

    PRIORITY_IDLE: 0;

    PRIORITY_DEFERRED_TIMERS: 1;

    PRIORITY_NORMAL: 4;

    PRIORITY_MEDIUMHIGH: 5;

    PRIORITY_INPUT_HIGH: 6;

    PRIORITY_HIGH: 7;
  }

  export interface nsIRunnablePriority extends nsISupports {

    readonly priority: number;
  }

  export interface nsISoundRef {
    readonly name: "nsISound";
    readonly number: "{c3c28d92-a17f-43df-976d-4eeae6f995fc}";

    /**
     * In some situations, playEventSound will be called.  Then, each
     * implementations will play a system sound for the event if it's necessary.
     *
     * NOTE: Don't change these values because they are used in
     * nsPIPromptService.idl. So, if they are changed, that makes big impact for
     * the embedders.
     */
    EVENT_NEW_MAIL_RECEIVED: 0;

    EVENT_ALERT_DIALOG_OPEN: 1;

    EVENT_CONFIRM_DIALOG_OPEN: 2;

    EVENT_PROMPT_DIALOG_OPEN: 3;

    EVENT_SELECT_DIALOG_OPEN: 4;

    EVENT_MENU_EXECUTE: 5;

    EVENT_MENU_POPUP: 6;

    EVENT_EDITOR_MAX_LEN: 7;
  }

  export interface nsISound extends nsISupports {

    readonly play: (aURL: (nsIURL | null)) => void;

    readonly beep: () => void;

    /**
     * Not strictly necessary, but avoids delay before first sound.
     * The various methods on nsISound call Init() if they need to.
     */
    readonly init: () => void;

    readonly playEventSound: (aEventId: number) => void;
  }

  export interface nsINativeOSFileSuccessCallbackRef {
    readonly name: "nsINativeOSFileSuccessCallback";
    readonly number: "{2c1922ca-ca1b-4099-8b61-ec23cff49412}";
  }

  type nsINativeOSFileSuccessCallbackFunction = (result: (nsINativeOSFileResult | null)) => void;

  /**
   * A callback invoked in case of success.
   */
  export interface nsINativeOSFileSuccessCallback extends nsISupports {

    readonly complete: (result: (nsINativeOSFileResult | null)) => void;
  }

  export interface nsIDOMWindowUtilsRef {
    readonly name: "nsIDOMWindowUtils";
    readonly number: "{4d6732ca-9da7-4176-b8a1-8dde15cd0bf9}";

    /**
     * Following modifiers are for sent*Event() except sendNative*Event().
     * NOTE: MODIFIER_ALT, MODIFIER_CONTROL, MODIFIER_SHIFT and MODIFIER_META
     *       are must be same values as Event_Binding::*_MASK for backward
     *       compatibility.
     */
    MODIFIER_ALT: 1;

    MODIFIER_CONTROL: 2;

    MODIFIER_SHIFT: 4;

    MODIFIER_META: 8;

    MODIFIER_ALTGRAPH: 16;

    MODIFIER_CAPSLOCK: 32;

    MODIFIER_FN: 64;

    MODIFIER_FNLOCK: 128;

    MODIFIER_NUMLOCK: 256;

    MODIFIER_SCROLLLOCK: 512;

    MODIFIER_SYMBOL: 1024;

    MODIFIER_SYMBOLLOCK: 2048;

    MODIFIER_OS: 4096;

    /** Synthesize a wheel event for a window. The event types supported is only
     *  wheel.
     *
     * Events are sent in coordinates offset by aX and aY from the window.
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * @param aX                 x offset in CSS pixels
     * @param aY                 y offset in CSS pixels
     * @param aDeltaX            deltaX value.
     * @param aDeltaY            deltaY value.
     * @param aDeltaZ            deltaZ value.
     * @param aDeltaMode         deltaMode value which must be one of the
     *                           WheelEvent DOM_DELTA_* constants.
     * @param aModifiers         modifiers pressed, using constants defined as
     *                           MODIFIER_*
     * @param aLineOrPageDeltaX  If you set this value non-zero for
     *                           DOM_DELTA_PIXEL event, EventStateManager will
     *                           dispatch NS_MOUSE_SCROLL event for horizontal
     *                           scroll.
     * @param aLineOrPageDeltaY  If you set this value non-zero for
     *                           DOM_DELTA_PIXEL event, EventStateManager will
     *                           dispatch NS_MOUSE_SCROLL event for vertical
     *                           scroll.
     * @param aOptions           Set following flags.
     */
    WHEEL_EVENT_CAUSED_BY_NO_LINE_OR_PAGE_DELTA_DEVICE: 1;

    WHEEL_EVENT_CAUSED_BY_MOMENTUM: 2;

    WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS: 4;

    WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO: 16;

    WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE: 32;

    WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE: 64;

    WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO: 256;

    WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE: 512;

    WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE: 1024;

    /**
     * The values for sendNativeMouseScrollEvent's aAdditionalFlags.
     */
    /**
     * If MOUSESCROLL_PREFER_WIDGET_AT_POINT is set, widget will dispatch
     * the event to a widget which is under the cursor.  Otherwise, dispatch to
     * a default target on the platform.  E.g., on Windows, it's focused window.
     */
    MOUSESCROLL_PREFER_WIDGET_AT_POINT: 1;

    /**
     * Interpret the scroll delta values as lines rather than pixels.
     */
    MOUSESCROLL_SCROLL_LINES: 2;

    /**
     * The platform specific values of aAdditionalFlags.  Must be over 0x00010000.
     */
    /**
     * If MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL is set and aNativeMessage is
     * WM_VSCROLL or WM_HSCROLL, widget will set the window handle to the lParam
     * instead of NULL.
     */
    MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL: 65536;

    /**
     * Touch states for sendNativeTouchPoint. These values match
     * nsIWidget's TouchPointerState.
     */
    TOUCH_HOVER: 1;

    TOUCH_CONTACT: 2;

    TOUCH_REMOVE: 4;

    TOUCH_CANCEL: 8;

    /**
     * Scroll the visual viewport to the given coordinates, relative to the
     * document origin.
     * Only applicable to the window associated with the root content document.
     * Note: this does not take effect right away. Rather, the visual scroll
     *       request is sent to APZ with the next transaction, and will be
     *       reflected in the main thread with the subsequent APZ repaint request.
     * Please see the caveats mentioned at PresShell::ScrollToVisual(), and
     * request APZ review if adding a new call to this.
     */
    UPDATE_TYPE_RESTORE: 0;

    UPDATE_TYPE_MAIN_THREAD: 1;

    SCROLL_MODE_INSTANT: 0;

    SCROLL_MODE_SMOOTH: 1;

    FLUSH_NONE: -1;

    FLUSH_STYLE: 0;

    FLUSH_LAYOUT: 1;

    FLUSH_DISPLAY: 2;

    /**
     * WARNING: These values must be same as nsIWidget's values.
     */
    /**
     * DISABLED means users cannot use IME completely.
     * Note that this state is *not* same as |ime-mode: disabled;|.
     */
    IME_STATUS_DISABLED: 0;

    /**
     * ENABLED means users can use all functions of IME. This state is same as
     * |ime-mode: normal;|.
     */
    IME_STATUS_ENABLED: 1;

    /**
     * PASSWORD means users cannot use most functions of IME. But on GTK2,
     * users can use "Simple IM" which only supports dead key inputting.
     * The behavior is same as the behavior of the native password field.
     * This state is same as |ime-mode: disabled;|.
     */
    IME_STATUS_PASSWORD: 2;

    /**
     * PLUGIN means a plug-in has focus. At this time we should not touch to
     * controlling the IME state.
     */
    IME_STATUS_PLUGIN: 3;

    /**
     * If sendQueryContentEvent()'s aAdditionalFlags argument is
     * QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK, plain text generated from content
     * is created with "\n".
     * Otherwise, platform dependent.  E.g., on Windows, "\r\n" is used.
     * aOffset and aLength are offset and length in/of the plain text content.
     * This flag also affects the result values such as offset, length and string.
     */
    QUERY_CONTENT_FLAG_USE_NATIVE_LINE_BREAK: 0;

    QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK: 1;

    /**
     * sendQueryContentEvent()'s aAdditionalFlags may have one of following
     * flags when aType is QUERY_SELECTED_TEXT.  If one of them is set,
     * the result is the first range of the selection type.  See also
     * nsISelectionController::SELECTION_*.
     */
    QUERY_CONTENT_FLAG_SELECTION_SPELLCHECK: 2;

    QUERY_CONTENT_FLAG_SELECTION_IME_RAWINPUT: 4;

    QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDRAWTEXT: 8;

    QUERY_CONTENT_FLAG_SELECTION_IME_CONVERTEDTEXT: 16;

    QUERY_CONTENT_FLAG_SELECTION_IME_SELECTEDCONVERTEDTEXT: 32;

    QUERY_CONTENT_FLAG_SELECTION_ACCESSIBILITY: 64;

    QUERY_CONTENT_FLAG_SELECTION_FIND: 128;

    QUERY_CONTENT_FLAG_SELECTION_URLSECONDARY: 256;

    QUERY_CONTENT_FLAG_SELECTION_URLSTRIKEOUT: 512;

    /**
     * One of sendQueryContentEvent()'s aAdditionalFlags.  If this is specified,
     * aOffset is relative to start of selection or composition.
     * Note that this is supported only when QUERY_CONTENT_FLAG_USE_XP_LINE_BREAK
     * is not specified for now.
     */
    QUERY_CONTENT_FLAG_OFFSET_RELATIVE_TO_INSERTION_POINT: 1024;

    /**
     * QUERY_SELECTED_TEXT queries the first selection range's information.
     *
     * @param aOffset   Not used.
     * @param aLength   Not used.
     * @param aX        Not used.
     * @param aY        Not used.
     *
     * @return offset, reversed and text properties of the result are available.
     */
    QUERY_SELECTED_TEXT: 3200;

    /**
     * QUERY_TEXT_CONTENT queries the text at the specified range.
     *
     * @param aOffset   The first character's offset.  0 is the first character.
     * @param aLength   The length of getting text.  If the aLength is too long,
     *                  the result text is shorter than this value.
     * @param aX        Not used.
     * @param aY        Not used.
     *
     * @return text property of the result is available.
     */
    QUERY_TEXT_CONTENT: 3201;

    /**
     * QUERY_CARET_RECT queries the (collapsed) caret rect of the offset.
     * If the actual caret is there at the specified offset, this returns the
     * actual caret rect.  Otherwise, this guesses the caret rect from the
     * metrics of the text.
     *
     * @param aOffset   The caret offset.  0 is the left side of the first
     *                  caracter in LTR text.
     * @param aLength   Not used.
     * @param aX        Not used.
     * @param aY        Not used.
     *
     * @return left, top, width and height properties of the result are available.
     *         The left and the top properties are offset in the client area of
     *         the DOM window.
     */
    QUERY_CARET_RECT: 3203;

    /**
     * QUERY_TEXT_RECT queries the specified text's rect.
     *
     * @param aOffset   The first character's offset.  0 is the first character.
     * @param aLength   The length of getting text.  If the aLength is too long,
     *                  the extra length is ignored.
     * @param aX        Not used.
     * @param aY        Not used.
     *
     * @return left, top, width and height properties of the result are available.
     *         The left and the top properties are offset in the client area of
     *         the DOM window.
     */
    QUERY_TEXT_RECT: 3204;

    /**
     * QUERY_TEXT_RECT queries the focused editor's rect.
     *
     * @param aOffset   Not used.
     * @param aLength   Not used.
     * @param aX        Not used.
     * @param aY        Not used.
     *
     * @return left, top, width and height properties of the result are available.
     */
    QUERY_EDITOR_RECT: 3205;

    /**
     * QUERY_CHARACTER_AT_POINT queries the character information at the
     * specified point.  The point is offset in the window.
     * NOTE: If there are some panels at the point, this method send the query
     * event to the panel's widget automatically.
     *
     * @param aOffset   Not used.
     * @param aLength   Not used.
     * @param aX        X offset in the widget.
     * @param aY        Y offset in the widget.
     *
     * @return offset, notFound, left, top, width and height properties of the
     *         result are available.
     */
    QUERY_CHARACTER_AT_POINT: 3208;

    /**
     * QUERY_TEXT_RECT_ARRAY queries the rects per character
     *
     * @param aOffset   The first character's offset.  0 is the first character.
     * @param aLength   The length of getting text.  If the aLength is too long,
     *                  the extra length is ignored.
     * @param aX        Not used.
     * @param aY        Not used.
     */
    QUERY_TEXT_RECT_ARRAY: 3209;

    /**
     * If sendQueryContentEvent()'s aAdditionalFlags argument is
     * SELECTION_SET_FLAG_USE_NATIVE_LINE_BREAK, aOffset and aLength are offset
     * and length in/of plain text generated from content is created with "\n".
     * Otherwise, platform dependent.  E.g., on Windows, "\r\n" is used.
     */
    SELECTION_SET_FLAG_USE_NATIVE_LINE_BREAK: 0;

    SELECTION_SET_FLAG_USE_XP_LINE_BREAK: 1;

    /**
     * If SELECTION_SET_FLAG_REVERSE is set, the selection is set from
     * |aOffset + aLength| to |aOffset|.  Otherwise, it's set from |aOffset| to
     * |aOffset + aLength|.
     */
    SELECTION_SET_FLAG_REVERSE: 2;

    SELECT_CHARACTER: 0;

    SELECT_CLUSTER: 1;

    SELECT_WORD: 2;

    SELECT_LINE: 3;

    SELECT_BEGINLINE: 4;

    SELECT_ENDLINE: 5;

    SELECT_PARAGRAPH: 6;

    SELECT_WORDNOSPACE: 7;

    /**
     * Returns all the audio input/output devices.
     */
    AUDIO_INPUT: 0;

    AUDIO_OUTPUT: 1;

    AGENT_SHEET: 0;

    USER_SHEET: 1;

    AUTHOR_SHEET: 2;

    DEFAULT_MOUSE_POINTER_ID: 0;

    DEFAULT_PEN_POINTER_ID: 1;

    DEFAULT_TOUCH_POINTER_ID: 2;

    MOUSE_BUTTON_LEFT_BUTTON: 0;

    MOUSE_BUTTON_MIDDLE_BUTTON: 1;

    MOUSE_BUTTON_RIGHT_BUTTON: 2;

    MOUSE_BUTTONS_NO_BUTTON: 0;

    MOUSE_BUTTONS_LEFT_BUTTON: 1;

    MOUSE_BUTTONS_RIGHT_BUTTON: 2;

    MOUSE_BUTTONS_MIDDLE_BUTTON: 4;

    MOUSE_BUTTONS_4TH_BUTTON: 8;

    MOUSE_BUTTONS_5TH_BUTTON: 16;

    MOUSE_BUTTONS_NOT_SPECIFIED: -1;

    DIRECTION_LTR: 0;

    DIRECTION_RTL: 1;

    DIRECTION_NOT_SET: 2;
  }

  export interface nsIDOMWindowUtils extends nsISupports {

    /**
     * Image animation mode of the window. When this attribute's value
     * is changed, the implementation should set all images in the window
     * to the given value. That is, when set to kDontAnimMode, all images
     * will stop animating. The attribute's value must be one of the
     * animationMode values from imgIContainer.
     * @note Images may individually override the window's setting after
     *       the window's mode is set. Therefore images given different modes
     *       since the last setting of the window's mode may behave
     *       out of line with the window's overall mode.
     * @note The attribute's value is the window's overall mode. It may
     *       for example continue to report kDontAnimMode after all images
     *       have subsequently been individually animated.
     * @note Only images immediately in this window are affected;
     *       this is not recursive to subwindows.
     * @see imgIContainer
     */
    imageAnimationMode: number;

    /**
     * Whether the charset of the window's current document has been forced by
     * the user.
     * Cannot be accessed from unprivileged context (not content-accessible)
     */
    readonly docCharsetIsForced: boolean;

    /**
     * Return the conversion of a physical millimeter in CSS pixels.
     */
    readonly physicalMillimeterInCSSPixels: number;

    /**
     * Function to get metadata associated with the window's current document
     * @param aName the name of the metadata.  This should be all lowercase.
     * @return the value of the metadata, or the empty string if it's not set
     *
     * Will throw a DOM security error if called without chrome privileges.
     */
    readonly getDocumentMetadata: (aName: IDLAString) => IDLAString;

    /**
     * Force a synchronous layer transaction for this window if necessary.
     */
    readonly updateLayerTree: () => void;

    /**
     * Get the last used layer transaction id for this window's refresh driver.
     */
    readonly lastTransactionId: number;

    /**
     * Information retrieved from the <meta name="viewport"> tag.
     * See Document::GetViewportInfo for more information.
     */
    readonly getViewportInfo: (aDisplayWidth: number, aDisplayHeight: number, aDefaultZoom: Out<number>, aAllowZoom: Out<boolean>, aMinZoom: Out<number>, aMaxZoom: Out<number>, aWidth: Out<number>, aHeight: Out<number>, aAutoSize: Out<boolean>) => void;

    /**
     * Information about the window size in device pixels.
     */
    readonly getContentViewerSize: (aDisplayWidth: Out<number>, aDisplayHeight: Out<number>) => void;

    /**
     * For any scrollable element, this allows you to override the
     * visible region and draw more than what is visible, which is
     * useful for asynchronous drawing. The "displayport" will be
     * <xPx, yPx, widthPx, heightPx> in units of CSS pixels,
     * regardless of the size of the enclosing container.  This
     * will *not* trigger reflow.
     *
     * For the root scroll area, pass in the root document element.
     * For scrollable elements, pass in the container element (for
     * instance, the element with overflow: scroll).
     *
     * <x, y> is relative to the top-left of what would normally be
     * the visible area of the element. This means that the pixels
     * rendered to the displayport take scrolling into account,
     * for example.
     *
     * It's legal to set a displayport that extends beyond the overflow
     * area in any direction (left/right/top/bottom).
     *
     * It's also legal to set a displayport that extends beyond the
     * area's bounds.  No pixels are rendered outside the area bounds.
     *
     * The caller of this method must have chrome privileges.
     *
     * Calling this will always force a recomposite, so it should be
     * avoided if at all possible. Client code should do checks before
     * calling this so that duplicate sets are not made with the same
     * displayport.
     *
     * aPriority is recorded along with the displayport rectangle. If this
     * method is called with a lower priority than the current priority, the
     * call is ignored.
     */
    readonly setDisplayPortForElement: (aXPx: number, aYPx: number, aWidthPx: number, aHeightPx: number, aElement: WebIDL.Element, aPriority: number) => void;

    /**
     * An alternate way to represent a displayport rect as a set of margins and a
     * base rect to apply those margins to. A consumer of pixels may ask for as
     * many extra pixels as it would like in each direction. Layout then sets
     * the base rect to the "visible rect" of the element, which is just the
     * subrect of the element that is drawn (it does not take in account content
     * covering the element).
     *
     * If both a displayport rect and displayport margins with corresponding base
     * rect are set with the same priority then the margins will take precendence.
     *
     * Specifying an alignment value will ensure that after the base rect has
     * been expanded by the displayport margins, it will be further expanded so
     * that each edge is located at a multiple of the "alignment" value.
     *
     * Note that both the margin values and alignment are treated as values in
     * ScreenPixels. Refer to layout/base/Units.h for a description of this unit.
     * The base rect values are in app units.
     */
    readonly setDisplayPortMarginsForElement: (aLeftMargin: number, aTopMargin: number, aRightMargin: number, aBottomMargin: number, aElement: WebIDL.Element, aPriority: number) => void;

    readonly setDisplayPortBaseForElement: (aX: number, aY: number, aWidth: number, aHeight: number, aElement: WebIDL.Element) => void;

    /**
     * If |aElement| is a scroll container, returns the amount of layout
     * space taken up by its scrollbars (that is, the width of the vertical
     * scrollbar and the height of the horizontal scrollbar) in CSS pixels;
     * otherwise returns zero.
     *
     * Note that on some platforms, scrollbars don't take up layout space
     * ("overlay scrollbars"). On such platforms, the returned sizes are
     * always zero.
     */
    readonly getScrollbarSizes: (aElement: WebIDL.Element, aVerticalScrollbarWidth: Out<number>, aHorizontalScrollbarHeight: Out<number>) => void;

    /**
     * Get/set the resolution at which rescalable web content is drawn.
     *
     * Setting a new resolution does *not* trigger reflow.  This API is
     * entirely separate from textZoom and fullZoom; a resolution scale
     * can be applied together with both textZoom and fullZoom.
     *
     * The effect of this API is for gfx code to allocate more or fewer
     * pixels for rescalable content by a factor of |resolution| in
     * both dimensions.
     *
     * In addition, the content is scaled by the amount of the resolution,
     * so that it is displayed at a correspondingly larger or smaller size,
     * without the need for the caller to set an additional transform.
     *
     * This can be used to implement a non-reflowing scale-zoom, e.g.
     * for pinch-zoom on mobile platforms.
     *
     * The caller of this method must have chrome privileges.
     */
    readonly setResolutionAndScaleTo: (aResolution: number) => void;

    readonly getResolution: () => number;

    /**
     * Set a resolution on the presShell which is the "restored" from history.
     * The display dimensions are compared to their current values and used
     * to scale the resolution value if necessary, e.g. if the device was
     * rotated between saving and restoring of the session data.
     * This resolution should be used when painting for the first time. Calling
     * this too late may have no effect.
     */
    readonly setRestoreResolution: (aResolution: number, aDisplayWidth: number, aDisplayHeight: number) => void;

    /**
     * Whether the next paint should be flagged as the first paint for a document.
     * This gives a way to track the next paint that occurs after the flag is
     * set. The flag gets cleared after the next paint.
     *
     * Can only be accessed with chrome privileges.
     */
    isFirstPaint: boolean;

    readonly getPresShellId: () => number;

    /** Synthesize a mouse event. The event types supported are:
     *    mousedown, mouseup, mousemove, mouseover, mouseout, mousecancel,
     *    contextmenu, MozMouseHittest
     *
     * Events are sent in coordinates offset by aX and aY from the window.
     *
     * Note that additional events may be fired as a result of this call. For
     * instance, typically a click event will be fired as a result of a
     * mousedown and mouseup in sequence.
     *
     * Normally at this level of events, the mouseover and mouseout events are
     * only fired when the window is entered or exited. For inter-element
     * mouseover and mouseout events, a movemove event fired on the new element
     * should be sufficient to generate the correct over and out events as well.
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * The event is dispatched via the toplevel window, so it could go to any
     * window under the toplevel window, in some cases it could never reach this
     * window at all.
     *
     * NOTE: mousecancel is used to represent the vanishing of an input device
     * such as a pen leaving its digitizer by synthesizing a WidgetMouseEvent,
     * whose mMessage is eMouseExitFromWidget and mExitFrom is
     * WidgetMouseEvent::eTopLevel.
     *
     * @param aType event type
     * @param aX x offset in CSS pixels
     * @param aY y offset in CSS pixels
     * @param aButton button to synthesize
     * @param aClickCount number of clicks that have been performed
     * @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
     * @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
     *                           during dispatch
     * @param aPressure touch input pressure: 0.0 -> 1.0
     * @param aInputSourceArg input source, see MouseEvent for values,
     *        defaults to mouse input.
     * @param aIsDOMEventSynthesized controls Event.isSynthesized value
     *                               that helps identifying test related events,
     *                               defaults to true
     * @param aIsWidgetEventSynthesized controls WidgetMouseEvent.mReason value
     *                                  defaults to false (WidgetMouseEvent::eReal)
     * @param aIdentifier A unique identifier for the pointer causing the event,
     *                    defaulting to nsIDOMWindowUtils::DEFAULT_MOUSE_POINTER_ID.
     *
     * returns true if the page called prevent default on this event
     */
    readonly sendMouseEvent: (aType: IDLAString, aX: number, aY: number, aButton: number, aClickCount: number, aModifiers: number, aIgnoreRootScrollFrame?: boolean, aPressure?: number, aInputSourceArg?: number, aIsDOMEventSynthesized?: boolean, aIsWidgetEventSynthesized?: boolean, aButtons?: number, aIdentifier?: number) => boolean;

    /** Synthesize a touch event. The event types supported are:
     *    touchstart, touchend, touchmove, and touchcancel
     *
     * Events are sent in coordinates offset by aX and aY from the window.
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * The event is dispatched via the toplevel window, so it could go to any
     * window under the toplevel window, in some cases it could never reach this
     * window at all.
     *
     * @param aType event type
     * @param xs array of offsets in CSS pixels for each touch to be sent
     * @param ys array of offsets in CSS pixels for each touch to be sent
     * @param rxs array of radii in CSS pixels for each touch to be sent
     * @param rys array of radii in CSS pixels for each touch to be sent
     * @param rotationAngles array of angles in degrees for each touch to be sent
     * @param forces array of forces (floats from 0 to 1) for each touch to be sent
     * @param count number of touches in this set
     * @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
     * @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
     *                           during dispatch
     *
     * returns true if the page called prevent default on this touch event
     */
    readonly sendTouchEvent: (aType: IDLAString, aIdentifiers: number[], aXs: number[], aYs: number[], aRxs: number[], aRys: number[], aRotationAngles: number[], aForces: number[], aModifiers: number, aIgnoreRootScrollFrame?: boolean) => boolean;

    /** The same as sendMouseEvent but ensures that the event is dispatched to
     *  this DOM window or one of its children.
     */
    readonly sendMouseEventToWindow: (aType: IDLAString, aX: number, aY: number, aButton: number, aClickCount: number, aModifiers: number, aIgnoreRootScrollFrame?: boolean, aPressure?: number, aInputSourceArg?: number, aIsDOMEventSynthesized?: boolean, aIsWidgetEventSynthesized?: boolean, aButtons?: number, aIdentifier?: number) => void;

    /** The same as sendTouchEvent but ensures that the event is dispatched to
     *  this DOM window or one of its children.
     */
    readonly sendTouchEventToWindow: (aType: IDLAString, aIdentifiers: number[], aXs: number[], aYs: number[], aRxs: number[], aRys: number[], aRotationAngles: number[], aForces: number[], aModifiers: number, aIgnoreRootScrollFrame?: boolean) => boolean;

    readonly sendWheelEvent: (aX: number, aY: number, aDeltaX: number, aDeltaY: number, aDeltaZ: number, aDeltaMode: number, aModifiers: number, aLineOrPageDeltaX: number, aLineOrPageDeltaY: number, aOptions: number) => void;

    /**
     * See nsIWidget::SynthesizeNativeKeyEvent
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * When you use this for tests, use the constants defined in NativeKeyCodes.js
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a "keyevent"
     * topic.
     */
    readonly sendNativeKeyEvent: (aNativeKeyboardLayout: number, aNativeKeyCode: number, aModifierFlags: number, aCharacters: IDLAString, aUnmodifiedCharacters: IDLAString, aObserver?: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * See nsIWidget::SynthesizeNativeMouseEvent
     *
     * Will be called on the widget that contains aElement.
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a "mouseevent"
     * topic.
     */
    readonly sendNativeMouseEvent: (aScreenX: number, aScreenY: number, aNativeMessage: number, aModifierFlags: number, aElement: WebIDL.Element, aObserver?: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * See nsIWidget::SynthesizeNativeMouseMove and sendNativeMouseEvent
     */
    readonly sendNativeMouseMove: (aScreenX: number, aScreenY: number, aElement: WebIDL.Element, aObserver?: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * Suppress animations that are applied to a window by OS when
     * resizing, moving, changing size mode, ...
     */
    readonly suppressAnimation: (aSuppress: boolean) => void;

    /**
     * See nsIWidget::SynthesizeNativeMouseScrollEvent
     *
     * Will be called on the widget that contains aElement.
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a
     * "mousescrollevent" topic.
     *
     * @param aNativeMessage
     *   On Windows:  WM_MOUSEWHEEL (0x020A), WM_MOUSEHWHEEL(0x020E),
     *                WM_VSCROLL (0x0115) or WM_HSCROLL (0x114).
     */
    readonly sendNativeMouseScrollEvent: (aScreenX: number, aScreenY: number, aNativeMessage: number, aDeltaX: number, aDeltaY: number, aDeltaZ: number, aModifierFlags: number, aAdditionalFlags: number, aElement: WebIDL.Element, aObserver?: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * Create a new or update an existing touch point on the digitizer.
     * To trigger os level gestures, individual touch points should
     * transition through a complete set of touch states which should be
     * sent as individual calls. For example:
     * tap - msg1:TOUCH_CONTACT, msg2:TOUCH_REMOVE
     * drag - msg1-n:TOUCH_CONTACT (moving), msgn+1:TOUCH_REMOVE
     * hover drag - msg1-n:TOUCH_HOVER (moving), msgn+1:TOUCH_REMOVE
     *
     * Widget support: Windows 8.0+, Winrt/Win32. Other widgets will throw.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a "touchpoint"
     * topic.
     *
     * @param aPointerId The touch point id to create or update.
     * @param aTouchState one or more of the touch states listed above
     * @param aScreenX, aScreenY screen coords of this event
     * @param aPressure 0.0 -> 1.0 float val indicating pressure
     * @param aOrientation 0 -> 359 degree value indicating the
     * orientation of the pointer. Use 90 for normal taps.
     */
    readonly sendNativeTouchPoint: (aPointerId: number, aTouchState: number, aScreenX: number, aScreenY: number, aPressure: number, aOrientation: number, aObserver?: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * Simulates native touch based taps on the input digitizer. Events
     * triggered by this call are injected at the os level. Events do not
     * bypass widget level input processing and as such can be used to
     * test widget event logic and async pan-zoom controller functionality.
     * Cannot be accessed from an unprivileged context.
     *
     * Long taps (based on the aLongTap parameter) will be completed
     * asynchrnously after the call returns. Long tap delay is based on
     * the ui.click_hold_context_menus.delay pref or 1500 msec if pref
     * is not set.
     *
     * Widget support: Windows 8.0+, Winrt/Win32. Other widgets will
     * throw.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified, with a "touchtap"
     * topic.
     *
     * @param aScreenX, aScreenY screen coords of this event
     * @param aLongTap true if the tap should be long, false for a short
     * tap.
     */
    readonly sendNativeTouchTap: (aScreenX: number, aScreenY: number, aLongTap: boolean, aObserver?: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * Cancel any existing touch points or long tap delays. Calling this is safe
     * even if you're sure there aren't any pointers recorded. You should call
     * this when tests shut down to reset the digitizer driver. Not doing so can
     * leave the digitizer in an undetermined state which can screw up subsequent
     * tests and native input.
     *
     * NOTE: The synthesized native event will be fired asynchronously, and upon
     * completion the observer, if provided, will be notified with a "cleartouch"
     * topic.
     */
    readonly clearNativeTouchSequence: (aObserver?: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * See nsIWidget::ActivateNativeMenuItemAt
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     */
    readonly activateNativeMenuItemAt: (indexString: IDLAString) => void;

    /**
     * See nsIWidget::ForceUpdateNativeMenuAt
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     */
    readonly forceUpdateNativeMenuAt: (indexString: IDLAString) => void;

    /**
     * Returns the current selection as plaintext. Note that the result may be
     * different from the result of sendQueryContentEvent(QUERY_SELECTED_TEXT).
     * This result is computed by native API with transferable data. In other
     * words, when the OS treats the selection as plaintext, it treats current
     * selection as this result.
     */
    readonly GetSelectionAsPlaintext: () => IDLAString;

    /**
     * Force a garbage collection followed by a cycle collection.
     *
     * Will throw a DOM security error if called without chrome privileges in
     * non-debug builds. Available to all callers in debug builds.
     *
     * @param aListener listener that receives information about the CC graph
     */
    readonly garbageCollect: (aListener?: (nsICycleCollectorListener | null)) => void;

    /**
     * Force a cycle collection without garbage collection.
     *
     * Will throw a DOM security error if called without chrome privileges in
     * non-debug builds. Available to all callers in debug builds.
     *
     * @param aListener listener that receives information about the CC graph
     */
    readonly cycleCollect: (aListener?: (nsICycleCollectorListener | null)) => void;

    /**
     * Trigger whichever GC or CC timer is currently active and waiting to fire.
     * Don't do this too much for initiating heavy actions, like the start of a IGC.
     */
    readonly runNextCollectorTimer: () => void;

    /** Synthesize a simple gesture event for a window. The event types
     *  supported are: MozSwipeGestureMayStart, MozSwipeGestureStart,
     *  MozSwipeGestureUpdate, MozSwipeGestureEnd, MozSwipeGesture,
     *  MozMagnifyGestureStart, MozMagnifyGestureUpdate, MozMagnifyGesture,
     *  MozRotateGestureStart, MozRotateGestureUpdate, MozRotateGesture,
     *  MozPressTapGesture, MozTapGesture, and MozEdgeUIGesture.
     *
     * Cannot be accessed from unprivileged context (not
     * content-accessible) Will throw a DOM security error if called
     * without chrome privileges.
     *
     * @param aType event type
     * @param aX x offset in CSS pixels
     * @param aY y offset in CSS pixels
     * @param aDirection direction, using constants defined in SimpleGestureEvent.webidl
     * @param aDelta  amount of magnification or rotation for magnify and rotation events
     * @param aModifiers modifiers pressed, using constants defined in Event.webidl
     * @param aClickCount For tap gestures, the number of taps.
     */
    readonly sendSimpleGestureEvent: (aType: IDLAString, aX: number, aY: number, aDirection: number, aDelta: number, aModifiers: number, aClickCount?: number) => void;

    /**
     * Retrieve the element at point aX, aY in the window's document.
     *
     * @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
     *        frame when retrieving the element. If false, this method returns
     *        null for coordinates outside of the viewport.
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     */
    readonly elementFromPoint: (aX: number, aY: number, aIgnoreRootScrollFrame: boolean, aFlushLayout: boolean) => WebIDL.Element;

    /**
     * Retrieve all nodes that intersect a rect in the window's document.
     *
     * @param aX x reference for the rectangle in CSS pixels
     * @param aY y reference for the rectangle in CSS pixels
     * @param aTopSize How much to expand up the rectangle
     * @param aRightSize How much to expand right the rectangle
     * @param aBottomSize How much to expand down the rectangle
     * @param aLeftSize How much to expand left the rectangle
     * @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
     *        frame when retrieving the element. If false, this method returns
     *        null for coordinates outside of the viewport.
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     * @param aOnlyVisible Set to true if you only want nodes that pass a visibility
     *        hit test.
     */
    readonly nodesFromRect: (aX: number, aY: number, aTopSize: number, aRightSize: number, aBottomSize: number, aLeftSize: number, aIgnoreRootScrollFrame: boolean, aFlushLayout: boolean, aOnlyVisible: boolean) => WebIDL.NodeList;

    /**
     * Get a list of nodes that have meaningful textual content to
     * be translated. The implementation of this algorithm is in flux
     * as we experiment and refine which approach works best.
     *
     * This method requires chrome privileges.
     */
    readonly getTranslationNodes: (aRoot: WebIDL.Node) => (nsITranslationNodeList | null);

    /**
     * Compare the two canvases, returning the number of differing pixels and
     * the maximum difference in a channel.  This will throw an error if
     * the dimensions of the two canvases are different.
     *
     * This method requires chrome privileges.
     */
    readonly compareCanvases: (aCanvas1: (nsISupports | null), aCanvas2: (nsISupports | null), aMaxDifference: Out<number>) => number;

    /**
     * Returns true if a MozAfterPaint event has been queued but not yet
     * fired.
     */
    readonly isMozAfterPaintPending: boolean;

    /**
     * Suppresses/unsuppresses user initiated event handling in window's document
     * and subdocuments.
     *
     * @throw NS_ERROR_DOM_SECURITY_ERR if called without chrome privileges and
     *        NS_ERROR_FAILURE if window doesn't have a document.
     */
    readonly suppressEventHandling: (aSuppress: boolean) => void;

    /**
     * Disable or enable non synthetic test mouse events on *all* windows.
     *
     * Cannot be accessed from unprivileged context (not content-accessible).
     * Will throw a DOM security error if called without chrome privileges.
     *
     * @param aDisable  If true, disable all non synthetic test mouse events
     *               on all windows.  Otherwise, enable them.
     */
    readonly disableNonTestMouseEvents: (aDisable: boolean) => void;

    /**
     * Returns the scroll position of the window's currently loaded document.
     *
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     * @see nsIDOMWindow::scrollX/Y
     */
    readonly getScrollXY: (aFlushLayout: boolean, aScrollX: Out<number>, aScrollY: Out<number>) => void;

    /**
     * Returns the scroll position of the window's currently loaded document.
     *
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     * @see nsIDOMWindow::scrollX/Y
     */
    readonly getScrollXYFloat: (aFlushLayout: boolean, aScrollX: Out<number>, aScrollY: Out<number>) => void;

    /**
     * Returns the scrollbar width of the window's scroll frame.
     *
     * @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
     */
    readonly getScrollbarSize: (aFlushLayout: boolean, aWidth: Out<number>, aHeight: Out<number>) => void;

    /**
     * Returns the given element's bounds without flushing pending layout changes.
     */
    readonly getBoundsWithoutFlushing: (aElement: WebIDL.Element) => WebIDL.DOMRect;

    readonly scrollToVisual: (aOffsetX: number, aOffsetY: number, aUpdateType: number, aScrollMode: number) => void;

    /**
     * Returns the offset of the window's visual viewport relative to the
     * layout viewport.
     */
    readonly getVisualViewportOffsetRelativeToLayoutViewport: (aOffsetX: Out<number>, aOffsetY: Out<number>) => void;

    /**
     * Returns the scroll position of the window's visual viewport.
     */
    readonly getVisualViewportOffset: (aOffsetX: Out<number>, aOffsetY: Out<number>) => void;

    /**
     * Sets the maximum height of the dynamic toolbar in Screen pixel units.
     */
    readonly setDynamicToolbarMaxHeight: (aHeightInScreen: number) => void;

    /**
     * Returns true if a flush of the given type is needed.
     */
    readonly needsFlush: (aFlushtype: number) => boolean;

    /**
     * Flush pending layout-type notification without flushing throttled
     * animations.
     */
    readonly flushLayoutWithoutThrottledAnimations: () => void;

    /**
     * Returns the bounds of the window's currently loaded document. This will
     * generally be (0, 0, pageWidth, pageHeight) but in some cases (e.g. RTL
     * documents) may have a negative left value.
     */
    readonly getRootBounds: () => WebIDL.DOMRect;

    /**
     * Get IME open state. TRUE means 'Open', otherwise, 'Close'.
     * This property works only when IMEEnabled is IME_STATUS_ENABLED.
     */
    readonly IMEIsOpen: boolean;

    /**
     * Get IME status, see above IME_STATUS_* definitions.
     */
    readonly IMEStatus: number;

    /**
     * Get the number of screen pixels per CSS pixel.
     */
    readonly screenPixelsPerCSSPixel: number;

    /**
     * Get the current zoom factor.
     * This is _approximately_ the same as nsIContentViewer.fullZoom,
     * but takes into account Gecko's quantization of the zoom factor, which is
     * implemented by adjusting the (integer) number of appUnits per devPixel.
     */
    readonly fullZoom: number;

    /**
     * Dispatches aEvent as a synthesized trusted event for tests via the
     * PresShell object of the window's document.
     * The event is dispatched to aTarget, which should be an object
     * which implements nsIContent interface (#element, #text, etc).
     *
     * Cannot be accessed from unprivileged context (not
     * content-accessible) Will throw a DOM security error if called
     * without chrome privileges.
     *
     * @note Event handlers won't get aEvent as parameter, but a similar event.
     *       Also, aEvent should not be reused.
     */
    readonly dispatchDOMEventViaPresShellForTesting: (aTarget: WebIDL.Node, aEvent: WebIDL.Event) => boolean;

    /**
     * Sets WidgetEvent::mFlags::mOnlyChromeDispatch to true to ensure that
     * the event is propagated only to chrome.
     * Event's .target property will be aTarget.
     * Returns the same value as what EventTarget.dispatchEvent does.
     */
    readonly dispatchEventToChromeOnly: (aTarget: WebIDL.EventTarget, aEvent: WebIDL.Event) => boolean;

    /**
     * Returns the real classname (possibly of the mostly-transparent security
     * wrapper) of aObj.
     */
    readonly getClassName: (aObject: IDLjsval) => string;

    /**
     * Generate a content command event.
     *
     * Cannot be accessed from unprivileged context (not content-accessible)
     * Will throw a DOM security error if called without chrome privileges.
     *
     * @param aType Type of command content event to send.  Can be one of "cut",
     *        "copy", "paste", "delete", "undo", "redo", or "pasteTransferable".
     * @param aTransferable an instance of nsITransferable when aType is
     *        "pasteTransferable"
     */
    readonly sendContentCommandEvent: (aType: IDLAString, aTransferable?: (nsITransferable | null)) => void;

    /**
     * Synthesize a query content event. Note that the result value returned here
     * is in LayoutDevice pixels rather than CSS pixels.
     *
     * @param aType  One of the following const values.  And see also each comment
     *               for the other parameters and the result.
     * @param aAdditionalFlags See the description of QUERY_CONTENT_FLAG_*.
     */
    readonly sendQueryContentEvent: (aType: number, aOffset: number, aLength: number, aX: number, aY: number, aAdditionalFlags?: number) => (nsIQueryContentEventResult | null);

    /**
     * Called when the remote child frame has changed its fullscreen state,
     * when entering fullscreen, and when the origin which is fullscreen changes.
     * aFrameElement is the iframe element which contains the child-process
     * fullscreen document.
     */
    readonly remoteFrameFullscreenChanged: (aFrameElement: WebIDL.Element) => void;

    /**
     * Called when the remote frame has popped all fullscreen elements off its
     * stack, so that the operation can complete on the parent side.
     */
    readonly remoteFrameFullscreenReverted: () => void;

    /**
     * Calls the document to handle any pending fullscreen requests.
     * It is called when the parent document has entered fullscreen, and
     * we want to put the current document into fullscreen as well.
     * The return value indicates whether there is any fullscreen request
     * handled by this call.
     */
    readonly handleFullscreenRequests: () => boolean;

    /**
     * Called when the child frame has fully exit fullscreen, so that the parent
     * process can also fully exit.
     */
    readonly exitFullscreen: () => void;

    /**
     * Synthesize a selection set event to the window.
     *
     * This sets the selection as the specified information.
     *
     * @param aOffset  The caret offset of the selection start.
     * @param aLength  The length of the selection.  If this is too long, the
     *                 extra length is ignored.
     * @param aAdditionalFlags See the description of SELECTION_SET_FLAG_*.
     * @return True, if succeeded.  Otherwise, false.
     */
    readonly sendSelectionSetEvent: (aOffset: number, aLength: number, aAdditionalFlags?: number) => boolean;

    /**
     * Select content at a client point based on a selection behavior if the
     * underlying content is selectable. Selection will accumulate with any
     * existing selection, callers should clear selection prior if needed.
     * May fire selection changed events. Calls nsFrame's SelectByTypeAtPoint.
     *
     * @param aX, aY The selection point in client coordinates.
     * @param aSelectType The selection behavior requested.
     * @return True if a selection occured, false otherwise.
     * @throw NS_ERROR_DOM_SECURITY_ERR, NS_ERROR_UNEXPECTED for utils
     * issues, and NS_ERROR_INVALID_ARG for coordinates that are outside
     * this window.
     */
    readonly selectAtPoint: (aX: number, aY: number, aSelectBehavior: number) => boolean;

    /**
     * Perform the equivalent of:
     *   window.getComputedStyle(aElement, aPseudoElement).
     *     getPropertyValue(aPropertyName)
     * except that, when the link whose presence in history is allowed to
     * influence aElement's style is visited, get the value the property
     * would have if allowed all properties to change as a result of
     * :visited selectors (except for cases where getComputedStyle uses
     * data from the frame).
     *
     * This is easier to implement than adding our property restrictions
     * to this API, and is sufficient for the present testing
     * requirements (which are essentially testing 'color').
     */
    readonly getVisitedDependentComputedStyle: (aElement: WebIDL.Element, aPseudoElement: IDLAString, aPropertyName: IDLAString) => IDLAString;

    /**
     * Get the id of the outer window of this window.  This will never throw.
     */
    readonly outerWindowID: number;

    /**
     * Get the id of the current inner window of this window.  If there
     * is no current inner window, throws NS_ERROR_NOT_AVAILABLE.
     */
    readonly currentInnerWindowID: number;

    /**
     * Put the window into a state where scripts are frozen and events
     * suppressed, for use when the window has launched a modal prompt.
     */
    readonly enterModalState: () => void;

    /**
     * Resume normal window state, where scripts can run and events are
     * delivered.
     */
    readonly leaveModalState: () => void;

    /**
     * Request set internal desktopMode flag change.
     */
    readonly setDesktopModeViewport: (aDesktopModeViewport: boolean) => void;

    /**
     * Suspend/resume timeouts on this window and its descendant windows.
     */
    readonly suspendTimeouts: () => void;

    readonly resumeTimeouts: () => void;

    /**
     * What type of layer manager the widget associated with this window is
     * using. "Basic" is unaccelerated; other types are accelerated. Throws an
     * error if there is no widget associated with this window.
     */
    readonly layerManagerType: IDLAString;

    /**
     * True if the layer manager for the widget associated with this window is
     * forwarding layers to a remote compositor, false otherwise. Throws an
     * error if there is no widget associated with this window.
     */
    readonly layerManagerRemote: boolean;

    /**
     * True if advanced layers is enabled on this window, false otherwise.
     */
    readonly usingAdvancedLayers: boolean;

    /**
     * True if webrender was requested by the user (via pref or env-var), false
     * otherwise. Note that this doesn't represent whether or not webrender is
     * *actually* enabled, just whether or not it was requested.
     */
    readonly isWebRenderRequested: boolean;

    /**
     * Returns the current audio backend as a free-form string.
     */
    readonly currentAudioBackend: IDLAString;

    /**
     * Returns the max channel counts of the current audio device.
     */
    readonly currentMaxAudioChannels: number;

    /**
     * Returns the preferred sample rate of the current audio device.
     */
    readonly currentPreferredSampleRate: number;

    readonly audioDevices: (aSide: number) => (nsIArray | null);

    /**
     * Record (and return) frame-intervals for frames which were presented
     *   between calling StartFrameTimeRecording and StopFrameTimeRecording.
     *
     * - Uses a cyclic buffer and serves concurrent consumers, so if Stop is called too late
     *     (elements were overwritten since Start), result is considered invalid and hence empty.
     * - Buffer is capable of holding 10 seconds @ 60fps (or more if frames were less frequent).
     *     Can be changed (up to 1 hour) via pref: toolkit.framesRecording.bufferSize.
     * - Note: the first frame-interval may be longer than expected because last frame
     *     might have been presented some time before calling StartFrameTimeRecording.
     */
    /**
     * Returns a handle which represents current recording start position.
     */
    readonly startFrameTimeRecording: () => number;

    /**
     * Returns array of frame intervals since the time when the given startIndex
     * was handed out from startFrameTimeRecording.
     */
    readonly stopFrameTimeRecording: (startIndex: number) => number[];

    /**
     * The DPI of the display
     */
    readonly displayDPI: number;

    /**
     * Return this window's frame element.
     * Ignores all chrome/content or mozbrowser boundaries.
     */
    readonly containerElement: WebIDL.Element;

    /**
     * advanceTimeAndRefresh allows the caller to take over the refresh
     * driver timing for a window.  A call to advanceTimeAndRefresh does
     * three things:
     *  (1) It marks the refresh driver for this presentation so that it
     *      no longer refreshes on its own, but is instead driven entirely
     *      by the caller (except for the refresh that happens when a
     *      document comes out of the bfcache).
     *  (2) It advances the refresh driver's current refresh time by the
     *      argument given.  Negative advances are permitted.
     *  (3) It does a refresh (i.e., notifies refresh observers) at that
     *      new time.
     *
     * Note that this affects other connected docshells of the same type
     * in the same docshell tree, such as parent frames.
     *
     * When callers have completed their use of advanceTimeAndRefresh,
     * they must call restoreNormalRefresh.
     */
    readonly advanceTimeAndRefresh: (aMilliseconds: number) => void;

    /**
     * Undoes the effects of advanceTimeAndRefresh.
     */
    readonly restoreNormalRefresh: () => void;

    /**
     * Reports whether the current state is test-controlled refreshes
     * (see advanceTimeAndRefresh and restoreNormalRefresh above).
     */
    readonly isTestControllingRefreshes: boolean;

    /**
     * Reports whether APZ is enabled on the widget that this window is attached
     * to. If there is no widget it will report the default platform value of
     * whether or not APZ is enabled.
     */
    readonly asyncPanZoomEnabled: boolean;

    /**
     * Set async scroll offset on an element. The next composite will render
     * with that offset if async scrolling is enabled, and then the offset
     * will be removed. Only call this while test-controlled refreshes is enabled.
     */
    readonly setAsyncScrollOffset: (aElement: WebIDL.Element, aX: number, aY: number) => void;

    /**
     * Set async zoom value. aRootElement should be the document element of our
     * document. The next composite will render with that zoom added to any
     * existing zoom if async scrolling is enabled, and then the zoom will be
     * removed. Only call this while test-controlled refreshes is enabled.
     */
    readonly setAsyncZoom: (aRootElement: WebIDL.Element, aValue: number) => void;

    /**
     * Do a round-trip to the compositor to ensure any pending APZ repaint requests
     * get flushed to the main thread. If the function returns true, the flush was
     * triggered and an "apz-repaints-flushed" notification will be dispatched via
     * the observer service once the flush is complete. If the function returns
     * false, an error occurred or a flush is not needed, and the notification
     * will not fire. This is intended to be used by test code only!
     */
    readonly flushApzRepaints: () => boolean;

    /**
     * Ask APZ to pan and zoom to the focused input element.
     */
    readonly zoomToFocusedInput: () => void;

    /**
     * Method for testing StyleAnimationValue::ComputeDistance.
     *
     * Returns the distance between the two values as reported by
     * StyleAnimationValue::ComputeDistance for the given element and
     * property.
     */
    readonly computeAnimationDistance: (element: WebIDL.Element, property: IDLAString, value1: IDLAString, value2: IDLAString) => number;

    /**
     * Returns the computed style for the specified property of given pseudo type
     * on the given element after removing styles from declarative animations.
     * @param aElement - A target element
     * @param aPseudoElement - A pseudo type (e.g. '::before' or null)
     * @param aProperty - A longhand CSS property (e.g. 'background-color')
     * @param aFlushType - FLUSH_NONE if any pending styles should not happen,
     *                     FLUSH_STYLE to flush pending styles.
     */
    readonly getUnanimatedComputedStyle: (aElement: WebIDL.Element, aPseudoElement: IDLAString, aProperty: IDLAString, aFlushType: number) => IDLAString;

    /**
     * Get the type of the currently focused html input, if any.
     */
    readonly focusedInputType: IDLAString;

    /**
     * Get the action hint of the currently focused html input, if any.
     */
    readonly focusedActionHint: IDLAString;

    /**
     * Find the view ID for a given element. This is the reverse of
     * findElementWithViewId().
     */
    readonly getViewId: (aElement: WebIDL.Element) => number;

    /**
     * Checks the layer tree for this window and returns true
     * if all layers have transforms that are translations by integers,
     * no leaf layers overlap, and the union of the leaf layers is exactly
     * the bounds of the window. Always returns true in non-DEBUG builds.
     */
    readonly leafLayersPartitionWindow: () => boolean;

    /**
     * Check if any PaintedLayer painting has been done for this element,
     * clears the painted flags if they have.
     */
    readonly checkAndClearPaintedState: (aElement: WebIDL.Element) => boolean;

    /**
     * Check if any display list building has been done for this element,
     * clears the display list flags if they have.
     */
    readonly checkAndClearDisplayListState: (aElement: WebIDL.Element) => boolean;

    /**
     * Check whether all display items of the primary frame of aElement have been
     * assigned to the same single PaintedLayer in the last paint. If that is the
     * case, returns whether that PaintedLayer is opaque; if it's not the case, an
     * exception is thrown.
     */
    readonly isPartOfOpaqueLayer: (aElement: WebIDL.Element) => boolean;

    /**
     * Count the number of different PaintedLayers that the supplied elements have
     * been assigned to in the last paint. Throws an exception if any of the
     * elements doesn't have a primary frame, or if that frame's display items are
     * assigned to any other layers than just a single PaintedLayer per element.
     */
    readonly numberOfAssignedPaintedLayers: (aElements: WebIDL.Element[]) => number;

    /**
     * Get internal id of the stored blob, file or file handle.
     */
    readonly getFileId: (aFile: IDLjsval) => number;

    /**
     * Get internal file path of the stored file or file handle.
     *
     * TODO: File handle objects are actually not supported at the moment.
     */
    readonly getFilePath: (aFile: IDLjsval) => IDLAString;

    /**
     * Get file ref count info for given database and file id.
     *
     */
    readonly getFileReferences: (aDatabaseName: IDLAString, aId: number, aOptions?: IDLjsval, aRefCnt?: Out<number>, aDBRefCnt?: Out<number>, aSliceRefCnt?: Out<number>) => boolean;

    readonly flushPendingFileDeletions: () => void;

    /**
     * Return whether incremental GC has been disabled due to a binary add-on.
     */
    readonly isIncrementalGCEnabled: () => boolean;

    /**
     * Begin opcode-level profiling of all JavaScript execution in the window's
     * runtime.
     */
    readonly startPCCountProfiling: () => void;

    /**
     * Stop opcode-level profiling of JavaScript execution in the runtime, and
     * collect all counts for use by getPCCount methods.
     */
    readonly stopPCCountProfiling: () => void;

    /**
     * Purge collected PC counters.
     */
    readonly purgePCCounts: () => void;

    /**
     * Get the number of scripts with opcode-level profiling information.
     */
    readonly getPCCountScriptCount: () => number;

    /**
     * Get a JSON string for a short summary of a script and the PC counts
     * accumulated for it.
     */
    readonly getPCCountScriptSummary: (script: number) => IDLAString;

    /**
     * Get a JSON string with full information about a profiled script,
     * including the decompilation of the script and placement of decompiled
     * operations within it, and PC counts for each operation.
     */
    readonly getPCCountScriptContents: (script: number) => IDLAString;

    /**
     * Returns true if painting is suppressed for this window and false
     * otherwise.
     */
    readonly paintingSuppressed: boolean;

    /**
     * Returns an array of plugins on the page for opt-in activation.
     *
     * Cannot be accessed from unprivileged context (not content-accessible).
     * Will throw a DOM security error if called without chrome privileges.
     *
     */
    readonly plugins: IDLjsval;

    /**
     * Set the viewport size for the purposes of clamping scroll positions for
     * the root scroll frame of this document to be (aWidth,aHeight) in CSS pixels.
     *
     * The caller of this method must have chrome privileges.
     */
    readonly setVisualViewportSize: (aWidth: number, aHeight: number) => void;

    /**
     * These are used to control whether dialogs (alert, prompt, confirm) are
     * allowed.
     */
    readonly disableDialogs: () => void;

    readonly enableDialogs: () => void;

    readonly areDialogsEnabled: () => boolean;

    /**
     * Synchronously loads a style sheet from |sheetURI| and adds it to the list
     * of additional style sheets of the document.
     *
     * These additional style sheets are very much like user/agent sheets loaded
     * with loadAndRegisterSheet. The only difference is that they are applied only
     * on the document owned by this window.
     *
     * Sheets added via this API take effect immediately on the document.
     */
    readonly loadSheet: (sheetURI: (nsIURI | null), type: number) => void;

    /**
     * Same as the above method but allows passing the URI as a string.
     */
    readonly loadSheetUsingURIString: (sheetURI: IDLACString, type: number) => void;

    /**
     * Adds a style sheet to the list of additional style sheets of the document.
     *
     * Style sheets can be preloaded with nsIStyleSheetService.preloadSheet.
     *
     * Sheets added via this API take effect immediately on the document.
     */
    readonly addSheet: (sheet: (nsIPreloadedStyleSheet | null), type: number) => void;

    /**
     * Remove the document style sheet at |sheetURI| from the list of additional
     * style sheets of the document.  The removal takes effect immediately.
     */
    readonly removeSheet: (sheetURI: (nsIURI | null), type: number) => void;

    /**
     * Same as the above method but allows passing the URI as a string.
     */
    readonly removeSheetUsingURIString: (sheetURI: IDLACString, type: number) => void;

    /**
     * Returns true if a user input is being handled.
     *
     * This calls EventStateManager::IsHandlingUserInput().
     */
    readonly isHandlingUserInput: boolean;

    /**
     * Returns milliseconds elapsed since last user input was started.
     * Returns -1 if there wasn't any previous user input.
     *
     * This relies on EventStateManager::LatestUserInputStart()
     */
    readonly millisSinceLastUserInput: number;

    /**
     * After calling the method, the window for which this DOMWindowUtils
     * was created can be closed using scripts.
     */
    readonly allowScriptsToClose: () => void;

    /**
     * Is the parent window's main widget visible?  If it isn't, we probably
     * don't want to display any dialogs etc it may request.  This corresponds
     * to the visibility check in nsWindowWatcher::OpenWindowInternal().
     *
     * Will throw a DOM security error if called without chrome privileges or
     * NS_ERROR_NOT_AVAILABLE in the unlikely event that the parent window's
     * main widget can't be reached.
     */
    readonly isParentWindowMainWidgetVisible: boolean;

    /**
     * In certain cases the event handling of nodes, form controls in practice,
     * may be disabled. Such cases are for example the existence of disabled
     * attribute or -moz-user-input: none.
     */
    readonly isNodeDisabledForEvents: (aNode: WebIDL.Node) => boolean;

    /**
     * Setting paintFlashing to true will flash newly painted area.
     */
    paintFlashing: boolean;

    readonly getOMTAStyle: (aElement: WebIDL.Element, aProperty: IDLAString, aPseudoElement?: IDLAString) => IDLAString;

    readonly getOMTCTransform: (aElement: WebIDL.Element, aPseudoElement?: IDLAString) => IDLAString;

    readonly isAnimationInPendingTracker: (aAnimation: WebIDL.Animation) => boolean;

    /**
     * If aHandlingInput is true, this informs the event state manager that
     * we're handling user input. Otherwise, this is a no-op (as by default
     * we're not handling user input).
     * Remember to call destruct() on the return value!
     * See also nsIDOMWindowUtils::isHandlingUserInput.
     */
    readonly setHandlingUserInput: (aHandlingInput: boolean) => (nsIJSRAIIHelper | null);

    /**
     * Get the content- and compositor-side APZ test data instances.
     * The return values are of type APZTestData (see APZTestData.webidl).
     */
    readonly getContentAPZTestData: () => IDLjsval;

    readonly getCompositorAPZTestData: () => IDLjsval;

    /**
     * Posts an RestyleHint::RESTYLE_SELF restyle event for the given element.
     */
    readonly postRestyleSelfEvent: (aElement: WebIDL.Element) => void;

    /**
     * Used to pause or resume all media in this window. Use-cases are audio
     * competing, remote media control and to prevent auto-playing media.
     */
    mediaSuspend: number;

    /**
     * This method doesn't do anything useful.  It was solely added for the
     * purpose of the test for bug 503926.
     */
    readonly xpconnectArgument: (aObj: (nsISupports | null)) => void;

    /**
     * Helper for JS components that need to send permission requests with
     * e10s support properly.
     */
    readonly askPermission: (aRequest: (nsIContentPermissionRequest | null)) => void;

    /**
     * Restyle generation for the current document.
     *
     * May throw NS_ERROR_NOT_AVAILABLE.
     */
    readonly restyleGeneration: number;

    /**
     * Number of frames constructed (excluding breaking) for the curent
     * document.
     *
     * May throw NS_ERROR_NOT_AVAILABLE.
     */
    readonly framesConstructed: number;

    /**
     * Number of frames reflowed for the curent document.
     *
     * May throw NS_ERROR_NOT_AVAILABLE.
     */
    readonly framesReflowed: number;

    /**
     * Controls the amount of chrome that should be visible on each side of
     * the window. Works like the chromemargin xul:window attribute.
     * This should only be used with non-XUL windows.
     */
    readonly setChromeMargin: (aTop: number, aRight: number, aBottom: number, aLeft: number) => void;

    /**
     * Enable some service workers testing features.
     */
    serviceWorkersTestingEnabled: boolean;

    /**
     * Returns a JSObject which contains a list of frame uniformities
     * when the pref gfx.vsync.collect-scroll-data is enabled.
     * Every result contains a layer address and a frame uniformity for that layer.
     * A negative frame uniformity value indicates an invalid frame uniformity and an error has occured.
     */
    readonly getFrameUniformityTestData: () => IDLjsval;

    readonly enterChaosMode: () => void;

    /**
     * Decrease the chaos mode activation level. See enterChaosMode().
     */
    readonly leaveChaosMode: () => void;

    /**
     * Alerts Gecko of a device reset
     */
    readonly triggerDeviceReset: () => void;

    /**
     * Returns whether the document's style set's rule processor for the
     * specified level of the cascade is shared by multiple style sets.
     * (Used by tests to ensure that certain optimizations do not regress.)
     *
     * @param aSheetType One of the nsIStyleSheetService.*_SHEET constants.
     */
    readonly hasRuleProcessorUsedByMultipleStyleSets: (aSheetType: number) => boolean;

    /**
     * Enable or disable displayport suppression. This is intended to be used by
     * testing code, to provide more deterministic behaviour over the displayport
     * suppression during tests. Note that this updates a flag, so whatever value
     * was last provided is what will be used.
     */
    readonly respectDisplayPortSuppression: (aEnabled: boolean) => void;

    /**
     * Set a flag that forces the next reflow interrupt check to return true. This
     * can be used by tests to force execution of the interrupted reflow codepaths.
     */
    readonly forceReflowInterrupt: () => void;

    /**
     * Terminate the GPU process. Used for testing GPU process restarts.
     */
    readonly terminateGPUProcess: () => void;

    /**
     * Returns the GPU process pid, or -1 if there is no GPU process.
     */
    readonly gpuProcessPid: number;

    /**
     * Adds an EventStates bit to the element.
     *
     * The state string must be one of the following:
     *   * (none yet; but for example "higlighted" for NS_EVENT_STATE_HIGHLIGHTED)
     *
     * The supported state strings are defined in kManuallyManagedStates
     * in nsDOMWindowUtils.cpp.
     */
    readonly addManuallyManagedState: (element: WebIDL.Element, state: IDLAString) => void;

    /**
     * Removes the specified EventStates bits from the element.
     *
     * See above for the strings that can be passed for |state|.
     */
    readonly removeManuallyManagedState: (element: WebIDL.Element, state: IDLAString) => void;

    /**
     * Returns usage data for a given storage object.
     *
     * @param aStorage
     *    The storage object to get usage data for.
     */
    readonly getStorageUsage: (aStorage: WebIDL.Storage) => number;

    /**
     * Returns the directionality of a string using the first-strong character
     * algorithm defined in http://unicode.org/reports/tr9/#P2.
     *
     * @param aString the string to retrieve the direction for.
     * @return one of DIRECTION_LTR, DIRECTION_RTL or DIRECTION_NOT_SET depending
     *         on the first-strong character found in the string.
     */
    readonly getDirectionFromText: (aString: IDLAString) => number;

    /**
     * Calls FrameNeedsReflow on that root frame so that a layout flush
     * will be necessary.
     *
     * This should only be used for testing.
     */
    readonly ensureDirtyRootFrame: () => void;

    /**
     * Capture the contents of the current WebRender frame and
     * save them to a folder relative to the current working directory.
     */
    readonly wrCapture: () => void;

    /**
     * Toggle recording of composition on and off.
     *
     * This is equivalent to calling |startCompositionRecorder()| or
     * |stopCompositionRecorder(true)|.
     */
    readonly setCompositionRecording: (aValue: boolean) => IDLPromise;

    /**
     * Start the composition recorder.
     *
     * @return A promise that is resolved to true if the composion recorder was
     *         started successfully.
     */
    readonly startCompositionRecording: () => IDLPromise;

    /**
     * Stop the composition recorder.
     *
     * @param aWriteToDisk Whether or not the frames should be written to disk.
     *                     If false, they will be returned in the promise.
     * @return A promise that resolves when the frames have been collected.
     *         When |aWriteToDisk| is true, the promise will resolve to |undefined|.
     *         Otherwise, the promise will resolve to a |DOMCollectedFrames| dictionary,
     *         which contains the timestamps and contents of the captured frames.
     */
    readonly stopCompositionRecording: (aWriteToDisk: boolean) => IDLPromise;

    /**
     * Toggle transaction logging on and off.
     */
    readonly setTransactionLogging: (aValue: boolean) => void;

    /**
     * Returns whether the document we're associated to has recorded a given CSS
     * property via the use counter mechanism.
     *
     * Throws if there's no document or the property is invalid.
     */
    readonly isCssPropertyRecordedInUseCounter: (aProperty: IDLACString) => boolean;

    /**
     * NOTE: Currently works only on GTK+.
     */
    systemFont: IDLACString;

    /**
     * Returns the number of times this document for this window has
     * been painted to the screen.
     *
     * Use this instead of window.mozPaintCount
     */
    readonly paintCount: number;

    /**
     * Simulate the system setting corresponding to 'prefers-reduced-motion'
     * media queries feature is changed to 'on' or 'off'.
     *
     * This function doesn't work on Windows.
     */
    readonly setPrefersReducedMotionOverrideForTest: (aValue: boolean) => void;

    /**
     * Reset the internal state to be used for above setPrefersReducedMotion.
     */
    readonly resetPrefersReducedMotionOverrideForTest: () => void;

    readonly syncFlushCompositor: () => void;

    readonly getLayersId: () => number;

    readonly usesOverlayScrollbars: boolean;
  }

  export interface nsILoginManagerPrompterRef {
    readonly name: "nsILoginManagerPrompter";
    readonly number: "{c47ff942-9678-44a5-bc9b-05e0d676c79c}";
  }

  export interface nsILoginManagerPrompter extends nsISupports {

    /**
     * Ask the user if they want to save a login (Yes, Never, Not Now)
     *
     * @param aBrowser
     *        The browser of the webpage request that triggered the prompt.
     * @param aLogin
     *        The login to be saved.
     * @param dismissed
     *        A boolean value indicating whether the save logins doorhanger should
     *        be dismissed automatically when shown.
     * @param notifySaved
     *        A boolean value indicating whether the notification should indicate that
     *        a login has been saved
     */
    readonly promptToSavePassword: (aBrowser: WebIDL.Element, aLogin: (nsILoginInfo | null), dismissed?: boolean, notifySaved?: boolean) => void;

    /**
     * Ask the user if they want to change a login's password or username.
     * If the user consents, modifyLogin() will be called.
     *
     * @param aBrowser
     *        The browser of the webpage request that triggered the prompt.
     * @param aOldLogin
     *        The existing login (with the old password).
     * @param aNewLogin
     *        The new login.
     * @param dismissed
     *        A boolean value indicating whether the save logins doorhanger should
     *        be dismissed automatically when shown.
     * @param autoSavedLoginGuid
     *        A string guid value for the old login to be removed if the changes
     *        match it to a different login
     */
    readonly promptToChangePassword: (aBrowser: WebIDL.Element, aOldLogin: (nsILoginInfo | null), aNewLogin: (nsILoginInfo | null), dismissed?: boolean, notifySaved?: boolean, autoSavedLoginGuid?: IDLAString) => void;

    /**
     * Ask the user if they want to change the password for one of
     * multiple logins, when the caller can't determine exactly which
     * login should be changed. If the user consents, modifyLogin() will
     * be called.
     *
     * @param aBrowser
     *        The browser of the webpage request that triggered the prompt.
     * @param logins
     *        An array of existing logins.
     * @param aNewLogin
     *        The new login.
     *
     * Note: Because the caller does not know the username of the login
     *       to be changed, aNewLogin.username and aNewLogin.usernameField
     *       will be set (using the user's selection) before modifyLogin()
     *       is called.
     */
    readonly promptToChangePasswordWithUsernames: (aBrowser: WebIDL.Element, logins: (nsILoginInfo | null)[], aNewLogin: (nsILoginInfo | null)) => void;
  }

  export interface mozIStorageProgressHandlerRef {
    readonly name: "mozIStorageProgressHandler";
    readonly number: "{a3a6fcd4-bf89-4208-a837-bf2a73afd30c}";
  }

  /**
   * mozIProgressHandler is to be implemented by storage consumers that
   * wish to receive callbacks during the request execution.
   */
  export interface mozIStorageProgressHandler extends nsISupports {

    /**
     * onProgress is invoked periodically during long running calls.
     *
     * @param aConnection    connection, for which progress handler is
     *                       invoked.
     *
     * @return true to abort request, false to continue work.
     */
    readonly onProgress: (aConnection: (mozIStorageConnection | null)) => boolean;
  }

  export interface nsISupportsPRUint8Ref {
    readonly name: "nsISupportsPRUint8";
    readonly number: "{dec2e4e0-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for 8-bit integers
   */
  export interface nsISupportsPRUint8 extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsIDroppedLinkItemRef {
    readonly name: "nsIDroppedLinkItem";
    readonly number: "{69e14f91-2e09-4ca6-a511-a715c99a2804}";
  }

  export interface nsIDroppedLinkItem extends nsISupports {

    /**
     * Returns the URL of the link.
     */
    readonly url: IDLAString;

    /**
     * Returns the link name.
     */
    readonly name: IDLAString;

    /**
     * Returns the MIME-Type.
     */
    readonly type: IDLAString;
  }

  export interface nsISupportsPriorityRef {
    readonly name: "nsISupportsPriority";
    readonly number: "{aa578b44-abd5-4c19-8b14-36d4de6fdc36}";

    /**
     * Typical priority values.
     */
    PRIORITY_HIGHEST: -20;

    PRIORITY_HIGH: -10;

    PRIORITY_NORMAL: 0;

    PRIORITY_LOW: 10;

    PRIORITY_LOWEST: 20;
  }

  /**
   * This interface exposes the general notion of a scheduled object with a
   * integral priority value.  Following UNIX conventions, smaller (and possibly
   * negative) values have higher priority.
   *
   * This interface does not strictly define what happens when the priority of an
   * object is changed.  An implementation of this interface is free to define
   * the side-effects of changing the priority of an object.  In some cases,
   * changing the priority of an object may be disallowed (resulting in an
   * exception being thrown) or may simply be ignored.
   */
  export interface nsISupportsPriority extends nsISupports {

    /**
     * This attribute may be modified to change the priority of this object.  The
     * implementation of this interface is free to truncate a given priority
     * value to whatever limits are appropriate.  Typically, this attribute is
     * initialized to PRIORITY_NORMAL, but implementations may choose to assign a
     * different initial value.
     */
    priority: number;

    /**
     * This method adjusts the priority attribute by a given delta.  It helps
     * reduce the amount of coding required to increment or decrement the value
     * of the priority attribute.
     */
    readonly adjustPriority: (delta: number) => void;
  }

  export interface xpcIJSGetFactoryRef {
    readonly name: "xpcIJSGetFactory";
    readonly number: "{3fe0c205-d75b-4cac-9347-d2b855050143}";
  }

  /**
   * Every JS module exports a single NSGetFactory symbol which is converted into this
   * functional interface type.
   */
  export interface xpcIJSGetFactory extends nsISupports {
  }

  export interface nsIDOMGeoPositionRef {
    readonly name: "nsIDOMGeoPosition";
    readonly number: "{dd9f7e81-0f74-4fb5-b361-37019bf60c3f}";
  }

  export interface nsIDOMGeoPosition extends nsISupports {

    readonly timestamp: number;

    readonly coords: (nsIDOMGeoPositionCoords | null);
  }

  export interface nsINetworkLinkServiceRef {
    readonly name: "nsINetworkLinkService";
    readonly number: "{103e5293-77b3-4b70-af59-6e9e4a1f994a}";

    LINK_TYPE_UNKNOWN: 0;

    LINK_TYPE_ETHERNET: 1;

    LINK_TYPE_USB: 2;

    LINK_TYPE_WIFI: 3;

    LINK_TYPE_WIMAX: 4;

    LINK_TYPE_2G: 5;

    LINK_TYPE_3G: 6;

    LINK_TYPE_4G: 7;

    NONE_DETECTED: 0;

    VPN_DETECTED: 1;

    PROXY_DETECTED: 2;

    NRPT_DETECTED: 4;
  }

  /**
   * Network link status monitoring service.
   */
  export interface nsINetworkLinkService extends nsISupports {

    /**
     * This is set to true when the system is believed to have a usable
     * network connection.
     *
     * The link is only up when network connections can be established. For
     * example, the link is down during DHCP configuration (unless there
     * is another usable interface already configured).
     *
     * If the link status is not currently known, we generally assume that
     * it is up.
     */
    readonly isLinkUp: boolean;

    /**
     * This is set to true when we believe that isLinkUp is accurate.
     */
    readonly linkStatusKnown: boolean;

    /**
     * The type of network connection.
     */
    readonly linkType: number;

    /**
     * A string uniquely identifying the current active network interfaces.
     * Empty when there are no active network interfaces.
     */
    readonly networkID: IDLACString;

    /**
     * The list of DNS suffixes for the currently active network interfaces.
     */
    readonly dnsSuffixList: IDLACString[];

    /**
     * A bitfield that encodes the platform attributes we detected which
     * indicate that we should only use DNS, not TRR.
     */
    readonly platformDNSIndications: number;
  }

  export interface nsIAsyncInputStreamRef {
    readonly name: "nsIAsyncInputStream";
    readonly number: "{a5f255ab-4801-4161-8816-277ac92f6ad1}";

    /**
     * If passed to asyncWait, this flag overrides the default behavior,
     * causing the OnInputStreamReady notification to be suppressed until the
     * stream becomes closed (either as a result of closeWithStatus/close being
     * called on the stream or possibly due to some error in the underlying
     * stream).
     */
    WAIT_CLOSURE_ONLY: 1;
  }

  /**
   * If an input stream is non-blocking, it may return NS_BASE_STREAM_WOULD_BLOCK
   * when read.  The caller must then wait for the stream to have some data to
   * read.  If the stream implements nsIAsyncInputStream, then the caller can use
   * this interface to request an asynchronous notification when the stream
   * becomes readable or closed (via the AsyncWait method).
   *
   * While this interface is almost exclusively used with non-blocking streams, it
   * is not necessary that nsIInputStream::isNonBlocking return true.  Nor is it
   * necessary that a non-blocking nsIInputStream implementation also implement
   * nsIAsyncInputStream.
   */
  export interface nsIAsyncInputStream extends nsIInputStream {

    /**
     * This method closes the stream and sets its internal status.  If the
     * stream is already closed, then this method is ignored.  Once the stream
     * is closed, the stream's status cannot be changed.  Any successful status
     * code passed to this method is treated as NS_BASE_STREAM_CLOSED, which
     * has an effect equivalent to nsIInputStream::close.
     *
     * NOTE: this method exists in part to support pipes, which have both an
     * input end and an output end.  If the input end of a pipe is closed, then
     * writes to the output end of the pipe will fail.  The error code returned
     * when an attempt is made to write to a "broken" pipe corresponds to the
     * status code passed in when the input end of the pipe was closed, which
     * greatly simplifies working with pipes in some cases.
     *
     * @param aStatus
     *        The error that will be reported if this stream is accessed after
     *        it has been closed.
     */
    readonly closeWithStatus: (aStatus: number) => void;

    /**
     * Asynchronously wait for the stream to be readable or closed.  The
     * notification is one-shot, meaning that each asyncWait call will result
     * in exactly one notification callback.  After the OnInputStreamReady event
     * is dispatched, the stream releases its reference to the
     * nsIInputStreamCallback object.  It is safe to call asyncWait again from the
     * notification handler.
     *
     * This method may be called at any time (even if read has not been called).
     * In other words, this method may be called when the stream already has
     * data to read.  It may also be called when the stream is closed.  If the
     * stream is already readable or closed when AsyncWait is called, then the
     * OnInputStreamReady event will be dispatched immediately.  Otherwise, the
     * event will be dispatched when the stream becomes readable or closed.
     *
     * @param aCallback
     *        This object is notified when the stream becomes ready.  This
     *        parameter may be null to clear an existing callback.
     * @param aFlags
     *        This parameter specifies optional flags passed in to configure
     *        the behavior of this method.  Pass zero to specify no flags.
     * @param aRequestedCount
     *        Wait until at least this many bytes can be read.  This is only
     *        a suggestion to the underlying stream; it may be ignored.  The
     *        caller may pass zero to indicate no preference.
     * @param aEventTarget
     *        Specify NULL to receive notification on ANY thread (possibly even
     *        recursively on the calling thread -- i.e., synchronously), or
     *        specify that the notification be delivered to a specific event
     *        target.
     */
    readonly asyncWait: (aCallback: (nsIInputStreamCallback | nsIInputStreamCallbackFunction | null), aFlags: number, aRequestedCount: number, aEventTarget: (nsIEventTarget | null)) => void;
  }

  export interface nsIImageDocumentRef {
    readonly name: "nsIImageDocument";
    readonly number: "{87c27f98-37dc-4b64-a8cd-92003624bcee}";
  }

  export interface nsIImageDocument extends nsISupports {

    readonly imageIsOverflowing: boolean;

    readonly imageIsResized: boolean;

    readonly imageRequest: (imgIRequest | null);

    readonly shrinkToFit: () => void;

    readonly restoreImage: () => void;

    readonly restoreImageTo: (x: number, y: number) => void;

    readonly toggleImageSize: () => void;
  }

  export interface nsIBidirectionalIteratorRef {
    readonly name: "nsIBidirectionalIterator";
    readonly number: "{948defaa-1dd1-11b2-89f6-8ce81f5ebda9}";
  }

  /**
   * ...
   */
  export interface nsIBidirectionalIterator extends nsISupports {

    /**
     * Retrieve (and |AddRef()|) the element this iterator currently points to.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @result a new reference to the element this iterator currently points to (if any)
     */
    readonly getElement: () => (nsISupports | null);

    /**
     * Put |anElementToPut| into the underlying container or sequence at the position currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    readonly putElement: (anElementToPut: (nsISupports | null)) => void;

    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    readonly stepForward: () => void;

    /**
     * Move this iterator to the previous position in the underlying container or sequence.
     */
    readonly stepBackward: () => void;

    /**
     * Test if |anotherIterator| points to the same position in the underlying container or sequence.
     *
     * The result is undefined if |anotherIterator| was not created by or for the same underlying container or sequence.
     *
     * @param anotherIterator another iterator to compare against, created by or for the same underlying container or sequence
     * @result true if |anotherIterator| points to the same position in the underlying container or sequence
     */
    readonly isEqualTo: (anotherIterator: (nsISupports | null)) => boolean;

    /**
     * Create a new iterator pointing to the same position in the underlying container or sequence to which this iterator currently points.
     * The returned iterator is suitable for use in a subsequent call to |isEqualTo()| against this iterator.
     *
     * @result a new iterator pointing at the same position in the same underlying container or sequence as this iterator
     */
    readonly clone: () => (nsISupports | null);
  }

  export interface nsIContentSecurityPolicyRef {
    readonly name: "nsIContentSecurityPolicy";
    readonly number: "{1d632008-6c97-48ae-a51c-16e2daa0f4f6}";

    /**
     * Directives supported by Content Security Policy.  These are enums for
     * the CSPDirective type.
     * The NO_DIRECTIVE entry is  used for checking default permissions and
     * returning failure when asking CSP which directive to check.
     *
     * NOTE: When implementing a new directive, you will need to add it here but also
     * add it to the CSPStrDirectives array in nsCSPUtils.h.
     */
    NO_DIRECTIVE: 0;

    DEFAULT_SRC_DIRECTIVE: 1;

    SCRIPT_SRC_DIRECTIVE: 2;

    OBJECT_SRC_DIRECTIVE: 3;

    STYLE_SRC_DIRECTIVE: 4;

    IMG_SRC_DIRECTIVE: 5;

    MEDIA_SRC_DIRECTIVE: 6;

    FRAME_SRC_DIRECTIVE: 7;

    FONT_SRC_DIRECTIVE: 8;

    CONNECT_SRC_DIRECTIVE: 9;

    REPORT_URI_DIRECTIVE: 10;

    FRAME_ANCESTORS_DIRECTIVE: 11;

    REFLECTED_XSS_DIRECTIVE: 12;

    BASE_URI_DIRECTIVE: 13;

    FORM_ACTION_DIRECTIVE: 14;

    WEB_MANIFEST_SRC_DIRECTIVE: 15;

    UPGRADE_IF_INSECURE_DIRECTIVE: 16;

    CHILD_SRC_DIRECTIVE: 17;

    BLOCK_ALL_MIXED_CONTENT: 18;

    SANDBOX_DIRECTIVE: 19;

    WORKER_SRC_DIRECTIVE: 20;

    NAVIGATE_TO_DIRECTIVE: 21;

    VIOLATION_TYPE_INLINE_SCRIPT: 1;

    VIOLATION_TYPE_EVAL: 2;

    VIOLATION_TYPE_INLINE_STYLE: 3;

    VIOLATION_TYPE_NONCE_SCRIPT: 4;

    VIOLATION_TYPE_NONCE_STYLE: 5;

    VIOLATION_TYPE_HASH_SCRIPT: 6;

    VIOLATION_TYPE_HASH_STYLE: 7;

    VIOLATION_TYPE_REQUIRE_SRI_FOR_STYLE: 8;

    VIOLATION_TYPE_REQUIRE_SRI_FOR_SCRIPT: 9;
  }

  export interface nsIContentSecurityPolicy extends nsISerializable {

    /**
     * Accessor method for a read-only string version of the policy at a given
     * index.
     */
    readonly getPolicy: (index: number) => IDLAString;

    /**
     * Returns the number of policies attached to this CSP instance.  Useful with
     * getPolicy().
     */
    readonly policyCount: number;

    /**
     * Returns whether this policy uses the directive upgrade-insecure-requests.
     * Please note that upgrade-insecure-reqeusts also applies if the parent or
     * including document (context) makes use of the directive.
     */
    readonly upgradeInsecureRequests: boolean;

    /**
     * Returns whether this policy uses the directive block-all-mixed-content.
     * Please note that block-all-mixed-content takes presedence in case the
     * directive upgrade-insecure-requests is defined in the same policy and
     * will therefore block all mixed content without even trying to perform
     * an upgrade.
     */
    readonly blockAllMixedContent: boolean;

    /**
     * Returns whether this policy enforces the frame-ancestors directive.
     */
    readonly enforcesFrameAncestors: boolean;

    /**
     * Parse and install a CSP policy.
     * @param aPolicy
     *        String representation of the policy
     *        (e.g., header value, meta content)
     * @param reportOnly
     *        Should this policy affect content, script and style processing or
     *        just send reports if it is violated?
     * @param deliveredViaMetaTag
     *        Indicates whether the policy was delivered via the meta tag.
     */
    readonly appendPolicy: (policyString: IDLAString, reportOnly: boolean, deliveredViaMetaTag: boolean) => void;

    readonly getAllowsInline: (aContentPolicyType: number, aNonce: IDLAString, aParserCreated: boolean, aTriggeringElement: WebIDL.Element, aCSPEventListener: (nsICSPEventListener | nsICSPEventListenerFunction | null), aContentOfPseudoScript: IDLAString, aLineNumber: number, aColumnNumber: number) => boolean;

    readonly getAllowsNavigateTo: (aURI: (nsIURI | null), aLoadInfo: (nsILoadInfo | null), aWasRedirected: boolean, aEnforceWhitelist: boolean) => boolean;

    /**
     * whether this policy allows eval and eval-like functions
     * such as setTimeout("code string", time).
     * @param shouldReportViolations
     *     Whether or not the use of eval should be reported.
     *     This function returns "true" when violating report-only policies, but
     *     when any policy (report-only or otherwise) is violated,
     *     shouldReportViolations is true as well.
     * @return
     *     Whether or not the effects of the eval call should be allowed
     *     (block the call if false).
     */
    readonly getAllowsEval: (shouldReportViolations: Out<boolean>) => boolean;

    /**
     * Delegate method called by the service when the protected document is loaded.
     * Returns the union of all the sandbox flags contained in CSP policies. This is the most
     * restrictive interpretation of flags set in multiple policies.
     * See nsSandboxFlags.h for the possible flags.
     *
     * @return
     *    sandbox flags or SANDBOXED_NONE if no sandbox directive exists
     */
    readonly getCSPSandboxFlags: () => number;

    /**
     * For each violated policy (of type violationType), log policy violation on
     * the Error Console and send a report to report-uris present in the violated
     * policies.
     *
     * @param violationType
     *     one of the VIOLATION_TYPE_* constants, e.g. inline-script or eval
     * @param triggeringElement
     *     the element that triggers this CSP violation. It can be null.
     * @param sourceFile
     *     name of the source file containing the violation (if available)
     * @param contentSample
     *     sample of the violating content (to aid debugging)
     * @param lineNum
     *     source line number of the violation (if available)
     * @param columnNum
     *     source column number of the violation (if available)
     * @param aNonce
     *     (optional) If this is a nonce violation, include the nonce so we can
     *     recheck to determine which policies were violated and send the
     *     appropriate reports.
     * @param aContent
     *     (optional) If this is a hash violation, include contents of the inline
     *     resource in the question so we can recheck the hash in order to
     *     determine which policies were violated and send the appropriate
     *     reports.
     */
    readonly logViolationDetails: (violationType: number, triggeringElement: WebIDL.Element, aCSPEventListener: (nsICSPEventListener | nsICSPEventListenerFunction | null), sourceFile: IDLAString, scriptSample: IDLAString, lineNum: number, columnNum: number, nonce?: IDLAString, content?: IDLAString) => void;

    /**
     * Called after the CSP object is created to fill in appropriate request
     * context. Either use
     *  * aDocument (preferred), or if no document is available, then provide
     *  * aPrincipal, aSelfURI, aReferrer, aInnerWindowId explicitly.
     */
    readonly setRequestContextWithDocument: (aDocument: WebIDL.Document) => void;

    readonly setRequestContextWithPrincipal: (aRequestPrincipal: (nsIPrincipal | null), aSelfURI: (nsIURI | null), aReferrer: IDLAString, aInnerWindowId: number) => void;

    /**
     * Verifies ancestry as permitted by the policy.
     *
     * NOTE: Calls to this may trigger violation reports when queried, so this
     * value should not be cached.
     *
     * @param aLoadInfo
     *    The loadinfo of the channel containing the protected resource
     * @return
     *    true if the frame's ancestors are all allowed by policy (except for
     *    report-only policies, which will send reports and then return true
     *    here when violated).
     */
    readonly permitsAncestry: (aLoadInfo: (nsILoadInfo | null)) => boolean;

    /**
     * Checks if a specific directive permits loading of a URI.
     *
     * NOTE: Calls to this may trigger violation reports when queried, so the
     * return value should not be cached.
     *
     * @param aTriggeringElement
     *        The element that triggers this CSP check. It can be null.
     * @param aURI
     *    The URI about to be loaded or used.
     * @param aDir
     *    The CSPDirective to query (see above constants *_DIRECTIVE).
     * @param aSpecific
     *    If "true" and the directive is specified to fall back to "default-src"
     *    when it's not explicitly provided, directivePermits will NOT try
     *    default-src when the specific directive is not used.  Setting this to
     *    "false" allows CSP to fall back to default-src.  This function
     *    behaves the same for both values of canUseDefault when querying
     *    directives that don't fall-back.
     * @return
     *    Whether or not the provided URI is allowed by CSP under the given
     *    directive. (block the pending operation if false).
     */
    readonly permits: (aTriggeringElement: WebIDL.Element, aCSPEventListener: (nsICSPEventListener | nsICSPEventListenerFunction | null), aURI: (nsIURI | null), aDir: number, aSpecific: boolean) => boolean;

    /**
     * Delegate method called by the service when sub-elements of the protected
     * document are being loaded.  Given a bit of information about the request,
     * decides whether or not the policy is satisfied.
     *
     * Calls to this may trigger violation reports when queried, so
     * this value should not be cached.
     *
     * aOriginalURIIfRedirect must be passed only if this loading is the result
     * of a redirect. In this case, aOriginalURIIfRedirect must be the original
     * URL.
     */
    readonly shouldLoad: (aContentType: number, aCSPEventListener: (nsICSPEventListener | nsICSPEventListenerFunction | null), aContentLocation: (nsIURI | null), aContext: (nsISupports | null), aMimeTypeGuess: IDLACString, aOriginalURIIfRedirect: (nsIURI | null), aSendViolationReports: boolean, aNonce: IDLAString) => number;

    /**
     * Returns the CSP in JSON notation.
     */
    readonly toJSON: () => IDLAString;
  }

  export interface nsIPushErrorReporterRef {
    readonly name: "nsIPushErrorReporter";
    readonly number: "{b58249f9-1a04-48cc-bc20-2c992d64c73e}";

    /**
     * Ack types, reported when the Push service acknowledges an incoming message.
     *
     * Acks are sent before the message is dispatched to the service worker,
     * since the server delays new messages until all outstanding ones have been
     * acked. |reportDeliveryError| will be called if an error occurs in the
     * worker's `push` event handler after acking the message.
     */
    ACK_DELIVERED: 0;

    ACK_DECRYPTION_ERROR: 1;

    ACK_NOT_DELIVERED: 2;

    /**
     * Unsubscribe reasons, reported when the service drops a subscription.
     */
    UNSUBSCRIBE_MANUAL: 3;

    UNSUBSCRIBE_QUOTA_EXCEEDED: 4;

    UNSUBSCRIBE_PERMISSION_REVOKED: 5;

    /**
     * Delivery error reasons, reported when a service worker fails to handle
     * an incoming push message in its `push` event handler.
     */
    DELIVERY_UNCAUGHT_EXCEPTION: 6;

    DELIVERY_UNHANDLED_REJECTION: 7;

    DELIVERY_INTERNAL_ERROR: 8;
  }

  export interface nsIPushErrorReporter extends nsISupports {

    /**
     * Reports a `push` event handler error to the Push service. |messageId| is
     * an opaque string passed to `nsIPushNotifier.notifyPush{WithData}`.
     * |reason| is a delivery error reason.
     */
    readonly reportDeliveryError: (messageId: IDLAString, reason?: number) => void;
  }

  export interface nsIDocShellTreeItemRef {
    readonly name: "nsIDocShellTreeItem";
    readonly number: "{9b7c586f-9214-480c-a2c4-49b526fff1a6}";

    typeChrome: 0;

    typeContent: 1;

    typeContentWrapper: 2;

    typeChromeWrapper: 3;

    typeAll: 2147483647;
  }

  /**
   * The nsIDocShellTreeItem supplies the methods that are required of any item
   * that wishes to be able to live within the docshell tree either as a middle
   * node or a leaf.
   */
  export interface nsIDocShellTreeItem extends nsISupports {

    name: IDLAString;

    /**
     * Compares the provided name against the item's name and
     * returns the appropriate result.
     *
     * @return <CODE>PR_TRUE</CODE> if names match;
     *         <CODE>PR_FALSE</CODE> otherwise.
     */
    readonly nameEquals: (name: IDLAString) => boolean;

    readonly itemType: number;

    readonly parent: (nsIDocShellTreeItem | null);

    readonly sameTypeParent: (nsIDocShellTreeItem | null);

    readonly rootTreeItem: (nsIDocShellTreeItem | null);

    readonly sameTypeRootTreeItem: (nsIDocShellTreeItem | null);

    readonly treeOwner: (nsIDocShellTreeOwner | null);

    readonly childCount: number;

    /**
     * Return the child at the index requested.  This is 0-based.
     *
     * @deprecated: Prefer using `BrowsingContext::Children()`, as this will not
     * include out-of-process iframes.
     *
     * @throws NS_ERROR_UNEXPECTED if the index is out of range
     */
    readonly getChildAt: (index: number) => (nsIDocShellTreeItem | null);

    /**
     * BrowsingContext associated with the DocShell.
     */
    readonly browsingContext: WebIDL.BrowsingContext;

    /**
     * Returns the DOM outer window for the content viewer.
     */
    readonly domWindow: (mozIDOMWindowProxy | null);
  }

  export interface nsIUrlClassifierGetCacheCallbackRef {
    readonly name: "nsIUrlClassifierGetCacheCallback";
    readonly number: "{26e12ea4-14ff-4c77-858f-6745998b7659}";
  }

  export interface nsIUrlClassifierGetCacheCallback extends nsISupports {

    readonly onGetCacheComplete: (info: (nsIUrlClassifierCacheInfo | null)) => void;
  }

  export enum nsILoadInfo_CrossOriginOpenerPolicy {
    OPENER_POLICY_NULL = 0,
    OPENER_POLICY_SAME_ORIGIN = 1,
    OPENER_POLICY_SAME_SITE = 2,
    OPENER_POLICY_SAMENESS_MASK = 15,
    OPENER_POLICY_EMBEDDER_POLICY_REQUIRE_CORP_FLAG = 16,
    OPENER_POLICY_UNSAFE_ALLOW_OUTGOING_FLAG = 128,
    OPENER_POLICY_SAME_ORIGIN_EMBEDDER_POLICY_REQUIRE_CORP = 17,
    OPENER_POLICY_SAME_ORIGIN_ALLOW_OUTGOING = 129,
    OPENER_POLICY_SAME_SITE_ALLOW_OUTGOING = 130,
  }

  export enum nsILoadInfo_CrossOriginEmbedderPolicy {
    EMBEDDER_POLICY_NULL = 0,
    EMBEDDER_POLICY_REQUIRE_CORP = 1,
  }

  export interface nsILoadInfoRef {
    readonly name: "nsILoadInfo";
    readonly number: "{ddc65bf9-2f60-41ab-b22a-4f1ae9efcd36}";

    OPENER_POLICY_NULL: 0;
    OPENER_POLICY_SAME_ORIGIN: 1;
    OPENER_POLICY_SAME_SITE: 2;
    OPENER_POLICY_SAMENESS_MASK: 15;
    OPENER_POLICY_EMBEDDER_POLICY_REQUIRE_CORP_FLAG: 16;
    OPENER_POLICY_UNSAFE_ALLOW_OUTGOING_FLAG: 128;
    OPENER_POLICY_SAME_ORIGIN_EMBEDDER_POLICY_REQUIRE_CORP: 17;
    OPENER_POLICY_SAME_ORIGIN_ALLOW_OUTGOING: 129;
    OPENER_POLICY_SAME_SITE_ALLOW_OUTGOING: 130;

    EMBEDDER_POLICY_NULL: 0;
    EMBEDDER_POLICY_REQUIRE_CORP: 1;

    /**
     * The LoadInfo object contains information about a network load, why it
     * was started, and how we plan on using the resulting response.
     * If a network request is redirected, the new channel will receive a new
     * LoadInfo object. The new object will contain mostly the same
     * information as the pre-redirect one, but updated as appropriate.
     * For detailed information about what parts of LoadInfo are updated on
     * redirect, see documentation on individual properties.
     */
    /**
     * The following five flags determine the security mode and hence what kind of
     * security checks should be performed throughout the lifetime of the channel.
     *
     *    * SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
     *    * SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
     *    * SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
     *    * SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
     *    * SEC_REQUIRE_CORS_DATA_INHERITS
     *
     * Exactly one of these flags are required to be set in order to allow
     * the channel to perform the correct security checks (SOP, CORS, ...) and
     * return the correct result principal. If none or more than one of these
     * flags are set AsyncOpen will fail.
     */
    /**
     * Warning: Never use this flag when creating a new channel!
     * Only use this flag if you have to create a temporary LoadInfo
     * for performing an explicit nsIContentPolicy check, like e.g.
     * when loading something from the cache that needs an explicit
     * nsIContentPolicy check. In all other cases pick one of the
     * security flags underneath.
     */
    SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK: 0;

    SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS: 1;

    SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED: 2;

    /**
     * Allow loads from other origins. Loads from data: will inherit the
     * principal.  See the documentation for principalToInherit, which describes
     * exactly what principal is inherited.
     *
     * Commonly used by plain <img>, <video>, <link rel=stylesheet> etc.
     */
    SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS: 4;

    /**
     * Allow loads from other origins. Loads from data: will be allowed,
     * but the resulting resource will get a null principal.
     * Used in blink/webkit for <iframe>s. Likely also the mode
     * that should be used by most Chrome code.
     */
    SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL: 8;

    /**
     * Allow loads from any origin, but require CORS for cross-origin loads.
     * Loads from data: are allowed and the result will inherit the principal.
     * See the documentation for principalToInherit, which describes exactly what
     * principal is inherited.
     *
     * Commonly used by <img crossorigin>, <video crossorigin>,
     * XHR, fetch(), etc.
     */
    SEC_REQUIRE_CORS_DATA_INHERITS: 16;

    /**
     * Choose cookie policy. The default policy is equivalent to "INCLUDE" for
     * SEC_REQUIRE_SAME_ORIGIN_* and SEC_ALLOW_CROSS_ORIGIN_* modes, and
     * equivalent to "SAME_ORIGIN" for SEC_REQUIRE_CORS_DATA_INHERITS mode.
     *
     * This means that if you want to perform a CORS load with credentials, pass
     * SEC_COOKIES_INCLUDE.
     *
     * Note that these flags are still subject to the user's cookie policies.
     * For example, if the user is blocking 3rd party cookies, those cookies
     * will be blocked no matter which of these flags are set.
     */
    SEC_COOKIES_DEFAULT: 0;

    SEC_COOKIES_INCLUDE: 32;

    SEC_COOKIES_SAME_ORIGIN: 64;

    SEC_COOKIES_OMIT: 96;

    /**
     * Force inheriting of the principal.  See the documentation for
     * principalToInherit, which describes exactly what principal is inherited.
     *
     * Setting this flag will cause GetChannelResultPrincipal to return the
     * principal to be inherited as the channel principal.
     *
     * This will happen independently of the scheme of the URI that the
     * channel is loading.
     *
     * So if the principal that gets inherited is "http://a.com/", and the channel
     * is loading the URI "http://b.com/whatever", GetChannelResultPrincipal
     * will return a principal from "http://a.com/".
     *
     * This flag can not be used together with SEC_SANDBOXED.  If both are passed
     * to the LoadInfo constructor then this flag will be dropped.  If you need
     * to know whether this flag would have been present but was dropped due to
     * sandboxing, check for the forceInheritPrincipalDropped flag.
     */
    SEC_FORCE_INHERIT_PRINCIPAL: 128;

    /**
     * Sandbox the load. The resulting resource will use a freshly created
     * null principal. So GetChannelResultPrincipal will always return a
     * null principal whenever this flag is set.
     *
     * This will happen independently of the scheme of the URI that the
     * channel is loading.
     *
     * This flag can not be used together with SEC_FORCE_INHERIT_PRINCIPAL.
     */
    SEC_SANDBOXED: 256;

    /**
     * Inherit the Principal for about:blank.
     */
    SEC_ABOUT_BLANK_INHERITS: 512;

    /**
     * Allow access to chrome: packages that are content accessible.
     */
    SEC_ALLOW_CHROME: 1024;

    /**
     * Disallow access to javascript: uris.
     */
    SEC_DISALLOW_SCRIPT: 2048;

    /**
     * Don't follow redirects. Instead the redirect response is returned
     * as a successful response for the channel.
     *
     * Redirects not initiated by a server response, i.e. REDIRECT_INTERNAL and
     * REDIRECT_STS_UPGRADE, are still followed.
     *
     * Note: If this flag is set and the channel response is a redirect, then
     * the response body might not be available.
     * This can happen if the redirect was cached.
     */
    SEC_DONT_FOLLOW_REDIRECTS: 4096;

    /**
     * Load an error page, it should be one of following : about:neterror,
     * about:certerror, about:blocked, about:tabcrashed or about:restartrequired.
     */
    SEC_LOAD_ERROR_PAGE: 8192;

    /**
     * Force inheriting of the principal, overruling any owner that might be set
     * on the channel. (Please note that channel.owner is deprecated and will be
     * removed within Bug 1286838).  See the documentation for principalToInherit,
     * which describes exactly what principal is inherited.
     *
     * Setting this flag will cause GetChannelResultPrincipal to return the
     * principal to be inherited as the channel principal.
     *
     * This will happen independently of the scheme of the URI that the
     * channel is loading.
     */
    SEC_FORCE_INHERIT_PRINCIPAL_OVERRULE_OWNER: 16384;

    /**
     * Constants reflecting the channel tainting.  These are mainly defined here
     * for script.  Internal C++ code should use the enum defined in LoadTainting.h.
     * See LoadTainting.h for documentation.
     */
    TAINTING_BASIC: 0;

    TAINTING_CORS: 1;

    TAINTING_OPAQUE: 2;

    /**
     * List of possible reasons the request associated with this load info
     * may have been blocked, set by various content blocking checkers.
     */
    BLOCKING_REASON_NONE: 0;

    BLOCKING_REASON_CORSDISABLED: 1001;

    BLOCKING_REASON_CORSDIDNOTSUCCEED: 1002;

    BLOCKING_REASON_CORSREQUESTNOTHTTP: 1003;

    BLOCKING_REASON_CORSMULTIPLEALLOWORIGINNOTALLOWED: 1004;

    BLOCKING_REASON_CORSMISSINGALLOWORIGIN: 1005;

    BLOCKING_REASON_CORSNOTSUPPORTINGCREDENTIALS: 1006;

    BLOCKING_REASON_CORSALLOWORIGINNOTMATCHINGORIGIN: 1007;

    BLOCKING_REASON_CORSMISSINGALLOWCREDENTIALS: 1008;

    BLOCKING_REASON_CORSORIGINHEADERNOTADDED: 1009;

    BLOCKING_REASON_CORSEXTERNALREDIRECTNOTALLOWED: 1010;

    BLOCKING_REASON_CORSPREFLIGHTDIDNOTSUCCEED: 1011;

    BLOCKING_REASON_CORSINVALIDALLOWMETHOD: 1012;

    BLOCKING_REASON_CORSMETHODNOTFOUND: 1013;

    BLOCKING_REASON_CORSINVALIDALLOWHEADER: 1014;

    BLOCKING_REASON_CORSMISSINGALLOWHEADERFROMPREFLIGHT: 1015;

    BLOCKING_REASON_CLASSIFY_MALWARE_URI: 2001;

    BLOCKING_REASON_CLASSIFY_PHISHING_URI: 2002;

    BLOCKING_REASON_CLASSIFY_UNWANTED_URI: 2003;

    BLOCKING_REASON_CLASSIFY_TRACKING_URI: 2004;

    BLOCKING_REASON_CLASSIFY_BLOCKED_URI: 2005;

    BLOCKING_REASON_CLASSIFY_HARMFUL_URI: 2006;

    BLOCKING_REASON_CLASSIFY_CRYPTOMINING_URI: 2007;

    BLOCKING_REASON_CLASSIFY_FINGERPRINTING_URI: 2008;

    BLOCKING_REASON_CLASSIFY_SOCIALTRACKING_URI: 2009;

    BLOCKING_REASON_MIXED_BLOCKED: 3001;

    BLOCKING_REASON_CONTENT_POLICY_GENERAL: 4000;

    BLOCKING_REASON_CONTENT_POLICY_NO_DATA_PROTOCOL: 4001;

    BLOCKING_REASON_CONTENT_POLICY_WEBEXT: 4002;

    BLOCKING_REASON_CONTENT_POLICY_CONTENT_BLOCKED: 4003;

    BLOCKING_REASON_CONTENT_POLICY_DATA_DOCUMENT: 4004;

    BLOCKING_REASON_CONTENT_POLICY_WEB_BROWSER: 4005;

    BLOCKING_REASON_CONTENT_POLICY_PRELOAD: 4006;

    BLOCKING_REASON_NOT_SAME_ORIGIN: 5000;
  }

  export interface nsILoadInfo extends nsISupports {

    /**
     * This is the principal of the network request's caller/requester where
     * the resulting resource will be used. I.e. it is the principal which
     * will get access to the result of the request. (Where "get access to"
     * might simply mean "embed" depending on the type of resource that is
     * loaded).
     *
     * For example for an image, it is the principal of the document where
     * the image is rendered. For a stylesheet it is the principal of the
     * document where the stylesheet will be applied.
     *
     * So if document at http://a.com/page.html loads an image from
     * http://b.com/pic.jpg, then loadingPrincipal will be
     * http://a.com/page.html.
     *
     * For <iframe> and <frame> loads, the LoadingPrincipal is the
     * principal of the parent document. For top-level loads, the
     * LoadingPrincipal is null. For all loads except top-level loads
     * the LoadingPrincipal is never null.
     *
     * If the loadingPrincipal is the system principal, no security checks
     * will be done at all. There will be no security checks on the initial
     * load or any subsequent redirects. This means there will be no
     * nsIContentPolicy checks or any CheckLoadURI checks. Because of
     * this, never set the loadingPrincipal to the system principal when
     * the URI to be loaded is controlled by a webpage.
     * If the loadingPrincipal and triggeringPrincipal are both
     * content principals, then we will always call into
     * nsIContentPolicies and CheckLoadURI. The call to nsIContentPolicies
     * and CheckLoadURI happen even if the URI to be loaded is same-origin
     * with the loadingPrincipal or triggeringPrincipal.
     */
    readonly loadingPrincipal: (nsIPrincipal | null);

    /**
     * This is the principal which caused the network load to start. I.e.
     * this is the principal which provided the URL to be loaded. This is
     * often the same as the LoadingPrincipal, but there are a few cases
     * where that's not true.
     *
     * For example for loads into an <iframe>, the LoadingPrincipal is always
     * the principal of the parent document. However the triggeringPrincipal
     * is the principal of the document which provided the URL that the
     * <iframe> is navigating to. This could be the previous document inside
     * the <iframe> which set document.location. Or a document elsewhere in
     * the frame tree which contained a <a target="..."> which targetted the
     * <iframe>.
     *
     * If a stylesheet links to a sub-resource, like an @imported stylesheet,
     * or a background image, then the triggeringPrincipal is the principal
     * of the stylesheet, while the LoadingPrincipal is the principal of the
     * document being styled.
     *
     * The triggeringPrincipal is never null.
     *
     * If the triggeringPrincipal is the system principal, no security checks
     * will be done at all. There will be no security checks on the initial
     * load or any subsequent redirects. This means there will be no
     * nsIContentPolicy checks or any CheckLoadURI checks. Because of
     * this, never set the triggeringPrincipal to the system principal when
     * the URI to be loaded is controlled by a webpage.
     * If the loadingPrincipal and triggeringPrincipal are both
     * content principals, then we will always call into
     * nsIContentPolicies and CheckLoadURI. The call to nsIContentPolicies
     * and CheckLoadURI happen even if the URI to be loaded is same-origin
     * with the loadingPrincipal or triggeringPrincipal.
     */
    readonly triggeringPrincipal: (nsIPrincipal | null);

    /**
     * For non-document loads the principalToInherit is always null. For
     * loads of type TYPE_DOCUMENT or TYPE_SUBDOCUMENT the principalToInherit
     * might be null. If it's non null, then this is the principal that is
     * inherited if a principal needs to be inherited. If the principalToInherit
     * is null but the inherit flag is set, then the triggeringPrincipal is
     * the principal that is inherited.
     */
    principalToInherit: (nsIPrincipal | null);

    /**
     * This is the ownerDocument of the LoadingNode. Unless the LoadingNode
     * is a Document, in which case the LoadingDocument is the same as the
     * LoadingNode.
     *
     * For top-level loads, and for loads originating from workers, the
     * LoadingDocument is null. When the LoadingDocument is not null, the
     * LoadingPrincipal is set to the principal of the LoadingDocument.
     */
    readonly loadingDocument: WebIDL.Document;

    /**
     * For all loads except loads of TYPE_DOCUMENT, the loadingContext
     * simply returns the loadingNode. For loads of TYPE_DOCUMENT this
     * will return the context available for top-level loads which
     * do not have a loadingNode.
     */
    readonly loadingContext: (nsISupports | null);

    /**
     * The securityFlags of that channel.
     */
    readonly securityFlags: number;

    /**
     * Allows to query only the security mode bits from above.
     */
    readonly securityMode: number;

    /**
     * This flag is used for any browsing context where we should not sniff
     * the content type. E.g if an iframe has the XCTO nosniff header, then
     * that flag is set to true so we skip content sniffing for that browsing
     * context.
     */
    skipContentSniffing: boolean;

    /**
     * True if this request is embedded in a context that can't be third-party
     * (i.e. an iframe embedded in a cross-origin parent window). If this is
     * false, then this request may be third-party if it's a third-party to
     * loadingPrincipal.
     */
    readonly isInThirdPartyContext: boolean;

    /**
     * See the SEC_COOKIES_* flags above. This attribute will never return
     * SEC_COOKIES_DEFAULT, but will instead return what the policy resolves to.
     * I.e. SEC_COOKIES_SAME_ORIGIN for CORS mode, and SEC_COOKIES_INCLUDE
     * otherwise.
     */
    readonly cookiePolicy: number;

    /**
     * If forceInheritPrincipal is true, the data coming from the channel should
     * inherit its principal, even when the data is loaded over http:// or another
     * protocol that would normally use a URI-based principal.
     *
     * See the documentation for principalToInherit, which describes exactly what
     * principal is inherited.
     *
     * This attribute will never be true when loadingSandboxed is true.
     */
    readonly forceInheritPrincipal: boolean;

    /**
     * If forceInheritPrincipalOverruleOwner is true, the data coming from the
     * channel should inherit the principal, even when the data is loaded over
     * http:// or another protocol that would normally use a URI-based principal
     * and even if the channel's .owner is not null.  This last is the difference
     * between forceInheritPrincipalOverruleOwner and forceInheritPrincipal: the
     * latter does _not_ overrule the .owner setting.
     *
     * See the documentation for principalToInherit, which describes exactly what
     * principal is inherited.
     */
    readonly forceInheritPrincipalOverruleOwner: boolean;

    /**
     * If loadingSandboxed is true, the data coming from the channel is
     * being loaded sandboxed, so it should have a nonce origin and
     * hence should use a NullPrincipal.
     */
    readonly loadingSandboxed: boolean;

    /**
     * If aboutBlankInherits is true, then about:blank should inherit
     * the principal.
     */
    readonly aboutBlankInherits: boolean;

    /**
     * If allowChrome is true, then use nsIScriptSecurityManager::ALLOW_CHROME
     * when calling CheckLoadURIWithPrincipal().
     */
    readonly allowChrome: boolean;

    /**
     * If disallowScript is true, then use nsIScriptSecurityManager::DISALLOW_SCRIPT
     * when calling CheckLoadURIWithPrincipal().
     */
    readonly disallowScript: boolean;

    /**
     * Returns true if SEC_DONT_FOLLOW_REDIRECTS is set.
     */
    readonly dontFollowRedirects: boolean;

    /**
     * Returns true if SEC_LOAD_ERROR_PAGE is set.
     */
    readonly loadErrorPage: boolean;

    /**
     * Returns true if this is a non-subresource request that was triggered
     * by docshell with the LOAD_CMD_RELOAD flag set.  Note, this is more
     * specific than looking at the load flags which indicate whether to
     * bypass the http cache.  The load flags can be set for other reasons,
     * so they can't be used to infer this value.
     */
    isDocshellReload: boolean;

    /**
     * True if the load was initiated by a form request.
     * This is important to know to handle the CSP directive navigate-to.
     */
    isFormSubmission: boolean;

    /**
     * The external contentPolicyType of the channel, used for security checks
     * like Mixed Content Blocking and Content Security Policy.
     *
     * Specifically, content policy types with _INTERNAL_ in their name will
     * never get returned from this attribute.
     */
    readonly externalContentPolicyType: number;

    /**
     * CSP uses this parameter to send or not CSP violation events.
     * Default value: true.
     */
    sendCSPViolationEvents: boolean;

    /**
     * Returns true if document or any of the documents ancestors
     * up to the toplevel document make use of the CSP directive
     * 'block-all-mixed-content'.
     *
     * Warning: If the loadingDocument is null, then the
     * blockAllMixedContent is false.
     */
    readonly blockAllMixedContent: boolean;

    /**
     * Returns true if document or any of the documents ancestors
     * up to the toplevel document make use of the CSP directive
     * 'upgrade-insecure-requests'.
     *
     * Warning: If the loadingDocument is null, then the
     * upgradeInsecureRequests is false.
     */
    readonly upgradeInsecureRequests: boolean;

    /**
     * Returns true if the the page is https and the content is upgradable from http
     * requires 'security.mixed_content.upgrade_display_content' pref to be true.
     * Currently this only upgrades display content but might be expanded to other loads.
     * This is very similar in implementation to upgradeInsecureRequests but browser set.
     */
    readonly browserUpgradeInsecureRequests: boolean;

    /**
     * Returns true if the the page is https and the content is upgradable from http
     * requires 'security.mixed_content.upgrade_display_content' pref to be false.
     * See browserUpgradeInsecureRequests for more details, this only happens
     * when *not* upgrading purely for telemetry.
     */
    readonly browserWouldUpgradeInsecureRequests: boolean;

    /**
     * If true, toplevel data: URI navigation is allowed
     */
    forceAllowDataURI: boolean;

    /**
     * If true, insecure redirects to a data: URI are allowed.
     */
    allowInsecureRedirectToDataURI: boolean;

    /**
     * If true, CORS checks will be skipped.
     */
    bypassCORSChecks: boolean;

    /**
     * If true, the content policy security check is excluded from web requests.
     */
    skipContentPolicyCheckForWebRequest: boolean;

    /**
     * If true, this is the load of a frame's original src attribute
     */
    originalFrameSrcLoad: boolean;

    /**
     * The SEC_FORCE_INHERIT_PRINCIPAL flag may be dropped when a load info
     * object is created.  Specifically, it will be dropped if the SEC_SANDBOXED
     * flag is also present.  This flag is set if SEC_FORCE_INHERIT_PRINCIPAL was
     * dropped.
     */
    readonly forceInheritPrincipalDropped: boolean;

    /**
     * These are the window IDs of the window in which the element being
     * loaded lives. parentOuterWindowID is the window ID of this window's
     * parent. topOuterWindowID is the ID of the top-level window of the same
     * docShell type.
     *
     * Note that these window IDs can be 0 if the window is not
     * available. parentOuterWindowID and topOuterWindowID will be the same as
     * outerWindowID if the window has no parent.
     */
    readonly innerWindowID: number;

    readonly outerWindowID: number;

    readonly parentOuterWindowID: number;

    readonly topOuterWindowID: number;

    /**
     * Only when the element being loaded is <frame src="foo.html">
     * (or, more generally, if the element QIs to nsFrameLoaderOwner),
     * the frameOuterWindowID is the outer window containing the
     * foo.html document.
     *
     * Note: For other cases, frameOuterWindowID is 0.
     */
    readonly frameOuterWindowID: number;

    /**
     * The BrowsingContext performing the load for this nsILoadInfo object.
     */
    readonly browsingContextID: number;

    readonly browsingContext: WebIDL.BrowsingContext;

    /**
     * Like `frameOuterWindowID`, however returning the BrowsingContextID
     * instead.
     */
    readonly frameBrowsingContextID: number;

    readonly frameBrowsingContext: WebIDL.BrowsingContext;

    /**
     * Resets the PrincipalToInherit to a freshly created NullPrincipal
     * which inherits the origin attributes from the loadInfo.
     *
     * WARNING: Please only use that function if you know exactly what
     * you are doing!!!
     */
    readonly resetPrincipalToInheritToNullPrincipal: () => void;

    /**
     * Customized OriginAttributes within LoadInfo to allow overwriting of the
     * default originAttributes from the loadingPrincipal.
     *
     * In chrome side, originAttributes.privateBrowsingId will always be 0 even if
     * the usePrivateBrowsing is true, because chrome docshell won't set
     * privateBrowsingId on origin attributes (See bug 1278664). This is to make
     * sure nsILoadInfo and nsILoadContext have the same origin attributes.
     */
    originAttributes: IDLjsval;

    /**
     * Whenever a channel is evaluated by the ContentSecurityManager
     * the first time, we set this flag to true to indicate that
     * subsequent calls of AsyncOpen() do not have to enforce all
     * security checks again. E.g., after a redirect there is no
     * need to set up CORS again. We need this separate flag
     * because the redirectChain might also contain internal
     * redirects which might pollute the redirectChain so we can't
     * rely on the size of the redirectChain-array to query whether
     * a channel got redirected or not.
     *
     * Please note, once the flag is set to true it must remain true
     * throughout the lifetime of the channel. Trying to set it
     * to anything else than true will be discarded.
     *
     */
    initialSecurityCheckDone: boolean;

    /**
     * Returns true if the load was triggered from an external application
     * (e.g. Thunderbird). Please note that this flag will only ever be true
     * if the load is of TYPE_DOCUMENT.
     */
    loadTriggeredFromExternal: boolean;

    /**
     * Whenever a channel gets redirected, append the redirect history entry of
     * the channel which contains principal referrer and remote address [before
     * the channels got redirected] to the loadinfo, so that at every point this
     * array provides us information about all the redirects this channel went
     * through.
     * @param entry, the nsIRedirectHistoryEntry before the channel
     *         got redirected.
     * @param aIsInternalRedirect should be true if the channel is going
     *        through an internal redirect, otherwise false.
     */
    readonly appendRedirectHistoryEntry: (entry: (nsIRedirectHistoryEntry | null), isInternalRedirect: boolean) => void;

    /**
     * An array of nsIRedirectHistoryEntry which stores redirects associated
     * with this channel. This array is filled whether or not the channel has
     * ever been opened. The last element of the array is associated with the
     * most recent redirect. Please note, that this array *includes* internal
     * redirects.
     */
    readonly redirectChainIncludingInternalRedirects: IDLjsval;

    /**
     * Same as RedirectChain but does *not* include internal redirects.
     */
    readonly redirectChain: IDLjsval;

    /**
     * Returns value set through setCorsPreflightInfo.
     */
    readonly forcePreflight: boolean;

    /**
     * A C++ friendly getter for the forcePreflight flag.
     */
    readonly isPreflight: boolean;

    /**
     * Determine the associated channel's current tainting.  Note, this can
     * change due to a service worker intercept, so it should be checked after
     * OnStartRequest() fires.
     */
    readonly tainting: number;

    /**
     * Note a new tainting level and possibly increase the current tainting
     * to match.  If the tainting level is already greater than the given
     * value, then there is no effect.  It is not possible to reduce the tainting
     * level on an existing channel/loadinfo.
     */
    readonly maybeIncreaseTainting: (aTainting: number) => void;

    /**
     * Various helper code to provide more convenient C++ access to the tainting
     * attribute and maybeIncreaseTainting().
     */
    /**
     * Returns true if this load is for top level document.
     * Note that the load for a sub-frame's document will return false here.
     */
    readonly isTopLevelLoad: boolean;

    /**
     * If this is non-null, this property represents two things: (1) the
     * URI to be used for the principal if the channel with this loadinfo
     * gets a principal based on URI and (2) the URI to use for a document
     * created from the channel with this loadinfo.
     */
    resultPrincipalURI: (nsIURI | null);

    /**
     * The top-level document has been user-interacted.
     */
    documentHasUserInteracted: boolean;

    /**
     * This attribute represents whether the document to which this
     * load belongs had finished loading when the load was initiated.
     */
    documentHasLoaded: boolean;

    /**
     * A snapshot of the nonce at load start time which is used for CSP
     * checks and only set for:
     *  * TYPE_SCRIPT and
     *  * TYPE_STYLESHEET
     */
    cspNonce: IDLAString;

    /**
     * If the request associated with this load info was blocked by some of
     * our content or load blockers, the reason can be found here.
     * Note that setting this attribute has NO EFFECT on blocking the request.
     * This attribute is only informative!
     *
     * By default the value is '0' - NONE.
     * Each write rewrites the last value.
     * Can be accessed only on a single thread.
     */
    requestBlockingReason: number;

    /**
     * The object in charged to receive CSP violation events. It can be null.
     * This attribute will be merged into the CSP object eventually.
     * See bug 1500908.
     */
    cspEventListener: (nsICSPEventListener | null);

    /**
     * This attribute will be true if this is a load triggered by
     * https://html.spec.whatwg.org/multipage/iframe-embed-object.html#process-the-iframe-attributes
     * or https://html.spec.whatwg.org/multipage/obsolete.html#process-the-frame-attributes
     */
    readonly isFromProcessingFrameAttributes: boolean;
  }

  export interface nsICommandLineRef {
    readonly name: "nsICommandLine";
    readonly number: "{bc3173bd-aa46-46a0-9d25-d9867a9659b6}";

    STATE_INITIAL_LAUNCH: 0;

    STATE_REMOTE_AUTO: 1;

    STATE_REMOTE_EXPLICIT: 2;
  }

  /**
   * Represents the command line used to invoke a XUL application. This may be the
   * original command-line of this instance, or a command line remoted from another
   * instance of the application.
   *
   * DEFINITIONS:
   * "arguments" are any values found on the command line.
   * "flags" are switches. In normalized form they are preceded by a single dash.
   * Some flags may take "parameters", e.g. "--url <param>".
   */
  export interface nsICommandLine extends nsISupports {

    /**
     * Number of arguments in the command line. The application name is not
     * part of the command line.
     */
    readonly length: number;

    /**
     * Get an argument from the array of command-line arguments.
     *
     * On windows, flags of the form /flag are normalized to -flag. /flag:param
     * are normalized to -flag param.
     *
     * On *nix and mac flags of the form --flag are normalized to -flag. --flag=param
     * are normalized to the form -flag param.
     *
     * @param aIndex The argument to retrieve. This index is 0-based, and does
     *               not include the application name.
     * @return       The indexth argument.
     * @throws       NS_ERROR_INVALID_ARG if aIndex is out of bounds.
     */
    readonly getArgument: (aIndex: number) => IDLAString;

    /**
     * Find a command-line flag.
     *
     * @param aFlag          The flag name to locate. Do not include the initial
     *                       hyphen.
     * @param aCaseSensitive Whether to do case-sensitive comparisons.
     * @return               The position of the flag in the command line.
     */
    readonly findFlag: (aFlag: IDLAString, aCaseSensitive: boolean) => number;

    /**
     * Remove arguments from the command line. This normally occurs after
     * a handler has processed the arguments.
     *
     * @param aStart  Index to begin removing.
     * @param aEnd    Index to end removing, inclusive.
     */
    readonly removeArguments: (aStart: number, aEnd: number) => void;

    /**
     * A helper method which will find a flag and remove it in one step.
     *
     * @param aFlag  The flag name to find and remove.
     * @param aCaseSensitive Whether to do case-sensitive comparisons.
     * @return       Whether the flag was found.
     */
    readonly handleFlag: (aFlag: IDLAString, aCaseSensitive: boolean) => boolean;

    /**
     * Find a flag with a parameter and remove both. This is a helper
     * method that combines "findFlag" and "removeArguments" in one step.
     *
     * @return   null (a void astring) if the flag is not found. The parameter value
     *           if found. Note that null and the empty string are not the same.
     * @throws   NS_ERROR_INVALID_ARG if the flag exists without a parameter
     *
     * @param aFlag The flag name to find and remove.
     * @param aCaseSensitive Whether to do case-sensitive flag search.
     */
    readonly handleFlagWithParam: (aFlag: IDLAString, aCaseSensitive: boolean) => IDLAString;

    /**
     * The type of command line being processed.
     *
     * STATE_INITIAL_LAUNCH  is the first launch of the application instance.
     * STATE_REMOTE_AUTO     is a remote command line automatically redirected to
     *                       this instance.
     * STATE_REMOTE_EXPLICIT is a remote command line explicitly redirected to
     *                       this instance using xremote/windde/appleevents.
     */
    readonly state: number;

    /**
     * There may be a command-line handler which performs a default action if
     * there was no explicit action on the command line (open a default browser
     * window, for example). This flag allows the default action to be prevented.
     */
    preventDefault: boolean;

    /**
     * The working directory for this command line. Use this property instead
     * of the working directory for the current process, since a redirected
     * command line may have had a different working directory.
     */
    readonly workingDirectory: (nsIFile | null);

    /**
     * Resolve a file-path argument into an nsIFile. This method gracefully
     * handles relative or absolute file paths, according to the working
     * directory of this command line.
     *
     * @param aArgument  The command-line argument to resolve.
     */
    readonly resolveFile: (aArgument: IDLAString) => (nsIFile | null);

    /**
     * Resolves a URI argument into a URI. This method has platform-specific
     * logic for converting an absolute URI or a relative file-path into the
     * appropriate URI object; it gracefully handles win32 C:\ paths which would
     * confuse the ioservice if passed directly.
     *
     * @param aArgument  The command-line argument to resolve.
     */
    readonly resolveURI: (aArgument: IDLAString) => (nsIURI | null);
  }

  export interface nsISharingHandlerAppRef {
    readonly name: "nsISharingHandlerApp";
    readonly number: "{7111f769-53ec-41fd-b314-613661d5b6ba}";
  }

  export interface nsISharingHandlerApp extends nsIHandlerApp {

    readonly share: (data: IDLAString, title?: IDLAString) => void;
  }

  export interface nsIInputStreamPumpRef {
    readonly name: "nsIInputStreamPump";
    readonly number: "{400f5468-97e7-4d2b-9c65-a82aecc7ae82}";
  }

  /**
   * nsIInputStreamPump
   *
   * This interface provides a means to configure and use a input stream pump
   * instance.  The input stream pump will asynchronously read from an input
   * stream, and push data to an nsIStreamListener instance.  It utilizes the
   * current thread's nsIEventTarget in order to make reading from the stream
   * asynchronous. A different thread can be used if the pump also implements
   * nsIThreadRetargetableRequest.
   *
   * If the given stream supports nsIAsyncInputStream, then the stream pump will
   * call the stream's AsyncWait method to drive the stream listener.  Otherwise,
   * the stream will be read on a background thread utilizing the stream
   * transport service.  More details are provided below.
   */
  export interface nsIInputStreamPump extends nsIRequest {

    /**
     * Initialize the input stream pump.
     *
     * @param aStream
     *        contains the data to be read.  if the input stream is non-blocking,
     *        then it will be QI'd to nsIAsyncInputStream.  if the QI succeeds
     *        then the stream will be read directly.  otherwise, it will be read
     *        on a background thread using the stream transport service.
     * @param aSegmentSize
     *        if the stream transport service is used, then this parameter
     *        specifies the segment size for the stream transport's buffer.
     *        pass 0 to specify the default value.
     * @param aSegmentCount
     *        if the stream transport service is used, then this parameter
     *        specifies the segment count for the stream transport's buffer.
     *        pass 0 to specify the default value.
     * @param aCloseWhenDone
     *        if true, the input stream will be closed after it has been read.
     * @param aMainThreadTarget
     *        a labeled main therad event target.
     */
    readonly init: (aStream: (nsIInputStream | null), aSegmentSize: number, aSegmentCount: number, aCloseWhenDone: boolean, aMainThreadTarget?: (nsIEventTarget | null)) => void;

    /**
     * asyncRead causes the input stream to be read in chunks and delivered
     * asynchronously to the listener via OnDataAvailable.
     *
     * @param aListener
     *        receives notifications.
     * @param aListenerContext
     *        passed to listener methods.
     */
    readonly asyncRead: (aListener: (nsIStreamListener | null), aListenerContext: (nsISupports | null)) => void;
  }

  export interface nsIHttpActivityObserverRef {
    readonly name: "nsIHttpActivityObserver";
    readonly number: "{412880c8-6c36-48d8-bf8f-84f91f892503}";

    ACTIVITY_TYPE_SOCKET_TRANSPORT: 1;

    ACTIVITY_TYPE_HTTP_TRANSACTION: 2;

    ACTIVITY_SUBTYPE_REQUEST_HEADER: 20481;

    ACTIVITY_SUBTYPE_REQUEST_BODY_SENT: 20482;

    ACTIVITY_SUBTYPE_RESPONSE_START: 20483;

    ACTIVITY_SUBTYPE_RESPONSE_HEADER: 20484;

    ACTIVITY_SUBTYPE_RESPONSE_COMPLETE: 20485;

    ACTIVITY_SUBTYPE_TRANSACTION_CLOSE: 20486;
  }

  /**
   * nsIHttpActivityObserver
   *
   * This interface provides a way for http activities to be reported
   * to observers.
   */
  export interface nsIHttpActivityObserver extends nsISupports {

    /**
     * observe activity from the http transport
     *
     * @param aHttpChannel
     *        nsISupports interface for the the http channel that
     *        generated this activity
     * @param aActivityType
     *        The value of this aActivityType will be one of
     *          ACTIVITY_TYPE_SOCKET_TRANSPORT or
     *          ACTIVITY_TYPE_HTTP_TRANSACTION
     * @param aActivitySubtype
     *        The value of this aActivitySubtype, will be depend
     *        on the value of aActivityType. When aActivityType
     *        is ACTIVITY_TYPE_SOCKET_TRANSPORT
     *          aActivitySubtype will be one of the
     *          nsISocketTransport::STATUS_???? values defined in
     *          nsISocketTransport.idl
     *        OR when aActivityType
     *        is ACTIVITY_TYPE_HTTP_TRANSACTION
     *          aActivitySubtype will be one of the
     *          nsIHttpActivityObserver::ACTIVITY_SUBTYPE_???? values
     *          defined below
     * @param aTimestamp
     *        microseconds past the epoch of Jan 1, 1970
     * @param aExtraSizeData
     *        Any extra size data optionally available with
     *        this activity
     * @param aExtraStringData
     *        Any extra string data optionally available with
     *        this activity
     */
    readonly observeActivity: (aHttpChannel: (nsISupports | null), aActivityType: number, aActivitySubtype: number, aTimestamp: number, aExtraSizeData: number, aExtraStringData: IDLACString) => void;

    /**
     * This attribute is true when this interface is active and should
     * observe http activities. When false, observeActivity() should not
     * be called. It is present for compatibility reasons and should be
     * implemented only by nsHttpActivityDistributor.
     */
    readonly isActive: boolean;
  }

  export interface nsIDisplayInfoRef {
    readonly name: "nsIDisplayInfo";
    readonly number: "{615bc23d-6346-4b15-9c10-add002f140b6}";
  }

  export interface nsIDisplayInfo extends nsISupports {

    readonly id: number;

    readonly connected: boolean;
  }

  export interface nsITCPDeviceInfoRef {
    readonly name: "nsITCPDeviceInfo";
    readonly number: "{296fd171-e4d0-4de0-99ff-ad8ed52ddef3}";
  }

  export interface nsITCPDeviceInfo extends nsISupports {

    readonly id: IDLAUTF8String;

    readonly address: IDLAUTF8String;

    readonly port: number;

    readonly certFingerprint: IDLAUTF8String;
  }

  export interface nsIResProtocolHandlerRef {
    readonly name: "nsIResProtocolHandler";
    readonly number: "{241d34ac-9ed5-46d7-910c-7a9d914aa0c5}";
  }

  /**
   * Protocol handler interface for the resource:// protocol
   */
  export interface nsIResProtocolHandler extends nsISubstitutingProtocolHandler {

    readonly allowContentToAccess: (url: (nsIURI | null)) => boolean;
  }

  export interface nsISimpleEnumeratorBaseRef {
    readonly name: "nsISimpleEnumeratorBase";
    readonly number: "{796f340d-0a2a-490b-9c60-640765e99782}";
  }

  export interface nsISimpleEnumeratorBase extends nsISupports {

    /**
     * Returns a JavaScript iterator for all remaining entries in the enumerator.
     * Each entry is typically queried to the appropriate interface for the
     * enumerator.
     */
    readonly iterator: () => (nsIJSEnumerator | null);
  }

  export interface mozILocaleServiceRef {
    readonly name: "mozILocaleService";
    readonly number: "{c27f8983-b48b-4d1a-92d7-feb8106f212d}";

    /**
     * List of language negotiation strategies to use.
     * For an example list of requested and available locales:
     *
     *   Requested: ['es-MX', 'fr-FR']
     *   Available: ['fr', 'fr-CA', 'es', 'es-MX', 'it']
     *   DefaultLocale: ['en-US']
     *
     * each of those strategies will build a different result:
     *
     *
     * filtering (default) -
     *   Matches as many of the available locales as possible.
     *
     *   Result:
     *     Supported: ['es-MX', 'es', 'fr', 'fr-CA', 'en-US']
     *
     * matching -
     *   Matches the best match from the available locales for every requested
     *   locale.
     *
     *   Result:
     *     Supported: ['es-MX', 'fr', 'en-US']
     *
     * lookup -
     *   Matches a single best locale. This strategy always returns a list
     *   of the length 1 and requires a defaultLocale to be set.
     *
     *   Result:
     *     Supported: ['es-MX']
     */
    langNegStrategyFiltering: 0;

    langNegStrategyMatching: 1;

    langNegStrategyLookup: 2;
  }

  export interface mozILocaleService extends nsISupports {

    /**
     * Default locale of the browser. The locale we are guaranteed to have
     * resources for that should be used as a last resort fallack in cases
     * where requested locales do not match available locales.
     */
    readonly defaultLocale: IDLACString;

    /**
     * Last fallback is the final fallback locale we're going to attempt if all
     * else fails in any language negotiation or locale resource retrieval situations.
     *
     * At the moment it returns `en-US`.
     */
    readonly lastFallbackLocale: IDLACString;

    /**
     * Returns a list of locales that the application should be localized to.
     *
     * The result is a ordered list of valid locale IDs and it should be
     * used for all APIs that accept list of locales, like ECMA402 and L10n APIs.
     *
     * This API always returns at least one locale.
     *
     * When retrieving the locales for language negotiation and matching
     * to language resources, use the language tag form.
     * When retrieving the locales for Intl API or ICU locale settings,
     * use the BCP47 form.
     *
     * Example: ["en-US", "de", "pl", "sr-Cyrl", "zh-Hans-HK"]
     */
    readonly appLocalesAsLangTags: IDLACString[];

    readonly appLocalesAsBCP47: IDLACString[];

    /**
     * Returns a list of locales to use for any regional specific operations
     * like date formatting, calendars, unit formatting etc.
     *
     * The result is a ordered list of valid locale IDs and it should be
     * used for all APIs that accept list of locales, like ECMA402 and L10n APIs.
     *
     * This API always returns at least one locale.
     *
     * Example: ["en-US", "de", "pl", "sr-Cyrl", "zh-Hans-HK"]
     */
    readonly regionalPrefsLocales: IDLACString[];

    readonly webExposedLocales: IDLACString[];

    /**
     * Negotiates the best locales out of a ordered list of requested locales and
     * a list of available locales.
     *
     * Internally it uses the following naming scheme:
     *
     *  Requested - locales requested by the user
     *  Available - locales for which the data is available
     *  Supported - locales negotiated by the algorithm
     *
     * Additionally, if defaultLocale is provided, it adds it to the end of the
     * result list as a "last resort" locale.
     *
     * Strategy is one of the three strategies described at the top of this file.
     *
     * The result list is canonicalized and ordered according to the order
     * of the requested locales.
     *
     * (See LocaleService.h for a more C++-friendly version of this.)
     */
    readonly negotiateLanguages: (aRequested: IDLAUTF8String[], aAvailable: IDLAUTF8String[], aDefaultLocale?: IDLACString, langNegStrategy?: number) => IDLACString[];

    /**
     * Returns the best locale that the application should be localized to.
     *
     * The result is a valid locale ID and it should be
     * used for all APIs that do not handle language negotiation.
     *
     * When retrieving the locales for language negotiation and matching
     * to language resources, use the language tag form.
     * When retrieving the locales for Intl API or ICU locale settings,
     * use the BCP47 form.
     *
     * Where possible, appLocales* should be preferred over this API and
     * all callsites should handle some form of "best effort" language
     * negotiation to respect user preferences in case the use case does
     * not have data for the first locale in the list.
     *
     * Example: "zh-Hans-HK"
     */
    readonly appLocaleAsLangTag: IDLACString;

    readonly appLocaleAsBCP47: IDLACString;

    /**
     * Returns a list of locales that the user requested the app to be
     * localized to.
     *
     * The result is an ordered list of locale IDs which should be
     * used as a requestedLocales input list for language negotiation.
     *
     * Example: ["en-US", "de", "pl", "sr-Cyrl", "zh-Hans-HK"]
     */
    requestedLocales: IDLACString[];

    /**
     * Returns the top-requested locale from the user, or an empty string if none is set.
     */
    readonly requestedLocale: IDLACString;

    /**
     * Returns a list of locales that the app can be localized to.
     *
     * The result is an unordered list of locale IDs which should be
     * used as a availableLocales input list for language negotiation.
     *
     * Example: ["en-US", "de", "pl", "sr-Cyrl", "zh-Hans-HK"]
     */
    availableLocales: IDLACString[];

    /**
     * Returns whether the current app locale is RTL.
     */
    readonly isAppLocaleRTL: boolean;

    /**
     * Returns a list of locales packaged into the app bundle.
     *
     * Example: ["en-US", "de", "pl", "sr-Cyrl", "zh-Hans-HK"]
     */
    readonly packagedLocales: IDLACString[];
  }

  export interface nsIControllersRef {
    readonly name: "nsIControllers";
    readonly number: "{f36e3ec1-9197-4ad8-8d4c-d3b1927fd6df}";
  }

  export interface nsIControllers extends nsISupports {

    readonly getControllerForCommand: (command: string) => (nsIController | null);

    readonly insertControllerAt: (index: number, controller: (nsIController | null)) => void;

    readonly removeControllerAt: (index: number) => (nsIController | null);

    readonly getControllerAt: (index: number) => (nsIController | null);

    readonly appendController: (controller: (nsIController | null)) => void;

    readonly removeController: (controller: (nsIController | null)) => void;

    readonly getControllerId: (controller: (nsIController | null)) => number;

    readonly getControllerById: (controllerID: number) => (nsIController | null);

    readonly getControllerCount: () => number;
  }

  export interface nsITLSClientStatusRef {
    readonly name: "nsITLSClientStatus";
    readonly number: "{19668ea4-e5ad-4182-9698-7e890d48f327}";

    /**
     * Values for tlsVersionUsed, as defined by TLS
     */
    SSL_VERSION_3: 768;

    TLS_VERSION_1: 769;

    TLS_VERSION_1_1: 770;

    TLS_VERSION_1_2: 771;

    TLS_VERSION_1_3: 772;

    TLS_VERSION_UNKNOWN: -1;
  }

  /**
   * Security summary for a given TLS client connection being handled by a
   * |nsITLSServerSocket| server.
   *
   * This is accessible through the security info object on the transport, which
   * will be an instance of |nsITLSServerConnectionInfo| (see below).
   *
   * The values of these attributes are available once the |onHandshakeDone|
   * method of the security observer has been called (see
   * |nsITLSServerSecurityObserver| below).
   */
  export interface nsITLSClientStatus extends nsISupports {

    /**
     * peerCert
     *
     * The client's certificate, if one was requested via |requestCertificate|
     * above and supplied by the client.
     */
    readonly peerCert: (nsIX509Cert | null);

    /**
     * tlsVersionUsed
     *
     * The version of TLS used by the connection.  See values above.
     */
    readonly tlsVersionUsed: number;

    /**
     * cipherName
     *
     * Name of the cipher suite used, such as
     * "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256".
     * See security/nss/lib/ssl/sslinfo.c for the possible values.
     */
    readonly cipherName: IDLACString;

    /**
     * keyLength
     *
     * The "effective" key size of the symmetric key in bits.
     */
    readonly keyLength: number;

    /**
     * macLength
     *
     * The size of the MAC in bits.
     */
    readonly macLength: number;
  }

  export interface nsICommandControllerRef {
    readonly name: "nsICommandController";
    readonly number: "{eec0b435-7f53-44fe-b00a-cf3eed65c01a}";
  }

  export interface nsICommandController extends nsISupports {

    readonly getCommandStateWithParams: (command: string, aCommandParams: (nsICommandParams | null)) => void;

    readonly doCommandWithParams: (command: string, aCommandParams: (nsICommandParams | null)) => void;

    readonly getSupportedCommands: () => IDLACString[];
  }

  export interface nsIAlertsIconURIRef {
    readonly name: "nsIAlertsIconURI";
    readonly number: "{f3c82915-bf60-41ea-91ce-6c46b22e381a}";
  }

  export interface nsIAlertsIconURI extends nsISupports {

    /**
     * Shows an alert with an icon URI. Web notifications use |moz-anno:|
     * URIs to reference favicons from Places. If the page doesn't have a
     * favicon, |aIconURI| will be |null|.
     */
    readonly showAlertWithIconURI: (aAlert: (nsIAlertNotification | null), aAlertListener?: (nsIObserver | nsIObserverFunction | null), aIconURI?: (nsIURI | null)) => void;
  }

  export interface mozILocalizationJSMRef {
    readonly name: "mozILocalizationJSM";
    readonly number: "{96632d26-1422-12e9-b1ce-9bb586acd241}";
  }

  export interface mozILocalizationJSM extends nsISupports {

    readonly getLocalization: (resourceIds: IDLAString[], sync: boolean) => (mozILocalization | null);

    readonly getLocalizationWithCustomGenerateMessages: (resourceIds: IDLAString[], generateMessages: IDLjsval) => (mozILocalization | null);
  }

  export enum nsIScriptableContentIterator_IteratorType {
    NOT_INITIALIZED = 0,
    POST_ORDER_ITERATOR = 1,
    PRE_ORDER_ITERATOR = 2,
    SUBTREE_ITERATOR = 3,
  }

  export interface nsIScriptableContentIteratorRef {
    readonly name: "nsIScriptableContentIterator";
    readonly number: "{9f25fb2a-265f-44f9-a122-62bbf443239e}";

    NOT_INITIALIZED: 0;
    POST_ORDER_ITERATOR: 1;
    PRE_ORDER_ITERATOR: 2;
    SUBTREE_ITERATOR: 3;
  }

  /**
   * nsIScriptableContentIterator is designed to testing concrete classes of
   * ContentIteratorBase.
   */
  export interface nsIScriptableContentIterator extends nsISupports {

    /**
     * You need to call initWith*() first.  Then, the instance of this interface
     * decides the type of iterator with its aType argument.  You can call
     * initWith*() multiple times, but you need to keep setting same type as
     * previous call.  If you set different type, these method with throw an
     * exception.
     */
    readonly initWithRootNode: (aType: nsIScriptableContentIterator_IteratorType, aRoot: WebIDL.Node) => void;

    readonly initWithRange: (aType: nsIScriptableContentIterator_IteratorType, aRange: WebIDL.Range) => void;

    readonly initWithPositions: (aType: nsIScriptableContentIterator_IteratorType, aStartContainer: WebIDL.Node, aStartOffset: number, aEndContainer: WebIDL.Node, aEndOffset: number) => void;

    readonly first: () => void;

    readonly last: () => void;

    readonly next: () => void;

    readonly prev: () => void;

    readonly currentNode: WebIDL.Node;

    readonly isDone: boolean;

    readonly positionAt: (aNode: WebIDL.Node) => void;
  }

  export interface nsIParentChannelRef {
    readonly name: "nsIParentChannel";
    readonly number: "{e0fc4801-6030-4653-a59f-1fb282bd1a04}";
  }

  /**
   * Implemented by chrome side of IPC protocols.
   */
  export interface nsIParentChannel extends nsIStreamListener {

    /**
     * Called to invoke deletion of the IPC protocol.
     */
    readonly delete: () => void;
  }

  export interface nsIWebSocketFrameRef {
    readonly name: "nsIWebSocketFrame";
    readonly number: "{6714a6be-2265-4f73-a988-d78a12416037}";

    OPCODE_CONTINUATION: 0;

    OPCODE_TEXT: 1;

    OPCODE_BINARY: 2;

    OPCODE_CLOSE: 8;

    OPCODE_PING: 9;

    OPCODE_PONG: 10;
  }

  export interface nsIWebSocketFrame extends nsISupports {

    readonly timeStamp: number;

    readonly finBit: boolean;

    readonly rsvBit1: boolean;

    readonly rsvBit2: boolean;

    readonly rsvBit3: boolean;

    readonly opCode: number;

    readonly maskBit: boolean;

    readonly mask: number;

    readonly payload: IDLACString;
  }

  export interface nsIWebBrowserPersistWriteCompletionRef {
    readonly name: "nsIWebBrowserPersistWriteCompletion";
    readonly number: "{a07e6892-38ae-4207-8340-7fa6ec446ed6}";
  }

  type nsIWebBrowserPersistWriteCompletionFunction = (aDocument: (nsIWebBrowserPersistDocument | null), aStream: (nsIOutputStream | null), aContentType: IDLACString, aStatus: number) => void;

  export interface nsIWebBrowserPersistWriteCompletion extends nsISupports {

    /**
     * Asynchronous callback for when nsIWebBrowserPersistDocument is finished
     * serializing the document's DOM.
     */
    /**
     * Indicates that serialization is finished.
     *
     * @param aDocument     The document that was being serialized.
     *
     * @param aStream       The stream that was being written to.  If it
     *                      needs to be closed, the callback must do that;
     *                      the serialization process leaves it open.
     *
     * @param aContentType  The content type with which the document was
     *                      actually serialized; this may be useful to set
     *                      metadata on the result, or if uploading it.
     *
     * @param aStatus       Indicates whether serialization encountered an error.
     */
    readonly onFinish: (aDocument: (nsIWebBrowserPersistDocument | null), aStream: (nsIOutputStream | null), aContentType: IDLACString, aStatus: number) => void;
  }

  export interface nsIUnicharInputStreamRef {
    readonly name: "nsIUnicharInputStream";
    readonly number: "{d5e3bd80-6723-4b92-b0c9-22f6162fd94f}";
  }

  export interface nsIUnicharInputStream extends nsISupports {

    /**
     * Read into a string object.
     * @param aCount The number of characters that should be read
     * @return The number of characters that were read.
     */
    readonly readString: (aCount: number, aString: Out<IDLAString>) => number;

    /**
     * Close the stream and free associated resources. This also closes the
     * underlying stream, if any.
     */
    readonly close: () => void;
  }

  export interface nsIXPCComponents_ExceptionRef {
    readonly name: "nsIXPCComponents_Exception";
    readonly number: "{5bf039c0-e028-11d3-8f5d-0010a4e73d9a}";
  }

  /**
   * interface of Components.Exception
   * (interesting stuff only reflected into JavaScript)
   */
  export interface nsIXPCComponents_Exception extends nsISupports {
  }

  export interface nsIExternalURLHandlerServiceRef {
    readonly name: "nsIExternalURLHandlerService";
    readonly number: "{56c5c7d3-6fd3-43f8-9429-4397e111453a}";
  }

  /**
   * The external URL handler service is used for finding
   * platform-specific applications for handling particular URLs.
   */
  export interface nsIExternalURLHandlerService extends nsISupports {

    /**
     * Given a URL, looks up the handler info from the OS. This should be
     * overridden by each OS's implementation.
     *
     * @param aURL The URL we are looking for.
     * @param aFound  Was an OS default handler for this URL found?
     * @return  An nsIHanderInfo for the protocol.
     */
    readonly getURLHandlerInfoFromOS: (aURL: (nsIURI | null), aFound: Out<boolean>) => (nsIHandlerInfo | null);
  }

  export interface nsISupportsDoubleRef {
    readonly name: "nsISupportsDouble";
    readonly number: "{b32523a0-4ac0-11d3-baea-00805f8a5dd7}";
  }

  /**
   * Scriptable storage for doubles
   */
  export interface nsISupportsDouble extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsITXTToHTMLConvRef {
    readonly name: "nsITXTToHTMLConv";
    readonly number: "{933355f6-1dd2-11b2-a9b0-d335b9e35983}";
  }

  export interface nsITXTToHTMLConv extends nsIStreamConverter {

    /**
     * @param text: Title to set for the HTML document.  Only applicable if
     *              preFormatHTML(true) is called.
     * @result      The given title will be used to form an HTML document
     *              from the plain text document.
     */
    readonly setTitle: (text: string) => void;

    /**
     * @param value: true to use an HTML header and footer on the document,
     *               false to omit it.
     * @result       The document will use a header and footer if value is
     *               true.
     */
    readonly preFormatHTML: (value: boolean) => void;
  }

  export interface nsINullChannelRef {
    readonly name: "nsINullChannel";
    readonly number: "{4610b901-df41-4bb4-bd3f-fd4d6b6d8d68}";
  }

  /**
   * This interface is only used in order to mark the fact that
   * an object isn't a complete implementation of its interfaces.
   * For example, a consumer can QI NullHttpChannel to nsINullChannel,
   * to determine if the object is just a dummy implementation of nsIHttpChannel.
   */
  export interface nsINullChannel extends nsISupports {
  }

  export interface nsISupportsPRUint16Ref {
    readonly name: "nsISupportsPRUint16";
    readonly number: "{dfacb090-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for unsigned 16-bit integers
   */
  export interface nsISupportsPRUint16 extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsICacheListenerRef {
    readonly name: "nsICacheListener";
    readonly number: "{8eadf2ed-8cac-4961-8025-6da6d5827e74}";
  }

  export interface nsICacheListener extends nsISupports {

    /**
     * Called when the requested access (or appropriate subset) is
     * acquired.  The status parameter equals NS_OK on success.
     * See nsICacheService.idl for accessGranted values.
     */
    readonly onCacheEntryAvailable: (descriptor: (nsICacheEntryDescriptor | null), accessGranted: number, status: number) => void;

    /**
     * Called when nsCacheSession::DoomEntry() is completed. The status
     * parameter is NS_OK when the entry was doomed, or NS_ERROR_NOT_AVAILABLE
     * when there is no such entry.
     */
    readonly onCacheEntryDoomed: (status: number) => void;
  }

  export interface nsIOSFileConstantsServiceRef {
    readonly name: "nsIOSFileConstantsService";
    readonly number: "{d6dd239f-34d6-4b34-baa1-f69ab4a20bc4}";
  }

  export interface nsIOSFileConstantsService extends nsISupports {

    /**
     * Inject module OS.Constants in the environment.
     *
     * This method must be called only from the main thread.
     * Method is idempotent.
     */
    readonly init: () => void;
  }

  export interface nsIStackFrameRef {
    readonly name: "nsIStackFrame";
    readonly number: "{28bfb2a2-5ea6-4738-918b-049dc4d51f0b}";
  }

  export interface nsIStackFrame extends nsISupports {

    readonly filename: IDLAString;

    readonly name: IDLAString;

    readonly sourceId: number;

    readonly lineNumber: number;

    readonly columnNumber: number;

    readonly sourceLine: IDLAUTF8String;

    readonly asyncCause: IDLAString;

    readonly asyncCaller: (nsIStackFrame | null);

    readonly caller: (nsIStackFrame | null);

    readonly formattedStack: IDLAString;

    readonly nativeSavedFrame: IDLjsval;

    readonly toString: () => IDLAUTF8String;
  }

  export interface nsIPresentationRequestUIGlueRef {
    readonly name: "nsIPresentationRequestUIGlue";
    readonly number: "{faa45119-6fb5-496c-aa4c-f740177a38b5}";
  }

  export interface nsIPresentationRequestUIGlue extends nsISupports {

    readonly sendRequest: (url: IDLAString, sessionId: IDLAString, device: (nsIPresentationDevice | null)) => IDLPromise;
  }

  export interface nsILoadGroupChildRef {
    readonly name: "nsILoadGroupChild";
    readonly number: "{02efe8e2-fbbc-4718-a299-b8a09c60bf6b}";
  }

  /**
   * nsILoadGroupChild provides a hierarchy of load groups so that the
   * root load group can be used to conceptually tie a series of loading
   * operations into a logical whole while still leaving them separate
   * for the purposes of cancellation and status events.
   */
  export interface nsILoadGroupChild extends nsISupports {

    /**
     * The parent of this load group. It is stored with
     * a nsIWeakReference/nsWeakPtr so there is no requirement for the
     * parentLoadGroup to out live the child, nor will the child keep a
     * reference count on the parent.
     */
    parentLoadGroup: (nsILoadGroup | null);

    /**
     * The nsILoadGroup associated with this nsILoadGroupChild
     */
    readonly childLoadGroup: (nsILoadGroup | null);

    /**
     * The rootLoadGroup is the recursive parent of this
     * load group where parent is defined as parentlLoadGroup if set
     * or childLoadGroup.loadGroup as a backup. (i.e. parentLoadGroup takes
     * precedence.) The nsILoadGroup child is the root if neither parent
     * nor loadgroup attribute is specified.
     */
    readonly rootLoadGroup: (nsILoadGroup | null);
  }

  export interface nsIFileInputStreamRef {
    readonly name: "nsIFileInputStream";
    readonly number: "{e3d56a20-c7ec-11d3-8cda-0060b0fc14a3}";

    /**
     * If this is set, the file will close automatically when the end of the
     * file is reached.
     */
    CLOSE_ON_EOF: 4;

    /**
     * If this is set, the file will be reopened whenever we reach the start of
     * the file, either by doing a Seek(0, NS_SEEK_CUR), or by doing a relative
     * seek that happen to reach the beginning of the file. If the file is
     * already open and the seek occurs, it will happen naturally.  (The file
     * will only be reopened if it is closed for some reason.)
     */
    REOPEN_ON_REWIND: 8;

    /**
     * If this is set, the file will be opened (i.e., a call to
     * PR_Open done) only when we do an actual operation on the stream,
     * or more specifically, when one of the following is called:
     *   - Seek
     *   - Tell
     *   - SetEOF
     *   - Available
     *   - Read
     *   - ReadLine
     *
     * DEFER_OPEN is useful if we use the stream on a background
     * thread, so that the opening and possible |stat|ing of the file
     * happens there as well.
     *
     * @note Using this flag results in the file not being opened
     *       during the call to Init.  This means that any errors that might
     *       happen when this flag is not set would happen during the
     *       first read.  Also, the file is not locked when Init is called,
     *       so it might be deleted before we try to read from it.
     */
    DEFER_OPEN: 16;

    /**
     * This flag has no effect and is totally ignored on any platform except
     * Windows since this is the default behavior on POSIX systems. On Windows
     * if this flag is set then the stream is opened in a special mode that
     * allows the OS to delete the file from disk just like POSIX.
     */
    SHARE_DELETE: 32;
  }

  /**
   * An input stream that allows you to read from a file.
   */
  export interface nsIFileInputStream extends nsIInputStream {

    /**
     * @param file          file to read from
     * @param ioFlags       file open flags listed in prio.h (see
     *                      PR_Open documentation) or -1 to open the
     *                      file in default mode (PR_RDONLY).
     * @param perm          file mode bits listed in prio.h or -1 to
     *                      use the default value (0)
     * @param behaviorFlags flags specifying various behaviors of the class
     *        (see enumerations in the class)
     */
    readonly init: (file: (nsIFile | null), ioFlags: number, perm: number, behaviorFlags: number) => void;
  }

  export interface nsIHapticFeedbackRef {
    readonly name: "nsIHapticFeedback";
    readonly number: "{91917c98-a8f3-4c98-8f10-4afb872f54c7}";

    ShortPress: 0;

    LongPress: 1;
  }

  export interface nsIHapticFeedback extends nsISupports {

    /**
     * Perform haptic feedback
     *
     * @param isLongPress
     *        indicate whether feedback is for a long press (vs. short press)
     */
    readonly performSimpleAction: (isLongPress: number) => void;
  }

  export interface nsIWritablePropertyBagRef {
    readonly name: "nsIWritablePropertyBag";
    readonly number: "{96fc4671-eeb4-4823-9421-e50fb70ad353}";
  }

  export interface nsIWritablePropertyBag extends nsIPropertyBag {

    /**
     * Set a property with the given name to the given value.  If
     * a property already exists with the given name, it is
     * overwritten.
     */
    readonly setProperty: (name: IDLAString, value: (nsIVariant | null)) => void;

    /**
     * Delete a property with the given name.
     * @throws NS_ERROR_FAILURE if a property with that name doesn't
     * exist.
     */
    readonly deleteProperty: (name: IDLAString) => void;
  }

  export interface nsIAppStartupRef {
    readonly name: "nsIAppStartup";
    readonly number: "{6621f6d5-6c04-4a0e-9e74-447db221484e}";

    /**
     * The following flags may be passed as the aMode parameter to the quit
     * method.  One and only one of the "Quit" flags must be specified.  The
     * eRestart flag may be bit-wise combined with one of the "Quit" flags to
     * cause the application to restart after it quits.
     */
    /**
     * Attempt to quit if all windows are closed.
     */
    eConsiderQuit: 1;

    /**
     * Try to close all windows, then quit if successful.
     */
    eAttemptQuit: 2;

    /**
     * Quit, damnit!
     */
    eForceQuit: 3;

    /**
     * Restart the application after quitting.  The application will be
     * restarted with the same profile and an empty command line.
     */
    eRestart: 16;
  }

  export interface nsIAppStartup extends nsISupports {

    /**
     * Create the hidden window.
     */
    readonly createHiddenWindow: () => void;

    /**
     * Destroys the hidden window. This will have no effect if the hidden window
     * has not yet been created.
     */
    readonly destroyHiddenWindow: () => void;

    /**
     * Runs an application event loop: normally the main event pump which
     * defines the lifetime of the application. If there are no windows open
     * and no outstanding calls to enterLastWindowClosingSurvivalArea this
     * method will exit immediately.
     *
     * @returnCode NS_SUCCESS_RESTART_APP
     *             This return code indicates that the application should be
     *             restarted because quit was called with the eRestart flag.
     */
    readonly run: () => void;

    /**
     * There are situations where all application windows will be
     * closed but we don't want to take this as a signal to quit the
     * app. Bracket the code where the last window could close with
     * these.
     */
    readonly enterLastWindowClosingSurvivalArea: () => void;

    readonly exitLastWindowClosingSurvivalArea: () => void;

    /**
     * Startup Crash Detection
     *
     * Keeps track of application startup begining and success using flags to
     * determine whether the application is crashing on startup.
     * When the number of crashes crosses the acceptable threshold, safe mode
     * or other repair procedures are performed.
     */
    /**
     * Whether automatic safe mode is necessary at this time.  This gets set
     * in trackStartupCrashBegin.
     *
     * @see trackStartupCrashBegin
     */
    readonly automaticSafeModeNecessary: boolean;

    /**
     * Restart the application in safe mode
     * @param aQuitMode
     *        This parameter modifies how the app is shutdown.
     * @see nsIAppStartup::quit
     */
    readonly restartInSafeMode: (aQuitMode: number) => void;

    /**
     * Run a new instance of this app with a specified profile
     * @param aProfile
     *        The profile we want to use.
     * @see nsIAppStartup::quit
     */
    readonly createInstanceWithProfile: (aProfile: (nsIToolkitProfile | null)) => void;

    /**
     * If the last startup crashed then increment a counter.
     * Set a flag so on next startup we can detect whether TrackStartupCrashEnd
     * was called (and therefore the application crashed).
     * @return whether safe mode is necessary
     */
    readonly trackStartupCrashBegin: () => boolean;

    /**
     * We have succesfully started without crashing. Clear flags that were
     * tracking past crashes.
     */
    readonly trackStartupCrashEnd: () => void;

    /**
     * Exit the event loop, and shut down the app.
     *
     * @param aMode
     *        This parameter modifies how the app is shutdown, and it is
     *        constructed from the constants defined above.
     */
    readonly quit: (aMode: number) => void;

    /**
     * True if the application is in the process of shutting down.
     */
    readonly shuttingDown: boolean;

    /**
     * True if the application is in the process of starting up.
     *
     * Startup is complete once all observers of final-ui-startup have returned.
     */
    readonly startingUp: boolean;

    /**
     * True if the application is being restarted
     */
    readonly restarting: boolean;

    /**
     * True if this is the startup following restart, i.e. if the application
     * was restarted using quit(eRestart*).
     */
    readonly wasRestarted: boolean;

    /**
     * The number of seconds since the OS was last rebooted
     */
    readonly secondsSinceLastOSRestart: number;

    /**
     * Returns an object with main, process, firstPaint, sessionRestored properties.
     * Properties may not be available depending on platform or application
     */
    readonly getStartupInfo: () => IDLjsval;

    /**
     * True if startup was interrupted by an interactive prompt.
     */
    interrupted: boolean;
  }

  export interface nsIProtocolProxyServiceRef {
    readonly name: "nsIProtocolProxyService";
    readonly number: "{ef57c8b6-e09d-4cd4-9222-2a5d2402e15d}";

    /** Flag 1 << 0 is unused **/
    /**
     * When the proxy configuration is manual this flag may be passed to the
     * resolve and asyncResolve methods to request to prefer the SOCKS proxy
     * to HTTP ones.
     */
    RESOLVE_PREFER_SOCKS_PROXY: 2;

    /**
     * When the proxy configuration is manual this flag may be passed to the
     * resolve and asyncResolve methods to request to not analyze the uri's
     * scheme specific proxy. When this flag is set the main HTTP proxy is the
     * preferred one.
     *
     * NOTE: if RESOLVE_PREFER_SOCKS_PROXY is set then the SOCKS proxy is
     *       the preferred one.
     *
     * NOTE: if RESOLVE_PREFER_HTTPS_PROXY is set then the HTTPS proxy
     *       is the preferred one.
     */
    RESOLVE_IGNORE_URI_SCHEME: 4;

    /**
     * When the proxy configuration is manual this flag may be passed to the
     * resolve and asyncResolve methods to request to prefer the HTTPS proxy
     * to the others HTTP ones.
     *
     * NOTE: RESOLVE_PREFER_SOCKS_PROXY takes precedence over this flag.
     *
     * NOTE: This flag implies RESOLVE_IGNORE_URI_SCHEME.
     */
    RESOLVE_PREFER_HTTPS_PROXY: 12;

    /**
     * When the proxy configuration is manual this flag may be passed to the
     * resolve and asyncResolve methods to that all methods will be tunneled via
     * CONNECT through the http proxy.
     */
    RESOLVE_ALWAYS_TUNNEL: 16;

    /**
     * These values correspond to the possible integer values for the
     * network.proxy.type preference.
     */
    PROXYCONFIG_DIRECT: 0;

    PROXYCONFIG_MANUAL: 1;

    PROXYCONFIG_PAC: 2;

    PROXYCONFIG_WPAD: 4;

    PROXYCONFIG_SYSTEM: 5;
  }

  /**
   * nsIProtocolProxyService provides methods to access information about
   * various network proxies.
   */
  export interface nsIProtocolProxyService extends nsISupports {

    /**
     * This method returns via callback a nsIProxyInfo instance that identifies
     * a proxy to be used for the given channel.  Otherwise, this method returns
     * null indicating that a direct connection should be used.
     *
     * @param aChannelOrURI
     *        The channel for which a proxy is to be found, or, if no channel is
     *        available, a URI indicating the same. This method will return
     *        NS_ERROR_NOINTERFACE if this argument isn't either an nsIURI or an
     *        nsIChannel.
     * @param aFlags
     *        A bit-wise combination of the RESOLVE_ flags defined above.  Pass
     *        0 to specify the default behavior.  Any additional bits that do
     *        not correspond to a RESOLVE_ flag are reserved for future use.
     * @param aCallback
     *        The object to be notified when the result is available.
     * @param aMainThreadTarget
     *        A labelled event target for dispatching runnables to main thread.
     *
     * @return An object that can be used to cancel the asychronous operation.
     *         If canceled, the cancelation status (aReason) will be forwarded
     *         to the callback's onProxyAvailable method via the aStatus param.
     *
     * NOTE: If this proxy is unavailable, getFailoverForProxy may be called
     * to determine the correct secondary proxy to be used.
     *
     * NOTE: If the protocol handler for the given URI supports
     * nsIProxiedProtocolHandler, then the nsIProxyInfo instance returned from
     * resolve may be passed to the newProxiedChannel method to create a
     * nsIChannel to the given URI that uses the specified proxy.
     *
     * NOTE: However, if the nsIProxyInfo type is "http", then it means that
     * the given URI should be loaded using the HTTP protocol handler, which
     * also supports nsIProxiedProtocolHandler.
     *
     * @see nsIProxiedProtocolHandler::newProxiedChannel
     */
    readonly asyncResolve: (aChannelOrURI: (nsISupports | null), aFlags: number, aCallback: (nsIProtocolProxyCallback | null), aMainThreadTarget?: (nsIEventTarget | null)) => (nsICancelable | null);

    /**
     * This method may be called to construct a nsIProxyInfo instance from
     * the given parameters.  This method may be useful in conjunction with
     * nsISocketTransportService::createTransport for creating, for example,
     * a SOCKS connection.
     *
     * @param aType
     *        The proxy type.  This is a string value that identifies the proxy
     *        type.  Standard values include:
     *          "http"    - specifies a HTTP proxy
     *          "https"   - specifies HTTP proxying over TLS connection to proxy
     *          "socks"   - specifies a SOCKS version 5 proxy
     *          "socks4"  - specifies a SOCKS version 4 proxy
     *          "direct"  - specifies a direct connection (useful for failover)
     *        The type name is case-insensitive.  Other string values may be
     *        possible, and new types may be defined by a future version of
     *        this interface.
     * @param aHost
     *        The proxy hostname or IP address.
     * @param aPort
     *        The proxy port.
     * @param aFlags
     *        Flags associated with this connection.  See nsIProxyInfo.idl
     *        for currently defined flags.
     * @param aFailoverTimeout
     *        Specifies the length of time (in seconds) to ignore this proxy if
     *        this proxy fails.  Pass UINT32_MAX to specify the default
     *        timeout value, causing nsIProxyInfo::failoverTimeout to be
     *        assigned the default value.
     * @param aFailoverProxy
     *        Specifies the next proxy to try if this proxy fails.  This
     *        parameter may be null.
     */
    readonly newProxyInfo: (aType: IDLACString, aHost: IDLAUTF8String, aPort: number, aProxyAuthorizationHeader: IDLACString, aConnectionIsolationKey: IDLACString, aFlags: number, aFailoverTimeout: number, aFailoverProxy: (nsIProxyInfo | null)) => (nsIProxyInfo | null);

    /**
     * This method may be called to construct a nsIProxyInfo instance for
     * with the specified username and password.
     * Currently implemented for SOCKS proxies only.
     * @param aType
     *        The proxy type.  This is a string value that identifies the proxy
     *        type.  Standard values include:
     *          "socks"   - specifies a SOCKS version 5 proxy
     *          "socks4"  - specifies a SOCKS version 4 proxy
     *        The type name is case-insensitive.  Other string values may be
     *        possible, and new types may be defined by a future version of
     *        this interface.
     * @param aHost
     *        The proxy hostname or IP address.
     * @param aPort
     *        The proxy port.
     * @param aUsername
     *        The proxy username
     * @param aPassword
     *        The proxy password
     * @param aFlags
     *        Flags associated with this connection.  See nsIProxyInfo.idl
     *        for currently defined flags.
     * @param aFailoverTimeout
     *        Specifies the length of time (in seconds) to ignore this proxy if
     *        this proxy fails.  Pass UINT32_MAX to specify the default
     *        timeout value, causing nsIProxyInfo::failoverTimeout to be
     *        assigned the default value.
     * @param aFailoverProxy
     *        Specifies the next proxy to try if this proxy fails.  This
     *        parameter may be null.
     */
    readonly newProxyInfoWithAuth: (aType: IDLACString, aHost: IDLAUTF8String, aPort: number, aUsername: IDLACString, aPassword: IDLACString, aProxyAuthorizationHeader: IDLACString, aConnectionIsolationKey: IDLACString, aFlags: number, aFailoverTimeout: number, aFailoverProxy: (nsIProxyInfo | null)) => (nsIProxyInfo | null);

    /**
     * If the proxy identified by aProxyInfo is unavailable for some reason,
     * this method may be called to access an alternate proxy that may be used
     * instead.  As a side-effect, this method may affect future result values
     * from resolve/asyncResolve as well as from getFailoverForProxy.
     *
     * @param aProxyInfo
     *        The proxy that was unavailable.
     * @param aURI
     *        The URI that was originally passed to resolve/asyncResolve.
     * @param aReason
     *        The error code corresponding to the proxy failure.  This value
     *        may be used to tune the delay before this proxy is used again.
     *
     * @throw NS_ERROR_NOT_AVAILABLE if there is no alternate proxy available.
     */
    readonly getFailoverForProxy: (aProxyInfo: (nsIProxyInfo | null), aURI: (nsIURI | null), aReason: number) => (nsIProxyInfo | null);

    /**
     * This method may be used to register a proxy filter instance.  Each proxy
     * filter is registered with an associated position that determines the
     * order in which the filters are applied (starting from position 0).  When
     * resolve/asyncResolve is called, it generates a list of proxies for the
     * given URI, and then it applies the proxy filters.  The filters have the
     * opportunity to modify the list of proxies.
     *
     * If two filters register for the same position, then the filters will be
     * visited in the order in which they were registered.
     *
     * If the filter is already registered, then its position will be updated.
     *
     * After filters have been run, any disabled or disallowed proxies will be
     * removed from the list.  A proxy is disabled if it had previously failed-
     * over to another proxy (see getFailoverForProxy).  A proxy is disallowed,
     * for example, if it is a HTTP proxy and the nsIProtocolHandler for the
     * queried URI does not permit proxying via HTTP.
     *
     * If a nsIProtocolHandler disallows all proxying, then filters will never
     * have a chance to intercept proxy requests for such URLs.
     *
     * @param aFilter
     *        The nsIProtocolProxyFilter instance to be registered.
     * @param aPosition
     *        The position of the filter.
     *
     * NOTE: It is possible to construct filters that compete with one another
     * in undesirable ways.  This API does not attempt to protect against such
     * problems.  It is recommended that any extensions that choose to call
     * this method make their position value configurable at runtime (perhaps
     * via the preferences service).
     */
    readonly registerFilter: (aFilter: (nsIProtocolProxyFilter | null), aPosition: number) => void;

    /**
     * Similar to registerFilter, but accepts an nsIProtocolProxyChannelFilter,
     * which selects proxies according to channel rather than URI.
     *
     * @param aFilter
     *        The nsIProtocolProxyChannelFilter instance to be registered.
     * @param aPosition
     *        The position of the filter.
     */
    readonly registerChannelFilter: (aFilter: (nsIProtocolProxyChannelFilter | null), aPosition: number) => void;

    /**
     * This method may be used to unregister a proxy filter instance.  All
     * filters will be automatically unregistered at XPCOM shutdown.
     *
     * @param aFilter
     *        The nsIProtocolProxyFilter instance to be unregistered.
     */
    readonly unregisterFilter: (aFilter: (nsIProtocolProxyFilter | null)) => void;

    /**
     * This method may be used to unregister a proxy channel filter instance.  All
     * filters will be automatically unregistered at XPCOM shutdown.
     *
     * @param aFilter
     *        The nsIProtocolProxyChannelFilter instance to be unregistered.
     */
    readonly unregisterChannelFilter: (aFilter: (nsIProtocolProxyChannelFilter | null)) => void;

    /**
     * This attribute specifies the current type of proxy configuration.
     */
    readonly proxyConfigType: number;
  }

  export interface nsIClassOfServiceRef {
    readonly name: "nsIClassOfService";
    readonly number: "{1ccb58ec-5e07-4cf9-a30d-ac5490d23b41}";

    Leader: 1;

    Follower: 2;

    Speculative: 4;

    Background: 8;

    Unblocked: 16;

    Throttleable: 32;

    UrgentStart: 64;

    DontThrottle: 128;

    Tail: 256;

    TailAllowed: 512;

    TailForbidden: 1024;
  }

  /**
   * nsIClassOfService.idl
   *
   * Used to express class dependencies and characteristics - complimentary to
   * nsISupportsPriority which is used to express weight
   *
   * Channels that implement this interface may make use of this
   * information in different ways.
   */
  export interface nsIClassOfService extends nsISupports {

    classFlags: number;

    readonly clearClassFlags: (flags: number) => void;

    readonly addClassFlags: (flags: number) => void;
  }

  export interface nsISupportsCStringRef {
    readonly name: "nsISupportsCString";
    readonly number: "{d65ff270-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for ASCII strings
   */
  export interface nsISupportsCString extends nsISupportsPrimitive {

    data: IDLACString;

    readonly toString: () => string;
  }

  export interface nsIContentPermissionPromptRef {
    readonly name: "nsIContentPermissionPrompt";
    readonly number: "{f72de90d-e954-4e69-9a61-917303029301}";
  }

  type nsIContentPermissionPromptFunction = (request: (nsIContentPermissionRequest | null)) => void;

  /**
   * Interface provides a way for the application to handle
   * the UI prompts associated with geo position.
   */
  export interface nsIContentPermissionPrompt extends nsISupports {

    /**
     * Called when a request has been made to access
     * privileged content apis
     */
    readonly prompt: (request: (nsIContentPermissionRequest | null)) => void;
  }

  export interface nsIColorPickerShownCallbackRef {
    readonly name: "nsIColorPickerShownCallback";
    readonly number: "{d2ce78d1-40b5-49d1-b66d-5801fcb9a385}";
  }

  /**
   * nsIColorPicker is representing colors as strings because the internal
   * representation will depend on the underlying backend.
   * The format of the colors taken in input and returned will always follow the
   * format of the <input type='color'> value as described in the HTML
   * specifications.
   */
  export interface nsIColorPickerShownCallback extends nsISupports {

    /**
     * Callback called when the color picker requests a color update.
     * This callback can not be called after done() was called.
     * When this callback is used, the consumer can assume that the color value has
     * changed.
     *
     * @param  color  The new selected color value following the format specifed on
     *                top of this file.
     */
    readonly update: (color: IDLAString) => void;

    /**
     * Callback called when the color picker is dismissed.
     * When this callback is used, the color might have changed or could stay the
     * same.
     * If the color has not changed, the color parameter will be the empty string.
     *
     * @param  color  The new selected color value following the format specifed on
     *                top of this file or the empty string.
     */
    readonly done: (color: IDLAString) => void;
  }

  export interface nsIGSettingsCollectionRef {
    readonly name: "nsIGSettingsCollection";
    readonly number: "{16d5b0ed-e756-4f1b-a8ce-9132e869acd8}";
  }

  export interface nsIGSettingsCollection extends nsISupports {

    readonly setString: (key: IDLAUTF8String, value: IDLAUTF8String) => void;

    readonly setBoolean: (key: IDLAUTF8String, value: boolean) => void;

    readonly setInt: (key: IDLAUTF8String, value: number) => void;

    readonly getString: (key: IDLAUTF8String) => IDLAUTF8String;

    readonly getBoolean: (key: IDLAUTF8String) => boolean;

    readonly getInt: (key: IDLAUTF8String) => number;

    readonly getStringList: (key: IDLAUTF8String) => (nsIArray | null);
  }

  export interface nsIWebBrowserPersistResourceVisitorRef {
    readonly name: "nsIWebBrowserPersistResourceVisitor";
    readonly number: "{8ce37706-b7d3-481a-be68-54f174fc0d0a}";
  }

  export interface nsIWebBrowserPersistResourceVisitor extends nsISupports {

    /**
     * Asynchronous visitor that receives external resources linked by an
     * nsIWebBrowserPersistDocument and which are needed to render the
     * document.
     */
    /**
     * Indicates a resource that is not a document; e.g., an image, script,
     * or stylesheet.
     *
     * @param aDocument   The document containing the reference.
     * @param aURI        The absolute URI spec for the referenced resource.
     * @param aContentPolicyType The type of resource.
     */
    readonly visitResource: (aDocument: (nsIWebBrowserPersistDocument | null), aURI: IDLAUTF8String, aContentPolicyType: number) => void;

    /**
     * Indicates a subdocument resource; e.g., a frame or iframe.
     *
     * @param aDocument     The document containing the reference.
     * @param aSubDocument  The referenced document.
     */
    readonly visitDocument: (aDocument: (nsIWebBrowserPersistDocument | null), aSubDocument: (nsIWebBrowserPersistDocument | null)) => void;

    /**
     * Indicates that the document traversal is complete.
     *
     * @param aDocument   The document that was being traversed.
     * @param aStatus     Indicates whether the traversal encountered an error.
     */
    readonly endVisit: (aDocument: (nsIWebBrowserPersistDocument | null), aStatus: number) => void;
  }

  export interface nsISimpleEnumeratorRef {
    readonly name: "nsISimpleEnumerator";
    readonly number: "{d1899240-f9d2-11d2-bdd6-000064657374}";
  }

  export interface nsISimpleEnumerator extends nsISimpleEnumeratorBase {

    /**
     * Called to determine whether or not the enumerator has
     * any elements that can be returned via getNext(). This method
     * is generally used to determine whether or not to initiate or
     * continue iteration over the enumerator, though it can be
     * called without subsequent getNext() calls. Does not affect
     * internal state of enumerator.
     *
     * @see getNext()
     * @return true if there are remaining elements in the enumerator.
     *         false if there are no more elements in the enumerator.
     */
    readonly hasMoreElements: () => boolean;

    /**
     * Called to retrieve the next element in the enumerator. The "next"
     * element is the first element upon the first call. Must be
     * pre-ceeded by a call to hasMoreElements() which returns PR_TRUE.
     * This method is generally called within a loop to iterate over
     * the elements in the enumerator.
     *
     * @see hasMoreElements()
     * @throws NS_ERROR_FAILURE if there are no more elements
     *                          to enumerate.
     * @return the next element in the enumeration.
     */
    readonly getNext: () => (nsISupports | null);
  }

  export interface nsIFilePickerShownCallbackRef {
    readonly name: "nsIFilePickerShownCallback";
    readonly number: "{0d79adad-b244-49a5-9997-2a8cad93fc44}";
  }

  type nsIFilePickerShownCallbackFunction = (aResult: number) => void;

  export interface nsIFilePickerShownCallback extends nsISupports {

    /**
     * Callback which is called when a filepicker is shown and a result
     * is returned.
     *
     * @param aResult One of returnOK, returnCancel, or returnReplace
     */
    readonly done: (aResult: number) => void;
  }

  export interface nsITextToSubURIRef {
    readonly name: "nsITextToSubURI";
    readonly number: "{8b042e24-6f87-11d3-b3c8-00805f8a6670}";
  }

  export interface nsITextToSubURI extends nsISupports {

    readonly ConvertAndEscape: (charset: IDLACString, text: IDLAString) => IDLACString;

    readonly UnEscapeAndConvert: (charset: IDLACString, text: IDLACString) => IDLAString;

    /**
     * Unescapes the given URI fragment (for UI purpose only)
     * Note:
     * <ul>
     *  <li> escaping back the result (unescaped string) is not guaranteed to
     *       give the original escaped string
     *  <li> In case of a conversion error, the URI fragment (escaped) is
     *       assumed to be in UTF-8 and converted to AString (UTF-16)
     *  <li> In case of successful conversion any resulting character listed
     *       in netwerk/dns/IDNCharacterBlocklist.inc (except space) is escaped
     *  <li> Always succeeeds (callers don't need to do error checking)
     * </ul>
     *
     * @param aCharset the charset to convert from
     * @param aURIFragment the URI (or URI fragment) to unescape
     * @return Unescaped aURIFragment  converted to unicode
     */
    readonly unEscapeURIForUI: (aCharset: IDLACString, aURIFragment: IDLAUTF8String) => IDLAString;

    /**
     * Unescapes only non ASCII characters in the given URI fragment
     * note: this method assumes the URI as UTF-8 and fallbacks to the given
     * charset if the charset is an ASCII superset
     *
     * @param aCharset the charset to convert from
     * @param aURIFragment the URI (or URI fragment) to unescape
     * @return Unescaped aURIFragment  converted to unicode
     * @throws NS_ERROR_UCONV_NOCONV when there is no decoder for aCharset
     *         or NS_ERROR_UDEC_ILLEGALINPUT in case of conversion failure
     */
    readonly unEscapeNonAsciiURI: (aCharset: IDLACString, aURIFragment: IDLAUTF8String) => IDLAString;
  }

  export interface nsIDNSRecordRef {
    readonly name: "nsIDNSRecord";
    readonly number: "{f92228ae-c417-4188-a604-0830a95e7eb9}";
  }

  /**
   * nsIDNSRecord
   *
   * this interface represents the result of a DNS lookup.  since a DNS
   * query may return more than one resolved IP address, the record acts
   * like an enumerator, allowing the caller to easily step through the
   * list of IP addresses.
   */
  export interface nsIDNSRecord extends nsISupports {

    /**
     * @return the canonical hostname for this record.  this value is empty if
     * the record was not fetched with the RESOLVE_CANONICAL_NAME flag.
     *
     * e.g., www.mozilla.org --> rheet.mozilla.org
     */
    readonly canonicalName: IDLACString;

    /**
     * this function returns the value of the next IP address as a
     * scriptable address and increments the internal address iterator.
     *
     * @param aPort
     *        A port number to initialize the nsINetAddr with.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if there is not another IP address in
     * the record.
     */
    readonly getScriptableNextAddr: (aPort: number) => (nsINetAddr | null);

    /**
     * this function returns the value of the next IP address as a
     * string and increments the internal address iterator.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if there is not another IP address in
     * the record.
     */
    readonly getNextAddrAsString: () => IDLACString;

    /**
     * this function returns true if there is another address in the record.
     */
    readonly hasMore: () => boolean;

    /**
     * this function resets the internal address iterator to the first
     * address in the record.
     */
    readonly rewind: () => void;

    /**
     * This function indicates that the last address obtained via getNextAddr*()
     * was not usuable and should be skipped in future uses of this
     * record if other addresses are available.
     *
     * @param aPort is the port number associated with the failure, if any.
     *        It may be zero if not applicable.
     */
    readonly reportUnusable: (aPort: number) => void;

    /**
     * Record retreived with TRR.
     */
    readonly IsTRR: () => boolean;
  }

  export interface nsIDOMXULSelectControlElementRef {
    readonly name: "nsIDOMXULSelectControlElement";
    readonly number: "{9bf188a7-d6f9-431b-b5c7-118013998e8b}";
  }

  export interface nsIDOMXULSelectControlElement extends nsIDOMXULControlElement {

    selectedItem: WebIDL.Element;

    selectedIndex: number;

    value: IDLAString;

    readonly itemCount: number;

    readonly getIndexOfItem: (item: (nsIDOMXULSelectControlItemElement | null)) => number;

    readonly getItemAtIndex: (index: number) => WebIDL.Element;
  }

  export interface nsISeekableStreamRef {
    readonly name: "nsISeekableStream";
    readonly number: "{8429d350-1040-4661-8b71-f2a6ba455980}";

    NS_SEEK_SET: 0;

    NS_SEEK_CUR: 1;

    NS_SEEK_END: 2;
  }

  export interface nsISeekableStream extends nsITellableStream {

    /**
     *  seek
     *
     *  This method moves the stream offset of the steam implementing this
     *  interface.
     *
     *   @param whence specifies how to interpret the 'offset' parameter in
     *                 setting the stream offset associated with the implementing
     *                 stream.
     *
     *   @param offset specifies a value, in bytes, that is used in conjunction
     *                 with the 'whence' parameter to set the stream offset of the
     *                 implementing stream.  A negative value causes seeking in
     *                 the reverse direction.
     *
     *   @throws NS_BASE_STREAM_CLOSED if called on a closed stream.
     */
    readonly seek: (whence: number, offset: number) => void;

    /**
     *  setEOF
     *
     *  This method truncates the stream at the current offset.
     *
     *   @throws NS_BASE_STREAM_CLOSED if called on a closed stream.
     */
    readonly setEOF: () => void;
  }

  export interface nsISOCKSSocketInfoRef {
    readonly name: "nsISOCKSSocketInfo";
    readonly number: "{d5c0d1f9-22d7-47dc-bf91-d9ac6e1251a6}";
  }

  export interface nsISOCKSSocketInfo extends nsISupports {
  }

  export interface nsISearchServiceRef {
    readonly name: "nsISearchService";
    readonly number: "{0301834b-2630-440e-8b98-db8dc55f34b9}";

    ERROR_UNKNOWN_FAILURE: 1;

    ERROR_DUPLICATE_ENGINE: 2;
  }

  export interface nsISearchService extends nsISupports {

    /**
     * Start asynchronous initialization.
     *
     * The promise is resolved once initialization is complete, which may be
     * immediately, if initialization has already been completed by some previous
     * call to this method.
     * This method should only be called when you need or want to wait for the
     * full initialization of the search service, which may include waiting for
     * outbound service requests.
     *
     * @param skipRegionCheck
     *        Flag to avoid SearchService from waiting on the results
     *        of the region lookups before completing initialisation.
     *        Exposed for testing only.
     */
    readonly init: (skipRegionCheck?: boolean) => IDLPromise;

    /**
     * Exposed for testing.
     */
    readonly reInit: (skipRegionCheck?: boolean) => void;

    readonly reset: () => void;

    readonly makeEngineFromConfig: (config: IDLjsval) => IDLPromise;

    readonly ensureBuiltinExtension: (id: IDLAString, locales?: IDLjsval) => IDLPromise;

    /**
     * Determine whether initialization has been completed.
     *
     * Clients of the service can use this attribute to quickly determine whether
     * initialization is complete, and decide to trigger some immediate treatment,
     * to launch asynchronous initialization or to bailout.
     *
     * Note that this attribute does not indicate that initialization has succeeded.
     *
     * @return |true| if the search service is now initialized, |false| if
     * initialization has not been triggered yet.
     */
    readonly isInitialized: boolean;

    /**
     * Resets the default engine to its original value.
     */
    readonly resetToOriginalDefaultEngine: () => IDLPromise;

    /**
     * Checks if an EngineURL of type URLTYPE_SEARCH_HTML exists for
     * any engine, with a matching method, template URL, and query params.
     *
     * @param method
     *        The HTTP request method used when submitting a search query.
     *        Must be a case insensitive value of either "get" or "post".
     *
     * @param url
     *        The URL to which search queries should be sent.
     *        Must not be null.
     *
     * @param formData
     *        The un-sorted form data used as query params.
     */
    readonly hasEngineWithURL: (method: IDLAString, url: IDLAString, formData: IDLjsval) => boolean;

    /**
     * Adds a new search engine from the file at the supplied URI, optionally
     * asking the user for confirmation first.  If a confirmation dialog is
     * shown, it will offer the option to begin using the newly added engine
     * right away.
     *
     * @param engineURL
     *        The URL to the search engine's description file.
     *
     * @param iconURL
     *        A URL string to an icon file to be used as the search engine's
     *        icon. This value may be overridden by an icon specified in the
     *        engine description file.
     *
     * @param confirm
     *        A boolean value indicating whether the user should be asked for
     *        confirmation before this engine is added to the list.  If this
     *        value is false, the engine will be added to the list upon successful
     *        load, but it will not be selected as the current engine.
     *
     * @param extensionID [optional]
     *        Optional: The correct extensionID if called by an add-on.
     *
     * @throws NS_ERROR_FAILURE if the description file cannot be successfully
     *         loaded.
     */
    readonly addEngine: (engineURL: IDLAString, iconURL: IDLAString, confirm: boolean, extensionID?: IDLAString) => IDLPromise;

    /**
     * Adds a new search engine, without asking the user for confirmation and
     * without starting to use it right away.
     *
     * @param name
     *        The search engine's name. Must be unique. Must not be null.
     *
     * @param  details
     *         An object that can contain the following fields:
     *
     *         {iconURL} Optional: A URL string pointing to the icon to be used to
     *                   represent the engine.
     *
     *         {alias} Optional: A unique shortcut that can be used to retrieve the
     *                 search engine.
     *
     *         {description} Optional: A description of the search engine.
     *
     *         {method} Optional: The HTTP request method used when submitting a
     *                  search query. Case insensitive value of either "get" or "post".
     *                  Defaults to "get".
     *
     *         {template} The template for the URL to which search queries should be
     *                    sent. The template will be subjected to OpenSearch parameter
     *                    substitution.
     *                    See http://www.opensearch.org/Specifications/OpenSearch
     *                    Must not be null.
     *
     *         {extensionID} Optional: The correct extensionID if called by an add-on.
     *
     *         {suggestURL} Optional: The URL to which search suggestion requests should
     *                      be sent.
     *
     *         {postData} Optional: For POST requests, a string of URL parameters to send,
     *                    seperated by '&'. The string will be subjected to OpenSearch
     *                    parameter substitution.
     *
     */
    readonly addEngineWithDetails: (name: IDLAString, details: IDLjsval) => IDLPromise;

    /**
     * Adds search providers to the search service.  If the search
     * service is configured to load multiple locales for the extension,
     * it may load more than one search engine. If called directly
     * ensure the extension has been initialised.
     *
     * @param extension
     *        The extension to load from.
     * @returns Promise that resolves when finished.
     */
    readonly addEnginesFromExtension: (extension: IDLjsval) => IDLPromise;

    /**
     * Returns an engine object given a search WebExtension.
     *
     * @returns an array of nsISearchEngine objects.
     */
    readonly getEngineParams: (extension: IDLjsval, manifest: IDLjsval, locale: IDLAString, params: IDLjsval) => IDLPromise;

    /**
     * Un-hides all engines in the set of engines returned by getDefaultEngines.
     */
    readonly restoreDefaultEngines: () => void;

    /**
     * Returns an engine with the specified alias.
     *
     * @param   alias
     *          The search engine's alias.
     * @returns The corresponding nsISearchEngine object, or null if it doesn't
     *          exist.
     */
    readonly getEngineByAlias: (alias: IDLAString) => (nsISearchEngine | null);

    /**
     * Returns an engine with the specified name.
     *
     * @param   aEngineName
     *          The name of the engine.
     * @returns The corresponding nsISearchEngine object, or null if it doesn't
     *          exist.
     */
    readonly getEngineByName: (aEngineName: IDLAString) => (nsISearchEngine | null);

    /**
     * Returns an array of all installed search engines.
     * The array is sorted either to the user requirements or the default order.
     *
     * @returns an array of nsISearchEngine objects.
     */
    readonly getEngines: () => IDLPromise;

    /**
     * Returns an array of all installed search engines whose hidden attribute is
     * false.
     * The array is sorted either to the user requirements or the default order.
     *
     * @returns an array of nsISearchEngine objects.
     */
    readonly getVisibleEngines: () => IDLPromise;

    /**
     * Returns an array of all default search engines. This includes all loaded
     * engines that aren't in the user's profile directory.
     * The array is sorted to the default order.
     *
     * @returns an array of nsISearchEngine objects.
     */
    readonly getDefaultEngines: () => IDLPromise;

    /**
     * Returns an array of search engines installed by a given extension.
     *
     * @returns an array of nsISearchEngine objects.
     */
    readonly getEnginesByExtensionID: (extensionID: IDLAString) => IDLPromise;

    /**
     * Moves a visible search engine.
     *
     * @param  engine
     *         The engine to move.
     * @param  newIndex
     *         The engine's new index in the set of visible engines.
     *
     * @throws NS_ERROR_FAILURE if newIndex is out of bounds, or if engine is
     *         hidden.
     */
    readonly moveEngine: (engine: (nsISearchEngine | null), newIndex: number) => IDLPromise;

    /**
     * Removes the search engine. If the search engine is installed in a global
     * location, this will just hide the engine. If the engine is in the user's
     * profile directory, it will be removed from disk.
     *
     * @param  engine
     *         The engine to remove.
     */
    readonly removeEngine: (engine: (nsISearchEngine | null)) => IDLPromise;

    /**
     * Notify nsSearchService that an extension has been removed. Removes any
     * engines that are associated with that extension.
     *
     * @param  id
     *         The id of the extension.
     */
    readonly removeWebExtensionEngine: (id: IDLAString) => IDLPromise;

    /**
     * The original Engine object that is the default for this region,
     * ignoring changes the user may have subsequently made.
     */
    readonly originalDefaultEngine: (nsISearchEngine | null);

    /**
     * The original Engine object that is the default for this region when in
     * private browsing mode, ignoring changes the user may have subsequently made.
     */
    readonly originalPrivateDefaultEngine: (nsISearchEngine | null);

    /**
     * The currently active search engine.
     * Unless the application doesn't ship any search plugin, this should never
     * be null. If the currently active engine is removed, this attribute will
     * fallback first to the original default engine if it's not hidden, then to
     * the first visible engine, and as a last resort it will unhide the original
     * default engine.
     */
    defaultEngine: (nsISearchEngine | null);

    readonly getDefault: () => IDLPromise;

    readonly setDefault: (engine: (nsISearchEngine | null)) => IDLPromise;

    /**
     * The currently active search engine for private browsing mode.
     * @see defaultEngine.
     */
    defaultPrivateEngine: (nsISearchEngine | null);

    readonly getDefaultPrivate: () => IDLPromise;

    readonly setDefaultPrivate: (engine: (nsISearchEngine | null)) => IDLPromise;

    /**
     * Gets a representation of the default engine in an anonymized JSON
     * string suitable for recording in the Telemetry environment.
     *
     * @return {object} result
     *   contains anonymized info about the default engine(s).
     * @return {string} result.defaultSearchEngine
     *   contains the telemetry id of the default engine.
     * @return {object} result.defaultSearchEngineData
     *   contains information about the default engine:
     *     name, loadPath, original submissionURL
     * @return {string} [result.defaultPrivateSearchEngine]
     *   only returned if the preference for having a separate engine in private
     *   mode is turned on.
     *   contains the telemetry id of the default engine for private browsing mode.
     * @return {object} [result.defaultPrivateSearchEngineData]
     *   only returned if the preference for having a separate engine in private
     *   mode is turned on.
     *   contains information about the default engine for private browsing mode:
     *     name, loadPath, original submissionURL
     */
    readonly getDefaultEngineInfo: () => IDLPromise;

    /**
     * Determines if the provided URL represents results from a search engine, and
     * provides details about the match.
     *
     * The lookup mechanism checks whether the domain name and path of the
     * provided HTTP or HTTPS URL matches one of the known values for the visible
     * search engines.  The match does not depend on which of the schemes is used.
     * The expected URI parameter for the search terms must exist in the query
     * string, but other parameters are ignored.
     *
     * @param url
     *        String containing the URL to parse, for example
     *        "https://www.google.com/search?q=terms".
     */
    readonly parseSubmissionURL: (url: IDLAString) => (nsISearchParseSubmissionResult | null);
  }

  export interface nsIConsoleListenerRef {
    readonly name: "nsIConsoleListener";
    readonly number: "{35c400a4-5792-438c-b915-65e30d58d557}";
  }

  type nsIConsoleListenerFunction = (aMessage: (nsIConsoleMessage | null)) => void;

  export interface nsIConsoleListener extends nsISupports {

    readonly observe: (aMessage: (nsIConsoleMessage | null)) => void;
  }

  export interface nsIZipEntryRef {
    readonly name: "nsIZipEntry";
    readonly number: "{fad6f72f-13d8-4e26-9173-53007a4afe71}";
  }

  export interface nsIZipEntry extends nsISupports {

    /**
     * The type of compression used for the item.  The possible values and
     * their meanings are defined in the zip file specification at
     * http://www.pkware.com/business_and_developers/developer/appnote/
     */
    readonly compression: number;

    /**
     * The compressed size of the data in the item.
     */
    readonly size: number;

    /**
     * The uncompressed size of the data in the item.
     */
    readonly realSize: number;

    /**
     * The CRC-32 hash of the file in the entry.
     */
    readonly CRC32: number;

    /**
     * True if the name of the entry ends with '/' and false otherwise.
     */
    readonly isDirectory: boolean;

    /**
     * The time at which this item was last modified.
     */
    readonly lastModifiedTime: number;

    /**
     * Use this attribute to determine whether this item is an actual zip entry
     * or is one synthesized for part of a real entry's path.  A synthesized
     * entry represents a directory within the zip file which has no
     * corresponding entry within the zip file.  For example, the entry for the
     * directory foo/ in a zip containing exactly one entry for foo/bar.txt
     * is synthetic.  If the zip file contains an actual entry for a directory,
     * this attribute will be false for the nsIZipEntry for that directory.
     * It is impossible for a file to be synthetic.
     */
    readonly isSynthetic: boolean;

    /**
     * The UNIX style file permissions of this item.
     */
    readonly permissions: number;
  }

  export interface nsINavHistoryServiceRef {
    readonly name: "nsINavHistoryService";
    readonly number: "{20c974ff-ee16-4828-9326-1b7c9e036622}";

    /**
     * System Notifications:
     *
     * places-init-complete - Sent once the History service is completely
     *                        initialized successfully.
     * places-database-locked - Sent if initialization of the History service
     *                          failed due to the inability to open the places.sqlite
     *                          for access reasons.
     */
    /**
     * This transition type means the user followed a link and got a new toplevel
     * window.
     */
    TRANSITION_LINK: 1;

    /**
     * This transition type means that the user typed the page's URL in the
     * URL bar or selected it from URL bar autocomplete results, clicked on
     * it from a history query (from the History sidebar, History menu,
     * or history query in the personal toolbar or Places organizer.
     */
    TRANSITION_TYPED: 2;

    /**
     * This transition is set when the user followed a bookmark to get to the
     * page.
     */
    TRANSITION_BOOKMARK: 3;

    /**
     * This transition type is set when some inner content is loaded. This is
     * true of all images on a page, and the contents of the iframe. It is also
     * true of any content in a frame if the user did not explicitly follow
     * a link to get there.
     */
    TRANSITION_EMBED: 4;

    /**
     * Set when the transition was a permanent redirect.
     */
    TRANSITION_REDIRECT_PERMANENT: 5;

    /**
     * Set when the transition was a temporary redirect.
     */
    TRANSITION_REDIRECT_TEMPORARY: 6;

    /**
     * Set when the transition is a download.
     */
    TRANSITION_DOWNLOAD: 7;

    /**
     * This transition type means the user followed a link and got a visit in
     * a frame.
     */
    TRANSITION_FRAMED_LINK: 8;

    /**
     * This transition type means the page has been reloaded.
     */
    TRANSITION_RELOAD: 9;

    /**
     * Set when database is coherent
     */
    DATABASE_STATUS_OK: 0;

    /**
     * Set when database did not exist and we created a new one.
     */
    DATABASE_STATUS_CREATE: 1;

    /**
     * Set when database was corrupt and we replaced it with a new one.
     */
    DATABASE_STATUS_CORRUPT: 2;

    /**
     * Set when database schema has been upgraded.
     */
    DATABASE_STATUS_UPGRADED: 3;

    /**
     * Set when database couldn't be opened.
     */
    DATABASE_STATUS_LOCKED: 4;
  }

  export interface nsINavHistoryService extends nsISupports {

    /**
     * Returns the current database status
     */
    readonly databaseStatus: number;

    /**
     * This is just like markPageAsTyped (in nsIBrowserHistory, also implemented
     * by the history service), but for bookmarks. It declares that the given URI
     * is being opened as a result of following a bookmark. If this URI is loaded
     * soon after this message has been received, that transition will be marked
     * as following a bookmark.
     */
    readonly markPageAsFollowedBookmark: (aURI: (nsIURI | null)) => void;

    /**
     * Designates the url as having been explicitly typed in by the user.
     *
     * @param aURI
     *        URI of the page to be marked.
     */
    readonly markPageAsTyped: (aURI: (nsIURI | null)) => void;

    /**
     * Designates the url as coming from a link explicitly followed by
     * the user (for example by clicking on it).
     *
     * @param aURI
     *        URI of the page to be marked.
     */
    readonly markPageAsFollowedLink: (aURI: (nsIURI | null)) => void;

    /**
     * Returns true if this URI would be added to the history. You don't have to
     * worry about calling this, adding a visit will always check before
     * actually adding the page. This function is public because some components
     * may want to check if this page would go in the history (i.e. for
     * annotations).
     */
    readonly canAddURI: (aURI: (nsIURI | null)) => boolean;

    /**
     * This returns a new query object that you can pass to executeQuer[y/ies].
     * It will be initialized to all empty (so using it will give you all history).
     */
    readonly getNewQuery: () => (nsINavHistoryQuery | null);

    /**
     * This returns a new options object that you can pass to executeQuer[y/ies]
     * after setting the desired options.
     */
    readonly getNewQueryOptions: () => (nsINavHistoryQueryOptions | null);

    /**
     * Executes a single query.
     */
    readonly executeQuery: (aQuery: (nsINavHistoryQuery | null), options: (nsINavHistoryQueryOptions | null)) => (nsINavHistoryResult | null);

    /**
     * Converts a query URI-like string to a query object.
     */
    readonly queryStringToQuery: (aQueryString: IDLAUTF8String, aQuery: Out<(nsINavHistoryQuery | null)>, options: Out<(nsINavHistoryQueryOptions | null)>) => void;

    /**
     * Converts a query into an equivalent string that can be persisted. Inverse
     * of queryStringToQuery()
     */
    readonly queryToQueryString: (aQuery: (nsINavHistoryQuery | null), options: (nsINavHistoryQueryOptions | null)) => IDLAUTF8String;

    /**
     * Adds a history observer. If ownsWeak is false, the history service will
     * keep an owning reference to the observer.  If ownsWeak is true, then
     * aObserver must implement nsISupportsWeakReference, and the history service
     * will keep a weak reference to the observer.
     */
    readonly addObserver: (observer: (nsINavHistoryObserver | null), ownsWeak?: boolean) => void;

    /**
     * Removes a history observer.
     */
    readonly removeObserver: (observer: (nsINavHistoryObserver | null)) => void;

    /**
     * Gets an array of registered nsINavHistoryObserver objects.
     */
    readonly getObservers: () => (nsINavHistoryObserver | null)[];

    /**
     * True if history is disabled. currently,
     * history is disabled if the places.history.enabled pref is false.
     */
    readonly historyDisabled: boolean;

    /**
     * Generate a guid.
     * Guids can be used for any places purposes (history, bookmarks, etc.)
     * Returns null if the generation of the guid failed.
     */
    readonly makeGuid: () => IDLACString;

    /**
     * Returns a 48-bit hash for a URI spec.
     *
     * @param aSpec
     *        The URI spec to hash.
     * @param aMode
     *        The hash mode: `""` (default), `"prefix_lo"`, or `"prefix_hi"`.
     */
    readonly hashURL: (aSpec: IDLACString, aMode?: IDLACString) => number;

    /**
     * Resets and recalculates the origin frecency statistics that are kept in the
     * moz_meta table.
     *
     * @param aCallback
     *        Called when the recalculation is complete.  The arguments passed to
     *        the observer are not defined.
     */
    readonly recalculateOriginFrecencyStats: (aCallback?: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * The database connection used by Places.
     */
    readonly DBConnection: (mozIStorageConnection | null);

    /**
     * Asynchronously executes the statement created from a query.
     *
     * @see nsINavHistoryService::executeQuery
     * @note THIS IS A TEMPORARY API.  Don't rely on it, since it will be replaced
     *       in future versions by a real async querying API.
     * @note Results obtained from this method differ from results obtained from
     *       executeQuery, because there is additional filtering and sorting
     *       done by the latter.  Thus you should use executeQuery, unless you
     *       are absolutely sure that the returned results are fine for
     *       your use-case.
     */
    readonly asyncExecuteLegacyQuery: (aQuery: (nsINavHistoryQuery | null), aOptions: (nsINavHistoryQueryOptions | null), aCallback: (mozIStorageStatementCallback | null)) => (mozIStoragePendingStatement | null);

    /**
     * Hook for clients who need to perform actions during/by the end of
     * the shutdown of the database.
     * May be null if it's too late to get one.
     */
    readonly shutdownClient: (nsIAsyncShutdownClient | null);

    /**
     * Hook for internal clients who need to perform actions just before the
     * connection gets closed.
     * May be null if it's too late to get one.
     */
    readonly connectionShutdownClient: (nsIAsyncShutdownClient | null);

    /**
     * Asynchronously recalculates frecency for all pages where frecency < 0, then
     * decays frecency and inputhistory values.
     */
    readonly decayFrecency: () => void;
  }

  export interface nsIRequestObserverRef {
    readonly name: "nsIRequestObserver";
    readonly number: "{fd91e2e0-1481-11d3-9333-00104ba0fd40}";
  }

  /**
   * nsIRequestObserver
   */
  export interface nsIRequestObserver extends nsISupports {

    /**
     * Called to signify the beginning of an asynchronous request.
     *
     * @param aRequest request being observed
     *
     * An exception thrown from onStartRequest has the side-effect of
     * causing the request to be canceled.
     */
    readonly onStartRequest: (aRequest: (nsIRequest | null)) => void;

    /**
     * Called to signify the end of an asynchronous request.  This
     * call is always preceded by a call to onStartRequest.
     *
     * @param aRequest request being observed
     * @param aStatusCode reason for stopping (NS_OK if completed successfully)
     *
     * An exception thrown from onStopRequest is generally ignored.
     */
    readonly onStopRequest: (aRequest: (nsIRequest | null), aStatusCode: number) => void;
  }

  export interface nsIAlertsIconDataRef {
    readonly name: "nsIAlertsIconData";
    readonly number: "{fc6d7f0a-0cf6-4268-8c71-ab640842b9b1}";
  }

  export interface nsIAlertsIconData extends nsISupports {

    /**
     * Shows an alert with an icon. Web notifications use the favicon of the
     * page that created the alert. If the favicon is not in the Places database,
     * |aIconSize| will be zero.
     */
    readonly showAlertWithIconData: (aAlert: (nsIAlertNotification | null), aAlertListener?: (nsIObserver | nsIObserverFunction | null), aIconSize?: number) => void;
  }

  export interface nsIDocumentEncoderNodeFixupRef {
    readonly name: "nsIDocumentEncoderNodeFixup";
    readonly number: "{3d9371d8-a2ad-403e-8b0e-8885ad3562e3}";
  }

  export interface nsIDocumentEncoderNodeFixup extends nsISupports {

    /**
     * Create a fixed up version of a node. This method is called before
     * each node in a document is about to be persisted. The implementor
     * may return a new node with fixed up attributes or null. If null is
     * returned the node should be used as-is.
     * @param aNode Node to fixup.
     * @param [OUT] aSerializeCloneKids True if the document encoder should
     * apply recursive serialization to the children of the fixed up node
     * instead of the children of the original node.
     * @return The resulting fixed up node.
     */
    readonly fixupNode: (aNode: WebIDL.Node, aSerializeCloneKids: Out<boolean>) => WebIDL.Node;
  }

  export interface nsIStorageActivityServiceRef {
    readonly name: "nsIStorageActivityService";
    readonly number: "{fd1310ba-d1be-4327-988e-92b39fcff6f4}";
  }

  /**
   * nsIStorageActivityService is a service that can be used to know which
   * origins have been active in a time range. This information can be used to
   * implement "Clear Recent History" or similar features.
   *
   * If you are implementing a new Storage component, you should use
   * QuotaManager. But if you don't do it, remember to call
   * StorageActivityService methods in order to inform this service about
   * 'writing' operations executed by origins.
   */
  export interface nsIStorageActivityService extends nsISupports {

    readonly getActiveOrigins: (from: number, to: number) => (nsIArray | null);

    readonly moveOriginInTime: (origin: (nsIPrincipal | null), when: number) => void;

    readonly testOnlyReset: () => void;
  }

  export interface nsILoadContextRef {
    readonly name: "nsILoadContext";
    readonly number: "{2813a7a3-d084-4d00-acd0-f76620315c02}";
  }

  /**
   * An nsILoadContext represents the context of a load.  This interface
   * can be queried for various information about where the load is
   * happening.
   */
  export interface nsILoadContext extends nsISupports {

    /**
     * associatedWindow is the window with which the load is associated, if any.
     * Note that the load may be triggered by a document which is different from
     * the document in associatedWindow, and in fact the source of the load need
     * not be same-origin with the document in associatedWindow.  This attribute
     * may be null if there is no associated window.
     */
    readonly associatedWindow: (mozIDOMWindowProxy | null);

    /**
     * topWindow is the top window which is of same type as associatedWindow.
     * This is equivalent to associatedWindow.top, but is provided here as a
     * convenience.  All the same caveats as associatedWindow of apply, of
     * course.  This attribute may be null if there is no associated window.
     */
    readonly topWindow: (mozIDOMWindowProxy | null);

    /**
     * topFrameElement is the <iframe>, <frame>, or <browser> element which
     * contains the topWindow with which the load is associated.
     *
     * Note that we may have a topFrameElement even when we don't have an
     * associatedWindow, if the topFrameElement's content lives out of process.
     * topFrameElement is available in single-process and multiprocess contexts.
     * Note that topFrameElement may be in chrome even when the nsILoadContext is
     * associated with content.
     */
    readonly topFrameElement: WebIDL.Element;

    /**
     * If this LoadContext corresponds to a nested remote iframe, we don't have
     * access to the topFrameElement.  Instead, we must use this id to send
     * messages. A return value of 0 signifies that this load context is not for
     * a nested frame.
     */
    readonly nestedFrameId: number;

    /**
     * True if the load context is content (as opposed to chrome).  This is
     * determined based on the type of window the load is performed in, NOT based
     * on any URIs that might be around.
     */
    readonly isContent: boolean;

    usePrivateBrowsing: boolean;

    /**
     * Attribute that determines if remote (out-of-process) tabs should be used.
     */
    readonly useRemoteTabs: boolean;

    /**
     * Determines if out-of-process iframes should be used.
     */
    readonly useRemoteSubframes: boolean;

    useTrackingProtection: boolean;

    /**
     * A dictionary of the non-default origin attributes associated with this
     * nsILoadContext.
     */
    readonly originAttributes: IDLjsval;
  }

  export interface nsIProtocolProxyCallbackRef {
    readonly name: "nsIProtocolProxyCallback";
    readonly number: "{fbb6eff6-0cc2-4d99-8d6f-0a12b462bdeb}";
  }

  /**
   * This interface serves as a closure for nsIProtocolProxyService's
   * asyncResolve method.
   */
  export interface nsIProtocolProxyCallback extends nsISupports {

    /**
     * This method is called when proxy info is available or when an error
     * in the proxy resolution occurs.
     *
     * @param aRequest
     *        The value returned from asyncResolve.
     * @param aChannel
     *        The channel passed to asyncResolve.
     * @param aProxyInfo
     *        The resulting proxy info or null if there is no associated proxy
     *        info for aURI.  As with the result of nsIProtocolProxyService's
     *        resolve method, a null result implies that a direct connection
     *        should be used.
     * @param aStatus
     *        The status of the callback.  This is a failure code if the request
     *        could not be satisfied, in which case the value of aStatus
     *        indicates the reason for the failure and aProxyInfo will be null.
     */
    readonly onProxyAvailable: (aRequest: (nsICancelable | null), aChannel: (nsIChannel | null), aProxyInfo: (nsIProxyInfo | null), aStatus: number) => void;
  }

  export interface nsINativeOSFileResultRef {
    readonly name: "nsINativeOSFileResult";
    readonly number: "{08b4cf29-3d65-4e79-b522-a694c322ed07}";
  }

  /**
   * The result of a successful asynchronous operation.
   */
  export interface nsINativeOSFileResult extends nsISupports {

    /**
     * The actual value produced by the operation.
     *
     * Actual type of this value depends on the options passed to the
     * operation.
     */
    readonly result: IDLjsval;

    /**
     * Delay between when the operation was requested on the main thread and
     * when the operation was started off main thread.
     */
    readonly dispatchDurationMS: number;

    /**
     * Duration of the off main thread execution.
     */
    readonly executionDurationMS: number;
  }

  export interface nsISiteSecurityServiceRef {
    readonly name: "nsISiteSecurityService";
    readonly number: "{275127f8-dbd7-4681-afbf-6df0c6587a01}";

    HEADER_HSTS: 0;

    HEADER_HPKP: 1;

    HEADER_OMS: 2;

    Success: 0;

    ERROR_UNKNOWN: 1;

    ERROR_UNTRUSTWORTHY_CONNECTION: 2;

    ERROR_COULD_NOT_PARSE_HEADER: 3;

    ERROR_NO_MAX_AGE: 4;

    ERROR_MULTIPLE_MAX_AGES: 5;

    ERROR_INVALID_MAX_AGE: 6;

    ERROR_MULTIPLE_INCLUDE_SUBDOMAINS: 7;

    ERROR_INVALID_INCLUDE_SUBDOMAINS: 8;

    ERROR_INVALID_PIN: 9;

    ERROR_MULTIPLE_REPORT_URIS: 10;

    ERROR_PINSET_DOES_NOT_MATCH_CHAIN: 11;

    ERROR_NO_BACKUP_PIN: 12;

    ERROR_COULD_NOT_SAVE_STATE: 13;

    ERROR_ROOT_NOT_BUILT_IN: 14;

    /**
     * nsISiteSecurityService::IsSecureURI can optionally return a flag
     * indicating the source of the HSTS cache entry, if it comes from the
     * preload list, was seen naturally, or is a result of HSTS priming.
     */
    SOURCE_UNKNOWN: 0;

    SOURCE_PRELOAD_LIST: 1;

    SOURCE_ORGANIC_REQUEST: 2;
  }

  export interface nsISiteSecurityService extends nsISupports {

    readonly processHeader: (aType: number, aSourceURI: (nsIURI | null), aHeader: IDLACString, aSecInfo: (nsITransportSecurityInfo | null), aFlags: number, aSource: number, aOriginAttributes?: IDLjsval, aMaxAge?: Out<number>, aIncludeSubdomains?: Out<boolean>, aFailureResult?: Out<number>) => void;

    /**
     * Given a header type, resets state relating to that header of a host,
     * including the includeSubdomains state that would affect subdomains.
     * This essentially removes the state for the domain tree rooted at this
     * host. If any preloaded information is present for that host, that
     * information will then be used instead of any other previously existing
     * state.
     *
     * @param aType   the type of security state in question
     * @param aURI    the URI of the target host
     * @param aFlags  options for this request as defined in nsISocketProvider:
     *                  NO_PERMANENT_STORAGE
     * @param aOriginAttributes the origin attributes that isolate this origin,
     *                          (note that this implementation does not isolate
     *                          by userContextId because of the risk of man-in-
     *                          the-middle attacks before trust-on-second-use
     *                          happens).
     */
    readonly resetState: (aType: number, aURI: (nsIURI | null), aFlags: number, aOriginAttributes?: IDLjsval) => void;

    readonly isSecureURI: (aType: number, aURI: (nsIURI | null), aFlags: number, aOriginAttributes?: IDLjsval, aCached?: Out<boolean>, aSource?: Out<number>) => boolean;

    /**
     * Removes all non-preloaded security state by resetting to factory-original
     * settings.
     */
    readonly clearAll: () => void;

    /**
     * Removes all preloaded security state.
     */
    readonly clearPreloads: () => void;

    /**
     * Set public-key pins for a host. The resulting pins will be permanent
     * and visible from private and non-private contexts. These pins replace
     * any already set by this mechanism or those built-in to Gecko.
     *
     * @param aHost the hostname (punycode) that pins will apply to
     * @param aIncludeSubdomains whether these pins also apply to subdomains
     * @param aExpires the time this pin should expire (millis since epoch)
     * @param aSha256Pins array of hashed key fingerprints (SHA-256, base64)
     * @param aIsPreload are these key pins for a preload entry? (false by
     *        default)
     * @param aOriginAttributes the origin attributes that isolate this origin,
     *                          (note that this implementation does not isolate
     *                          by userContextId because of the risk of man-in-
     *                          the-middle attacks before trust-on-second-use
     *                          happens).
     */
    readonly setKeyPins: (aHost: IDLACString, aIncludeSubdomains: boolean, aExpires: number, aSha256Pins: IDLACString[], aIsPreload?: boolean, aOriginAttributes?: IDLjsval) => boolean;

    /**
     * Set an HSTS preload entry for a host. The resulting entries will be
     * permanent and visible from private and non-private contexts. These
     * entries replace any already set by this mechanism or those built-in to
     * Gecko.
     *
     * @param aHost the hostname (punycode) that the entry applies to
     * @param aIncludeSubdomains whether this entry also applies to subdomains
     * @param aExpires the time this entry should expire (millis since epoch)
     */
    readonly setHSTSPreload: (aHost: IDLACString, aIncludesSubdomains: boolean, aExpires: number) => boolean;

    /**
     * Returns an enumerator of the nsISiteSecurityService storage. Each item in
     * the enumeration is a nsISiteSecurityState that can be QueryInterfaced to
     * the appropriate nsISiteHSTSState or nsISiteHPKPState, depending on the
     * provided type. Doesn't include preloaded entries (either the hard-coded
     * ones or the preloaded-delivered-by-kinto ones).
     *
     * @param aType the type of security state in question.
     */
    readonly enumerate: (aType: number) => (nsISimpleEnumerator | null);
  }

  export interface nsIStringEnumeratorRef {
    readonly name: "nsIStringEnumerator";
    readonly number: "{50d3ef6c-9380-4f06-9fb2-95488f7d141c}";
  }

  export interface nsIStringEnumerator extends nsIStringEnumeratorBase {

    readonly hasMore: () => boolean;

    readonly getNext: () => IDLAString;
  }

  export interface nsIPresentationDeviceListenerRef {
    readonly name: "nsIPresentationDeviceListener";
    readonly number: "{46fd372b-2e40-4179-9b36-0478d141e440}";
  }

  export interface nsIPresentationDeviceListener extends nsISupports {

    readonly addDevice: (device: (nsIPresentationDevice | null)) => void;

    readonly removeDevice: (device: (nsIPresentationDevice | null)) => void;

    readonly updateDevice: (device: (nsIPresentationDevice | null)) => void;

    readonly onSessionRequest: (device: (nsIPresentationDevice | null), url: IDLAString, presentationId: IDLAString, controlChannel: (nsIPresentationControlChannel | null)) => void;

    readonly onTerminateRequest: (device: (nsIPresentationDevice | null), presentationId: IDLAString, controlChannel: (nsIPresentationControlChannel | null), aIsFromReceiver: boolean) => void;

    readonly onReconnectRequest: (device: (nsIPresentationDevice | null), url: IDLAString, presentationId: IDLAString, controlChannel: (nsIPresentationControlChannel | null)) => void;
  }

  export interface nsICacheStorageServiceRef {
    readonly name: "nsICacheStorageService";
    readonly number: "{ae29c44b-fbc3-4552-afaf-0a157ce771e7}";

    /**
     * Purge only data of disk backed entries.  Metadata are left for
     * performance purposes.
     */
    PURGE_DISK_DATA_ONLY: 1;

    /**
     * Purge whole disk backed entries from memory.  Disk files will
     * be left unattended.
     */
    PURGE_DISK_ALL: 2;

    /**
     * Purge all entries we keep in memory, including memory-storage
     * entries.  This may be dangerous to use.
     */
    PURGE_EVERYTHING: 3;
  }

  /**
   * Provides access to particual cache storages of the network URI cache.
   */
  export interface nsICacheStorageService extends nsISupports {

    /**
     * Get storage where entries will only remain in memory, never written
     * to the disk.
     *
     * NOTE: Any existing disk entry for [URL|id-extension] will be doomed
     * prior opening an entry using this memory-only storage.  Result of
     * AsyncOpenURI will be a new and empty memory-only entry.  Using
     * OPEN_READONLY open flag has no effect on this behavior.
     *
     * @param aLoadContextInfo
     *    Information about the loading context, this focuses the storage JAR and
     *    respects separate storage for private browsing.
     */
    readonly memoryCacheStorage: (aLoadContextInfo: (nsILoadContextInfo | null)) => (nsICacheStorage | null);

    /**
     * Get storage where entries will be written to disk when not forbidden by
     * response headers.
     *
     * @param aLookupAppCache
     *    When set true (for top level document loading channels) app cache will
     *    be first to check on to find entries in.
     */
    readonly diskCacheStorage: (aLoadContextInfo: (nsILoadContextInfo | null), aLookupAppCache: boolean) => (nsICacheStorage | null);

    /**
     * Get storage where entries will be written to disk and marked as pinned.
     * These pinned entries are immune to over limit eviction and call of clear()
     * on this service.
     */
    readonly pinningCacheStorage: (aLoadContextInfo: (nsILoadContextInfo | null)) => (nsICacheStorage | null);

    /**
     * Get storage for a specified application cache obtained using some different
     * mechanism.
     *
     * @param aLoadContextInfo
     *    Mandatory reference to a load context information.
     * @param aApplicationCache
     *    Optional reference to an existing appcache.  When left null, this will
     *    work with offline cache as a whole.
     */
    readonly appCacheStorage: (aLoadContextInfo: (nsILoadContextInfo | null), aApplicationCache: (nsIApplicationCache | null)) => (nsICacheStorage | null);

    /**
     * Get storage for synthesized cache entries that we currently use for ServiceWorker interception in non-e10s mode.
     *
     * This cache storage has no limits on file size to allow the ServiceWorker to intercept large files.
     */
    readonly synthesizedCacheStorage: (aLoadContextInfo: (nsILoadContextInfo | null)) => (nsICacheStorage | null);

    /**
     * Evict any cache entry having the same origin of aPrincipal.
     *
     * @param aPrincipal
     *   The principal to compare the entries with.
     */
    readonly clearOrigin: (aPrincipal: (nsIPrincipal | null)) => void;

    /**
     * Evict any cache entry having the same originAttributes.
     *
     * @param aOriginAttributes
     *   The origin attributes in string format to compare the entries with.
     */
    readonly clearOriginAttributes: (aOriginAttributes: IDLAString) => void;

    /**
     * Evict the whole cache.
     */
    readonly clear: () => void;

    /**
     * Purges data we keep warmed in memory.  Use for tests and for
     * saving memory.
     */
    readonly purgeFromMemory: (aWhat: number) => void;

    /**
     * I/O thread target to use for any operations on disk
     */
    readonly ioTarget: (nsIEventTarget | null);

    /**
     * Asynchronously determine how many bytes of the disk space the cache takes.
     * @see nsICacheStorageConsumptionObserver
     * @param aObserver
     *    A mandatory (weak referred) observer.  Documented at
     *    nsICacheStorageConsumptionObserver.
     *    NOTE: the observer MUST implement nsISupportsWeakReference.
     */
    readonly asyncGetDiskConsumption: (aObserver: (nsICacheStorageConsumptionObserver | null)) => void;

    /**
     * Asynchronously visits all storages of the disk cache and memory cache.
     * @see nsICacheStorageVisitor
     * @param aVisitor
     *   A visitor callback.
     * @param aVisitEntries
     *   A boolean indicates whether visits entries.
     */
    readonly asyncVisitAllStorages: (aVisitor: (nsICacheStorageVisitor | null), aVisitEntries: boolean) => void;
  }

  export interface nsISharePickerRef {
    readonly name: "nsISharePicker";
    readonly number: "{1201d357-8417-4926-a694-e6408fbedcf8}";
  }

  export interface nsISharePicker extends nsISupports {

    /**
     * Initialize the share picker widget.
     * @param nsIDOMWindow openerWindow.
     */
    readonly init: (openerWindow: (mozIDOMWindowProxy | null)) => void;

    /**
     * Returns the parent window this was initialized with.
     */
    readonly openerWindow: (mozIDOMWindowProxy | null);

    /**
     * XPCOM Analog of navigator.share() as per:
     * https://w3c.github.io/web-share/#share-method
     */
    readonly share: (title: IDLAUTF8String, text: IDLAUTF8String, url: (nsIURI | null)) => IDLPromise;
  }

  export interface nsIStreamLoaderRef {
    readonly name: "nsIStreamLoader";
    readonly number: "{323bcff1-7513-4e1f-a541-1c9213c2ed1b}";
  }

  export interface nsIStreamLoader extends nsIStreamListener {

    /**
     * Asynchronously loads a channel into a memory buffer.
     *
     * To use this interface, first call init() with a nsIStreamLoaderObserver
     * that will be notified when the data has been loaded. Then call asyncOpen()
     * on the channel with the nsIStreamLoader as the listener. The context
     * argument in the asyncOpen() call will be passed to the onStreamComplete()
     * callback.
     *
     * XXX define behaviour for sizes >4 GB
     */
    /**
     * Initialize this stream loader, and start loading the data.
     *
     * @param aStreamObserver
     *        An observer that will be notified when the data is complete.
     * @param aRequestObserver
     *        An optional observer that will be notified when the request
     *        has started or stopped.
     */
    readonly init: (aStreamObserver: (nsIStreamLoaderObserver | null), aRequestObserver?: (nsIRequestObserver | null)) => void;

    /**
     * Gets the number of bytes read so far.
     */
    readonly numBytesRead: number;

    /**
     * Gets the request that loaded this file.
     * null after the request has finished loading.
     */
    readonly request: (nsIRequest | null);
  }

  export interface nsIPersistentPropertiesRef {
    readonly name: "nsIPersistentProperties";
    readonly number: "{706867af-0400-4faa-beb1-0dae87308784}";
  }

  export interface nsIPersistentProperties extends nsIProperties {

    /**
     * load a set of name/value pairs from the input stream
     * names and values should be in UTF8
     */
    readonly load: (input: (nsIInputStream | null)) => void;

    /**
     * output the values to the stream - results will be in UTF8
     */
    readonly save: (output: (nsIOutputStream | null), header: IDLAUTF8String) => void;

    /**
     * get an enumeration of nsIPropertyElement objects,
     * which are read-only (i.e. setting properties on the element will
     * not make changes back into the source nsIPersistentProperties
     */
    readonly enumerate: () => (nsISimpleEnumerator | null);

    /**
     * shortcut to nsIProperty's get() which retrieves a string value
     * directly (and thus faster)
     */
    readonly getStringProperty: (key: IDLAUTF8String) => IDLAString;

    /**
     * shortcut to nsIProperty's set() which sets a string value
     * directly (and thus faster). If the given property already exists,
     * then the old value will be returned
     */
    readonly setStringProperty: (key: IDLAUTF8String, value: IDLAString) => IDLAString;
  }

  export interface mozITXTToHTMLConvRef {
    readonly name: "mozITXTToHTMLConv";
    readonly number: "{77c0e42a-1dd2-11b2-8ebf-edc6606f2f4b}";

    kEntities: 0;

    kURLs: 2;

    kGlyphSubstitution: 4;

    kStructPhrase: 8;
  }

  export interface mozITXTToHTMLConv extends nsIStreamConverter {

    /**
      @param text: plain text to scan. May be a line, paragraph (recommended)
                   or just a substring.<p>
                   Must be non-escaped, pure unicode.<p>
                   <em>Note:</em> ScanTXT(a, o) + ScanTXT(b, o) may be !=
                   Scan(a + b, o)
      @param whattodo: Bitfield describing the modes of operation
      @result      "<", ">" and "&" are escaped and HTML tags are inserted where
                   appropriate.
     */
    readonly scanTXT: (text: IDLAString, whattodo: number) => IDLAString;

    /**
      Adds additional formatting to user edited text, that the user was too lazy
      or "unknowledged" (DELETEME: is that a word?) to make.
      <p>
      <em>Note:</em> Don't use kGlyphSubstitution with this function. This option
      generates tags, that are unuseable for UAs other than Mozilla. This would
      be a data loss bug.

      @param text: HTML source to scan. May be a line, paragraph (recommended)
                   or just a substring.<p>
                   Must be correct HTML. "<", ">" and "&" must be escaped,
                   other chars must be pure unicode.<p>
                   <em>Note:</em> ScanTXT(a, o) + ScanTXT(b, o) may be !=
                   Scan(a + b, o)
      @param whattodo: Bitfield describing the modes of operation
      @result      Additional HTML tags are inserted where appropriate.
     */
    readonly scanHTML: (text: IDLAString, whattodo: number) => IDLAString;

    /**
      @param line: line in original msg, possibly starting starting with
                   txt quote tags like ">"
      @param logLineStart: pos in line, where the real content (logical line)
                   begins, i.e. pos after all txt quote tags.
                   E.g. position of "t" in "> > text".
                   Initial value must be 0, unless line is not real line.
      @return      Cite Level, i.e. number of txt quote tags found, i.e. number of
                   nested quotes.
     */
    readonly citeLevelTXT: (line: string, logLineStart: Out<number>) => number;

    /**
     @param a wide string to scan for the presence of a URL.
     @param aLength --> the length of the buffer to be scanned
     @param aPos --> the position in the buffer to start scanning for a url

     aStartPos --> index into the start of a url (-1 if no url found)
     aEndPos --> index of the last character in the url (-1 if no url found)
     */
    readonly findURLInPlaintext: (text: string, aLength: number, aPos: number, aStartPos: Out<number>, aEndPos: Out<number>) => void;
  }

  export interface nsIDocumentLoaderFactoryRef {
    readonly name: "nsIDocumentLoaderFactory";
    readonly number: "{e795239e-9d3c-47c4-b063-9e600fb3b287}";
  }

  /**
   * To get a component that implements nsIDocumentLoaderFactory
   * for a given mimetype, use nsICategoryManager to find an entry
   * with the mimetype as its name in the category "Gecko-Content-Viewers".
   * The value of the entry is the contractid of the component.
   * The component is a service, so use GetService, not CreateInstance to get it.
   */
  export interface nsIDocumentLoaderFactory extends nsISupports {

    readonly createInstance: (aCommand: string, aChannel: (nsIChannel | null), aLoadGroup: (nsILoadGroup | null), aContentType: IDLACString, aContainer: (nsIDocShell | null), aExtraInfo: (nsISupports | null), aDocListenerResult: Out<(nsIStreamListener | null)>) => (nsIContentViewer | null);

    readonly createInstanceForDocument: (aContainer: (nsISupports | null), aDocument: WebIDL.Document, aCommand: string) => (nsIContentViewer | null);
  }

  export interface nsIRunnableRef {
    readonly name: "nsIRunnable";
    readonly number: "{4a2abaf0-6886-11d3-9382-00104ba0fd40}";
  }

  type nsIRunnableFunction = () => void;

  /**
   * Represents a task which can be dispatched to a thread for execution.
   */
  export interface nsIRunnable extends nsISupports {

    /**
     * The function implementing the task to be run.
     */
    readonly run: () => void;
  }

  export interface nsIPrintSettingsServiceRef {
    readonly name: "nsIPrintSettingsService";
    readonly number: "{841387c8-72e6-484b-9296-bf6eea80d58a}";
  }

  export interface nsIPrintSettingsService extends nsISupports {

    /**
     * Returns a "global" PrintSettings object
     * Creates a new the first time, if one doesn't exist.
     *
     * Then returns the same object each time after that.
     *
     * Initializes the globalPrintSettings from the default printer
     */
    readonly globalPrintSettings: (nsIPrintSettings | null);

    /**
     * Returns a new, unique PrintSettings object each time.
     *
     * For example, if each browser was to have its own unique
     * PrintSettings, then each browser window would call this to
     * create its own unique PrintSettings object.
     *
     * If each browse window was to use the same PrintSettings object
     * then it should use "globalPrintSettings"
     *
     * Initializes the newPrintSettings from the unprefixed printer
     * (Note: this may not happen if there is an OS specific implementation.)
     *
     */
    readonly newPrintSettings: (nsIPrintSettings | null);

    /**
     * The name of the last printer used, or else the system default printer.
     */
    readonly defaultPrinterName: IDLAString;

    /**
     * Initializes certain settings from the native printer into the PrintSettings
     * if aPrinterName is null then it uses the default printer name if it can
     * These settings include, but are not limited to:
     *   Page Orientation
     *   Page Size
     *   Number of Copies
     */
    readonly initPrintSettingsFromPrinter: (aPrinterName: IDLAString, aPrintSettings: (nsIPrintSettings | null)) => void;

    /**
     * Reads PrintSettings values from Prefs,
     * the values to be read are indicated by the "flags" arg.
     *
     * aPrintSettings should be initialized with the name of a printer. First
     * it reads in the PrintSettings from the last print job. Then it uses the
     * PrinterName in the PrinterSettings to read any settings that were saved
     * just for that printer.
     *
     * aPS - PrintSettings to have its settings read
     * aUsePrinterNamePrefix - indicates whether to use the printer name as a prefix
     * aFlags - indicates which prefs to read, see nsIPrintSettings.idl for the
     *          const values.
     *
     * Items not read:
     *   startPageRange, endPageRange, scaling, printRange, title
     *   docURL, isCancelled,
     *   printSilent, shrinkToFit, numCopies,
     *   printerName
     *
     */
    readonly initPrintSettingsFromPrefs: (aPrintSettings: (nsIPrintSettings | null), aUsePrinterNamePrefix: boolean, aFlags: number) => void;

    /**
     * Writes PrintSettings values to Prefs,
     * the values to be written are indicated by the "flags" arg.
     *
     * If there is no PrinterName in the PrinterSettings
     * the values are saved as the "generic" values not associated with any printer.
     * If a PrinterName is there, then it saves the items qualified for that Printer
     *
     * aPS - PrintSettings to have its settings saved
     * aUsePrinterNamePrefix - indicates whether to use the printer name as a prefix
     * aFlags - indicates which prefs to save, see nsIPrintSettings.idl for the const values.
     *
     * Items not written:
     *   startPageRange, endPageRange, scaling, printRange, title
     *   docURL, isCancelled,
     *   printSilent, shrinkToFit, numCopies
     *
     */
    readonly savePrintSettingsToPrefs: (aPrintSettings: (nsIPrintSettings | null), aUsePrinterNamePrefix: boolean, aFlags: number) => void;
  }

  export interface nsIWebSocketChannelRef {
    readonly name: "nsIWebSocketChannel";
    readonly number: "{ce71d028-322a-4105-a947-a894689b52bf}";

    CLOSE_NORMAL: 1000;

    CLOSE_GOING_AWAY: 1001;

    CLOSE_PROTOCOL_ERROR: 1002;

    CLOSE_UNSUPPORTED_DATATYPE: 1003;

    CLOSE_NO_STATUS: 1005;

    CLOSE_ABNORMAL: 1006;

    CLOSE_INVALID_PAYLOAD: 1007;

    CLOSE_POLICY_VIOLATION: 1008;

    CLOSE_TOO_LARGE: 1009;

    CLOSE_EXTENSION_MISSING: 1010;

    CLOSE_INTERNAL_ERROR: 1011;

    CLOSE_TLS_FAILED: 1015;
  }

  /**
   * Low-level websocket API: handles network protocol.
   *
   * This is primarly intended for use by the higher-level nsIWebSocket.idl.
   * We are also making it scriptable for now, but this may change once we have
   * WebSockets for Workers.
   */
  export interface nsIWebSocketChannel extends nsISupports {

    /**
     * The original URI used to construct the protocol connection. This is used
     * in the case of a redirect or URI "resolution" (e.g. resolving a
     * resource: URI to a file: URI) so that the original pre-redirect
     * URI can still be obtained.  This is never null.
     */
    readonly originalURI: (nsIURI | null);

    /**
     * The readonly URI corresponding to the protocol connection after any
     * redirections are completed.
     */
    readonly URI: (nsIURI | null);

    /**
     * The notification callbacks for authorization, etc..
     */
    notificationCallbacks: (nsIInterfaceRequestor | null);

    /**
     * Transport-level security information (if any)
     */
    readonly securityInfo: (nsISupports | null);

    /**
     * The load group of of the websocket
     */
    loadGroup: (nsILoadGroup | null);

    /**
     * The load info of the websocket
     */
    loadInfo: (nsILoadInfo | null);

    /**
     * Sec-Websocket-Protocol value
     */
    protocol: IDLACString;

    /**
     * Sec-Websocket-Extensions response header value
     */
    readonly extensions: IDLACString;

    /**
     * The channelId of the underlying http channel.
     * It's available only after nsIWebSocketListener::onStart
     */
    readonly httpChannelId: number;

    /**
     * Similar to the previous one but without nsICookieSettings.
     * This method is used by JS code where nsICookieSettings is not exposed.
     */
    readonly initLoadInfo: (aLoadingNode: WebIDL.Node, aLoadingPrincipal: (nsIPrincipal | null), aTriggeringPrincipal: (nsIPrincipal | null), aSecurityFlags: number, aContentPolicyType: number) => void;

    /**
     * Asynchronously open the websocket connection.  Received messages are fed
     * to the socket listener as they arrive.  The socket listener's methods
     * are called on the thread that calls asyncOpen and are not called until
     * after asyncOpen returns.  If asyncOpen returns successfully, the
     * protocol implementation promises to call at least onStop on the listener.
     *
     * NOTE: Implementations should throw NS_ERROR_ALREADY_OPENED if the
     * websocket connection is reopened.
     *
     * @param aURI the uri of the websocket protocol - may be redirected
     * @param aOrigin the uri of the originating resource
     * @param aInnerWindowID the inner window ID
     * @param aListener the nsIWebSocketListener implementation
     * @param aContext an opaque parameter forwarded to aListener's methods
     */
    readonly asyncOpen: (aURI: (nsIURI | null), aOrigin: IDLACString, aInnerWindowID: number, aListener: (nsIWebSocketListener | null), aContext: (nsISupports | null)) => void;

    readonly close: (aCode: number, aReason: IDLAUTF8String) => void;

    /**
     * Use to send text message down the connection to WebSocket peer.
     *
     * @param aMsg the utf8 string to send
     */
    readonly sendMsg: (aMsg: IDLAUTF8String) => void;

    /**
     * Use to send binary message down the connection to WebSocket peer.
     *
     * @param aMsg the data to send
     */
    readonly sendBinaryMsg: (aMsg: IDLACString) => void;

    /**
     * Use to send a binary stream (Blob) to Websocket peer.
     *
     * @param aStream The input stream to be sent.
     */
    readonly sendBinaryStream: (aStream: (nsIInputStream | null), length: number) => void;

    /**
     * This value determines how often (in seconds) websocket keepalive
     * pings are sent.  If set to 0 (the default), no pings are ever sent.
     *
     * This value can currently only be set before asyncOpen is called, else
     * NS_ERROR_IN_PROGRESS is thrown.
     *
     * Be careful using this setting: ping traffic can consume lots of power and
     * bandwidth over time.
     */
    pingInterval: number;

    /**
     * This value determines how long (in seconds) the websocket waits for
     * the server to reply to a ping that has been sent before considering the
     * connection broken.
     *
     * This value can currently only be set before asyncOpen is called, else
     * NS_ERROR_IN_PROGRESS is thrown.
     */
    pingTimeout: number;

    /**
     * Unique ID for this channel. It's not readonly because when the channel is
     * created via IPC, the serial number is received from the child process.
     */
    serial: number;

    /**
     * Set a nsITransportProvider and negotated extensions to be used by this
     * channel. Calling this function also means that this channel will
     * implement the server-side part of a websocket connection rather than the
     * client-side part.
     */
    readonly setServerParameters: (aProvider: (nsITransportProvider | null), aNegotiatedExtensions: IDLACString) => void;
  }

  export interface nsINetAddrRef {
    readonly name: "nsINetAddr";
    readonly number: "{652b9ec5-d159-45d7-9127-50bb559486cd}";

    /**
     * Network address families. These correspond to all the network address
     * families supported by the NetAddr struct.
     */
    FAMILY_INET: 1;

    FAMILY_INET6: 2;

    FAMILY_LOCAL: 3;
  }

  /**
   * nsINetAddr
   *
   * This interface represents a native NetAddr struct in a readonly
   * interface.
   */
  export interface nsINetAddr extends nsISupports {

    /**
     * @return the address family of the network address, which corresponds to
     * one of the FAMILY_ constants.
     */
    readonly family: number;

    /**
     * @return Either the IP address (FAMILY_INET, FAMILY_INET6) or the path
     * (FAMILY_LOCAL) in string form. IP addresses are in the format produced by
     * mozilla::net::NetAddrToString.
     *
     * Note: Paths for FAMILY_LOCAL may have length limitations which are
     * implementation dependent and not documented as part of this interface.
     */
    readonly address: IDLAUTF8String;

    /**
     * @return the port number for a FAMILY_INET or FAMILY_INET6 address.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the address family is not FAMILY_INET or
     * FAMILY_INET6.
     */
    readonly port: number;

    /**
     * @return the flow label for a FAMILY_INET6 address.
     *
     * @see http://www.ietf.org/rfc/rfc3697.txt
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the address family is not FAMILY_INET6
     */
    readonly flow: number;

    /**
     * @return the address scope of a FAMILY_INET6 address.
     *
     * @see http://tools.ietf.org/html/rfc4007
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the address family is not FAMILY_INET6
     */
    readonly scope: number;

    /**
     * @return whether a FAMILY_INET6 address is mapped from FAMILY_INET.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the address family is not FAMILY_INET6
     */
    readonly isV4Mapped: boolean;
  }

  export interface nsINavHistoryObserverRef {
    readonly name: "nsINavHistoryObserver";
    readonly number: "{0f0f45b0-13a1-44ae-a0ab-c6046ec6d4da}";

    /**
     * Removed by the user.
     */
    REASON_DELETED: 0;

    /**
     * Removed by automatic expiration.
     */
    REASON_EXPIRED: 1;

    /**
     * onPageChanged attribute indicating that favicon has been updated.
     * aNewValue parameter will be set to the new favicon URI string.
     */
    ATTRIBUTE_FAVICON: 3;
  }

  /**
   * DANGER! If you are in the middle of a batch transaction, there may be a
   * database transaction active. You can still access the DB, but be careful.
   */
  export interface nsINavHistoryObserver extends nsISupports {

    /**
     * Notifies you that a bunch of things are about to change, don't do any
     * heavy-duty processing until onEndUpdateBatch is called.
     */
    readonly onBeginUpdateBatch: () => void;

    /**
     * Notifies you that we are done doing a bunch of things and you should go
     * ahead and update UI, etc.
     */
    readonly onEndUpdateBatch: () => void;

    /**
     * Called whenever either the "real" title or the custom title of the page
     * changed. BOTH TITLES ARE ALWAYS INCLUDED in this notification, even though
     * only one will change at a time. Often, consumers will want to display the
     * user title if it is available, and fall back to the page title (the one
     * specified in the <title> tag of the page).
     *
     * Note that there is a difference between an empty title and a NULL title.
     * An empty string means that somebody specifically set the title to be
     * nothing. NULL means nobody set it. From C++: use IsVoid() and SetIsVoid()
     * to see whether an empty string is "null" or not (it will always be an
     * empty string in either case).
     *
     * @param aURI
     *        The URI of the page.
     * @param aPageTitle
     *        The new title of the page.
     * @param aGUID
     *        The unique ID associated with the page.
     */
    readonly onTitleChanged: (aURI: (nsIURI | null), aPageTitle: IDLAString, aGUID: IDLACString) => void;

    /**
     * Called when an individual page's frecency has changed.
     *
     * This is not called for pages whose frecencies change as the result of some
     * large operation where some large or unknown number of frecencies change at
     * once.  Use onManyFrecenciesChanged to detect such changes.
     *
     * @param aURI
     *        The page's URI.
     * @param aNewFrecency
     *        The page's new frecency.
     * @param aGUID
     *        The page's GUID.
     * @param aHidden
     *        True if the page is marked as hidden.
     * @param aVisitDate
     *        The page's last visit date.
     */
    readonly onFrecencyChanged: (aURI: (nsIURI | null), aNewFrecency: number, aGUID: IDLACString, aHidden: boolean, aVisitDate: number) => void;

    /**
     * Called when the frecencies of many pages have changed at once.
     *
     * onFrecencyChanged is not called for each of those pages.
     */
    readonly onManyFrecenciesChanged: () => void;

    /**
     * This page and all of its visits are being deleted. Note: the page may not
     * necessarily have actually existed for this function to be called.
     *
     * Delete notifications are only 99.99% accurate. Batch delete operations
     * must be done in two steps, so first come notifications, then a bulk
     * delete. If there is some error in the middle (for example, out of memory)
     * then you'll get a notification and it won't get deleted. There's no easy
     * way around this.
     *
     * @param aURI
     *        The URI that was deleted.
     * @param aGUID
     *        The unique ID associated with the page.
     * @param aReason
     *        Indicates the reason for the removal.  see REASON_* constants.
     */
    readonly onDeleteURI: (aURI: (nsIURI | null), aGUID: IDLACString, aReason: number) => void;

    /**
     * Notification that all of history is being deleted.
     */
    readonly onClearHistory: () => void;

    /**
     * An attribute of this page changed.
     *
     * @param aURI
     *        The URI of the page on which an attribute changed.
     * @param aChangedAttribute
     *        The attribute whose value changed.  See ATTRIBUTE_* constants.
     * @param aNewValue
     *        The attribute's new value.
     * @param aGUID
     *        The unique ID associated with the page.
     */
    readonly onPageChanged: (aURI: (nsIURI | null), aChangedAttribute: number, aNewValue: IDLAString, aGUID: IDLACString) => void;

    /**
     * Called when some visits of an history entry are expired.
     *
     * @param aURI
     *        The page whose visits have been expired.
     * @param aPartialRemoval
     *        Set to true if only some of the visits for the page have been removed.
     * @param aGUID
     *        The unique ID associated with the page.
     *
     * @note: when all visits for a page are expired and also the full page entry
     *        is expired, you will only get an onDeleteURI notification.  If a
     *        page entry is removed, then you can be sure that we don't have
     *        anymore visits for it.
     * @param aReason
     *        Indicates the reason for the removal.  see REASON_* constants.
     * @param aTransitionType
     *        If it's a valid TRANSITION_* value, all visits of the specified type
     *        have been removed.
     */
    readonly onDeleteVisits: (aURI: (nsIURI | null), aPartialRemoval: boolean, aGUID: IDLACString, aReason: number, aTransitionType: number) => void;
  }

  export interface nsIContentProcessProviderRef {
    readonly name: "nsIContentProcessProvider";
    readonly number: "{83ffb063-5f65-4c45-ae07-3f553e0809bb}";

    /**
     * Return this from provideProcess to create a new process.
     */
    NEW_PROCESS: -1;
  }

  export interface nsIContentProcessProvider extends nsISupports {

    /**
     * Given aAliveProcesses (with an opener aOpener), choose which process of
     * aType to use. Return nsIContentProcessProvider.NEW_PROCESS to ask the
     * caller to create a new content process.
     */
    readonly provideProcess: (aType: IDLAString, aOpener: (nsIContentProcessInfo | null), aAliveProcesses: (nsIContentProcessInfo | null)[], aMaxCount: number) => number;
  }

  export interface nsIPromptFactoryRef {
    readonly name: "nsIPromptFactory";
    readonly number: "{2803541c-c96a-4ff1-bd7c-9cb566d46aeb}";
  }

  /**
   * This interface allows creating various prompts that have a specific parent.
   */
  export interface nsIPromptFactory extends nsISupports {
  }

  /**
   * Each tested feature may be in one of 3 states:
   *   UNKNOWN, if a check hasn't been performed.
   *   OK, if the feature was successfully tested
   *   NOT_AVAILABLE, if the feature is blocked by the network.
   *                  Note that the endpoints are guaranteed to support the features.
   */
  export enum nsINetworkConnectivityService_ConnectivityState {
    UNKNOWN = 0,
    OK = 1,
    NOT_AVAILABLE = 2,
  }

  export interface nsINetworkConnectivityServiceRef {
    readonly name: "nsINetworkConnectivityService";
    readonly number: "{2693457e-3ba5-4455-991f-5350946adb12}";

    UNKNOWN: 0;
    OK: 1;
    NOT_AVAILABLE: 2;
  }

  export interface nsINetworkConnectivityService extends nsISupports {

    readonly DNSv4: nsINetworkConnectivityService_ConnectivityState;

    readonly DNSv6: nsINetworkConnectivityService_ConnectivityState;

    readonly IPv4: nsINetworkConnectivityService_ConnectivityState;

    readonly IPv6: nsINetworkConnectivityService_ConnectivityState;

    readonly recheckDNS: () => void;

    readonly recheckIPConnectivity: () => void;
  }

  export interface nsILoginManagerCryptoRef {
    readonly name: "nsILoginManagerCrypto";
    readonly number: "{2030770e-542e-40cd-8061-cd9d4ad4227f}";

    ENCTYPE_BASE64: 0;

    ENCTYPE_SDR: 1;
  }

  export interface nsILoginManagerCrypto extends nsISupports {

    /**
     * encrypt
     *
     * @param plainText
     *        The string to be encrypted.
     *
     * Encrypts the specified string, returning the ciphertext value.
     *
     * NOTE: The current implemention of this inferface simply uses NSS/PSM's
     * "Secret Decoder Ring" service. It is not recommended for general
     * purpose encryption/decryption.
     *
     * Can throw if the user cancels entry of their master password.
     */
    readonly encrypt: (plainText: IDLAString) => IDLAString;

    readonly encryptMany: (plainTexts: IDLjsval) => IDLPromise;

    /**
     * decrypt
     *
     * @param cipherText
     *        The string to be decrypted.
     *
     * Decrypts the specified string, returning the plaintext value.
     *
     * Can throw if the user cancels entry of their master password, or if the
     * cipherText value can not be successfully decrypted (eg, if it was
     * encrypted with some other key).
     */
    readonly decrypt: (cipherText: IDLAString) => IDLAString;

    /**
     * @param cipherTexts
     *        The strings to be decrypted.
     *
     * Decrypts the specified strings, returning the plaintext values.
     *
     * Can throw if the user cancels entry of their master password, or if the
     * cipherText value can not be successfully decrypted (eg, if it was
     * encrypted with some other key).
     */
    readonly decryptMany: (cipherTexts: IDLjsval) => IDLPromise;

    /**
     * uiBusy
     *
     * True when a master password prompt is being displayed.
     */
    readonly uiBusy: boolean;

    /**
     * isLoggedIn
     *
     * Current login state of the token used for encryption. If the user is
     * not logged in, performing a crypto operation will result in a master
     * password prompt.
     */
    readonly isLoggedIn: boolean;

    /**
     * defaultEncType
     *
     * Default encryption type used by an implementation of this interface.
     */
    readonly defaultEncType: number;
  }

  export interface nsIStreamBufferAccessRef {
    readonly name: "nsIStreamBufferAccess";
    readonly number: "{ac923b72-ac87-4892-ac7a-ca385d429435}";
  }

  /**
   * An interface for access to a buffering stream implementation's underlying
   * memory buffer.
   *
   * Stream implementations that QueryInterface to nsIStreamBufferAccess must
   * ensure that all buffers are aligned on the most restrictive type size for
   * the current architecture (e.g., sizeof(double) for RISCy CPUs).  malloc(3)
   * satisfies this requirement.
   */
  export interface nsIStreamBufferAccess extends nsISupports {

    /**
     * Disable and enable buffering on the stream implementing this interface.
     * DisableBuffering flushes an output stream's buffer, and invalidates an
     * input stream's buffer.
     */
    readonly disableBuffering: () => void;

    readonly enableBuffering: () => void;

    /**
     * The underlying, unbuffered input or output stream.
     */
    readonly unbufferedStream: (nsISupports | null);
  }

  export interface nsIBrowserRef {
    readonly name: "nsIBrowser";
    readonly number: "{14e5a0cb-e223-4202-95e8-fe53275193ea}";
  }

  export interface nsIBrowser extends nsISupports {

    /**
     * Gets an optional frame loader that is "related" to this browser.
     * If this exists, then we should attempt to use the same content parent as
     * this frame loader for any new remote tabs.  For example, view source
     * browsers set this to the frame loader for the original content to ensure
     * they are loaded in the same process as the content.
     */
    readonly sameProcessAsFrameLoader: WebIDL.FrameLoader;

    readonly dropLinks: (links: IDLAString[], triggeringPrincipal: (nsIPrincipal | null)) => void;

    /**
     * Swapping of frameloaders are usually initiated from a frameloader owner
     * or other components operating on frameloader owners. This is done by calling
     * swapFrameLoaders at MozFrameLoaderOwner webidl interface.
     *
     * This function aimed to provide the other way around -
     * if the swapping is initiated from frameloader itself or other platform level
     * components, it uses this interface to delegate the swapping request to
     * frameloader owners and ask them to re-initiate frameloader swapping, so that
     * frameloader owners such as <xul:browser> can setup their properties and /
     * or listeners properly on swapping.
     */
    readonly swapBrowsers: (aOtherBrowser: (nsIBrowser | null)) => void;

    /**
     * Close the browser (usually means to remove a tab).
     */
    readonly closeBrowser: () => void;

    /**
     * A browser can change from remote to non-remote and vice versa.
     * For example, when navigating from an in-process chrome page to
     * a web page, this value would change from false to true.
     */
    readonly isRemoteBrowser: boolean;

    /**
     * The nsIWebProgress instance responsible for handling progress events
     * from the content process.
     *
     * Will always be non-null when isRemoteBrowser is true.
     */
    readonly remoteWebProgressManager: (nsIWebProgress | null);

    /**
     * Called by the child to inform the parent that a command update has occurred
     * and the supplied set of commands are now enabled and disabled.
     *
     * @param action command updater action
     * @param enabledCommands commands to enable
     * @param disabledCommand commands to disable
     */
    readonly enableDisableCommandsRemoteOnly: (action: IDLAString, enabledCommands: IDLACString[], disabledCommands: IDLACString[]) => void;

    readonly contentPrincipal: (nsIPrincipal | null);

    readonly contentStoragePrincipal: (nsIPrincipal | null);

    readonly contentBlockingAllowListPrincipal: (nsIPrincipal | null);

    readonly csp: (nsIContentSecurityPolicy | null);

    readonly referrerInfo: (nsIReferrerInfo | null);

    /**
     * Whether or not the browser is in the process of an nsIWebNavigation
     * navigation method.
     */
    isNavigating: boolean;

    /**
     * Whether or not the character encoding menu may be enabled.
     */
    mayEnableCharacterEncodingMenu: boolean;

    /**
     * Whether or not the character encoding was detected by analyzing
     * content (as opposed to reading a protocol label).
     */
    charsetAutodetected: boolean;

    /**
     * Called by Gecko to update the browser when its state changes.
     *
     * @param aCharset the new character set of the document
     * @param aDocumentURI the URI of the current document
     * @param aContentType the content type of the document
     */
    readonly updateForStateChange: (aCharset: IDLAString, aDocumentURI: (nsIURI | null), aContentType: IDLAString) => void;

    /**
     * Called by Gecko to update the nsIWebNavigation when a location change occurs.
     *
     * @param aCanGoBack whether or not the nsIWebNavigation can go backwards in
     *                   history
     * @param aCanGoForward whether or not the nsIWebNavigation can go
     *                      forward in history
     */
    readonly updateWebNavigationForLocationChange: (aCanGoBack: boolean, aCanGoForward: boolean) => void;

    /**
     * Called by Gecko to update the browser when a location change occurs.
     *
     * @param aLocation the new location
     * @param aCharset the character set of the document
     * @param aMayEnableCharacterEncodingMenu whether or not the content encoding
     *                                        menu may be enabled
     * @param aCharsetAutodetected whether or not the given character set was
     *                             autodetected
     * @param aDocumentURI the URI of the new document
     * @param aTitle the title of the new doucment
     * @param aContentPrincipal the security principal of the new document
     * @param aContentStoragePrincipal the security principal for the new
     *                                 document's storage
     * @param aCSP the content security policy of the new document
     * @param aReferrerInfo the referrer info of the new document
     * @param aIsSynthetic whether or not the document is synthetic
     * @param aInnerWindowID the inner window ID of the document
     * @param aHasRequestContextID whether or not the the request context has a
     *                             value (true) or null should be used (false)
     * @param aRequestContextID the request context ID
     * @param aContentType the content type of the document
     */
    readonly updateForLocationChange: (aLocation: (nsIURI | null), aCharset: IDLAString, aMayEnableCharacterEncodingMenu: boolean, aCharsetAutodetected: boolean, aDocumentURI: (nsIURI | null), aTitle: IDLAString, aContentPrincipal: (nsIPrincipal | null), aContentStoragePrincipal: (nsIPrincipal | null), aContentBlockingAllowListPrincipal: (nsIPrincipal | null), aCSP: (nsIContentSecurityPolicy | null), aReferrerInfo: (nsIReferrerInfo | null), aIsSynthetic: boolean, aInnerWindowID: number, aHasRequestContextID: boolean, aRequestContextID: number, aContentType: IDLAString) => void;

    /**
     * Called by Gecko when a security chang event needs to update the event
     * state stored in the security UI object stored in the parent process.
     *
     * @param aSecurityInfo the transport security information from the content
     *                      process
     * @param aState the flags from the OnSecurityChange event that triggered
     *               this method, as outlined in nsIWebProgressListener
     * @param aIsSecureContext whether or not the context is secure
     */
    readonly updateSecurityUIForSecurityChange: (aSecurityInfo: (nsITransportSecurityInfo | null), aState: number, aIsSecureContext: boolean) => void;
  }

  export interface nsIDOMWindowRef {
    readonly name: "nsIDOMWindow";
    readonly number: "{b8343993-0383-4add-9930-ad176b189240}";
  }

  export interface nsIDOMWindow extends nsISupports {
  }

  export interface nsIPrefetchServiceRef {
    readonly name: "nsIPrefetchService";
    readonly number: "{422a1807-4e7f-463d-b8d7-ca2ceb9b5d53}";
  }

  export interface nsIPrefetchService extends nsISupports {

    /**
     * Enqueue a request to prefetch the specified URI.
     *
     * @param aURI the URI of the document to prefetch
     * @param aReferrerInfo the referrerInfo of the request
     * @param aSource the DOM node (such as a <link> tag) that requested this
     *        fetch, or null if the prefetch was not requested by a DOM node.
     * @param aExplicit the link element has an explicit prefetch link type
     */
    readonly prefetchURI: (aURI: (nsIURI | null), aReferrerInfo: (nsIReferrerInfo | null), aSource: WebIDL.Node, aExplicit: boolean) => void;

    /**
     * Start a preload of the specified URI.
     *
     * @param aURI the URI of the document to preload
     * @param aReferrerInfo the referrerInfo of the request
     * @param aSource the DOM node (such as a <link> tag) that requested this
     *        fetch, or null if the prefetch was not requested by a DOM node.
     * @param aPolicyType content policy to be used for this load.
     */
    readonly preloadURI: (aURI: (nsIURI | null), aReferrerInfo: (nsIReferrerInfo | null), aSource: WebIDL.Node, aPolicyType: number) => void;

    /**
     * Find out if there are any prefetches running or queued
     */
    readonly hasMoreElements: () => boolean;

    /**
     * Cancel prefetch or preload for a Node.
     */
    readonly cancelPrefetchPreloadURI: (aURI: (nsIURI | null), aSource: WebIDL.Node) => void;
  }

  export interface nsIWebBrowserChromeFocusRef {
    readonly name: "nsIWebBrowserChromeFocus";
    readonly number: "{947b2ee6-51ed-4c2b-9f45-426c27ca84c6}";
  }

  /**
   * The nsIWebBrowserChromeFocus is implemented by the same object as the
   * nsIEmbeddingSiteWindow. It represents the focus up-calls from mozilla
   * to the embedding chrome. See mozilla bug #70224 for gratuitous info.
   */
  export interface nsIWebBrowserChromeFocus extends nsISupports {

    /**
     * Set the focus at the next focusable element in the chrome. If
     * aForDocumentNavigation is true, this was a document navigation, so
     * focus the parent window.
     */
    readonly focusNextElement: (aForDocumentNavigation: boolean) => void;

    /**
     * Set the focus at the previous focusable element in the chrome.
     */
    readonly focusPrevElement: (aForDocumentNavigation: boolean) => void;
  }

  export interface nsISocketTransportRef {
    readonly name: "nsISocketTransport";
    readonly number: "{79221831-85e2-43a8-8152-05d77d6fde31}";

    /**
     * Values for the aType parameter passed to get/setTimeout.
     */
    TIMEOUT_CONNECT: 0;

    TIMEOUT_READ_WRITE: 1;

    /**
     * nsITransportEventSink status codes.
     *
     * Although these look like XPCOM error codes and are passed in an nsresult
     * variable, they are *not* error codes.  Note that while they *do* overlap
     * with existing error codes in Necko, these status codes are confined
     * within a very limited context where no error codes may appear, so there
     * is no ambiguity.
     *
     * The values of these status codes must never change.
     *
     * The status codes appear in near-chronological order (not in numeric
     * order).  STATUS_RESOLVING may be skipped if the host does not need to be
     * resolved.  STATUS_WAITING_FOR is an optional status code, which the impl
     * of this interface may choose not to generate.
     *
     * In C++, these constants have a type of uint32_t, so C++ callers must use
     * the NS_NET_STATUS_* constants defined below, which have a type of
     * nsresult.
     */
    STATUS_RESOLVING: 2152398851;

    STATUS_RESOLVED: 2152398859;

    STATUS_CONNECTING_TO: 2152398855;

    STATUS_CONNECTED_TO: 2152398852;

    STATUS_SENDING_TO: 2152398853;

    STATUS_WAITING_FOR: 2152398858;

    STATUS_RECEIVING_FROM: 2152398854;

    STATUS_TLS_HANDSHAKE_STARTING: 2152398860;

    STATUS_TLS_HANDSHAKE_ENDED: 2152398861;

    /**
     * Values for the connectionFlags
     *
     * When making a new connection BYPASS_CACHE will force the Necko DNS
     * cache entry to be refreshed with a new call to NSPR if it is set before
     * opening the new stream.
     */
    BYPASS_CACHE: 1;

    /**
     * When setting this flag, the socket will not apply any
     * credentials when establishing a connection. For example,
     * an SSL connection would not send any client-certificates
     * if this flag is set.
     */
    ANONYMOUS_CONNECT: 2;

    /**
     * If set, we will skip all IPv6 addresses the host may have and only
     * connect to IPv4 ones.
     */
    DISABLE_IPV6: 4;

    /**
     * If set, indicates that the connection was initiated from a source
     * defined as being private in the sense of Private Browsing. Generally,
     * there should be no state shared between connections that are private
     * and those that are not; it is OK for multiple private connections
     * to share state with each other, and it is OK for multiple non-private
     * connections to share state with each other.
     */
    NO_PERMANENT_STORAGE: 8;

    /**
     * If set, we will skip all IPv4 addresses the host may have and only
     * connect to IPv6 ones.
     */
    DISABLE_IPV4: 16;

    /**
     * If set, indicates that the socket should not connect if the hostname
     * resolves to an RFC1918 address or IPv6 equivalent.
     */
    DISABLE_RFC1918: 32;

    /**
     * If set, do not use newer protocol features that might have interop problems
     * on the Internet. Intended only for use with critical infra like the updater.
     * default is false.
     */
    BE_CONSERVATIVE: 64;

    /**
     * If set, do not use TRR for resolving the host name. Intended only for
     * retries or other scenarios when TRR is deemed likely to have returned a
     * wrong adddress.
     */
    DISABLE_TRR: 128;

    /**
     * Values for the connectionFlags
     *
     * When using BYPASS_CACHE, setting this bit will invalidate the existing
     * cached entry immediately while the new resolve is being done to avoid
     * other users from using stale content in the mean time.
     */
    REFRESH_CACHE: 256;

    /**
     * If this flag is set then it means that if connecting the preferred ip
     * family has failed, retry with the oppsite one once more.
     */
    RETRY_WITH_DIFFERENT_IP_FAMILY: 512;

    /**
     * If we know that a server speaks only tls <1.3 there is no need to try
     * to use esni and query dns for esni keys.
     */
    DONT_TRY_ESNI: 1024;
  }

  /**
   * nsISocketTransport
   *
   * NOTE: Connection setup is triggered by opening an input or output stream,
   * it does not start on its own. Completion of the connection setup is
   * indicated by a STATUS_CONNECTED_TO notification to the event sink (if set).
   *
   * NOTE: This is a free-threaded interface, meaning that the methods on
   * this interface may be called from any thread.
   */
  export interface nsISocketTransport extends nsITransport {

    /**
     * Get the peer's host for the underlying socket connection.
     * For Unix domain sockets, this is a pathname, or the empty string for
     * unnamed and abstract socket addresses.
     */
    readonly host: IDLAUTF8String;

    /**
     * Get the port for the underlying socket connection.
     * For Unix domain sockets, this is zero.
     */
    readonly port: number;

    /**
     * The origin attributes are used to create sockets.  The first party domain
     * will eventually be used to isolate OCSP cache and is only non-empty when
     * "privacy.firstparty.isolate" is enabled.  Setting this is the only way to
     * carry origin attributes down to NSPR layers which are final consumers.
     * It must be set before the socket transport is built.
     */
    originAttributes: IDLjsval;

    /**
     * Returns a scriptable version of getPeerAddr. This attribute is defined
     * only once a connection has been established.
     */
    readonly getScriptablePeerAddr: () => (nsINetAddr | null);

    /**
     * Returns a scriptable version of getSelfAddr. This attribute is defined
     * only once a connection has been established.
     */
    readonly getScriptableSelfAddr: () => (nsINetAddr | null);

    /**
     * Security info object returned from the secure socket provider.  This
     * object supports nsISSLSocketControl, nsITransportSecurityInfo, and
     * possibly other interfaces.
     *
     * This attribute is only available once the socket is connected.
     */
    readonly securityInfo: (nsISupports | null);

    /**
     * Security notification callbacks passed to the secure socket provider
     * via nsISSLSocketControl at socket creation time.
     *
     * NOTE: this attribute cannot be changed once a stream has been opened.
     */
    securityCallbacks: (nsIInterfaceRequestor | null);

    /**
     * Test if this socket transport is (still) connected.
     */
    readonly isAlive: () => boolean;

    /**
     * Socket timeouts in seconds.  To specify no timeout, pass UINT32_MAX
     * as aValue to setTimeout.  The implementation may truncate timeout values
     * to a smaller range of values (e.g., 0 to 0xFFFF).
     */
    readonly getTimeout: (aType: number) => number;

    readonly setTimeout: (aType: number, aValue: number) => void;

    /**
     * Sets the SO_LINGER option with the specified values for the l_onoff and
     * l_linger parameters. This applies PR_SockOpt_Linger before PR_Close and
     * can be used with a timeout of zero to send an RST packet when closing.
     */
    readonly setLinger: (aPolarity: boolean, aTimeout: number) => void;

    /**
     * True to set addr and port reuse socket options.
     */
    readonly setReuseAddrPort: (reuseAddrPort: boolean) => void;

    /**
     * connectionFlags is a bitmask that can be used to modify underlying
     * behavior of the socket connection. See the flags below.
     */
    connectionFlags: number;

    /**
     * An opaque flags for non-standard behavior of the TLS system.
     * It is unlikely this will need to be set outside of telemetry studies
     * relating to the TLS implementation.
     */
    tlsFlags: number;

    /**
     * Socket QoS/ToS markings. Valid values are IPTOS_DSCP_AFxx or
     * IPTOS_CLASS_CSx (or IPTOS_DSCP_EF, but currently no supported
     * services require expedited-forwarding).
     * Not setting this value will leave the socket with the default
     * ToS value, which on most systems if IPTOS_CLASS_CS0 (formerly
     * IPTOS_PREC_ROUTINE).
     */
    QoSBits: number;

    /**
     * TCP send and receive buffer sizes. A value of 0 means OS level
     * auto-tuning is in effect.
     */
    recvBufferSize: number;

    sendBufferSize: number;

    /**
     * TCP keepalive configuration (support varies by platform).
     * Note that the attribute as well as the setter can only accessed
     * in the socket thread.
     */
    keepaliveEnabled: boolean;

    readonly setKeepaliveVals: (keepaliveIdleTime: number, keepaliveRetryInterval: number) => void;

    readonly firstRetryError: number;

    /**
     * If true, this socket transport has found out the prefered family
     * according it's connection flags could not be used to establish
     * connections any more.  Hence, the preference should be reset.
     */
    readonly resetIPFamilyPreference: boolean;

    /**
     * This attribute holds information whether esni has been used.
     * The value is set after PR_Connect is called.
     */
    readonly esniUsed: boolean;

    /**
     * IP address resolved using TRR.
     */
    readonly resolvedByTRR: () => boolean;
  }

  export interface nsIURIClassifierRef {
    readonly name: "nsIURIClassifier";
    readonly number: "{596620cc-76e3-4133-9d90-360e59a794cf}";
  }

  /**
   * The URI classifier service checks a URI against lists of phishing
   * and malware sites.
   */
  export interface nsIURIClassifier extends nsISupports {

    /**
     * Classify a Principal using its URI.
     *
     * @param aPrincipal
     *        The principal that should be checked by the URI classifier.
     *
     * @param nsIEventTarget
     *        Event target for constructing actor in content process.
     *        The event target should be tied to Docgroup/Tabgroup by
     *        using EventTargetFor
     *
     * @param aCallback
     *        The URI classifier will call this callback when the URI has been
     *        classified.
     *
     * @return <code>false</code> if classification is not necessary.  The
     *         callback will not be called.
     *         <code>true</code> if classification will be performed.  The
     *         callback will be called.
     */
    readonly classify: (aPrincipal: (nsIPrincipal | null), aEventTarget: (nsIEventTarget | null), aCallback: (nsIURIClassifierCallback | nsIURIClassifierCallbackFunction | null)) => boolean;

    /**
     * Asynchronously classify a URI with list of features. This does not make
     * network requests.
     */
    readonly asyncClassifyLocalWithFeatures: (aURI: (nsIURI | null), aFeatures: (nsIUrlClassifierFeature | null)[], aListType: nsIUrlClassifierFeature_listType, aCallback: (nsIUrlClassifierFeatureCallback | nsIUrlClassifierFeatureCallbackFunction | null)) => void;

    /**
     * Returns a feature named aFeatureName.
     */
    readonly getFeatureByName: (aFeatureName: IDLACString) => (nsIUrlClassifierFeature | null);

    /**
     * Returns all the feature names.
     */
    readonly getFeatureNames: () => IDLACString[];

    /**
     * Create a new feature with a list of tables. This method is just for
     * testing! Don't use it elsewhere.
     */
    readonly createFeatureWithTables: (aName: IDLACString, aBlacklistTables: IDLACString[], aWhitelistTables: IDLACString[]) => (nsIUrlClassifierFeature | null);

    /**
     * Report to the provider that a Safe Browsing warning was shown.
     *
     * @param aChannel
     *        Channel for which the URL matched something on the threat list.
     * @param aProvider
     *        Provider to notify.
     * @param aList
     *        List where the full hash was found.
     * @param aFullHash
     *        Full URL hash that triggered the warning.
     */
    readonly sendThreatHitReport: (aChannel: (nsIChannel | null), aProvider: IDLACString, aList: IDLACString, aFullHash: IDLACString) => void;
  }

  export interface nsIKeyValueServiceRef {
    readonly name: "nsIKeyValueService";
    readonly number: "{46c893dd-4c14-4de0-b33d-a1be18c6d062}";
  }

  /**
   * The nsIKeyValue* interfaces provide a simple, asynchronous API to a key/value
   * storage engine.  Basic put/get/has/delete operations are supported, as is
   * enumeration of key/value pairs and the use of multiple named databases within
   * a single storage file.  Operations have ACID semantics.
   *
   * This API does not (yet) support transactions, so it will not be appropriate
   * for all use cases.  Extension of this API to support transactions is tracked
   * by bug 1499238.
   *
   * The kvstore.jsm module wraps this API in a more idiomatic, Promise-based
   * JS API that supports async/await.  In most cases, you're better off using
   * that API from JS rather than using this one directly.  Bug 1512319 tracks
   * native support for Promise in Rust-implemented XPCOM methods.
   */
  /**
   * The key/value service.  Enables retrieval of handles to key/value databases.
   */
  export interface nsIKeyValueService extends nsISupports {

    /**
     * Get a handle to an existing database or a newly-created one
     * at the specified path and with the given name.
     *
     * The service supports multiple named databases at the same path
     * (i.e. within the same storage file), so you can call this method
     * multiple times with the same path and different names to retrieve
     * multiple databases stored in the same location on disk.
     */
    readonly getOrCreate: (callback: (nsIKeyValueDatabaseCallback | null), path: IDLAUTF8String, name: IDLAUTF8String) => void;
  }

  export interface nsISearchableInputStreamRef {
    readonly name: "nsISearchableInputStream";
    readonly number: "{8c39ef62-f7c9-11d4-98f5-001083010e9b}";
  }

  /**
   * XXX this interface doesn't really belong in here.  It is here because
   * currently nsPipeInputStream is the only implementation of this interface.
   */
  export interface nsISearchableInputStream extends nsISupports {

    /**
     * Searches for a string in the input stream. Since the stream has a notion
     * of EOF, it is possible that the string may at some time be in the
     * buffer, but is is not currently found up to some offset. Consequently,
     * both the found and not found cases return an offset:
     *    if found, return offset where it was found
     *    if not found, return offset of the first byte not searched
     * In the case the stream is at EOF and the string is not found, the first
     * byte not searched will correspond to the length of the buffer.
     */
    readonly search: (forString: string, ignoreCase: boolean, found: Out<boolean>, offsetSearchedTo: Out<number>) => void;
  }

  export interface nsIKeyValueDatabaseCallbackRef {
    readonly name: "nsIKeyValueDatabaseCallback";
    readonly number: "{2becc1f8-2d80-4b63-92a8-24ee8f79ee45}";
  }

  export interface nsIKeyValueDatabaseCallback extends nsISupports {

    /**
     * A callback for the nsIKeyValueService.getOrCreate() method.
     *
     * The result is an nsIKeyValueDatabase.
     */
    readonly resolve: (database: (nsIKeyValueDatabase | null)) => void;

    readonly reject: (message: IDLAUTF8String) => void;
  }

  export interface nsIDNSServiceInfoRef {
    readonly name: "nsIDNSServiceInfo";
    readonly number: "{670ed0f9-2fa5-4544-bf1e-ea58ac179374}";
  }

  /**
   * Service information
   */
  export interface nsIDNSServiceInfo extends nsISupports {

    /**
     * The host name of the service. (E.g. "Android.local.")
     * @throws NS_ERROR_NOT_INITIALIZED when getting unset value.
     */
    host: IDLAUTF8String;

    /**
     * The IP address of the service.
     * @throws NS_ERROR_NOT_INITIALIZED when getting unset value.
     */
    address: IDLAUTF8String;

    /**
     * The port number of the service. (E.g. 80)
     * @throws NS_ERROR_NOT_INITIALIZED when getting unset value.
     */
    port: number;

    /**
     * The service name of the service for display. (E.g. "My TV")
     * @throws NS_ERROR_NOT_INITIALIZED when getting unset value.
     */
    serviceName: IDLAUTF8String;

    /**
     * The type of the service. (E.g. "_http._tcp")
     * @throws NS_ERROR_NOT_INITIALIZED when getting unset value.
     */
    serviceType: IDLAUTF8String;

    /**
     * The domain name of the service. (E.g. "local.")
     * @throws NS_ERROR_NOT_INITIALIZED when getting unset value.
     */
    domainName: IDLAUTF8String;

    /**
     * The attributes of the service.
     */
    attributes: (nsIPropertyBag2 | null);
  }

  export interface nsIWebNavigationRef {
    readonly name: "nsIWebNavigation";
    readonly number: "{3ade79d4-8cb9-4952-b18d-4f9b63ca0d31}";

    /****************************************************************************
     * The following flags may be bitwise combined to form the load flags
     * parameter passed to either the loadURI or reload method.  Some of these
     * flags are only applicable to loadURI.
     */
    /**
     * This flags defines the range of bits that may be specified.  Flags
     * outside this range may be used, but may not be passed to Reload().
     */
    LOAD_FLAGS_MASK: 65535;

    /**
     * This is the default value for the load flags parameter.
     */
    LOAD_FLAGS_NONE: 0;

    /**
     * Flags 0x1, 0x2, 0x4, 0x8 are reserved for internal use by
     * nsIWebNavigation implementations for now.
     */
    /**
     * This flag specifies that the load should have the semantics of an HTML
     * Meta-refresh tag (i.e., that the cache should be bypassed).  This flag
     * is only applicable to loadURI.
     * XXX the meaning of this flag is poorly defined.
     * XXX no one uses this, so we should probably deprecate and remove it.
     */
    LOAD_FLAGS_IS_REFRESH: 16;

    /**
     * This flag specifies that the load should have the semantics of a link
     * click.  This flag is only applicable to loadURI.
     * XXX the meaning of this flag is poorly defined.
     */
    LOAD_FLAGS_IS_LINK: 32;

    /**
     * This flag specifies that history should not be updated.  This flag is only
     * applicable to loadURI.
     */
    LOAD_FLAGS_BYPASS_HISTORY: 64;

    /**
     * This flag specifies that any existing history entry should be replaced.
     * This flag is only applicable to loadURI.
     */
    LOAD_FLAGS_REPLACE_HISTORY: 128;

    /**
     * This flag specifies that the local web cache should be bypassed, but an
     * intermediate proxy cache could still be used to satisfy the load.
     */
    LOAD_FLAGS_BYPASS_CACHE: 256;

    /**
     * This flag specifies that any intermediate proxy caches should be bypassed
     * (i.e., that the content should be loaded from the origin server).
     */
    LOAD_FLAGS_BYPASS_PROXY: 512;

    /**
     * This flag specifies that a reload was triggered as a result of detecting
     * an incorrect character encoding while parsing a previously loaded
     * document.
     */
    LOAD_FLAGS_CHARSET_CHANGE: 1024;

    /**
     * If this flag is set, Stop() will be called before the load starts
     * and will stop both content and network activity (the default is to
     * only stop network activity).  Effectively, this passes the
     * STOP_CONTENT flag to Stop(), in addition to the STOP_NETWORK flag.
     */
    LOAD_FLAGS_STOP_CONTENT: 2048;

    /**
     * A hint this load was prompted by an external program: take care!
     */
    LOAD_FLAGS_FROM_EXTERNAL: 4096;

    /**
        This flag is set when a user explicitly disables the Mixed Content
        Blocker, and allows Mixed Content to load on an https page.
      */
    LOAD_FLAGS_ALLOW_MIXED_CONTENT: 8192;

    /**
     * This flag specifies that this is the first load in this object.
     * Set with care, since setting incorrectly can cause us to assume that
     * nothing was actually loaded in this object if the load ends up being
     * handled by an external application.  This flag must not be passed to
     * Reload.
     */
    LOAD_FLAGS_FIRST_LOAD: 16384;

    /**
     * This flag specifies that the load should not be subject to popup
     * blocking checks.  This flag must not be passed to Reload.
     */
    LOAD_FLAGS_ALLOW_POPUPS: 32768;

    /**
     * This flag specifies that the URI classifier should not be checked for
     * this load.  This flag must not be passed to Reload.
     */
    LOAD_FLAGS_BYPASS_CLASSIFIER: 65536;

    /**
     * Force relevant cookies to be sent with this load even if normally they
     * wouldn't be.
     */
    LOAD_FLAGS_FORCE_ALLOW_COOKIES: 131072;

    /**
     * Prevent the owner principal from being inherited for this load.
     */
    LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL: 262144;

    /**
     * Overwrite the returned error code with a specific result code
     * when an error page is displayed.
     */
    LOAD_FLAGS_ERROR_LOAD_CHANGES_RV: 524288;

    /**
     * This flag specifies that the URI may be submitted to a third-party
     * server for correction. This should only be applied to non-sensitive
     * URIs entered by users.  This flag must not be passed to Reload.
     */
    LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP: 1048576;

    /**
     * This flag specifies that common scheme typos should be corrected.
     */
    LOAD_FLAGS_FIXUP_SCHEME_TYPOS: 2097152;

    /**
     * Allows a top-level data: navigation to occur. E.g. view-image
     * is an explicit user action which should be allowed.
     */
    LOAD_FLAGS_FORCE_ALLOW_DATA_URI: 4194304;

    /**
     * This load is the result of an HTTP redirect.
     */
    LOAD_FLAGS_IS_REDIRECT: 8388608;

    /****************************************************************************
     * The following flags may be passed as the stop flags parameter to the stop
     * method defined on this interface.
     */
    /**
     * This flag specifies that all network activity should be stopped.  This
     * includes both active network loads and pending META-refreshes.
     */
    STOP_NETWORK: 1;

    /**
     * This flag specifies that all content activity should be stopped.  This
     * includes animated images, plugins and pending Javascript timeouts.
     */
    STOP_CONTENT: 2;

    /**
     * This flag specifies that all activity should be stopped.
     */
    STOP_ALL: 3;
  }

  /**
   * The nsIWebNavigation interface defines an interface for navigating the web.
   * It provides methods and attributes to direct an object to navigate to a new
   * location, stop or restart an in process load, or determine where the object
   * has previously gone.
   */
  export interface nsIWebNavigation extends nsISupports {

    /**
     * Indicates if the object can go back.  If true this indicates that
     * there is back session history available for navigation.
     */
    readonly canGoBack: boolean;

    /**
     * Indicates if the object can go forward.  If true this indicates that
     * there is forward session history available for navigation
     */
    readonly canGoForward: boolean;

    /**
     * Tells the object to navigate to the previous session history item.  When a
     * page is loaded from session history, all content is loaded from the cache
     * (if available) and page state (such as form values and scroll position) is
     * restored.
     *
     * @throw NS_ERROR_UNEXPECTED
     *        Indicates that the call was unexpected at this time, which implies
     *        that canGoBack is false.
     */
    readonly goBack: () => void;

    /**
     * Tells the object to navigate to the next session history item.  When a
     * page is loaded from session history, all content is loaded from the cache
     * (if available) and page state (such as form values and scroll position) is
     * restored.
     *
     * @throw NS_ERROR_UNEXPECTED
     *        Indicates that the call was unexpected at this time, which implies
     *        that canGoForward is false.
     */
    readonly goForward: () => void;

    /**
     * Tells the object to navigate to the session history item at a given index.
     *
     * @throw NS_ERROR_UNEXPECTED
     *        Indicates that the call was unexpected at this time, which implies
     *        that session history entry at the given index does not exist.
     */
    readonly gotoIndex: (index: number) => void;

    /**
     * Loads a given URI.  This will give priority to loading the requested URI
     * in the object implementing this interface.  If it can't be loaded here
     * however, the URI dispatcher will go through its normal process of content
     * loading.
     *
     * @param aURI
     *        The URI string to load.  For HTTP and FTP URLs and possibly others,
     *        characters above U+007F will be converted to UTF-8 and then URL-
     *        escaped per the rules of RFC 2396.
     * @param aLoadURIOptions
     *        A JSObject defined in LoadURIOptions.webidl holding info like e.g.
     *        the triggeringPrincipal, the referrer info.
     */
    readonly loadURI: (aURI: IDLAString, aLoadURIOptions: IDLjsval) => void;

    /**
     * Tells the Object to reload the current page.  There may be cases where the
     * user will be asked to confirm the reload (for example, when it is
     * determined that the request is non-idempotent).
     *
     * @param aReloadFlags
     *        Flags modifying load behaviour.  This parameter is a bitwise
     *        combination of the Load Flags defined above.  (Undefined bits are
     *        reserved for future use.)  Generally you will pass LOAD_FLAGS_NONE
     *        for this parameter.
     *
     * @throw NS_BINDING_ABORTED
     *        Indicating that the user canceled the reload.
     */
    readonly reload: (aReloadFlags: number) => void;

    /**
     * Stops a load of a URI.
     *
     * @param aStopFlags
     *        This parameter is one of the stop flags defined above.
     */
    readonly stop: (aStopFlags: number) => void;

    /**
     * Retrieves the current DOM document for the frame, or lazily creates a
     * blank document if there is none.  This attribute never returns null except
     * for unexpected error situations.
     */
    readonly document: WebIDL.Document;

    /**
     * The currently loaded URI or null.
     */
    readonly currentURI: (nsIURI | null);

    /**
     * The session history object used by this web navigation instance. This
     * object will be a mozilla::dom::ChildSHistory object, but is returned as
     * nsISupports so it can be called from JS code.
     */
    readonly sessionHistory: (nsISupports | null);

    /**
     * Set an OriginAttributes dictionary in the docShell. This can be done only
     * before loading any content.
     */
    readonly setOriginAttributesBeforeLoading: (originAttributes: IDLjsval) => void;

    /**
     * Resume a load which has been redirected from another process.
     *
     * A negative |aHistoryIndex| value corresponds to a non-history load being
     * resumed.
     */
    readonly resumeRedirectedLoad: (aLoadIdentifier: number, aHistoryIndex: number) => void;
  }

  export interface nsITimedChannelRef {
    readonly name: "nsITimedChannel";
    readonly number: "{ca63784d-959c-4c3a-9a59-234a2a520de0}";
  }

  export interface nsITimedChannel extends nsISupports {

    timingEnabled: boolean;

    redirectCount: number;

    internalRedirectCount: number;

    readonly channelCreationTime: number;

    readonly asyncOpenTime: number;

    readonly launchServiceWorkerStartTime: number;

    readonly launchServiceWorkerEndTime: number;

    readonly dispatchFetchEventStartTime: number;

    readonly dispatchFetchEventEndTime: number;

    readonly handleFetchEventStartTime: number;

    readonly handleFetchEventEndTime: number;

    readonly domainLookupStartTime: number;

    readonly domainLookupEndTime: number;

    readonly connectStartTime: number;

    readonly tcpConnectEndTime: number;

    readonly secureConnectionStartTime: number;

    readonly connectEndTime: number;

    readonly requestStartTime: number;

    readonly responseStartTime: number;

    readonly responseEndTime: number;

    readonly cacheReadStartTime: number;

    readonly cacheReadEndTime: number;

    readonly redirectStartTime: number;

    readonly redirectEndTime: number;

    readonly serverTiming: (nsIArray | null);
  }

  export interface nsIScreenManagerRef {
    readonly name: "nsIScreenManager";
    readonly number: "{e8a96e60-6b61-4a14-bacc-53891604b502}";
  }

  export interface nsIScreenManager extends nsISupports {

    readonly screenForRect: (left: number, top: number, width: number, height: number) => (nsIScreen | null);

    readonly primaryScreen: (nsIScreen | null);

    readonly totalScreenPixels: number;
  }

  export interface nsIPresentationServiceCallbackRef {
    readonly name: "nsIPresentationServiceCallback";
    readonly number: "{12073206-0065-4b10-9488-a6eb9b23e65b}";
  }

  export interface nsIPresentationServiceCallback extends nsISupports {

    readonly notifySuccess: (url: IDLAString) => void;

    readonly notifyError: (error: number) => void;
  }

  export interface nsIContentPermissionRequestRef {
    readonly name: "nsIContentPermissionRequest";
    readonly number: "{875733da-0ac0-4a26-8c76-70a30876be46}";
  }

  /**
   * Interface allows access to a content to request
   * permission to perform a privileged operation such as
   * geolocation.
   */
  export interface nsIContentPermissionRequest extends nsISupports {

    /**
     *  The array will include the request types. Elements of this array are
     *  nsIContentPermissionType object.
     */
    readonly types: (nsIArray | null);

    readonly principal: (nsIPrincipal | null);

    readonly topLevelPrincipal: (nsIPrincipal | null);

    /**
     *  The window or element that the permission request was
     *  originated in.  Typically the element will be non-null
     *  in when using out of process content.  window or
     *  element can be null but not both.
     */
    readonly window: (mozIDOMWindow | null);

    readonly element: WebIDL.Element;

    readonly isHandlingUserInput: boolean;

    readonly maybeUnsafePermissionDelegate: boolean;

    /**
     *  The requester to get the required information of
     *  the window.
     */
    readonly requester: (nsIContentPermissionRequester | null);

    readonly getDelegatePrincipal: (aType: IDLACString) => (nsIPrincipal | null);

    /**
     * allow or cancel the request
     */
    readonly cancel: () => void;

    readonly allow: (choices?: IDLjsval) => void;
  }

  export interface nsIDeviceSensorsRef {
    readonly name: "nsIDeviceSensors";
    readonly number: "{e46e47c7-55ff-44c4-abce-21b14ba07f86}";
  }

  export interface nsIDeviceSensors extends nsISupports {

    /**
     * Returns true if the given window has any listeners of the given type
     */
    readonly hasWindowListener: (aType: number, aWindow: (nsIDOMWindow | null)) => boolean;
  }

  export interface nsIFileChannelRef {
    readonly name: "nsIFileChannel";
    readonly number: "{06169120-136d-45a5-b535-498f1f755ab7}";
  }

  /**
   * nsIFileChannel
   */
  export interface nsIFileChannel extends nsISupports {

    readonly file: (nsIFile | null);
  }

  export interface nsIKeyValuePairRef {
    readonly name: "nsIKeyValuePair";
    readonly number: "{bc37b06a-23b5-4b32-8281-4b8479601c7e}";
  }

  export interface nsIKeyValuePair extends nsISupports {

    /**
     * A key/value pair.  Returned by nsIKeyValueEnumerator.getNext().
     */
    readonly key: IDLAUTF8String;

    readonly value: (nsIVariant | null);
  }

  export interface nsICategoryManagerRef {
    readonly name: "nsICategoryManager";
    readonly number: "{3275b2cd-af6d-429a-80d7-f0c5120342ac}";
  }

  export interface nsICategoryManager extends nsISupports {

    /**
     * Get the value for the given category's entry.
     * @param aCategory The name of the category ("protocol")
     * @param aEntry The entry you're looking for ("http")
     * @return The value.
     */
    readonly getCategoryEntry: (aCategory: IDLACString, aEntry: IDLACString) => IDLACString;

    /**
     * Add an entry to a category.
     * @param aCategory The name of the category ("protocol")
     * @param aEntry The entry to be added ("http")
     * @param aValue The value for the entry ("moz.httprulez.1")
     * @param aPersist Should this data persist between invocations?
     * @param aReplace Should we replace an existing entry?
     * @return Previous entry, if any
     */
    readonly addCategoryEntry: (aCategory: IDLACString, aEntry: IDLACString, aValue: IDLACString, aPersist: boolean, aReplace: boolean) => IDLACString;

    /**
     * Delete an entry from the category.
     * @param aCategory The name of the category ("protocol")
     * @param aEntry The entry to be added ("http")
     * @param aPersist Delete persistent data from registry, if present?
     */
    readonly deleteCategoryEntry: (aCategory: IDLACString, aEntry: IDLACString, aPersist: boolean) => void;

    /**
     * Delete a category and all entries.
     * @param aCategory The category to be deleted.
     */
    readonly deleteCategory: (aCategory: IDLACString) => void;

    /**
     * Enumerate the entries in a category.
     * @param aCategory The category to be enumerated.
     * @return a simple enumerator, each result QIs to
     *         nsICategoryEntry.
     */
    readonly enumerateCategory: (aCategory: IDLACString) => (nsISimpleEnumerator | null);

    /**
     * Enumerate all existing categories
     * @param aCategory The category to be enumerated.
     * @return a simple enumerator, each result QIs to
     *         nsISupportsCString.
     */
    readonly enumerateCategories: () => (nsISimpleEnumerator | null);
  }

  export interface nsIIdentChannelRef {
    readonly name: "nsIIdentChannel";
    readonly number: "{1ebbff64-d742-4f4a-aad5-4df2d1eb937a}";
  }

  export interface nsIIdentChannel extends nsIChannel {

    /**
     * Unique ID of the channel, shared between parent and child. Needed if
     * the channel activity needs to be monitored across process boundaries,
     * like in devtools net monitor. See bug 1274556.
     */
    channelId: number;
  }

  export interface nsIEditorSpellCheckCallbackRef {
    readonly name: "nsIEditorSpellCheckCallback";
    readonly number: "{5f0a4bab-8538-4074-89d3-2f0e866a1c0b}";
  }

  type nsIEditorSpellCheckCallbackFunction = () => void;

  export interface nsIEditorSpellCheckCallback extends nsISupports {

    readonly editorSpellCheckDone: () => void;
  }

  export interface nsIMediaDeviceRef {
    readonly name: "nsIMediaDevice";
    readonly number: "{ba3b2e08-1c07-4cd3-8822-f4d7e35ff2ae}";
  }

  export interface nsIMediaDevice extends nsISupports {

    readonly type: IDLAString;

    readonly name: IDLAString;

    readonly id: IDLAString;

    readonly mediaSource: IDLAString;

    readonly rawId: IDLAString;

    readonly groupId: IDLAString;

    readonly scary: boolean;
  }

  export interface nsIPlatformInfoRef {
    readonly name: "nsIPlatformInfo";
    readonly number: "{ab6650cf-0806-4aea-b8f2-40fdae74f1cc}";
  }

  export interface nsIPlatformInfo extends nsISupports {

    /**
     * The version of the XULRunner platform.
     */
    readonly platformVersion: IDLACString;

    /**
     * The build ID/date of gecko and the XULRunner platform.
     */
    readonly platformBuildID: IDLACString;
  }

  export interface nsINetworkPredictorVerifierRef {
    readonly name: "nsINetworkPredictorVerifier";
    readonly number: "{2e43bb32-dabf-4494-9f90-2b3195b1c73d}";
  }

  export interface nsINetworkPredictorVerifier extends nsISupports {

    /**
     * Callback for when we do a predictive prefetch
     *
     * @param uri - The URI that was prefetched
     * @param status - The request status code returned by the
     *   prefetch attempt e.g. 200 (OK):w
     */
    readonly onPredictPrefetch: (uri: (nsIURI | null), status: number) => void;

    /**
     * Callback for when we do a predictive preconnect
     *
     * @param uri - The URI that was preconnected to
     */
    readonly onPredictPreconnect: (uri: (nsIURI | null)) => void;

    /**
     * Callback for when we do a predictive DNS lookup
     *
     * @param uri - The URI that was looked up
     */
    readonly onPredictDNS: (uri: (nsIURI | null)) => void;
  }

  export interface nsIWebSocketListenerRef {
    readonly name: "nsIWebSocketListener";
    readonly number: "{d74c96b2-65b3-4e39-9e39-c577de5d7a73}";
  }

  /**
   * nsIWebSocketListener: passed to nsIWebSocketChannel::AsyncOpen. Receives
   * websocket traffic events as they arrive.
   */
  export interface nsIWebSocketListener extends nsISupports {

    /**
     * Called to signify the establishment of the message stream.
     *
     * Unlike most other networking channels (which use nsIRequestObserver
     * instead of this class), we do not guarantee that OnStart is always
     * called: OnStop is called without calling this function if errors occur
     * during connection setup.  If the websocket connection is successful,
     * OnStart will be called before any other calls to this API.
     *
     * @param aContext user defined context
     */
    readonly onStart: (aContext: (nsISupports | null)) => void;

    /**
     * Called to signify the completion of the message stream.
     * OnStop is the final notification the listener will receive and it
     * completes the WebSocket connection: after it returns the
     * nsIWebSocketChannel will release its reference to the listener.
     *
     * Note: this event can be received in error cases even if
     * nsIWebSocketChannel::Close() has not been called.
     *
     * @param aContext user defined context
     * @param aStatusCode reason for stopping (NS_OK if completed successfully)
     */
    readonly onStop: (aContext: (nsISupports | null), aStatusCode: number) => void;

    /**
     * Called to deliver text message.
     *
     * @param aContext user defined context
     * @param aMsg the message data
     */
    readonly onMessageAvailable: (aContext: (nsISupports | null), aMsg: IDLAUTF8String) => void;

    /**
     * Called to deliver binary message.
     *
     * @param aContext user defined context
     * @param aMsg the message data
     */
    readonly onBinaryMessageAvailable: (aContext: (nsISupports | null), aMsg: IDLACString) => void;

    /**
     * Called to acknowledge message sent via sendMsg() or sendBinaryMsg.
     *
     * @param aContext user defined context
     * @param aSize number of bytes placed in OS send buffer
     */
    readonly onAcknowledge: (aContext: (nsISupports | null), aSize: number) => void;

    /**
     * Called to inform receipt of WebSocket Close message from server.
     * In the case of errors onStop() can be called without ever
     * receiving server close.
     *
     * No additional messages through onMessageAvailable(),
     * onBinaryMessageAvailable() or onAcknowledge() will be delievered
     * to the listener after onServerClose(), though outgoing messages can still
     * be sent through the nsIWebSocketChannel connection.
     *
     * @param aContext user defined context
     * @param aCode the websocket closing handshake close code.
     * @param aReason the websocket closing handshake close reason
     */
    readonly onServerClose: (aContext: (nsISupports | null), aCode: number, aReason: IDLAUTF8String) => void;
  }

  export interface nsIStructuredCloneContainerRef {
    readonly name: "nsIStructuredCloneContainer";
    readonly number: "{c664aae7-0d67-4155-a2dd-a3861778626f}";
  }

  /**
   * This interface acts as a container for an object serialized using the
   * structured clone algorithm.
   *
   * You can copy an object into an nsIStructuredCloneContainer using
   * initFromJSVal or initFromBase64.  It's an error to initialize an
   * nsIStructuredCloneContainer more than once.
   *
   * Once you've initialized the container, you can get a copy of the object it
   * stores by calling deserializeToVariant.  You can also get a base-64-encoded
   * string containing a copy of the container's serialized data, using
   * getDataAsBase64.
   */
  export interface nsIStructuredCloneContainer extends nsISupports {

    /**
     * Initialize this structured clone container from a base-64-encoded byte
     * stream, stored in aData.  aFormatVersion should be the version of the
     * structured clone algorithm which was used to generate aData.
     */
    readonly initFromBase64: (aData: IDLAString, aFormatVersion: number) => void;

    /**
     * Deserializes this structured clone container returning it as a jsval.
     * Can be called on main and worker threads.
     */
    readonly deserializeToJsval: () => IDLjsval;

    /**
     * Deserialize the object this container holds, returning it wrapped as
     * an nsIVariant.
     * Main thread only!
     */
    readonly deserializeToVariant: () => (nsIVariant | null);

    /**
     * Get this structured clone container's data as a base-64-encoded string.
     */
    readonly getDataAsBase64: () => IDLAString;

    /**
     * Get the size in bytes of this container's serialized data.
     */
    readonly serializedNBytes: number;

    /**
     * Get the version of the structured clone algorithm which was used to
     * generate this container's serialized buffer.
     */
    readonly formatVersion: number;
  }

  export interface nsICloneableInputStreamRef {
    readonly name: "nsICloneableInputStream";
    readonly number: "{8149be1f-44d3-4f14-8b65-a57a5fbbeb97}";
  }

  export interface nsICloneableInputStream extends nsISupports {

    readonly cloneable: boolean;

    readonly clone: () => (nsIInputStream | null);
  }

  export interface nsIResumableChannelRef {
    readonly name: "nsIResumableChannel";
    readonly number: "{4ad136fa-83af-4a22-a76e-503642c0f4a8}";
  }

  export interface nsIResumableChannel extends nsISupports {

    /**
     * Prepare this channel for resuming. The request will not start until
     * asyncOpen or open is called. Calling resumeAt after open or asyncOpen
     * has been called has undefined behaviour.
     *
     * @param startPos the starting offset, in bytes, to use to download
     * @param entityID information about the file, to match before obtaining
     *  the file. Pass an empty string to use anything.
     *
     * During OnStartRequest, this channel will have a status of
     *  NS_ERROR_NOT_RESUMABLE if the file cannot be resumed, eg because the
     *  server doesn't support this. This error may occur even if startPos
     *  is 0, so that the front end can warn the user.
     * Similarly, the status of this channel during OnStartRequest may be
     *  NS_ERROR_ENTITY_CHANGED, which indicates that the entity has changed,
     *  as indicated by a changed entityID.
     * In both of these cases, no OnDataAvailable will be called, and
     *  OnStopRequest will immediately follow with the same status code.
     */
    readonly resumeAt: (startPos: number, entityID: IDLACString) => void;

    /**
     * The entity id for this URI. Available after OnStartRequest.
     * @throw NS_ERROR_NOT_RESUMABLE if this load is not resumable.
     */
    readonly entityID: IDLACString;
  }

  export interface nsISecureBrowserUIRef {
    readonly name: "nsISecureBrowserUI";
    readonly number: "{718c662a-f810-4a80-a6c9-0b1810ecade2}";
  }

  export interface nsISecureBrowserUI extends nsISupports {

    readonly init: (docShell: (nsIDocShell | null)) => void;

    readonly state: number;

    readonly contentBlockingEvent: number;

    readonly isSecureContext: boolean;

    readonly secInfo: (nsITransportSecurityInfo | null);
  }

  export interface mozIStorageBindingParamsRef {
    readonly name: "mozIStorageBindingParams";
    readonly number: "{2d09f42f-966e-4663-b4b3-b0c8676bf2bf}";
  }

  export interface mozIStorageBindingParams extends nsISupports {

    /**
     * Binds aValue to the parameter with the name aName.
     *
     * @param aName
     *        The name of the parameter to bind aValue to.
     * @param aValue
     *        The value to bind.
     */
    readonly bindByName: (aName: IDLAUTF8String, aValue: (nsIVariant | null)) => void;

    readonly bindBlobByName: (aName: IDLAUTF8String, aValue: number[]) => void;

    readonly bindStringAsBlobByName: (aName: IDLAUTF8String, aValue: IDLAString) => void;

    readonly bindUTF8StringAsBlobByName: (aName: IDLAUTF8String, aValue: IDLAUTF8String) => void;

    /**
     * Binds aValue to the parameter with the index aIndex.
     *
     * @param aIndex
     *        The zero-based index of the parameter to bind aValue to.
     * @param aValue
     *        The value to bind.
     */
    readonly bindByIndex: (aIndex: number, aValue: (nsIVariant | null)) => void;

    readonly bindBlobByIndex: (aIndex: number, aValue: number[]) => void;

    readonly bindStringAsBlobByIndex: (aIndex: number, aValue: IDLAString) => void;

    readonly bindUTF8StringAsBlobByIndex: (aIndex: number, aValue: IDLAUTF8String) => void;
  }

  export interface nsICookieTransactionCallbackRef {
    readonly name: "nsICookieTransactionCallback";
    readonly number: "{0fc41ffb-f1b7-42d9-9a42-8dc420c158c1}";
  }

  type nsICookieTransactionCallbackFunction = () => void;

  /**
   * @see nsICookieService::runInTransaction
   */
  export interface nsICookieTransactionCallback extends nsISupports {

    readonly callback: () => void;
  }

  export interface nsIURIFixupInfoRef {
    readonly name: "nsIURIFixupInfo";
    readonly number: "{4819f183-b532-4932-ac09-b309cd853be7}";
  }

  /**
   * Interface indicating what we found/corrected when fixing up a URI
   */
  export interface nsIURIFixupInfo extends nsISupports {

    /**
     * Consumer that asked for fixed up URI.
     */
    consumer: (nsISupports | null);

    /**
     * Our best guess as to what URI the consumer will want. Might
     * be null if we couldn't salvage anything (for instance, because
     * the input was invalid as a URI and FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
     * was not passed)
     */
    readonly preferredURI: (nsIURI | null);

    /**
     * The fixed-up original input, *never* using a keyword search.
     * (might be null if the original input was not recoverable as
     * a URL, e.g. "foo bar"!)
     */
    readonly fixedURI: (nsIURI | null);

    /**
     * The name of the keyword search provider used to provide a keyword search;
     * empty string if no keyword search was done.
     */
    readonly keywordProviderName: IDLAString;

    /**
     * The keyword as used for the search (post trimming etc.)
     * empty string if no keyword search was done.
     */
    readonly keywordAsSent: IDLAString;

    /**
     * Whether we changed the protocol instead of using one from the input as-is.
     */
    readonly fixupChangedProtocol: boolean;

    /**
     * Whether we created an alternative URI. We might have added a prefix and/or
     * suffix, the contents of which are controlled by the
     * browser.fixup.alternate.prefix and .suffix prefs, with the defaults being
     * "www." and ".com", respectively.
     */
    readonly fixupCreatedAlternateURI: boolean;

    /**
     * The original input
     */
    readonly originalInput: IDLAUTF8String;
  }

  export interface nsIPushDataRef {
    readonly name: "nsIPushData";
    readonly number: "{dfc4f151-cead-40df-8eb7-7a7a67c54b16}";
  }

  /**
   * Provides methods for retrieving push message data in different formats.
   * This interface resembles the `PushMessageData` WebIDL interface.
   */
  export interface nsIPushData extends nsISupports {

    /** Extracts the data as a UTF-8 text string. */
    readonly text: () => IDLAString;

    /** Extracts the data as a JSON value. */
    readonly json: () => IDLjsval;

    /** Extracts the raw binary data. */
    readonly binary: () => number[];
  }

  export interface nsIClearDataServiceRef {
    readonly name: "nsIClearDataService";
    readonly number: "{6ef3ef16-a502-4576-9fb4-919f1c40bf61}";

    /**************************************************************************
     * Listed below are the various flags which may be or'd together.
     */
    /**
     * Delete cookies.
     */
    CLEAR_COOKIES: 1;

    /**
     * Network Cache.
     */
    CLEAR_NETWORK_CACHE: 2;

    /**
     * Image cache.
     */
    CLEAR_IMAGE_CACHE: 4;

    /**
     * Data stored by external plugins.
     */
    CLEAR_PLUGIN_DATA: 8;

    /**
     * Completed downloads.
     */
    CLEAR_DOWNLOADS: 16;

    /**
     * Stored passwords.
     */
    CLEAR_PASSWORDS: 32;

    /**
     * Media devices.
     */
    CLEAR_MEDIA_DEVICES: 64;

    /**
     * AppCache.
     */
    CLEAR_APPCACHE: 128;

    /**
     * LocalStorage, IndexedDB, ServiceWorkers, DOM Cache and so on.
     */
    CLEAR_DOM_QUOTA: 256;

    /**
     * Predictor network data
     */
    CLEAR_PREDICTOR_NETWORK_DATA: 512;

    /**
     * DOM Push notifications
     */
    CLEAR_DOM_PUSH_NOTIFICATIONS: 1024;

    /**
     * Places history
     */
    CLEAR_HISTORY: 2048;

    /**
     * Session history
     */
    CLEAR_SESSION_HISTORY: 4096;

    /**
     * Auth tokens
     */
    CLEAR_AUTH_TOKENS: 8192;

    /**
     * Login cache
     */
    CLEAR_AUTH_CACHE: 16384;

    /**
     * Site permissions
     */
    CLEAR_PERMISSIONS: 32768;

    /**
     * Site preferences
     */
    CLEAR_CONTENT_PREFERENCES: 65536;

    /**
     * Secure site settings
     */
    CLEAR_SECURITY_SETTINGS: 131072;

    /**
     * Media plugin data
     */
    CLEAR_EME: 262144;

    /**
     * Reporting API reports.
     */
    CLEAR_REPORTS: 524288;

    /**
     * StorageAccessAPI flag, which indicates user interaction.
     */
    CLEAR_STORAGE_ACCESS: 1048576;

    /**
     * Clear Cert Exceptions.
     */
    CLEAR_CERT_EXCEPTIONS: 2097152;

    /**
     * Clear entries in the content blocking database.
     */
    CLEAR_CONTENT_BLOCKING_RECORDS: 4194304;

    /**
     * Use this value to delete all the data.
     */
    CLEAR_ALL: 16777215;

    /**************************************************************************
     * The following flags are helpers: they combine some of the previous flags
     * in a more convenient way.
     */
    /**
     * Delete all the possible caches.
     */
    CLEAR_ALL_CACHES: 6;

    /**
     * Delete all DOM storages
     */
    CLEAR_DOM_STORAGES: 525696;

    /**
     * Helper flag for forget about site
     */
    CLEAR_FORGET_ABOUT_SITE: 3121087;
  }

  /**
   * nsIClearDataService
   *
   * Provides methods for cleaning data from a nsIPrincipal and/or from a time
   * range.
   */
  export interface nsIClearDataService extends nsISupports {

    /**
       * Delete data owned by local files or other hostless schemes.
       * @param aIsUserRequest true if this request comes from a user interaction.
       *        This information is important because if true, it's probably better
       *        to remove more than less, for privacy reason. If false (e.g.
       *        Clear-Site-Data header), we don't want to delete more than what is
       *        strictly required.
       * @param aFlags List of flags. See below the accepted values.
                       Note that not all flags will make sense (e.g. we can't clear
                       certificates for local files). Nonsensical flags will be
                       ignored.
       * @param aCallback this callback will be executed when the operation is
       *                  completed.
       */
    readonly deleteDataFromLocalFiles: (aIsUserRequest: boolean, aFlags: number, aCallback: (nsIClearDataCallback | nsIClearDataCallbackFunction | null)) => void;

    /**
     * Delete data owned by a host. For instance: mozilla.org. Data from any
     * possible originAttributes will be deleted.
     * @param aHost the host to be used.
     * @param aIsUserRequest true if this request comes from a user interaction.
     *        This information is important because if true, it's probably better
     *        to remove more than less, for privacy reason. If false (e.g.
     *        Clear-Site-Data header), we don't want to delete more than what is
     *        strictly required.
     * @param aFlags List of flags. See below the accepted values.
     * @param aCallback this callback will be executed when the operation is
     *                  completed.
     */
    readonly deleteDataFromHost: (aHost: IDLAUTF8String, aIsUserRequest: boolean, aFlags: number, aCallback: (nsIClearDataCallback | nsIClearDataCallbackFunction | null)) => void;

    /**
     * Delete data owned by a principal.
     * @param aPrincipal the nsIPrincipal to be used.
     * @param aIsUserRequest true if this request comes from a user interaction.
     *        This information is important because if true, it's probably better
     *        to remove more than less, for privacy reason. If false (e.g.
     *        Clear-Site-Data header), we don't want to delete more than what is
     *        strictly required.
     * @param aFlags List of flags. See below the accepted values.
     * @param aCallback ths callback will be executed when the operation is
     *                  completed.
     */
    readonly deleteDataFromPrincipal: (aPrincipal: (nsIPrincipal | null), aIsUserRequest: boolean, aFlags: number, aCallback: (nsIClearDataCallback | nsIClearDataCallbackFunction | null)) => void;

    /**
     * Delete all data in a time range. Limit excluded.
     * @param aFrom microseconds from the epoch
     * @param aTo microseconds from the epoch
     * @param aIsUserRequest true if this request comes from a user interaction.
     *        This information is important because if true, it's probably better
     *        to remove more than less, for privacy reason. If false (e.g.
     *        Clear-Site-Data header), we don't want to delete more than what is
     *        strictly required.
     * @param aFlags List of flags. See below the accepted values.
     * @param aCallback ths callback will be executed when the operation is
     *                  completed.
     */
    readonly deleteDataInTimeRange: (aFrom: number, aTo: number, aIsUserRequest: boolean, aFlags: number, aCallback: (nsIClearDataCallback | nsIClearDataCallbackFunction | null)) => void;

    /**
     * Delete all data from any host, in any time range.
     * @param aFlags List of flags. See below the accepted values.
     * @param aCallback ths callback will be executed when the operation is
     *                  completed.
     */
    readonly deleteData: (aFlags: number, aCallback: (nsIClearDataCallback | nsIClearDataCallbackFunction | null)) => void;

    /**
     * Delete all data from an OriginAttributesPatternDictionary.
     * @param aOriginAttributesPattern the originAttributes dictionary.
     * @param aCallback the optional callback will be executed when the operation
     *                  is completed.
     */
    readonly deleteDataFromOriginAttributesPattern: (aOriginAttributesPattern: IDLjsval, aCallback?: (nsIClearDataCallback | nsIClearDataCallbackFunction | null)) => void;
  }

  export interface nsINavHistoryQueryRef {
    readonly name: "nsINavHistoryQuery";
    readonly number: "{dc87ae79-22f1-4dcf-975b-852b01d210cb}";

    /**
     * This object encapsulates all the query parameters you're likely to need
     * when building up history UI. All parameters are ANDed together.
     *
     * This is not intended to be a super-general query mechanism. This was designed
     * so that most queries can be done in only one SQL query. This is important
     * because, if the user has their profile on a networked drive, query latency
     * can be non-negligible.
     */
    /**
     * Time range for results (INCLUSIVE). The *TimeReference is one of the
     * constants TIME_RELATIVE_* which indicates how to interpret the
     * corresponding time value.
     *   TIME_RELATIVE_EPOCH (default):
     *     The time is relative to Jan 1 1970 GMT, (this is a normal PRTime)
     *   TIME_RELATIVE_TODAY:
     *     The time is relative to this morning at midnight. Normally used for
     *     queries relative to today. For example, a "past week" query would be
     *     today-6 days -> today+1 day
     *   TIME_RELATIVE_NOW:
     *     The time is relative to right now.
     *
     * Note: PRTime is in MICROseconds since 1 Jan 1970. Javascript date objects
     * are expressed in MILLIseconds since 1 Jan 1970.
     *
     * As a special case, a 0 time relative to TIME_RELATIVE_EPOCH indicates that
     * the time is not part of the query. This is the default, so an empty query
     * will match any time. The has* functions return whether the corresponding
     * time is considered.
     *
     * You can read absolute*Time to get the time value that the currently loaded
     * reference points + offset resolve to.
     */
    TIME_RELATIVE_EPOCH: 0;

    TIME_RELATIVE_TODAY: 1;

    TIME_RELATIVE_NOW: 2;
  }

  export interface nsINavHistoryQuery extends nsISupports {

    beginTime: number;

    beginTimeReference: number;

    readonly hasBeginTime: boolean;

    readonly absoluteBeginTime: number;

    endTime: number;

    endTimeReference: number;

    readonly hasEndTime: boolean;

    readonly absoluteEndTime: number;

    /**
     * Text search terms.
     */
    searchTerms: IDLAString;

    readonly hasSearchTerms: boolean;

    /**
     * Set lower or upper limits for how many times an item has been
     * visited.  The default is -1, and in that case all items are
     * matched regardless of their visit count.
     */
    minVisits: number;

    maxVisits: number;

    /**
     * When the set of transitions is nonempty, results are limited to pages which
     * have at least one visit for each of the transition types.
     * @note: For searching on more than one transition this can be very slow.
     *
     * Limit results to the specified list of transition types.
     */
    readonly setTransitions: (transitions: number[]) => void;

    /**
     * Get the transitions set for this query.
     */
    readonly getTransitions: () => number[];

    /**
     * Get the count of the set query transitions.
     */
    readonly transitionCount: number;

    /**
     * When set, returns only bookmarked items, when unset, returns anything. Setting this
     * is equivalent to listing all bookmark folders in the 'folders' parameter.
     */
    onlyBookmarked: boolean;

    /**
     * This controls the meaning of 'domain', and whether it is an exact match
     * 'domainIsHost' = true, or hierarchical (= false).
     */
    domainIsHost: boolean;

    /**
     * This is the host or domain name (controlled by domainIsHost). When
     * domainIsHost, domain only does exact matching on host names. Otherwise,
     * it will return anything whose host name ends in 'domain'.
     *
     * This one is a little different than most. Setting it to an empty string
     * is a real query and will match any URI that has no host name (local files
     * and such). Set this to NULL (in C++ use SetIsVoid) if you don't want
     * domain matching.
     */
    domain: IDLAUTF8String;

    readonly hasDomain: boolean;

    /**
     * This is a URI to match, to, for example, find out every time you visited
     * a given URI. This is an exact match.
     */
    uri: (nsIURI | null);

    readonly hasUri: boolean;

    /**
     * Test for existence or non-existence of a given annotation. We don't
     * currently support >1 annotation name per query. If 'annotationIsNot' is
     * true, we test for the non-existence of the specified annotation.
     *
     * Testing for not annotation will do the same thing as a normal query and
     * remove everything that doesn't have that annotation. Asking for things
     * that DO have a given annotation is a little different. It also includes
     * things that have never been visited. This allows place queries to be
     * returned as well as anything else that may have been tagged with an
     * annotation. This will only work for RESULTS_AS_URI since there will be
     * no visits for these items.
     */
    annotationIsNot: boolean;

    annotation: IDLAUTF8String;

    readonly hasAnnotation: boolean;

    /**
     * Limit results to items that are tagged with all of the given tags.  This
     * attribute must be set to an array of strings.  When called as a getter it
     * will return an array of strings sorted ascending in lexicographical order.
     * The array may be empty in either case.  Duplicate tags may be specified
     * when setting the attribute, but the getter returns only unique tags.
     */
    tags: (nsIVariant | null);

    /**
     * If 'tagsAreNot' is true, the results are instead limited to items that
     * are not tagged with any of the given tags.  This attribute is used in
     * conjunction with the 'tags' attribute.
     */
    tagsAreNot: boolean;

    /**
     * Limit results to items that are in all of the given folders.
     */
    readonly getParents: () => IDLACString[];

    readonly parentCount: number;

    /**
     * This is not recursive so results will be returned from the first level of
     * that folder.
     */
    readonly setParents: (aGuids: IDLACString[]) => void;

    /**
     * Creates a new query item with the same parameters of this one.
     */
    readonly clone: () => (nsINavHistoryQuery | null);
  }

  export interface nsIFullHashMatchRef {
    readonly name: "nsIFullHashMatch";
    readonly number: "{aabeb50e-d9f7-418e-9469-2cd9608958c0}";
  }

  /**
   * This interface contains feilds in Matches object of FullHashResponse(V4).
   * Reference from:
   * https://developers.google.com/safe-browsing/v4/update-api#http-post-response_2
   */
  export interface nsIFullHashMatch extends nsISupports {

    readonly tableName: IDLACString;

    readonly fullHash: IDLACString;

    readonly cacheDuration: number;
  }

  export interface nsIForwardIteratorRef {
    readonly name: "nsIForwardIterator";
    readonly number: "{8da01646-1dd2-11b2-98a7-c7009045be7e}";
  }

  /**
   * ...
   */
  export interface nsIForwardIterator extends nsISupports {

    /**
     * Retrieve (and |AddRef()|) the element this iterator currently points to.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @result a new reference to the element this iterator currently points to (if any)
     */
    readonly getElement: () => (nsISupports | null);

    /**
     * Put |anElementToPut| into the underlying container or sequence at the position currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    readonly putElement: (anElementToPut: (nsISupports | null)) => void;

    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    readonly stepForward: () => void;

    /**
     * Test if |anotherIterator| points to the same position in the underlying container or sequence.
     *
     * The result is undefined if |anotherIterator| was not created by or for the same underlying container or sequence.
     *
     * @param anotherIterator another iterator to compare against, created by or for the same underlying container or sequence
     * @result true if |anotherIterator| points to the same position in the underlying container or sequence
     */
    readonly isEqualTo: (anotherIterator: (nsISupports | null)) => boolean;

    /**
     * Create a new iterator pointing to the same position in the underlying container or sequence to which this iterator currently points.
     * The returned iterator is suitable for use in a subsequent call to |isEqualTo()| against this iterator.
     *
     * @result a new iterator pointing at the same position in the same underlying container or sequence as this iterator
     */
    readonly clone: () => (nsISupports | null);
  }

  export interface nsINotificationStorageRef {
    readonly name: "nsINotificationStorage";
    readonly number: "{17f85e52-fe57-440e-9ba1-5c312ca02b95}";
  }

  /**
   * Interface for notification persistence layer.
   */
  export interface nsINotificationStorage extends nsISupports {

    /**
     * Add/replace a notification to the persistence layer.
     *
     * @param origin: the origin/app of this notification
     * @param id: a uuid for this notification
     * @param title: the notification title
     * @param dir: the notification direction,
     *             possible values are "ltr", "rtl", "auto"
     * @param lang: the notification language
     * @param body: the notification body
     * @param tag: notification tag, will replace any existing
     *             notifications with same origin/tag pair
     * @param alertName: the alert identifier as used by system app.
     *                   Stored in the database to avoid re-computing
     *                   it. Built from origin and tag or id depending
     *                   whether there is a tag defined.
     * @param registrationID: Opaque string that identifies the service worker
     *                        registration this Notification is associated with.
     *                        May be empty. Only set for Notifications created by
     *                        showNotification().
     */
    readonly put: (origin: IDLAString, id: IDLAString, title: IDLAString, dir: IDLAString, lang: IDLAString, body: IDLAString, tag: IDLAString, icon: IDLAString, alertName: IDLAString, data: IDLAString, behavior: IDLAString, serviceWorkerRegistrationScope: IDLAString) => void;

    /**
     * Retrieve a list of notifications.
     *
     * @param origin: the origin/app for which to fetch notifications from
     * @param tag: used to fetch only a specific tag
     * @param callback: nsINotificationStorageCallback, used for
     *                  returning notifications objects
     */
    readonly get: (origin: IDLAString, tag: IDLAString, aCallback: (nsINotificationStorageCallback | null)) => void;

    /**
     * Retrieve a notification by ID.
     *
     * @param origin: the origin/app for which to fetch notifications.
     * @param id: the id of the notification.
     * @param callback: nsINotificationStorageCallback whose Handle method will
     * be called *at most once* if the notification with that ID is found. Not
     * called if that ID is not found. Done() will be called right after
     * Handle().
     */
    readonly getByID: (origin: IDLAString, id: IDLAString, aCallback: (nsINotificationStorageCallback | null)) => void;

    /**
     * Remove a notification from storage.
     *
     * @param origin: the origin/app to delete the notification from
     * @param id: the uuid for the notification to delete
     */
    readonly delete: (origin: IDLAString, id: IDLAString) => void;

    /**
     * Notifications are not supposed to be persistent, according to spec, at
     * least for now. But we want to be able to have this behavior on B2G. Thus,
     * this method will check if the origin sending the notifications is a valid
     * registered app with a manifest or not. Hence, a webpage that has none
     * will have its notification sent and available (via Notification.get())
     * during the life time of the page.
     *
     * @param origin: Origin from which the notification is sent.
     *
     * @return boolean
     */
    readonly canPut: (origin: IDLAString) => boolean;
  }

  export interface nsIUrlClassifierUpdateObserverRef {
    readonly name: "nsIUrlClassifierUpdateObserver";
    readonly number: "{9fa11561-5816-4e1b-bcc9-b629ca05cce6}";
  }

  /**
   * The nsIUrlClassifierUpdateObserver interface is implemented by
   * clients streaming updates to the url-classifier (usually
   * nsUrlClassifierStreamUpdater.
   */
  export interface nsIUrlClassifierUpdateObserver extends nsISupports {

    /**
     * The update requested a new URL whose contents should be downloaded
     * and sent to the classifier as a new stream.
     *
     * @param url The url that was requested.
     * @param table The table name that this URL's contents will be associated
     *              with.  This should be passed back to beginStream().
     */
    readonly updateUrlRequested: (url: IDLACString, table: IDLACString) => void;

    /**
     * A stream update has completed.
     *
     * @param status The state of the update process.
     * @param delay The amount of time the updater should wait to fetch the
     *              next URL in ms.
     */
    readonly streamFinished: (status: number, delay: number) => void;

    readonly updateError: (error: number) => void;

    /**
     * The update has completed successfully.
     *
     * @param requestedTimeout The number of seconds that the caller should
     *                         wait before trying to update again.
     **/
    readonly updateSuccess: (requestedTimeout: number) => void;
  }

  export interface nsIGSettingsServiceRef {
    readonly name: "nsIGSettingsService";
    readonly number: "{849c088b-57d1-4f24-b7b2-3dc4acb04c0a}";
  }

  export interface nsIGSettingsService extends nsISupports {

    readonly getCollectionForSchema: (schema: IDLAUTF8String) => (nsIGSettingsCollection | null);
  }

  export interface nsIPrefLocalizedStringRef {
    readonly name: "nsIPrefLocalizedString";
    readonly number: "{ae419e24-1dd1-11b2-b39a-d3e5e7073802}";
  }

  /**
   * The nsIPrefLocalizedString interface is simply a wrapper interface for
   * nsISupportsString so the preferences service can have a unique identifier
   * to distinguish between requests for normal wide strings (nsISupportsString)
   * and "localized" wide strings, which get their default values from properites
   * files.
   *
   * @see nsIPrefBranch
   * @see nsISupportsString
   */
  export interface nsIPrefLocalizedString extends nsISupportsString {
  }

  export interface nsISessionStoreFunctionsRef {
    readonly name: "nsISessionStoreFunctions";
    readonly number: "{1a060fba-a19d-11e9-b7eb-580d0edd8e6f}";
  }

  export interface nsISessionStoreFunctions extends nsISupports {

    readonly UpdateSessionStore: (aBrowser: WebIDL.Element, aFlushId: number, aIsFinal: boolean, aEpoch: number, aData: IDLjsval) => void;
  }

  export interface mozIMozIntlHelperRef {
    readonly name: "mozIMozIntlHelper";
    readonly number: "{189eaa7d-b29a-43a9-b1fb-7658990df940}";
  }

  /**
   * This is an internal helper for mozIMozIntl API. There should be virtually
   * no reason for you to call this API except from mozIMozIntl implementation.
   *
   * This API helps accessing the SpiderMonkey Intl APIs, but it is mozIMozIntl
   * that exposes the thin wrapper around them that binds the functionality
   * to Gecko.
   */
  export interface mozIMozIntlHelper extends nsISupports {

    readonly addGetCalendarInfo: (intlObject: IDLjsval) => void;

    readonly addGetDisplayNames: (intlObject: IDLjsval) => void;

    readonly addGetLocaleInfo: (intlObject: IDLjsval) => void;

    /**
     * Adds a MozDateTimeFormat contructor to the given object. This function may only
     * be called once within a realm/global object: calling it multiple times will
     * throw.
     *
     * The difference between regular Intl.DateTimeFormat and the method created here
     * is that we support two more options:
     *
     *    timeStyle: full | long | medium | short
     *    dateStyle: full | long | medium | short
     *
     * which allow user to create normalized date/time style formats.
     * Additionally, when those options are used instead of the regular atomic
     * options (hour, minute, month, etc.) this code will look into host
     * Operating System regional preferences and adjust for that.
     *
     * That means that if user will manually select time format (hour12/24) or
     * adjust how the date should be displayed, MozDateTimeFormat will use that.
     *
     * This API should be used everywhere in the UI instead of regular Intl  API.
     */
    readonly addDateTimeFormatConstructor: (intlObject: IDLjsval) => void;
  }

  export interface nsICryptoHMACRef {
    readonly name: "nsICryptoHMAC";
    readonly number: "{8feb4c7c-1641-4a7b-bc6d-1964e2099497}";

    /**
     * Hashing Algorithms. These values are to be used by the |init| method to
     * indicate which hashing function to use. These values map onto the values
     * defined in mozilla/security/nss/lib/softoken/pkcs11t.h and are switched
     * to a CKM_*_HMAC constant.
     */
    MD5: 2;

    SHA1: 3;

    SHA256: 4;

    SHA384: 5;

    SHA512: 6;
  }

  /**
   * nsICryptoHMAC
   * This interface provides HMAC signature algorithms.
   */
  export interface nsICryptoHMAC extends nsISupports {

    /**
     * Initialize the hashing object. This method may be
     * called multiple times with different algorithm types.
     *
     * @param aAlgorithm the algorithm type to be used.
     *        This value must be one of the above valid
     *        algorithm types.
     *
     * @param aKeyObject
     *        Object holding a key. To create the key object use for instance:
     *        var keyObject = Components.classes["@mozilla.org/security/keyobjectfactory;1"]
     *            .getService(Components.interfaces.nsIKeyObjectFactory)
     *              .keyFromString(Components.interfaces.nsIKeyObject.HMAC, rawKeyData);
     *
     * WARNING: This approach is not FIPS compliant.
     *
     * @throws NS_ERROR_INVALID_ARG if an unsupported algorithm
     *        type is passed.
     *
     * NOTE: This method must be called before any other method on this
     *       interface is called.
     */
    readonly init: (aAlgorithm: number, aKeyObject: (nsIKeyObject | null)) => void;

    /**
     * @param aData a buffer to calculate the hash over
     *
     * @param aLen the length of the buffer |aData|
     *
     * @throws NS_ERROR_NOT_INITIALIZED If |init| has not been called.
     */
    readonly update: (aData: number[], aLen: number) => void;

    /**
     * Calculates and updates a new hash based on a given data stream.
     *
     * @param aStream an input stream to read from.
     *
     * @param aLen How much to read from the given |aStream|. Passing UINT32_MAX
     *        indicates that all data available will be used to update the hash.
     *
     * @throws NS_ERROR_NOT_INITIALIZED If |init| has not been called.
     *
     * @throws NS_ERROR_NOT_AVAILABLE If the requested amount of data to be
     *         calculated into the hash is not available.
     *
     */
    readonly updateFromStream: (aStream: (nsIInputStream | null), aLen: number) => void;

    /**
     * Completes this HMAC object and produces the actual HMAC digest data.
     *
     * @param aASCII If true then the returned value is a base64 encoded string.
     *        If false, then the returned value is binary data.
     *
     * @return a hash of the data that was read by this object.  This can
     *         be either binary data or base 64 encoded.
     *
     * @throws NS_ERROR_NOT_INITIALIZED If |init| has not been called.
     *
     * NOTE: This method may be called any time after |init|
     *       is called.  This call resets the object to its
     *       pre-init state.
     */
    readonly finish: (aASCII: boolean) => IDLACString;

    /**
     * Reinitialize HMAC context to be reused with the same settings (the key
     * and hash algorithm) but on a different set of data.
     */
    readonly reset: () => void;
  }

  export interface mozIStorageBaseStatementRef {
    readonly name: "mozIStorageBaseStatement";
    readonly number: "{16ca67aa-1325-43e2-aac7-859afd1590b2}";

    /**
     * The statement is not usable, either because it failed to initialize or
     * was explicitly finalized.
     */
    MOZ_STORAGE_STATEMENT_INVALID: 0;

    /**
     * The statement is usable.
     */
    MOZ_STORAGE_STATEMENT_READY: 1;

    /**
     * Indicates that the statement is executing and the row getters may be used.
     *
     * @note This is only relevant for mozIStorageStatement instances being used
     *       in a synchronous fashion.
     */
    MOZ_STORAGE_STATEMENT_EXECUTING: 2;
  }

  /**
   * The base interface for both pure asynchronous storage statements
   * (mozIStorageAsyncStatement) and 'classic' storage statements
   * (mozIStorageStatement) that can be used for both synchronous and asynchronous
   * purposes.
   */
  export interface mozIStorageBaseStatement extends mozIStorageBindingParams {

    /**
     * Finalizes a statement so you can successfully close a database connection.
     * Once a statement has been finalized it can no longer be used for any
     * purpose.
     *
     * Statements are implicitly finalized when their reference counts hits zero.
     * If you are a native (C++) caller this is accomplished by setting all of
     * your nsCOMPtr instances to be NULL.  If you are operating from JavaScript
     * code then you cannot rely on this behavior because of the involvement of
     * garbage collection.
     *
     * When finalizing an asynchronous statement you do not need to worry about
     * whether the statement has actually been executed by the asynchronous
     * thread; you just need to call finalize after your last call to executeAsync
     * involving the statement.  However, you do need to use asyncClose instead of
     * close on the connection if any statements have been used asynchronously.
     */
    readonly finalize: () => void;

    /**
     * Binds the array of parameters to the statement.  When executeAsync is
     * called, all the parameters in aParameters are bound and then executed.
     *
     * @param aParameters
     *        The array of parameters to bind to the statement upon execution.
     *
     * @note This is only works on statements being used asynchronously.
     */
    readonly bindParameters: (aParameters: (mozIStorageBindingParamsArray | null)) => void;

    /**
     * Creates a new mozIStorageBindingParamsArray that can be used to bind
     * multiple sets of data to a statement with bindParameters.
     *
     * @return a mozIStorageBindingParamsArray that multiple sets of parameters
     *         can be bound to.
     *
     * @note This is only useful for statements being used asynchronously.
     */
    readonly newBindingParamsArray: () => (mozIStorageBindingParamsArray | null);

    /**
     * Execute a query asynchronously using any currently bound parameters.  This
     * statement can be reused immediately, and reset does not need to be called.
     *
     * @note If you have any custom defined functions, they must be re-entrant
     *       since they can be called on multiple threads.
     *
     * @param aCallback [optional]
     *        The callback object that will be notified of progress, errors, and
     *        completion.
     * @return an object that can be used to cancel the statements execution.
     */
    readonly executeAsync: (aCallback?: (mozIStorageStatementCallback | null)) => (mozIStoragePendingStatement | null);

    /**
     * Find out whether the statement is usable (has not been finalized).
     */
    readonly state: number;

    /**
     * Escape a string for SQL LIKE search.
     *
     * @note Consumers will have to use same escape char when doing statements
     *       such as:   ...LIKE '?1' ESCAPE '/'...
     *
     * @param aValue
     *        The string to escape for SQL LIKE.
     * @param aEscapeChar
     *        The escape character.
     * @return an AString of an escaped version of aValue
     *         (%, _ and the escape char are escaped with the escape char)
     *         For example, we will convert "foo/bar_baz%20cheese"
     *         into "foo//bar/_baz/%20cheese" (if the escape char is '/').
     */
    readonly escapeStringForLIKE: (aValue: IDLAString, aEscapeChar: string) => IDLAString;
  }

  export interface nsIGfxInfoDebugRef {
    readonly name: "nsIGfxInfoDebug";
    readonly number: "{ca7b0bc7-c67c-4b79-8270-ed7ba002af08}";
  }

  export interface nsIGfxInfoDebug extends nsISupports {

    readonly spoofVendorID: (aVendorID: IDLAString) => void;

    readonly spoofDeviceID: (aDeviceID: IDLAString) => void;

    readonly spoofDriverVersion: (aDriverVersion: IDLAString) => void;

    readonly spoofOSVersion: (aVersion: number) => void;

    readonly fireTestProcess: () => void;
  }

  export interface nsIPresentationSessionRequestRef {
    readonly name: "nsIPresentationSessionRequest";
    readonly number: "{d808a084-d0f8-455a-a8df-5879e05a755b}";
  }

  export interface nsIPresentationSessionRequest extends nsISupports {

    readonly device: (nsIPresentationDevice | null);

    readonly url: IDLAString;

    readonly presentationId: IDLAString;

    readonly controlChannel: (nsIPresentationControlChannel | null);
  }

  export interface nsIFormSubmitObserverRef {
    readonly name: "nsIFormSubmitObserver";
    readonly number: "{867cb7e7-835d-408b-9788-d2834d284e03}";
  }

  export interface nsIFormSubmitObserver extends nsISupports {

    readonly notifyInvalidSubmit: (formNode: WebIDL.HTMLFormElement, invalidElements: WebIDL.Element[]) => void;
  }

  export interface nsIQuotaUsageCallbackRef {
    readonly name: "nsIQuotaUsageCallback";
    readonly number: "{c8a21a2a-17b9-4b63-ad95-e0fbcff5de18}";
  }

  type nsIQuotaUsageCallbackFunction = (aRequest: (nsIQuotaUsageRequest | null)) => void;

  export interface nsIQuotaUsageCallback extends nsISupports {

    readonly onUsageResult: (aRequest: (nsIQuotaUsageRequest | null)) => void;
  }

  export interface nsIServiceWorkerRegistrationInfoListenerRef {
    readonly name: "nsIServiceWorkerRegistrationInfoListener";
    readonly number: "{87e63548-d440-4b8a-b158-65ad1de0211e}";
  }

  export interface nsIServiceWorkerRegistrationInfoListener extends nsISupports {

    readonly onChange: () => void;
  }

  export interface nsIUrlClassifierCacheEntryRef {
    readonly name: "nsIUrlClassifierCacheEntry";
    readonly number: "{d6297907-8236-4126-adaf-c3aa239a0d40}";
  }

  /**
   * nsIUrlClassifierCacheEntry contains cache information for
   * a given prefix.
   */
  export interface nsIUrlClassifierCacheEntry extends nsISupports {

    /**
     * Prefix for this cache entry.
     */
    readonly prefix: IDLACString;

    /**
     * Negative cache expiry.
     */
    readonly expiry: number;

    /**
     * An array of nsIUrlClassifierPositiveCacheEntry, each item represents
     * a positive cache entry with its fullhash and expiry.
     */
    readonly matches: (nsIArray | null);
  }

  export interface nsIPK11TokenRef {
    readonly name: "nsIPK11Token";
    readonly number: "{51191434-1dd2-11b2-a17c-e49c4e99a4e3}";
  }

  export interface nsIPK11Token extends nsISupports {

    readonly tokenName: IDLAUTF8String;

    readonly isInternalKeyToken: boolean;

    /**
     * Manufacturer ID of the token.
     */
    readonly tokenManID: IDLAUTF8String;

    /**
     * Hardware version of the token.
     */
    readonly tokenHWVersion: IDLAUTF8String;

    /**
     * Firmware version of the token.
     */
    readonly tokenFWVersion: IDLAUTF8String;

    readonly tokenSerialNumber: IDLAUTF8String;

    readonly isLoggedIn: () => boolean;

    readonly login: (force: boolean) => void;

    readonly logoutSimple: () => void;

    readonly logoutAndDropAuthenticatedResources: () => void;

    readonly needsLogin: () => boolean;

    readonly needsUserInit: boolean;

    readonly reset: () => void;

    /**
     * Checks whether the given password is correct. Logs the token out if an
     * incorrect password is given.
     *
     * @param password The password to check.
     * @return true if the password was correct, false otherwise.
     */
    readonly checkPassword: (password: IDLAUTF8String) => boolean;

    readonly initPassword: (initialPassword: IDLAUTF8String) => void;

    readonly changePassword: (oldPassword: IDLAUTF8String, newPassword: IDLAUTF8String) => void;

    readonly hasPassword: boolean;
  }

  export interface nsIGeneralResponseDataRef {
    readonly name: "nsIGeneralResponseData";
    readonly number: "{b986773e-2b30-4ed2-b8fe-6a96631c8000}";
  }

  /**
   * The general purpose response data.
   */
  export interface nsIGeneralResponseData extends nsIPaymentResponseData {

    /**
     *  The stringified response data.
     */
    readonly data: IDLAString;

    /**
     *  The initial method for nsIGeneralResponseData.
     *  @param aData - the javascript object of the content.
     */
    readonly initData: (aData: IDLjsval) => void;
  }

  export interface nsIPermissionDelegateHandlerRef {
    readonly name: "nsIPermissionDelegateHandler";
    readonly number: "{07611dc6-bf4d-4d8a-a64b-f3a5904dddc7}";
  }

  export interface nsIPermissionDelegateHandler extends nsISupports {

    readonly maybeUnsafePermissionDelegate: (aTypes: IDLACString[]) => boolean;

    readonly permissionDelegateFPEnabled: boolean;
  }

  export interface nsIPushClearResultCallbackRef {
    readonly name: "nsIPushClearResultCallback";
    readonly number: "{bd47b38e-8bfa-4f92-834e-832a4431e05e}";
  }

  type nsIPushClearResultCallbackFunction = (status: number) => void;

  /**
   * Called by |clearForDomain|. A non-success |status| indicates that there was
   * a problem clearing subscriptions for the given domain.
   */
  export interface nsIPushClearResultCallback extends nsISupports {

    readonly onClear: (status: number) => void;
  }

  export interface nsICacheEntryDescriptorRef {
    readonly name: "nsICacheEntryDescriptor";
    readonly number: "{90b17d31-46aa-4fb1-a206-473c966cbc18}";
  }

  export interface nsICacheEntryDescriptor extends nsICacheEntryInfo {

    /**
     * Set the time at which the cache entry should be considered invalid (in
     * seconds since the Epoch).
     */
    readonly setExpirationTime: (expirationTime: number) => void;

    /**
     * Set the cache entry data size.  This will fail if the cache entry
     * IS stream based.
     */
    readonly setDataSize: (size: number) => void;

    /**
     * Open blocking input stream to cache data.  This will fail if the cache
     * entry IS NOT stream based.  Use the stream transport service to
     * asynchronously read this stream on a background thread.  The returned
     * stream MAY implement nsISeekableStream.
     *
     * @param offset
     *        read starting from this offset into the cached data.  an offset
     *        beyond the end of the stream has undefined consequences.
     *
     * @return blocking, unbuffered input stream.
     */
    readonly openInputStream: (offset: number) => (nsIInputStream | null);

    /**
     * Open blocking output stream to cache data.  This will fail if the cache
     * entry IS NOT stream based.  Use the stream transport service to
     * asynchronously write to this stream on a background thread.  The returned
     * stream MAY implement nsISeekableStream.
     *
     * If opening an output stream to existing cached data, the data will be
     * truncated to the specified offset.
     *
     * @param offset
     *        write starting from this offset into the cached data.  an offset
     *        beyond the end of the stream has undefined consequences.
     *
     * @return blocking, unbuffered output stream.
     */
    readonly openOutputStream: (offset: number) => (nsIOutputStream | null);

    /**
     * Get/set the cache data element.  This will fail if the cache entry
     * IS stream based.  The cache entry holds a strong reference to this
     * object.  The object will be released when the cache entry is destroyed.
     */
    cacheElement: (nsISupports | null);

    /**
     * Stores the Content-Length specified in the HTTP header for this
     * entry. Checked before we write to the cache entry, to prevent ever
     * taking up space in the cache for an entry that we know up front
     * is going to have to be evicted anyway. See bug 588507.
     */
    predictedDataSize: number;

    /**
     * Get the access granted to this descriptor.  See nsICache.idl for the
     * definitions of the access modes and a thorough description of their
     * corresponding meanings.
     */
    readonly accessGranted: number;

    /**
     * Get/set the storage policy of the cache entry.  See nsICache.idl for
     * the definitions of the storage policies.
     */
    storagePolicy: number;

    /**
     * Get the disk file associated with the cache entry.
     */
    readonly file: (nsIFile | null);

    /**
     * Get/set security info on the cache entry for this descriptor.  This fails
     * if the storage policy is not STORE_IN_MEMORY.
     */
    securityInfo: (nsISupports | null);

    /**
     * Get the size of the cache entry data, as stored. This may differ
     * from the entry's dataSize, if the entry is compressed.
     */
    readonly storageDataSize: number;

    /**
     * Doom the cache entry this descriptor references in order to slate it for
     * removal.  Once doomed a cache entry cannot be undoomed.
     *
     * A descriptor with WRITE access can doom the cache entry and choose to
     * fail pending requests.  This means that pending requests will not get
     * a cache descriptor.  This is meant as a tool for clients that wish to
     * instruct pending requests to skip the cache.
     */
    readonly doom: () => void;

    readonly doomAndFailPendingRequests: (status: number) => void;

    /**
     * Asynchronously doom an entry. Listener will be notified about the status
     * of the operation. Null may be passed if caller doesn't care about the
     * result.
     */
    readonly asyncDoom: (listener: (nsICacheListener | null)) => void;

    /**
     * A writer must validate this cache object before any readers are given
     * a descriptor to the object.
     */
    readonly markValid: () => void;

    /**
     *  Explicitly close the descriptor (optional).
     */
    readonly close: () => void;

    /**
     * Methods for accessing meta data.  Meta data is a table of key/value
     * string pairs.  The strings do not have to conform to any particular
     * charset, but they must be null terminated.
     */
    readonly getMetaDataElement: (key: string) => string;

    readonly setMetaDataElement: (key: string, value: string) => void;

    /**
     * Visitor will be called with key/value pair for each meta data element.
     */
    readonly visitMetaData: (visitor: (nsICacheMetaDataVisitor | null)) => void;
  }

  export interface nsIObserverServiceRef {
    readonly name: "nsIObserverService";
    readonly number: "{d07f5192-e3d1-11d2-8acd-00105a1b8860}";
  }

  /**
   * nsIObserverService
   *
   * Service allows a client listener (nsIObserver) to register and unregister for
   * notifications of specific string referenced topic. Service also provides a
   * way to notify registered listeners and a way to enumerate registered client
   * listeners.
   */
  export interface nsIObserverService extends nsISupports {

    /**
     * AddObserver
     *
     * Registers a given listener for a notifications regarding the specified
     * topic.
     *
     * @param anObserve : The interface pointer which will receive notifications.
     * @param aTopic    : The notification topic or subject.
     * @param ownsWeak  : If set to false, the nsIObserverService will hold a
     *                    strong reference to |anObserver|.  If set to true and
     *                    |anObserver| supports the nsIWeakReference interface,
     *                    a weak reference will be held.  Otherwise an error will be
     *                    returned.
     */
    readonly addObserver: (anObserver: (nsIObserver | nsIObserverFunction | null), aTopic: string, ownsWeak?: boolean) => void;

    /**
     * removeObserver
     *
     * Unregisters a given listener from notifications regarding the specified
     * topic.
     *
     * @param anObserver : The interface pointer which will stop recieving
     *                     notifications.
     * @param aTopic     : The notification topic or subject.
     */
    readonly removeObserver: (anObserver: (nsIObserver | nsIObserverFunction | null), aTopic: string) => void;

    /**
     * notifyObservers
     *
     * Notifies all registered listeners of the given topic.
     *
     * @param aSubject : Notification specific interface pointer.
     * @param aTopic   : The notification topic or subject.
     * @param someData : Notification specific wide string.
     */
    readonly notifyObservers: (aSubject: (nsISupports | null), aTopic: string, someData?: string) => void;

    /**
     * enumerateObservers
     *
     * Returns an enumeration of all registered listeners.
     *
     * @param aTopic   : The notification topic or subject.
     */
    readonly enumerateObservers: (aTopic: string) => (nsISimpleEnumerator | null);
  }

  export interface nsIPaymentAddressRef {
    readonly name: "nsIPaymentAddress";
    readonly number: "{49a02241-7e48-477a-9345-9f246925dcb3}";
  }

  export interface nsIPaymentAddress extends nsISupports {

    readonly country: IDLAString;

    readonly addressLine: (nsIArray | null);

    readonly region: IDLAString;

    readonly regionCode: IDLAString;

    readonly city: IDLAString;

    readonly dependentLocality: IDLAString;

    readonly postalCode: IDLAString;

    readonly sortingCode: IDLAString;

    readonly organization: IDLAString;

    readonly recipient: IDLAString;

    readonly phone: IDLAString;

    readonly init: (aCountry: IDLAString, aAddressLine: (nsIArray | null), aRegion: IDLAString, aRegionCode: IDLAString, aCity: IDLAString, aDependentLocality: IDLAString, aPostalCode: IDLAString, aSortingCode: IDLAString, aOrganization: IDLAString, aRecipient: IDLAString, aPhone: IDLAString) => void;
  }

  export interface nsINSSErrorsServiceRef {
    readonly name: "nsINSSErrorsService";
    readonly number: "{12f60021-e14b-4020-99d1-ed2c795be66a}";

    ERROR_CLASS_SSL_PROTOCOL: 1;

    ERROR_CLASS_BAD_CERT: 2;

    /**
     *  The following values define the range of NSPR error codes used by NSS.
     *  NSS remains the authorative source for these numbers, as a result,
     *  the values might change in the future.
     *  The security module will perform a runtime check and assertion
     *  to ensure the values are in synch with NSS.
     */
    NSS_SEC_ERROR_BASE: -8192;

    NSS_SEC_ERROR_LIMIT: -7192;

    NSS_SSL_ERROR_BASE: -12288;

    NSS_SSL_ERROR_LIMIT: -11288;

    /**
     * The error codes within each module must fit in 16 bits. We want these
     * errors to fit in the same module as the NSS errors but not overlap with
     * any of them. Converting an NSS SEC, NSS SSL, or mozilla::pkix error to
     * an NS error involves negating the value of the error and then
     * synthesizing an error in the NS_ERROR_MODULE_SECURITY module. Hence,
     * mozilla::pkix errors will start at a negative value that both doesn't
     * overlap with the current value ranges for NSS errors and that will fit
     * in 16 bits when negated.
     *
     * Keep these in sync with pkixnss.h.
     */
    MOZILLA_PKIX_ERROR_BASE: -16384;

    MOZILLA_PKIX_ERROR_LIMIT: -15384;
  }

  export interface nsINSSErrorsService extends nsISupports {

    /**
     *  @param aNSPRCode An error code obtained using PR_GetError()
     *  @return True if it is error code defined by the NSS library
     */
    readonly isNSSErrorCode: (aNSPRCode: number) => boolean;

    /**
     *  Function will fail if aNSPRCode is not an NSS error code.
     *  @param aNSPRCode An error code obtained using PR_GetError()
     *  @return The result of the conversion, an XPCOM error code
     */
    readonly getXPCOMFromNSSError: (aNSPRCode: number) => number;

    /**
     *  Function will fail if aXPCOMErrorCode is not an NSS error code.
     *  @param aXPCOMErrorCode An error code obtained using getXPCOMFromNSSError
     *  return A localized human readable error explanation.
     */
    readonly getErrorMessage: (aXPCOMErrorCode: number) => IDLAString;

    /**
     *  Function will fail if aXPCOMErrorCode is not an NSS error code.
     *  @param aXPCOMErrorCode An error code obtained using getXPCOMFromNSSError
     *  return the error class of the code, either ERROR_CLASS_BAD_CERT
     *         or ERROR_CLASS_SSL_PROTOCOL
     */
    readonly getErrorClass: (aXPCOMErrorCode: number) => number;
  }

  export interface nsICacheEntryMetaDataVisitorRef {
    readonly name: "nsICacheEntryMetaDataVisitor";
    readonly number: "{fea3e276-6ba5-4ceb-a581-807d1f43f6d0}";
  }

  export interface nsICacheEntryMetaDataVisitor extends nsISupports {

    /**
     * Argument for nsICacheEntry.visitMetaData, provides access to all metadata
     * keys and values stored on the entry.
     */
    /**
     * Called over each key / value pair.
     */
    readonly onMetaDataElement: (key: string, value: string) => void;
  }

  export interface nsICycleCollectorLogSinkRef {
    readonly name: "nsICycleCollectorLogSink";
    readonly number: "{3ad9875f-d0e4-4ac2-87e3-f127f6c02ce1}";
  }

  /**
   * This interface allows replacing the log-writing backend for an
   * nsICycleCollectorListener.  As this interface is also called while
   * the cycle collector is running, it cannot be implemented in JS.
   */
  export interface nsICycleCollectorLogSink extends nsISupports {

    readonly closeGCLog: () => void;

    readonly closeCCLog: () => void;

    filenameIdentifier: IDLAString;

    processIdentifier: number;

    readonly gcLog: (nsIFile | null);

    readonly ccLog: (nsIFile | null);
  }

  export interface nsIConverterInputStreamRef {
    readonly name: "nsIConverterInputStream";
    readonly number: "{fc66ffb6-5404-4908-a4a3-27f92fa0579d}";

    /**
     * Default replacement char value, U+FFFD REPLACEMENT CHARACTER.
     */
    DEFAULT_REPLACEMENT_CHARACTER: 65533;

    /**
     * Special replacement character value that requests errors to
     * be treated as fatal.
     */
    ERRORS_ARE_FATAL: 0;
  }

  /**
   * A unichar input stream that wraps an input stream.
   * This allows reading unicode strings from a stream, automatically converting
   * the bytes from a selected character encoding.
   */
  export interface nsIConverterInputStream extends nsIUnicharInputStream {

    /**
     * Initialize this stream.
     * @param aStream
     *        The underlying stream to read from.
     * @param aCharset
     *        The character encoding to use for converting the bytes of the
     *        stream. A null charset will be interpreted as UTF-8.
     * @param aBufferSize
     *        How many bytes to buffer.
     * @param aReplacementChar
     *        The character to replace unknown byte sequences in the stream
     *        with. The standard replacement character is U+FFFD.
     *        A value of 0x0000 will cause an exception to be thrown if unknown
     *        byte sequences are encountered in the stream.
     */
    readonly init: (aStream: (nsIInputStream | null), aCharset: string, aBufferSize: number, aReplacementChar: number) => void;
  }

  export interface nsPISocketTransportServiceRef {
    readonly name: "nsPISocketTransportService";
    readonly number: "{18f73bf1-b35b-4b7b-aa9a-11bcbdbc389c}";
  }

  /**
   * This is a private interface used by the internals of the networking library.
   * It will never be frozen.  Do not use it in external code.
   */
  export interface nsPISocketTransportService extends nsIRoutedSocketTransportService {

    /**
     * init/shutdown routines.
     */
    readonly init: () => void;

    readonly shutdown: (aXpcomShutdown: boolean) => void;

    /**
     * controls the TCP sender window clamp
     */
    readonly sendBufferSize: number;

    /**
     * Controls whether the socket transport service is offline.
     * Setting it offline will cause non-local socket detachment.
     */
    offline: boolean;

    /**
     * Controls the default timeout (in seconds) for sending keepalive probes.
     */
    readonly keepaliveIdleTime: number;

    /**
     * Controls the default interval (in seconds) between retrying keepalive probes.
     */
    readonly keepaliveRetryInterval: number;

    /**
     * Controls the default retransmission count for keepalive probes.
     */
    readonly keepaliveProbeCount: number;
  }

  export interface nsIQuotaOriginUsageResultRef {
    readonly name: "nsIQuotaOriginUsageResult";
    readonly number: "{96df03d2-116a-493f-bb0b-118c212a6b32}";
  }

  export interface nsIQuotaOriginUsageResult extends nsISupports {

    readonly usage: number;

    readonly fileUsage: number;
  }

  export interface nsIOSKeyStoreRef {
    readonly name: "nsIOSKeyStore";
    readonly number: "{57972956-5718-42d2-8070-b3fc72212eaf}";
  }

  export interface nsIOSKeyStore extends nsISupports {

    /**
     * This interface provides encryption and decryption operations for data at
     * rest. The key used to encrypt and decrypt the data is stored in the OS
     * key store.
     *
     * Usage:
     *
     * // obtain the singleton OSKeyStore instance
     * const oskeystore = Cc["@mozilla.org/security/oskeystore;1"].getService(Ci.nsIOSKeyStore);
     *
     * const PASSWORD_LABEL = "mylabel1";
     * const COOKIE_LABEL = "mylabel2";
     *
     * // Unlock the key store.
     * // Note that this is not necesssary. The key store will be unlocked
     * // automatically when an operation is performed on it.
     * await oskeystore.asyncUnlock();
     *
     * // Check if there's a secret for your label already.
     * if (!await oskeystore.asyncSecretAvailable(PASSWORD_LABEL)) {
     *   // Fail or generate a new secret for your label.
     *   // If you want to generate a new secret, do.
     *   // Hold onto `recoveryPhrase` to present to the user.
     *   let recoveryPhrase = await oskeystore.asyncGenerateSecret(PASSWORD_LABEL);
     * }
     *
     * // Assuming there's a secret with your label. Encrypt/Decrypt as follows.
     * let encryptedPasswordBytes = await oskeystore.asyncEncryptBytes(PASSWORD_LABEL, passwordBytes);
     * let newPasswordBytes = await oskeystore.asyncDecryptBytes(PASSWORD_LABEL, encryptedPasswordBytes);
     *
     * // Delete the secret from the key store.
     * await oskeystore.asyncDeleteSecret(PASSWORD_LABEL);
     *
     * // Recover a secret from a recovery code.
     * await oskeystore.asyncRecoverSecret(PASSWORD_LABEL, recoveryPhrase);
     *
     * // Lock the key store to prompt the user to log into her OS key store again.
     * await oskeystore.asyncLock();
     */
    /**
     * Generate a new secret and store it in the OS key store with the given label.
     * The caller should make sure that no other secrets with the same label are
     * present before calling this function.
     * This invalidates all previous ciphertexts created with the key
     * corresponding to the given label.
     *
     * @param label The label to use for the secret.
     * @return Promise that resolves to the recoveryPhrase string used to generate
     *         the secret.
     */
    readonly asyncGenerateSecret: (label: IDLACString) => IDLPromise;

    /**
     * Check whether a secret for a given label exists.
     *
     * @param label The label to lookup.
     * @return Promise that resolves to a bool (whether a secret with label is
     *         known or not) or an error.
     */
    readonly asyncSecretAvailable: (label: IDLACString) => IDLPromise;

    /**
     * Set a secret from a given recovery phrase.
     * This might not be implemented on all platforms.
     * This invalidates all previous ciphertexts.
     *
     * @param label The label to use for the secret.
     * @param recoveryPhrase The recovery phrase that's used to generate the secret.
     * @return Promise that resolves to undefined or an error.
     */
    readonly asyncRecoverSecret: (label: IDLACString, recoveryPhrase: IDLACString) => IDLPromise;

    /**
     * Delete secret with a given label. If there is no secret with the given
     * label, no action is taken.
     *
     * @param label The label of the secret to delete.
     * @return Promise that resolves to undefined or an error.
     */
    readonly asyncDeleteSecret: (label: IDLACString) => IDLPromise;

    /**
     * Encrypt the given data and then return the result as a base64-encoded
     * string.
     *
     * @param label The label of the key to use to encrypt.
     * @param inBytes The bytes to encrypt.
     * @return Promise resolving to the encrypted text, encoded as Base64, or an
     *         error.
     */
    readonly asyncEncryptBytes: (label: IDLACString, inBytes: number[]) => IDLPromise;

    /**
     * Decode and then decrypt the given base64-encoded string.
     *
     * @param label The label of the key to use to decrypt.
     * @param encryptedBase64Text Encrypted input text, encoded as Base64.
     * @return Promise resolving to the plaintext bytes or an error.
     */
    readonly asyncDecryptBytes: (label: IDLACString, encryptedBase64Text: IDLACString) => IDLPromise;

    /**
     * Lock the key store.
     * The actual behaviour of this depends on the OS.
     *
     * @return Promise resolving to undefined or an error.
     */
    readonly asyncLock: () => IDLPromise;

    /**
     * Unlock the key store.
     * The actual behaviour of this depends on the OS.
     *
     * @return Promise resolving to undefined or an error.
     */
    readonly asyncUnlock: () => IDLPromise;

    /**
     * Check if the implementation is using the NSS key store.
     * This is a special case because Firefox has to handle the locking and
     * unlocking.
     */
    readonly isNSSKeyStore: boolean;
  }

  export interface nsIQuotaRequestRef {
    readonly name: "nsIQuotaRequest";
    readonly number: "{22890e3e-ff25-4372-9684-d901060e2f6c}";
  }

  export interface nsIQuotaRequest extends nsIQuotaRequestBase {

    readonly result: (nsIVariant | null);

    callback: (nsIQuotaCallback | null);
  }

  export interface nsITransferableRef {
    readonly name: "nsITransferable";
    readonly number: "{97e0c418-1c1e-4106-bad1-9fcb11dff2fe}";
  }

  /**
   * nsIFlavorDataProvider allows a flavor to 'promise' data later,
   * supplying the data lazily.
   *
   * To use it, call setTransferData, passing the flavor string,
   * a nsIFlavorDataProvider QI'd to nsISupports, and a data size of 0.
   *
   * When someone calls getTransferData later, if the data size is
   * stored as 0, the nsISupports will be QI'd to nsIFlavorDataProvider,
   * and its getFlavorData called.
   *
   */
  export interface nsITransferable extends nsISupports {

    /**
     * Initializes a transferable object.  This should be called on all
     * transferable objects.  Failure to do so will result in fatal assertions in
     * debug builds.
     *
     * The load context is used to track whether the transferable is storing privacy-
     * sensitive information.  For example, we try to delete data that you copy
     * to the clipboard when you close a Private Browsing window.
     *
     * To get the appropriate load context in Javascript callers, one needs to get
     * to the document that the transferable corresponds to, and then get the load
     * context from the document like this:
     *
     * var loadContext = doc.defaultView.docShell
     *                                  .QueryInterface(Ci.nsILoadContext);
     *
     * In C++ callers, if you have the corresponding document, you can just call
     * Document::GetLoadContext to get to the load context object.
     *
     * @param aContext the load context associated with the transferable object.
     *        This can be set to null if a load context is not available.
     */
    readonly init: (aContext: (nsILoadContext | null)) => void;

    /**
     * Computes a list of flavors that the transferable can export, either
     * through intrinsic knowledge or output data converters.
     */
    readonly flavorsTransferableCanExport: () => IDLACString[];

    /**
     * Given a flavor retrieve the data.
     *
     * @param  aFlavor (in parameter) the flavor of data to retrieve
     * @param  aData the data. Some variant of class in nsISupportsPrimitives.idl
     */
    readonly getTransferData: (aFlavor: string, aData: Out<(nsISupports | null)>) => void;

    /**
     * Returns the best flavor in the transferable, given those that have
     * been added to it with |AddFlavor()|
     *
     * @param  aFlavor (out parameter) the flavor of data that was retrieved
     * @param  aData the data. Some variant of class in nsISupportsPrimitives.idl
     */
    readonly getAnyTransferData: (aFlavor: Out<IDLACString>, aData: Out<(nsISupports | null)>) => void;

    /**
     * Computes a list of flavors that the transferable can
     * accept into it, either through intrinsic knowledge or input data converters.
     *
     */
    readonly flavorsTransferableCanImport: () => IDLACString[];

    /**
     * Sets the data in the transferable with the specified flavor. The transferable
     * will maintain its own copy the data, so it is not necessary to do that beforehand.
     *
     * @param  aFlavor the flavor of data that is being set
     * @param  aData the data, either some variant of class in nsISupportsPrimitives.idl,
     *         an nsIFile, or an nsIFlavorDataProvider (see above)
     * @param  aDataLen the length of the data, or 0 if passing a nsIFlavorDataProvider
     */
    readonly setTransferData: (aFlavor: string, aData: (nsISupports | null)) => void;

    /**
     * Add the data flavor, indicating that this transferable
     * can receive this type of flavor
     *
     * @param  aDataFlavor a new data flavor to handle
     */
    readonly addDataFlavor: (aDataFlavor: string) => void;

    /**
     * Removes the data flavor matching the given one (string compare) and the data
     * that goes along with it.
     *
     * @param  aDataFlavor a data flavor to remove
     */
    readonly removeDataFlavor: (aDataFlavor: string) => void;

    converter: (nsIFormatConverter | null);
  }

  export interface nsIInputStreamChannelRef {
    readonly name: "nsIInputStreamChannel";
    readonly number: "{ea730238-4bfd-4015-8489-8f264d05b343}";
  }

  /**
   * nsIInputStreamChannel
   *
   * This interface provides methods to initialize an input stream channel.
   * The input stream channel serves as a data pump for an input stream.
   */
  export interface nsIInputStreamChannel extends nsISupports {

    /**
     * Sets the URI for this channel.  This must be called before the
     * channel is opened, and it may only be called once.
     */
    readonly setURI: (aURI: (nsIURI | null)) => void;

    /**
     * Get/set the content stream
     *
     * This stream contains the data that will be pushed to the channel's
     * stream listener.  If the stream is non-blocking and supports the
     * nsIAsyncInputStream interface, then the stream will be read directly.
     * Otherwise, the stream will be read on a background thread.
     *
     * This attribute must be set before the channel is opened, and it may
     * only be set once.
     *
     * @throws NS_ERROR_IN_PROGRESS if the setter is called after the channel
     * has been opened.
     */
    contentStream: (nsIInputStream | null);

    /**
     * Get/set the srcdoc data string.  When the input stream channel is
     * created to load a srcdoc iframe, this is set to hold the value of the
     * srcdoc attribute.
     *
     * This should be the same value used to create contentStream, but this is
     * not checked.
     *
     * Changing the value of this attribute will not otherwise affect the
     * functionality of the channel or input stream.
     */
    srcdocData: IDLAString;

    /**
     * Returns true if srcdocData has been set within the channel.
     */
    readonly isSrcdocChannel: boolean;

    /**
     * The base URI to be used for the channel.  Used when the base URI cannot
     * be inferred by other means, for example when this is a srcdoc channel.
     */
    baseURI: (nsIURI | null);
  }

  export interface nsINetworkInterceptControllerRef {
    readonly name: "nsINetworkInterceptController";
    readonly number: "{70d2b4fe-a552-48cd-8d93-1d8437a56b53}";
  }

  /**
   * Interface to allow consumers to attach themselves to a channel's
   * notification callbacks/loadgroup and determine if a given channel
   * request should be intercepted before any network request is initiated.
   */
  export interface nsINetworkInterceptController extends nsISupports {

    /**
     * Returns true if a channel should avoid initiating any network
     * requests until specifically instructed to do so.
     *
     * @param aURI The URI to be loaded.  Note, this may differ from
     *             the channel's current URL in some cases.
     * @param aChannel The channel that may be intercepted.  It will
     *                 be in the state prior to calling OnStartRequest().
     */
    readonly shouldPrepareForIntercept: (aURI: (nsIURI | null), aChannel: (nsIChannel | null)) => boolean;

    /**
     * Notification when a given intercepted channel is prepared to accept a synthesized
     * response via the provided stream.
     *
     * @param aChannel the controlling interface for a channel that has been intercepted
     */
    readonly channelIntercepted: (aChannel: (nsIInterceptedChannel | null)) => void;
  }

  export interface nsIThreadInternalRef {
    readonly name: "nsIThreadInternal";
    readonly number: "{a3a72e5f-71d9-4add-8f30-59a78fb6d5eb}";
  }

  /**
   * The XPCOM thread object implements this interface, which allows a consumer
   * to observe dispatch activity on the thread.
   */
  export interface nsIThreadInternal extends nsIThread {
  }

  export interface mozIStorageStatementRef {
    readonly name: "mozIStorageStatement";
    readonly number: "{5f567c35-6c32-4140-828c-683ea49cfd3a}";

    /**
     * Execute a query, using any currently-bound parameters.  Reset is called
     * when no more data is returned.  This method is only available to JavaScript
     * consumers.
     *
     * @deprecated As of Mozilla 1.9.2 in favor of executeStep().
     *
     * @return a boolean indicating whether there are more rows or not.
     *
     * [deprecated] boolean step();
     */
    /**
     * Obtains the current list of named parameters, which are settable.  This
     * property is only available to JavaScript consumers.
     *
     * readonly attribute mozIStorageStatementParams params;
     */
    /**
     * Obtains the current row, with access to all the data members by name.  This
     * property is only available to JavaScript consumers.
     *
     * readonly attribute mozIStorageStatementRow row;
     */
    /**
     * These type values are returned by getTypeOfIndex
     * to indicate what type of value is present at
     * a given column.
     */
    VALUE_TYPE_NULL: 0;

    VALUE_TYPE_INTEGER: 1;

    VALUE_TYPE_FLOAT: 2;

    VALUE_TYPE_TEXT: 3;

    VALUE_TYPE_BLOB: 4;
  }

  /**
   * A SQL statement that can be used for both synchronous and asynchronous
   * purposes.
   */
  export interface mozIStorageStatement extends mozIStorageBaseStatement {

    /**
     * Create a clone of this statement, by initializing a new statement
     * with the same connection and same SQL statement as this one.  It
     * does not preserve statement state; that is, if a statement is
     * being executed when it is cloned, the new statement will not be
     * executing.
     */
    readonly clone: () => (mozIStorageStatement | null);

    readonly parameterCount: number;

    /**
     * Name of nth parameter, if given
     */
    readonly getParameterName: (aParamIndex: number) => IDLAUTF8String;

    /**
     * Returns the index of the named parameter.
     *
     * @param aName
     *        The name of the parameter you want the index for.  This does not
     *        include the leading ':'.
     * @return the index of the named parameter.
     */
    readonly getParameterIndex: (aName: IDLAUTF8String) => number;

    /**
     * Number of columns returned
     */
    readonly columnCount: number;

    /**
     * Name of nth column
     */
    readonly getColumnName: (aColumnIndex: number) => IDLAUTF8String;

    /**
     * Obtains the index of the column with the specified name.
     *
     * @param aName
     *        The name of the column.
     * @return The index of the column with the specified name.
     */
    readonly getColumnIndex: (aName: IDLAUTF8String) => number;

    /**
     * Reset parameters/statement execution
     */
    readonly reset: () => void;

    /**
     * Execute the query, ignoring any results.  This is accomplished by
     * calling executeStep() once, and then calling reset().
     *
     * Error and last insert info, etc. are available from
     * the mozStorageConnection.
     */
    readonly execute: () => void;

    /**
     * Execute a query, using any currently-bound parameters.  Reset
     * must be called on the statement after the last call of
     * executeStep.
     *
     * @return a boolean indicating whether there are more rows or not;
     *         row data may be accessed using mozIStorageValueArray methods on
     *         the statement.
     */
    readonly executeStep: () => boolean;

    /**
     * The number of entries in the array (each corresponding to a column in the
     * database row)
     */
    readonly numEntries: number;

    /**
     * Indicate the data type of the current result row for the the given column.
     * SQLite will perform type conversion if you ask for a value as a different
     * type than it is stored as.
     *
     * @param aIndex
     *        0-based column index.
     * @return The type of the value at the given column index; one of
     *         VALUE_TYPE_NULL, VALUE_TYPE_INTEGER, VALUE_TYPE_FLOAT,
     *         VALUE_TYPE_TEXT, VALUE_TYPE_BLOB.
     */
    readonly getTypeOfIndex: (aIndex: number) => number;

    /**
     * Retrieve the contents of a column from the current result row as a
     * variant.
     *
     * @param aIndex
     *        0-based colummn index.
     * @return A variant with the type of the column value.
     */
    readonly getVariant: (aIndex: number) => (nsIVariant | null);

    /**
     * Retrieve the contents of a column from the current result row as an
     * integer.
     *
     * @param aIndex
     *        0-based colummn index.
     * @return Column value interpreted as an integer per type conversion rules.
     * @{
     */
    readonly getInt32: (aIndex: number) => number;

    readonly getInt64: (aIndex: number) => number;

    /** @} */
    /**
     * Retrieve the contents of a column from the current result row as a
     * floating point double.
     *
     * @param aIndex
     *        0-based colummn index.
     * @return Column value interpreted as a double per type conversion rules.
     */
    readonly getDouble: (aIndex: number) => number;

    /**
     * Retrieve the contents of a column from the current result row as a
     * string.
     *
     * @param aIndex
     *        0-based colummn index.
     * @return The value for the result column interpreted as a string.  If the
     *         stored value was NULL, you will get an empty string with IsVoid set
     *         to distinguish it from an explicitly set empty string.
     * @{
     */
    readonly getUTF8String: (aIndex: number) => IDLAUTF8String;

    readonly getString: (aIndex: number) => IDLAString;

    /** @} */
    /**
     * Retrieve the contents of a column from the current result row as a
     * blob.
     *
     * @param aIndex
     *        0-based colummn index.
     * @param[out] aDataSize
     *             The number of bytes in the blob.
     * @param[out] aData
     *             The contents of the BLOB.  This will be NULL if aDataSize == 0.
     */
    readonly getBlob: (aIndex: number, aDataSize: Out<number>) => void;

    /**
     * Retrieve the contents of a Blob column from the current result row as a
     * string.
     *
     * @param aIndex
     *        0-based colummn index.
     * @return The value for the result Blob column interpreted as a String.
     *         No encoding conversion is performed.
     */
    readonly getBlobAsString: (aIndex: number) => IDLAString;

    /**
     * Retrieve the contents of a Blob column from the current result row as a
     * UTF8 string.
     *
     * @param aIndex
     *        0-based colummn index.
     * @return The value for the result Blob column interpreted as a UTF8 String.
     *         No encoding conversion is performed.
     */
    readonly getBlobAsUTF8String: (aIndex: number) => IDLAUTF8String;

    /**
     * Check whether the given column in the current result row is NULL.
     *
     * @param aIndex
     *        0-based colummn index.
     * @return true if the value for the result column is null.
     */
    readonly getIsNull: (aIndex: number) => boolean;
  }

  export interface mozIStorageErrorRef {
    readonly name: "mozIStorageError";
    readonly number: "{1f350f96-7023-434a-8864-40a1c493aac1}";

    /**
     * General SQL error or missing database.
     */
    ERROR: 1;

    /**
     * Internal logic error.
     */
    INTERNAL: 2;

    /**
     * Access permission denied.
     */
    PERM: 3;

    /**
     * A callback routine requested an abort.
     */
    ABORT: 4;

    /**
     * The database file is locked.
     */
    BUSY: 5;

    /**
     * A table in the database is locked.
     */
    LOCKED: 6;

    /**
     * An allocation failed.
     */
    NOMEM: 7;

    /**
     * Attempt to write to a readonly database.
     */
    READONLY: 8;

    /**
     * Operation was terminated by an interrupt.
     */
    INTERRUPT: 9;

    /**
     * Some kind of disk I/O error occurred.
     */
    IOERR: 10;

    /**
     * The database disk image is malformed.
     */
    CORRUPT: 11;

    /**
     * An insertion failed because the database is full.
     */
    FULL: 13;

    /**
     * Unable to open the database file.
     */
    CANTOPEN: 14;

    /**
     * The database is empty.
     */
    EMPTY: 16;

    /**
     * The database scheme changed.
     */
    SCHEMA: 17;

    /**
     * A string or blob exceeds the size limit.
     */
    TOOBIG: 18;

    /**
     * Abort due to a constraint violation.
     */
    CONSTRAINT: 19;

    /**
     * Data type mismatch.
     */
    MISMATCH: 20;

    /**
     * Library used incorrectly.
     */
    MISUSE: 21;

    /**
     * Uses OS features not supported on the host system.
     */
    NOLFS: 22;

    /**
     * Authorization denied.
     */
    AUTH: 23;

    /**
     * Auxiliary database format error.
     */
    FORMAT: 24;

    /**
     * Attempt to bind a parameter using an out-of-range index or nonexistent
     * named parameter name.
     */
    RANGE: 25;

    /**
     * File opened that is not a database file.
     */
    NOTADB: 26;
  }

  export interface mozIStorageError extends nsISupports {

    /**
     * Indicates what type of error occurred.
     */
    readonly result: number;

    /**
     * An error string the gives more details, if available.
     */
    readonly message: IDLAUTF8String;
  }

  export interface nsIXPCComponents_utils_SandboxRef {
    readonly name: "nsIXPCComponents_utils_Sandbox";
    readonly number: "{4f8ae0dc-d266-4a32-875b-6a9de71a8ce9}";
  }

  /**
   * interface of object returned by Components.utils.Sandbox.
   */
  export interface nsIXPCComponents_utils_Sandbox extends nsISupports {
  }

  export interface mozIExtensionProcessScriptJSMRef {
    readonly name: "mozIExtensionProcessScriptJSM";
    readonly number: "{9f2a6434-f0ef-4063-ae33-368d929805d2}";
  }

  export interface mozIExtensionProcessScriptJSM extends nsISupports {

    readonly ExtensionProcessScript: (mozIExtensionProcessScript | null);
  }

  export interface nsIEditorObserverRef {
    readonly name: "nsIEditorObserver";
    readonly number: "{f3ee57a6-890c-4ce0-a584-8a84bba0292e}";
  }

  /**
   * nsIEditorObserver is the interface used by applications wishing to be
   * notified when the editor has completed a user action.
   * Note that when you want to use this from C++, please check if EditorBase
   * can treat your class directly since using this interface may make editor
   * slower.
   */
  export interface nsIEditorObserver extends nsISupports {

    /**
     * Called after the editor completes a user action.
     */
    readonly EditAction: () => void;
  }

  export interface nsICaptivePortalServiceRef {
    readonly name: "nsICaptivePortalService";
    readonly number: "{bdbe0555-fc3d-4f7b-9205-c309ceb2d641}";

    UNKNOWN: 0;

    NOT_CAPTIVE: 1;

    UNLOCKED_PORTAL: 2;

    LOCKED_PORTAL: 3;
  }

  /**
   * Service used for captive portal detection.
   * The service is only active in the main process. It is also available in the
   * content process, but only to mirror the captive portal state from the main
   * process.
   */
  export interface nsICaptivePortalService extends nsISupports {

    /**
     * Called from XPCOM to trigger a captive portal recheck.
     * A network request will only be performed if no other checks are currently
     * ongoing.
     * Will not do anything if called in the content process.
     */
    readonly recheckCaptivePortal: () => void;

    /**
     * Returns the state of the captive portal.
     */
    readonly state: number;

    /**
     * Returns the time difference between NOW and the last time a request was
     * completed in milliseconds.
     */
    readonly lastChecked: number;
  }

  export interface nsIWindowlessBrowserRef {
    readonly name: "nsIWindowlessBrowser";
    readonly number: "{abb46f48-abfc-41bf-aa9a-7feccefcf977}";
  }

  /**
   * This interface represents a nsIWebBrowser instance with no associated OS
   * window. Its main function is to manage the lifetimes of those windows.
   * A strong reference to this object must be held until the window is
   * ready to be destroyed.
   */
  export interface nsIWindowlessBrowser extends nsIWebNavigation {

    /**
     * "Closes" the windowless browser and destroys its associated nsIWebBrowser
     * and docshell.
     *
     * This method *must* be called for every windowless browser before its last
     * reference is released.
     */
    readonly close: () => void;

    /**
     * Get the docshell for this browser.  This is the docshell that gets
     * navigated when the browser's nsIWebNavigation interface is used.
     */
    readonly docShell: (nsIDocShell | null);
  }

  export interface nsIDomainSetRef {
    readonly name: "nsIDomainSet";
    readonly number: "{665c981b-0a0f-4229-ac06-a826e02d4f69}";
  }

  export interface nsIDomainSet extends nsISupports {

    readonly add: (aDomain: (nsIURI | null)) => void;

    readonly remove: (aDomain: (nsIURI | null)) => void;

    readonly clear: () => void;

    readonly contains: (aDomain: (nsIURI | null)) => boolean;

    readonly containsSuperDomain: (aDomain: (nsIURI | null)) => boolean;
  }

  export interface nsINamedRef {
    readonly name: "nsINamed";
    readonly number: "{0c5fe7de-7e83-4d0d-a8a6-4a6518b9a7b3}";
  }

  /**
   * Represents an object with a name, such as a runnable or a timer.
   */
  export interface nsINamed extends nsISupports {

    readonly name: IDLAUTF8String;
  }

  export interface nsIHttpChannelInternalRef {
    readonly name: "nsIHttpChannelInternal";
    readonly number: "{4e28263d-1e03-46f4-aa5c-9512f91957f9}";

    /**
     * This flag is set to force relevant cookies to be sent with this load
     * even if normally they wouldn't be.
     */
    THIRD_PARTY_FORCE_ALLOW: 1;

    CORS_MODE_SAME_ORIGIN: 0;

    CORS_MODE_NO_CORS: 1;

    CORS_MODE_CORS: 2;

    CORS_MODE_NAVIGATE: 3;

    REDIRECT_MODE_FOLLOW: 0;

    REDIRECT_MODE_ERROR: 1;

    REDIRECT_MODE_MANUAL: 2;

    FETCH_CACHE_MODE_DEFAULT: 0;

    FETCH_CACHE_MODE_NO_STORE: 1;

    FETCH_CACHE_MODE_RELOAD: 2;

    FETCH_CACHE_MODE_NO_CACHE: 3;

    FETCH_CACHE_MODE_FORCE_CACHE: 4;

    FETCH_CACHE_MODE_ONLY_IF_CACHED: 5;
  }

  /**
   * Dumping ground for http.  This interface will never be frozen.  If you are
   * using any feature exposed by this interface, be aware that this interface
   * will change and you will be broken.  You have been warned.
   */
  export interface nsIHttpChannelInternal extends nsISupports {

    /**
     * An http channel can own a reference to the document URI
     */
    documentURI: (nsIURI | null);

    /**
     * Get the major/minor version numbers for the request
     */
    readonly getRequestVersion: (major: Out<number>, minor: Out<number>) => void;

    /**
     * Get the major/minor version numbers for the response
     */
    readonly getResponseVersion: (major: Out<number>, minor: Out<number>) => void;

    /**
     * Helper method to set a cookie with a consumer-provided
     * cookie header, _but_ using the channel's other information
     * (URI's, prompters, date headers etc).
     *
     * @param aCookieHeader
     *        The cookie header to be parsed.
     */
    readonly setCookie: (aCookieHeader: IDLACString) => void;

    /**
     * Setup this channel as an application cache fallback channel.
     */
    readonly setupFallbackChannel: (aFallbackKey: string) => void;

    /**
     * When set, these flags modify the algorithm used to decide whether to
     * send 3rd party cookies for a given channel.
     */
    thirdPartyFlags: number;

    /**
     * This attribute was added before the "flags" above and is retained here
     * for compatibility. When set to true, has the same effect as
     * THIRD_PARTY_FORCE_ALLOW, described above.
     */
    forceAllowThirdPartyCookie: boolean;

    /**
     * External handlers may set this to true to notify the channel
     * that it is open on behalf of a download.
     */
    channelIsForDownload: boolean;

    /**
     * The local IP address to which this channel is bound, in the
     * format produced by PR_NetAddrToString. May be IPv4 or IPv6.
     * Note: in the presence of NAT, this may not be the same as the
     * address that the remote host thinks it's talking to.
     *
     * May throw NS_ERROR_NOT_AVAILABLE if accessed when the channel's
     * endpoints are not yet determined, or in any case when
     * nsIHttpActivityObserver.isActive is false. See bugs 534698 and 526207.
     */
    readonly localAddress: IDLAUTF8String;

    /**
     * The local port number to which this channel is bound.
     *
     * May throw NS_ERROR_NOT_AVAILABLE if accessed when the channel's
     * endpoints are not yet determined, or in any case when
     * nsIHttpActivityObserver.isActive is false. See bugs 534698 and 526207.
     */
    readonly localPort: number;

    /**
     * The IP address of the remote host that this channel is
     * connected to, in the format produced by PR_NetAddrToString.
     *
     * May throw NS_ERROR_NOT_AVAILABLE if accessed when the channel's
     * endpoints are not yet determined, or in any case when
     * nsIHttpActivityObserver.isActive is false. See bugs 534698 and 526207.
     */
    readonly remoteAddress: IDLAUTF8String;

    /**
     * The remote port number that this channel is connected to.
     *
     * May throw NS_ERROR_NOT_AVAILABLE if accessed when the channel's
     * endpoints are not yet determined, or in any case when
     * nsIHttpActivityObserver.isActive is false. See bugs 534698 and 526207.
     */
    readonly remotePort: number;

    /**
     * HTTPUpgrade allows for the use of HTTP to bootstrap another protocol
     * via the RFC 2616 Upgrade request header in conjunction with a 101 level
     * response. The nsIHttpUpgradeListener will have its
     * onTransportAvailable() method invoked if a matching 101 is processed.
     * The arguments to onTransportAvailable provide the new protocol the low
     * level tranport streams that are no longer used by HTTP. If any errors
     * occur during the upgrade but the original request has (potentially)
     * already received onStopRequest, the nsIHttpUpgradeListener will have its
     * onUpgradeFailed() method invoked instead of onTransportAvailable().
     *
     * The onStartRequest and onStopRequest events are still delivered and the
     * listener gets full control over the socket if and when onTransportAvailable
     * is delivered. Note that if onStopRequest is called with an error, no
     * methods on the nsIHttpUpgradeListener might be invoked at all.
     *
     * @param aProtocolName
     *        The value of the HTTP Upgrade request header
     * @param aListener
     *        The callback object used to handle a successful upgrade
     */
    readonly HTTPUpgrade: (aProtocolName: IDLACString, aListener: (nsIHttpUpgradeListener | null)) => void;

    /**
     * Enable only CONNECT to a proxy. Fails if no HTTPUpgrade listener
     * has been defined. An ALPN header is set using the upgrade protocol.
     *
     * Load flags are set with INHIBIT_CACHING, LOAD_ANONYMOUS,
     * LOAD_BYPASS_CACHE, and LOAD_BYPASS_SERVICE_WORKER.
     *
     * Proxy resolve flags are set with RESOLVE_PREFER_HTTPS_PROXY and
     * RESOLVE_ALWAYS_TUNNEL.
     */
    readonly setConnectOnly: () => void;

    /**
     * True iff the channel is CONNECT only.
     */
    readonly onlyConnect: boolean;

    /**
     * Enable/Disable Spdy negotiation on per channel basis.
     * The network.http.spdy.enabled preference is still a pre-requisite
     * for starting spdy.
     */
    allowSpdy: boolean;

    /**
     * This attribute en/disables the timeout for the first byte of an HTTP
     * response. Enabled by default.
     */
    responseTimeoutEnabled: boolean;

    /**
     * If the underlying transport supports RWIN manipulation, this is the
     * intiial window value for the channel. HTTP/2 implements this.
     * 0 means no override from system default. Set before opening channel.
     */
    initialRwin: number;

    /**
     * Get value of the URI passed to nsIHttpChannel.redirectTo() if any.
     * May return null when redirectTo() has not been called.
     */
    readonly apiRedirectToURI: (nsIURI | null);

    /**
     * Enable/Disable use of Alternate Services with this channel.
     * The network.http.altsvc.enabled preference is still a pre-requisite.
     */
    allowAltSvc: boolean;

    /**
     * If true, do not use newer protocol features that might have interop problems
     * on the Internet. Intended only for use with critical infra like the updater.
     * default is false.
     */
    beConservative: boolean;

    /**
     * An opaque flags for non-standard behavior of the TLS system.
     * It is unlikely this will need to be set outside of telemetry studies
     * relating to the TLS implementation.
     */
    tlsFlags: number;

    readonly lastModifiedTime: number;

    /**
     * Set by nsCORSListenerProxy if credentials should be included in
     * cross-origin requests. false indicates "same-origin", users should still
     * check flag LOAD_ANONYMOUS!
     */
    corsIncludeCredentials: boolean;

    /**
     * Set by nsCORSListenerProxy to indicate CORS load type. Defaults to CORS_MODE_NO_CORS.
     */
    corsMode: number;

    /**
     * Set to indicate Request.redirect mode exposed during ServiceWorker
     * interception. No policy enforcement is performed by the channel for this
     * value.
     */
    redirectMode: number;

    /**
     * Set to indicate Request.cache mode, which simulates the fetch API
     * semantics, and is also used for exposing this value to the Web page
     * during service worker interception.
     */
    fetchCacheMode: number;

    /**
     * The URI of the top-level window that's associated with this channel.
     */
    readonly topWindowURI: (nsIURI | null);

    /**
     * Set top-level window URI to this channel only when the topWindowURI
     * is null and there is no window associated to this channel.
     * Note that the current usage of this method is only for xpcshell test.
     */
    readonly setTopWindowURIIfUnknown: (topWindowURI: (nsIURI | null)) => void;

    /**
     * Read the proxy URI, which, if non-null, will be used to resolve
     * proxies for this channel.
     */
    readonly proxyURI: (nsIURI | null);

    /**
     * When set to true, the channel will not pop any authentication prompts up
     * to the user.  When provided or cached credentials lead to an
     * authentication failure, that failure will be propagated to the channel
     * listener.  Must be called before opening the channel, otherwise throws.
     */
    blockAuthPrompt: boolean;

    /**
     * Set to indicate Request.integrity.
     */
    integrityMetadata: IDLAString;

    /**
     * The connection info's hash key. We use it to test connection separation.
     */
    readonly connectionInfoHashKey: IDLACString;
  }

  export interface nsIWebBrowserPersistURIMapRef {
    readonly name: "nsIWebBrowserPersistURIMap";
    readonly number: "{d52e8b93-2771-45e8-a5b0-6e12b667046b}";
  }

  /**
   * Interface for the URI-mapping information that can be supplied when
   * serializing the DOM of an nsIWebBrowserPersistDocument.
   *
   * @see nsIWebBrowserPersistDocument
   */
  export interface nsIWebBrowserPersistURIMap extends nsISupports {

    /**
     * The number of URI mappings.
     */
    readonly numMappedURIs: number;

    /**
     * Obtain the URI mapping at the given index, which must be less than
     * numMappedURIs, as a pair of URI spec strings.
     */
    readonly getURIMapping: (aIndex: number, aMapFrom: Out<IDLAUTF8String>, aMapTo: Out<IDLAUTF8String>) => void;

    /**
     * The spec of the base URI that the document will have after it is
     * serialized.
     */
    readonly targetBaseURI: IDLAUTF8String;
  }

  export interface nsISupportsPrimitiveRef {
    readonly name: "nsISupportsPrimitive";
    readonly number: "{d0d4b136-1dd1-11b2-9371-f0727ef827c0}";

    TYPE_ID: 1;

    TYPE_CSTRING: 2;

    TYPE_STRING: 3;

    TYPE_PRBOOL: 4;

    TYPE_PRUINT8: 5;

    TYPE_PRUINT16: 6;

    TYPE_PRUINT32: 7;

    TYPE_PRUINT64: 8;

    TYPE_PRTIME: 9;

    TYPE_CHAR: 10;

    TYPE_PRINT16: 11;

    TYPE_PRINT32: 12;

    TYPE_PRINT64: 13;

    TYPE_FLOAT: 14;

    TYPE_DOUBLE: 15;

    TYPE_INTERFACE_POINTER: 17;
  }

  /**
   * Primitive base interface.
   *
   * These first three are pointer types and do data copying
   * using the nsIMemory. Be careful!
   */
  export interface nsISupportsPrimitive extends nsISupports {

    readonly type: number;
  }

  export interface nsIListNetworkAddressesListenerRef {
    readonly name: "nsIListNetworkAddressesListener";
    readonly number: "{c4bdaac1-3ab1-4fdb-9a16-17cbed794603}";
  }

  /**
   * Listener for getting list of addresses.
   */
  export interface nsIListNetworkAddressesListener extends nsISupports {

    /**
     * Callback function that gets called by nsINetworkInfoService.listNetworkAddresses.
     * Each address in the array is a string IP address in canonical form,
     * e.g. 192.168.1.10, or an IPV6 address in string form.
     */
    readonly onListedNetworkAddresses: (aAddressArray: IDLACString[]) => void;

    readonly onListNetworkAddressesFailed: () => void;
  }

  export interface nsITrackingDBServiceRef {
    readonly name: "nsITrackingDBService";
    readonly number: "{650934db-1939-4424-be26-6ffb0375424d}";

    OTHER_COOKIES_BLOCKED_ID: 0;

    TRACKERS_ID: 1;

    TRACKING_COOKIES_ID: 2;

    CRYPTOMINERS_ID: 3;

    FINGERPRINTERS_ID: 4;

    SOCIAL_ID: 5;
  }

  export interface nsITrackingDBService extends nsISupports {

    /**
     * Record entries from a content blocking log in the tracking database.
     * This function is typically called at the end of the document lifecycle,
     * since calling it multiple times results in multiple new entries.
     *
     * @param aInputStream the content blocking log as an input stream that outputs a JSON string
     */
    readonly recordContentBlockingLog: (aInputStream: (nsIAsyncInputStream | null)) => void;

    /**
     * Save new events in the content blocking database
     * @param data    a json string containing the content blocking log.
     */
    readonly saveEvents: (data: IDLAString) => IDLPromise;

    /**
     * Clear all content blocking database entries.
     */
    readonly clearAll: () => IDLPromise;

    /**
     * Clear all content blocking database entries added since the specified time.
     * @param since   a unix timestamp representing the number of milliseconds from
     *                Jan 1, 1970 00:00:00 UTC.
     */
    readonly clearSince: (since: number) => IDLPromise;

    /**
     * Fetch events from the content blocking database
     * @param dateFrom   a unix timestamp.
     * @param dateTo     a unix timestamp.
     */
    readonly getEventsByDateRange: (dateFrom: number, dateTo: number) => IDLPromise;

    /**
     * Return a count of all tracking events.
     */
    readonly sumAllEvents: () => IDLPromise;

    /**
     * Return the earliest recorded date.
     */
    readonly getEarliestRecordedDate: () => IDLPromise;
  }

  export interface nsIUrlClassifierParseFindFullHashCallbackRef {
    readonly name: "nsIUrlClassifierParseFindFullHashCallback";
    readonly number: "{fbb9684a-a0aa-11e6-88b0-08606e456b8a}";
  }

  /**
   * Interface for parseFindFullHashResponseV4 callback
   */
  export interface nsIUrlClassifierParseFindFullHashCallback extends nsISupports {

    /**
     * Callback when a match is found in full hash response. This callback may be
     * called multiple times when there are more than one matches in response.
     *
     * @param aCompleteHash A 32-byte complete hash string.
     * @param aTableNames The table names that this complete hash is associated with.
     *                    Since the server responded with a threat type, multiple
     *                    list names can be returned. The caller is reponsible
     *                    for filtering out the unrequested table names.
     *                    See |convertThreatTypeToListNames| for the format.
     * @param aPerHashCacheDuration See "FindFullHashesResponse" in safebrowsing.proto.
     *
     */
    readonly onCompleteHashFound: (aCompleteHash: IDLACString, aTableNames: IDLACString, aPerHashCacheDuration: number) => void;

    /**
     * Callback when full hash response is received.
     *
     * @param aMinWaitDuration See "FindFullHashesResponse" in safebrowsing.proto.
     * @param aNegCacheDuration See "FindFullHashesResponse" in safebrowsing.proto.
     *
     */
    readonly onResponseParsed: (aMinWaitDuration: number, aNegCacheDuration: number) => void;
  }

  export interface nsIToolkitProfileRef {
    readonly name: "nsIToolkitProfile";
    readonly number: "{7422b090-4a86-4407-972e-75468a625388}";
  }

  /**
   * A interface representing a profile.
   * @note THIS INTERFACE SHOULD BE IMPLEMENTED BY THE TOOLKIT CODE ONLY! DON'T
   *       EVEN THINK ABOUT IMPLEMENTING THIS IN JAVASCRIPT!
   */
  export interface nsIToolkitProfile extends nsISupports {

    /**
     * The location of the profile directory.
     */
    readonly rootDir: (nsIFile | null);

    /**
     * The location of the profile local directory, which may be the same as
     * the root directory.  See nsIProfileLock::localDirectory.
     */
    readonly localDir: (nsIFile | null);

    /**
     * The name of the profile.
     */
    name: IDLAUTF8String;

    /**
     * Removes the profile from the registry of profiles.
     *
     * @param removeFiles
     *        Indicates whether or not the profile directory should be
     *        removed in addition.
     */
    readonly remove: (removeFiles: boolean) => void;

    /**
     * Removes the profile from the registry of profiles.
     * The profile directory is removed in the stream transport thread.
     *
     * @param removeFiles
     *        Indicates whether or not the profile directory should be
     *        removed in addition.
     */
    readonly removeInBackground: (removeFiles: boolean) => void;

    /**
     * Lock this profile using platform-specific locking methods.
     *
     * @param lockFile If locking fails, this may return a lockFile object
     *                 which can be used in platform-specific ways to
     *                 determine which process has the file locked. Null
     *                 may be passed.
     * @return An interface which holds a profile lock as long as you reference
     *         it.
     * @throws NS_ERROR_FILE_ACCESS_DENIED if the profile was already locked.
     */
    readonly lock: (aUnlocker: Out<(nsIProfileUnlocker | null)>) => (nsIProfileLock | null);
  }

  export interface nsIFindRef {
    readonly name: "nsIFind";
    readonly number: "{40aba110-2a56-4678-be90-e2c17a9ae7d7}";
  }

  export interface nsIFind extends nsISupports {

    findBackwards: boolean;

    caseSensitive: boolean;

    entireWord: boolean;

    matchDiacritics: boolean;

    /**
     * Find some text in the current context. The implementation is
     * responsible for performing the find and highlighting the text.
     *
     * @param aPatText     The text to search for.
     * @param aSearchRange A Range specifying domain of search.
     * @param aStartPoint  A Range specifying search start point.
     *                     If not collapsed, we'll start from
     *                     end (forward) or start (backward).
     * @param aEndPoint    A Range specifying search end point.
     *                     If not collapsed, we'll end at
     *                     end (forward) or start (backward).
     * @retval             A range spanning the match that was found (or null).
     */
    readonly Find: (aPatText: IDLAString, aSearchRange: WebIDL.Range, aStartPoint: WebIDL.Range, aEndPoint: WebIDL.Range) => WebIDL.Range;
  }

  export interface nsIUTF8StringEnumeratorRef {
    readonly name: "nsIUTF8StringEnumerator";
    readonly number: "{9bdf1010-3695-4907-95ed-83d0410ec307}";
  }

  export interface nsIUTF8StringEnumerator extends nsIStringEnumeratorBase {

    readonly hasMore: () => boolean;

    readonly getNext: () => IDLAUTF8String;
  }

  export interface nsISupportsPRUint64Ref {
    readonly name: "nsISupportsPRUint64";
    readonly number: "{e13567c0-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for 64-bit integers
   */
  export interface nsISupportsPRUint64 extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsIProxyProtocolFilterResultRef {
    readonly name: "nsIProxyProtocolFilterResult";
    readonly number: "{009e6c3f-fb64-40c5-8093-f1495c64773e}";
  }

  /**
   * Recipient of the result of implementers of nsIProtocolProxy(Channel)Filter
   * allowing the proxyinfo be provided asynchronously.
   */
  export interface nsIProxyProtocolFilterResult extends nsISupports {

    /**
     * It's mandatory to call this method exactly once when the applyFilter()
     * implementation doesn't throw and to not call it when applyFilter() does
     * throw.
     *
     * It's mandatory to call this method on the same thread as the call to
     * applyFilter() has been made on.
     *
     * Following the above conditions, can be called either from within
     * applyFilter() or asynchronouly any time later.
     */
    readonly onProxyFilterResult: (aProxy: (nsIProxyInfo | null)) => void;
  }

  export interface nsITransferRef {
    readonly name: "nsITransfer";
    readonly number: "{37ec75d3-97ad-4da8-afaa-eabe5b4afd73}";
  }

  export interface nsITransfer extends nsIWebProgressListener2 {

    /**
     * Initializes the transfer with certain properties.  This function must
     * be called prior to accessing any properties on this interface.
     *
     * @param aSource The source URI of the transfer. Must not be null.
     *
     * @param aTarget The target URI of the transfer. Must not be null.
     *
     * @param aDisplayName The user-readable description of the transfer.
     *                     Can be empty.
     *
     * @param aMIMEInfo The MIME info associated with the target,
     *                  including MIME type and helper app when appropriate.
     *                  This parameter is optional.
     *
     * @param startTime Time when the download started (ie, when the first
     *                  response from the server was received)
     *                  XXX presumably wbp and exthandler do this differently
     *
     * @param aTempFile The location of a temporary file; i.e. a file in which
     *                  the received data will be stored, but which is not
     *                  equal to the target file. (will be moved to the real
     *                  target by the caller, when the download is finished)
     *                  May be null.
     *
     * @param aCancelable An object that can be used to abort the download.
     *                    Must not be null.
     *                    Implementations are expected to hold a strong
     *                    reference to this object until the download is
     *                    finished, at which point they should release the
     *                    reference.
     *
     * @param aIsPrivate Used to determine the privacy status of the new transfer.
     *                   If true, indicates that the transfer was initiated from
     *                   a source that desires privacy.
     */
    readonly init: (aSource: (nsIURI | null), aTarget: (nsIURI | null), aDisplayName: IDLAString, aMIMEInfo: (nsIMIMEInfo | null), startTime: number, aTempFile: (nsIFile | null), aCancelable: (nsICancelable | null), aIsPrivate: boolean) => void;

    readonly setSha256Hash: (aHash: IDLACString) => void;

    readonly setSignatureInfo: (aSignatureInfo: number[][][]) => void;

    readonly setRedirects: (aRedirects: (nsIArray | null)) => void;
  }

  export interface nsIPresentationDeviceProviderRef {
    readonly name: "nsIPresentationDeviceProvider";
    readonly number: "{3db2578a-0f50-44ad-b01b-28427b71b7bf}";
  }

  export interface nsIPresentationDeviceProvider extends nsISupports {

    listener: (nsIPresentationDeviceListener | null);

    readonly forceDiscovery: () => void;
  }

  export interface nsISupportsPRInt16Ref {
    readonly name: "nsISupportsPRInt16";
    readonly number: "{e30d94b0-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for 16-bit integers
   */
  export interface nsISupportsPRInt16 extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsINativeFileWatcherErrorCallbackRef {
    readonly name: "nsINativeFileWatcherErrorCallback";
    readonly number: "{5daeddc3-fc94-4880-8a4f-26d910b92662}";
  }

  type nsINativeFileWatcherErrorCallbackFunction = (xpcomError: number, osError: number) => void;

  /**
   * The interface for the callback invoked when there is an error.
   */
  export interface nsINativeFileWatcherErrorCallback extends nsISupports {

    /**
     * @param xpcomError The XPCOM error code.
     * @param osError The native OS error (errno under Unix, GetLastError under Windows).
     */
    readonly complete: (xpcomError: number, osError: number) => void;
  }

  export interface nsISupportsCharRef {
    readonly name: "nsISupportsChar";
    readonly number: "{e2b05e40-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for single character values
   * (often used to store an ASCII character)
   */
  export interface nsISupportsChar extends nsISupportsPrimitive {

    data: string;

    readonly toString: () => string;
  }

  export interface nsIFileProtocolHandlerRef {
    readonly name: "nsIFileProtocolHandler";
    readonly number: "{1fb25bd5-4354-4dcd-8d97-621b7b3ed2e4}";
  }

  export interface nsIFileProtocolHandler extends nsIProtocolHandler {

    /**
     * This method constructs a new file URI
     *
     * @param aFile nsIFile
     * @return reference to a new nsIURI object
     */
    readonly newFileURI: (aFile: (nsIFile | null)) => (nsIURI | null);

    /**
     * This method constructs a new file URI, and returns a URI mutator
     * that has not yet been finalized, allowing the URI to be changed without
     * being cloned.
     *
     * @param aFile nsIFile
     * @return reference to a new nsIURIMutator object
     */
    readonly newFileURIMutator: (file: (nsIFile | null)) => (nsIURIMutator | null);

    /**
     * Converts the nsIFile to the corresponding URL string.  NOTE: under
     * some platforms this is a lossy conversion (e.g., Mac Carbon build).
     * If the nsIFile is a local file, then the result will be a file://
     * URL string.
     *
     * The resulting string may contain URL-escaped characters.
     * NOTE: Callers should use getURLSpecFromActualFile or
     * getURLSpecFromDirFile if possible, for performance reasons.
     */
    readonly getURLSpecFromFile: (file: (nsIFile | null)) => IDLAUTF8String;

    /**
     * Converts the nsIFile to the corresponding URL string. Should
     * only be called on files which are not directories. Otherwise
     * identical to getURLSpecFromFile, but is usually more efficient.
     * WARNING: This restriction may not be enforced at runtime!
     */
    readonly getURLSpecFromActualFile: (file: (nsIFile | null)) => IDLAUTF8String;

    /**
     * Converts the nsIFile to the corresponding URL string. Should
     * only be called on files which are directories. Otherwise
     * identical to getURLSpecFromFile, but is usually more efficient.
     * WARNING: This restriction may not be enforced at runtime!
     */
    readonly getURLSpecFromDir: (file: (nsIFile | null)) => IDLAUTF8String;

    /**
     * Converts the URL string into the corresponding nsIFile if possible.
     * A local file will be created if the URL string begins with file://.
     */
    readonly getFileFromURLSpec: (url: IDLAUTF8String) => (nsIFile | null);

    /**
     * Takes a local file and tries to interpret it as an internet shortcut
     * (e.g. .url files on windows).
     * @param file The local file to read
     * @return The URI the file refers to
     *
     * @throw NS_ERROR_NOT_AVAILABLE if the OS does not support such files.
     * @throw NS_ERROR_NOT_AVAILABLE if this file is not an internet shortcut.
     */
    readonly readURLFile: (file: (nsIFile | null)) => (nsIURI | null);
  }

  export interface nsICacheStorageConsumptionObserverRef {
    readonly name: "nsICacheStorageConsumptionObserver";
    readonly number: "{7728ab5b-4c01-4483-a606-32bf5b8136cb}";
  }

  export interface nsICacheStorageConsumptionObserver extends nsISupports {

    /**
     * Callback invoked to answer asyncGetDiskConsumption call. Always triggered
     * on the main thread.
     * NOTE: implementers must also implement nsISupportsWeakReference.
     *
     * @param aDiskSize
     *    The disk consumption in bytes.
     */
    readonly onNetworkCacheDiskConsumption: (aDiskSize: number) => void;
  }

  export interface nsIUnsubscribeResultCallbackRef {
    readonly name: "nsIUnsubscribeResultCallback";
    readonly number: "{d574118f-61a9-4270-b1f6-4461aa85c4f5}";
  }

  type nsIUnsubscribeResultCallbackFunction = (status: number, success: boolean) => void;

  /**
   * Called by |unsubscribe|. A non-success |status| indicates that there was
   * a problem unsubscribing, and the |success| argument should be ignored.
   * Otherwise, |success| is true if unsubscribing was successful, and false if
   * the subscription does not exist.
   */
  export interface nsIUnsubscribeResultCallback extends nsISupports {

    readonly onUnsubscribe: (status: number, success: boolean) => void;
  }

  export interface nsIPlaintextEditorRef {
    readonly name: "nsIPlaintextEditor";
    readonly number: "{b74fb158-1265-4102-91eb-edd0136b49f8}";

    eEditorPlaintextMask: 1;

    eEditorSingleLineMask: 2;

    eEditorPasswordMask: 4;

    eEditorReadonlyMask: 8;

    eEditorDisabledMask: 16;

    eEditorFilterInputMask: 32;

    eEditorMailMask: 64;

    eEditorEnableWrapHackMask: 128;

    eEditorWidgetMask: 256;

    eEditorNoCSSMask: 512;

    eEditorAllowInteraction: 1024;

    eEditorDontEchoPassword: 2048;

    eEditorRightToLeft: 4096;

    eEditorLeftToRight: 8192;

    eEditorSkipSpellCheck: 16384;

    eNewlinesPasteIntact: 0;

    eNewlinesPasteToFirst: 1;

    eNewlinesReplaceWithSpaces: 2;

    eNewlinesStrip: 3;

    eNewlinesReplaceWithCommas: 4;

    eNewlinesStripSurroundingWhitespace: 5;
  }

  export interface nsIPlaintextEditor extends nsISupports {

    /**
     * The length of the contents in characters.
     * XXX change this type to 'unsigned long'
     */
    readonly textLength: number;

    /** Get and set the body wrap width.
     *
     * Special values:
     *    0 = wrap to window width
     *   -1 = no wrap at all
     */
    wrapWidth: number;

    /** Get and set newline handling.
     *
     *  Values are the constants defined above.
     */
    newlineHandling: number;

    /**
     * Inserts a string at the current location,
     * given by the selection.
     * If the selection is not collapsed, the selection is deleted
     * and the insertion takes place at the resulting collapsed selection.
     *
     * @param aString   the string to be inserted
     */
    readonly insertText: (aStringToInsert: IDLAString) => void;

    /**
     * Insert a line break into the content model.
     * The interpretation of a break is up to the implementation:
     * it may enter a character, split a node in the tree, etc.
     * This may be more efficient than calling InsertText with a newline.
     */
    readonly insertLineBreak: () => void;
  }

  export interface nsIBlocklistServiceRef {
    readonly name: "nsIBlocklistService";
    readonly number: "{a6dcc76e-9f62-4cc1-a470-b483a1a6f096}";

    STATE_NOT_BLOCKED: 0;

    STATE_SOFTBLOCKED: 1;

    STATE_BLOCKED: 2;

    STATE_OUTDATED: 3;

    STATE_VULNERABLE_UPDATE_AVAILABLE: 4;

    STATE_VULNERABLE_NO_UPDATE: 5;

    STATE_MAX: 6;
  }

  export interface nsIBlocklistService extends nsISupports {

    /**
     * Determine the blocklist state of a plugin
     * @param   plugin
     *          The plugin to get the state for
     * @param   appVersion
     *          The version of the application we are checking in the blocklist.
     *          If this parameter is null, the version of the running application
     *          is used.
     * @param   toolkitVersion
     *          The version of the toolkit we are checking in the blocklist.
     *          If this parameter is null, the version of the running toolkit
     *          is used.
     * @returns Promise that resolves to the STATE constant.
     */
    readonly getPluginBlocklistState: (plugin: (nsIPluginTag | null), appVersion?: IDLAString, toolkitVersion?: IDLAString) => IDLPromise;

    readonly isLoaded: boolean;
  }

  export interface nsIProxiedChannelRef {
    readonly name: "nsIProxiedChannel";
    readonly number: "{6238f134-8c3f-4354-958f-dfd9d54a4446}";
  }

  /**
   * An interface for accessing the proxy info that a channel was
   * constructed with.
   *
   * @see nsIProxiedProtocolHandler
   */
  export interface nsIProxiedChannel extends nsISupports {

    /**
     * Gets the proxy info the channel was constructed with. null or a
     * proxyInfo with type "direct" mean no proxy.
     *
     * The returned proxy info must not be modified.
     */
    readonly proxyInfo: (nsIProxyInfo | null);

    /**
     * The HTTP response code returned from the proxy to the CONNECT method.
     * The response code is only available when we get the response from
     * the proxy server, so this value is known in and after OnStartRequest.
     *
     * If CONNECT method is not used, httpProxyConnectResponseCode is always -1.
     * After OnStartRequest, httpProxyConnectResponseCode is the real HTTP
     * response code or 0 if we can't reach to the proxy.
     */
    readonly httpProxyConnectResponseCode: number;
  }

  export interface nsIFileOutputStreamRef {
    readonly name: "nsIFileOutputStream";
    readonly number: "{e734cac9-1295-4e6f-9684-3ac4e1f91063}";

    /**
     * See the same constant in nsIFileInputStream. The deferred open will
     * be performed when one of the following is called:
     *   - Seek
     *   - Tell
     *   - SetEOF
     *   - Write
     *   - Flush
     *
     * @note Using this flag results in the file not being opened
     *       during the call to Init.  This means that any errors that might
     *       happen when this flag is not set would happen during the
     *       first write, and if the file is to be created, then it will not
     *       appear on the disk until the first write.
     */
    DEFER_OPEN: 1;
  }

  /**
   * An output stream that lets you stream to a file.
   */
  export interface nsIFileOutputStream extends nsIOutputStream {

    /**
     * @param file          file to write to
     * @param ioFlags       file open flags listed in prio.h (see
     *                      PR_Open documentation) or -1 to open the
     *                      file in default mode (PR_WRONLY |
     *                      PR_CREATE_FILE | PR_TRUNCATE)
     * @param perm          file mode bits listed in prio.h or -1 to
     *                      use the default permissions (0664)
     * @param behaviorFlags flags specifying various behaviors of the class
     *        (currently none supported)
     */
    readonly init: (file: (nsIFile | null), ioFlags: number, perm: number, behaviorFlags: number) => void;
  }

  export interface mozIStoragePendingStatementRef {
    readonly name: "mozIStoragePendingStatement";
    readonly number: "{00da7d20-3768-4398-bedc-e310c324b3f0}";
  }

  export interface mozIStoragePendingStatement extends nsISupports {

    /**
     * Cancels a pending statement, if possible.  This will only fail if you try
     * cancel more than once.
     *
     * @note For read statements (such as SELECT), you will no longer receive any
     *       notifications about results once cancel is called.
     */
    readonly cancel: () => void;
  }

  export interface nsIParentalControlsServiceRef {
    readonly name: "nsIParentalControlsService";
    readonly number: "{2e97e5dd-467b-4aea-a1bb-6773c0f2beb0}";

    /**
     * Action types that can be blocked for users.
     */
    DOWNLOAD: 1;

    INSTALL_EXTENSION: 2;

    INSTALL_APP: 3;

    BROWSE: 4;

    SHARE: 5;

    BOOKMARK: 6;

    ADD_CONTACT: 7;

    SET_IMAGE: 8;

    MODIFY_ACCOUNTS: 9;

    REMOTE_DEBUGGING: 10;

    IMPORT_SETTINGS: 11;

    PRIVATE_BROWSING: 12;

    DATA_CHOICES: 13;

    CLEAR_HISTORY: 14;

    MASTER_PASSWORD: 15;

    GUEST_BROWSING: 16;

    ADVANCED_SETTINGS: 17;

    CAMERA_MICROPHONE: 18;

    BLOCK_LIST: 19;

    TELEMETRY: 20;

    HEALTH_REPORT: 21;

    DEFAULT_THEME: 22;

    /**
     * Log entry types. Additional types can be defined and implemented
     * as needed. Other possible event types might include email events,
     * media related events, and IM events.
     */
    ePCLog_URIVisit: 1;

    ePCLog_FileDownload: 2;
  }

  export interface nsIParentalControlsService extends nsISupports {

    /**
     * @returns true if the current user account has parental controls
     * restrictions enabled.
     */
    readonly parentalControlsEnabled: boolean;

    /**
     * @returns true if the current user account parental controls
     * restrictions include the blocking of all file downloads.
     */
    readonly blockFileDownloadsEnabled: boolean;

    /**
     * Check if the user can do the prescibed action for this uri.
     *
     * @param aAction             Action being performed
     * @param aUri                The uri requesting this action
     * @param aWindow             The window generating this event.
     */
    readonly isAllowed: (aAction: number, aUri?: (nsIURI | null)) => boolean;

    /**
     * @returns true if the current user account has parental controls
     * logging enabled. If true, applications should log relevent events
     * using 'log'.
     */
    readonly loggingEnabled: boolean;

    /**
     * Log an application specific parental controls
     * event.
     *
     * @param aEntryType       Constant defining the type of event.
     * @param aFlag            A flag indicating if the subject content
     *                         was blocked.
     * @param aSource          The URI source of the subject content.
     * @param aTarget          The location the content was saved to if
     *                         no blocking occurred.
     */
    readonly log: (aEntryType: number, aFlag: boolean, aSource: (nsIURI | null), aTarget?: (nsIFile | null)) => void;
  }

  export interface nsIJARChannelRef {
    readonly name: "nsIJARChannel";
    readonly number: "{e72b179b-d5df-4d87-b5de-fd73a65c60f6}";
  }

  export interface nsIJARChannel extends nsIChannel {

    /**
     * Returns the JAR file.  May be null if the jar is remote.
     * Setting the JAR file is optional and overrides the JAR
     * file used for local file JARs. Setting the JAR file after
     * the channel has been opened is not permitted.
     */
    jarFile: (nsIFile | null);

    /**
     * Returns the zip entry if the file is synchronously accessible.
     * This will work even without opening the channel.
     */
    readonly zipEntry: (nsIZipEntry | null);

    /**
     * If the JAR file is cached in the JAR cache, returns true and
     * holds a reference to the cached zip reader to be used when
     * the channel is read from, ensuring the cached reader will be used.
     * For a successful read from the cached reader, close() should not
     * be called on the reader--per nsIZipReader::getZip() documentation.
     * Returns false if the JAR file is not cached. Calling this method
     * after the channel has been opened is not permitted.
     */
    readonly ensureCached: () => boolean;
  }

  export interface nsIDumpGCAndCCLogsCallbackRef {
    readonly name: "nsIDumpGCAndCCLogsCallback";
    readonly number: "{dc1b2b24-65bd-441b-b6bd-cb5825a7ed14}";
  }

  /**
   * Callback interface for |dumpGCAndCCLogsToFile|, below.  Note that
   * these method calls can occur before |dumpGCAndCCLogsToFile|
   * returns.
   */
  export interface nsIDumpGCAndCCLogsCallback extends nsISupports {

    /**
     * Called whenever a process has successfully finished dumping its GC/CC logs.
     * Incomplete dumps (e.g., if the child crashes or is killed due to memory
     * exhaustion) are not reported.
     *
     * @param aGCLog The file that the GC log was written to.
     *
     * @param aCCLog The file that the CC log was written to.
     *
     * @param aIsParent indicates whether this log file pair is from the
     * parent process.
     */
    readonly onDump: (aGCLog: (nsIFile | null), aCCLog: (nsIFile | null), aIsParent: boolean) => void;

    /**
     * Called when GC/CC logging has finished, after all calls to |onDump|.
     */
    readonly onFinish: () => void;
  }

  export interface nsIFinishDumpingCallbackRef {
    readonly name: "nsIFinishDumpingCallback";
    readonly number: "{2dea18fc-fbfa-4bf7-ad45-0efaf5495f5e}";
  }

  type nsIFinishDumpingCallbackFunction = (data: (nsISupports | null)) => void;

  export interface nsIFinishDumpingCallback extends nsISupports {

    readonly callback: (data: (nsISupports | null)) => void;
  }

  export interface nsIMozBrowserFrameRef {
    readonly name: "nsIMozBrowserFrame";
    readonly number: "{0c0a862c-1a47-43c0-ae9e-d51835e3e1a6}";
  }

  export interface nsIMozBrowserFrame extends nsIDOMMozBrowserFrame {

    /**
     * Gets whether this frame really is a browser frame.
     *
     * In order to really be a browser frame, this frame's
     * nsIDOMMozBrowserFrame::mozbrowser attribute must be true, and the frame
     * may have to pass various security checks.
     */
    readonly reallyIsBrowser: boolean;
  }

  export interface amIWebInstallPromptRef {
    readonly name: "amIWebInstallPrompt";
    readonly number: "{386906f1-4d18-45bf-bc81-5dcd68e42c3b}";
  }

  /**
   * amIWebInstallPrompt is used, if available, by the default implementation of
   * amIWebInstallInfo to display a confirmation UI to the user before running
   * installs.
   */
  export interface amIWebInstallPrompt extends nsISupports {

    /**
     * Get a confirmation that the user wants to start the installs.
     *
     * @param  aBrowser
     *         The browser that triggered the installs
     * @param  aUri
     *         The URI of the site that triggered the installs
     * @param  aInstalls
     *         The AddonInstalls that were requested
     */
    readonly confirm: (aBrowser: WebIDL.Element, aUri: (nsIURI | null), aInstalls: (nsIVariant | null)[]) => void;
  }

  export interface nsICloneableInputStreamWithRangeRef {
    readonly name: "nsICloneableInputStreamWithRange";
    readonly number: "{ece853c3-aded-4cef-8f51-0d1493d60bd5}";
  }

  export interface nsICloneableInputStreamWithRange extends nsICloneableInputStream {

    readonly cloneWithRange: (start: number, length: number) => (nsIInputStream | null);
  }

  export interface nsIFilePickerRef {
    readonly name: "nsIFilePicker";
    readonly number: "{9285b984-02d3-46b4-9514-7da8c471a747}";

    modeOpen: 0;

    modeSave: 1;

    modeGetFolder: 2;

    modeOpenMultiple: 3;

    returnOK: 0;

    returnCancel: 1;

    returnReplace: 2;

    filterAll: 1;

    filterHTML: 2;

    filterText: 4;

    filterImages: 8;

    filterXML: 16;

    filterXUL: 32;

    filterApps: 64;

    filterAllowURLs: 128;

    filterAudio: 256;

    filterVideo: 512;

    captureNone: 0;

    captureDefault: 1;

    captureUser: 2;

    captureEnv: 3;
  }

  export interface nsIFilePicker extends nsISupports {

    /**
     * Initialize the file picker widget.  The file picker is not valid until this
     * method is called.
     *
     * @param      parent   mozIDOMWindow parent.  This dialog will be dependent
     *                      on this parent. parent must be non-null.
     * @param      title    The title for the file widget
     * @param      mode     load, save, or get folder
     *
     */
    readonly init: (parent: (mozIDOMWindowProxy | null), title: IDLAString, mode: number) => void;

    /**
     * Append to the  filter list with things from the predefined list
     *
     * @param      filters  mask of filters i.e. (filterAll | filterHTML)
     *
     */
    readonly appendFilters: (filterMask: number) => void;

    /**
     * Add a filter
     *
     * @param      title    name of the filter
     * @param      filter   extensions to filter -- semicolon and space separated
     *
     */
    readonly appendFilter: (title: IDLAString, filter: IDLAString) => void;

    /**
     * Add a raw filter (eg, add a MIME type without transforming it to a list of
     * extensions).
     *
     * @param     filter   a filter taken directly from the accept attribute
     *                     without processing
     *
     */
    readonly appendRawFilter: (filter: IDLAString) => void;

    /**
     * The filename that should be suggested to the user as a default. This should
     * include the extension.
     *
     * @throws NS_ERROR_FAILURE on attempts to get
     */
    defaultString: IDLAString;

    /**
     * The extension that should be associated with files of the type we
     * want to work with.  On some platforms, this extension will be
     * automatically appended to filenames the user enters, if needed.
     */
    defaultExtension: IDLAString;

    /**
     * The filter which is currently selected in the File Picker dialog
     *
     * @return Returns the index (0 based) of the selected filter in the filter list.
     */
    filterIndex: number;

    /**
     * Set the directory that the file open/save dialog initially displays
     * Note that, if displaySpecialDirectory has been already set, this value will
     * be ignored.
     *
     * @param      displayDirectory  the name of the directory
     *
     */
    displayDirectory: (nsIFile | null);

    /**
     * Set the directory that the file open/save dialog initially displays using
     * one of the special name as such as 'Desk', 'TmpD', and so on.
     * Note that, if displayDirectory has been already set, this value will be
     * ignored.
     *
     * @param      displaySpecialDirectory  the name of the special directory
     *
     */
    displaySpecialDirectory: IDLAString;

    /**
     * Get the nsIFile for the file or directory.
     *
     * @return Returns the file currently selected
     */
    readonly file: (nsIFile | null);

    /**
     * Get the nsIURI for the file or directory.
     *
     * @return Returns the file currently selected
     */
    readonly fileURL: (nsIURI | null);

    /**
     * Get the enumerator for the selected files
     * only works in the modeOpenMultiple mode
     *
     * @return Returns the files currently selected
     */
    readonly files: (nsISimpleEnumerator | null);

    /**
     * Get the DOM File or the DOM Directory
     *
     * @return Returns the file or directory currently selected DOM object.
     */
    readonly domFileOrDirectory: (nsISupports | null);

    /**
     * Get the enumerator for the selected files or directories
     * only works in the modeOpenMultiple mode
     *
     * @return Returns the files/directories currently selected as DOM object.
     */
    readonly domFileOrDirectoryEnumerator: (nsISimpleEnumerator | null);

    /**
     * Controls whether the chosen file(s) should be added to the system's recent
     * documents list. This attribute will be ignored if the system has no "Recent
     * Docs" concept, or if the application is in private browsing mode (in which
     * case the file will not be added). Defaults to true.
     */
    addToRecentDocs: boolean;

    /**
     * Opens the file dialog asynchrounously.
     * The passed in object's done method will be called upon completion.
     */
    readonly open: (aFilePickerShownCallback: (nsIFilePickerShownCallback | nsIFilePickerShownCallbackFunction | null)) => void;

    /**
     * The picker's mode, as set by the 'mode' argument passed to init()
     * (one of the modeOpen et. al. constants specified above).
     */
    readonly mode: number;

    /**
     * If set to non-empty string, the nsIFilePicker implementation
     * may use okButtonLabel as the label for the button the user uses to accept
     * file selection.
     */
    okButtonLabel: IDLAString;

    capture: number;
  }

  export interface nsIWeakReferenceRef {
    readonly name: "nsIWeakReference";
    readonly number: "{9188bc85-f92e-11d2-81ef-0060083a0bcf}";
  }

  /**
   * An instance of |nsIWeakReference| is a proxy object that cooperates with
   * its referent to give clients a non-owning, non-dangling reference.  Clients
   * own the proxy, and should generally manage it with an |nsCOMPtr| (see the
   * type |nsWeakPtr| for a |typedef| name that stands out) as they would any
   * other XPCOM object.  The |QueryReferent| member function provides a
   * (hopefully short-lived) owning reference on demand, through which clients
   * can get useful access to the referent, while it still exists.
   *
   * @version 1.0
   * @see nsISupportsWeakReference
   * @see nsWeakReference
   * @see nsWeakPtr
   */
  export interface nsIWeakReference extends nsISupports {
  }

  export interface nsICommandLineHandlerRef {
    readonly name: "nsICommandLineHandler";
    readonly number: "{d4b123df-51ee-48b1-a663-002180e60d3b}";
  }

  /**
   * Handles arguments on the command line of an XUL application.
   *
   * Each handler is registered in the category "command-line-handler".
   * The entries in this category are read in alphabetical order, and each
   * category value is treated as a service contractid implementing this
   * interface.
   *
   * By convention, handler with ordinary priority should begin with "m".
   *
   * Example:
   * Category             Entry          Value
   * command-line-handler c-extensions   @mozilla.org/extension-manager/clh;1
   * command-line-handler m-edit         @mozilla.org/composer/clh;1
   * command-line-handler m-irc          @mozilla.org/chatzilla/clh;1
   * command-line-handler y-final        @mozilla.org/browser/clh-final;1
   *
   * @note What do we do about localizing helpInfo? Do we make each handler do it,
   *       or provide a generic solution of some sort? Don't freeze this interface
   *       without thinking about this!
   */
  export interface nsICommandLineHandler extends nsISupports {

    /**
     * Process a command line. If this handler finds arguments that it
     * understands, it should perform the appropriate actions (such as opening
     * a window), and remove the arguments from the command-line array.
     *
     * @throw NS_ERROR_ABORT to immediately cease command-line handling
     *        (if this is STATE_INITIAL_LAUNCH, quits the app).
     *        All other exceptions are silently ignored.
     */
    readonly handle: (aCommandLine: (nsICommandLine | null)) => void;

    /**
     * When the app is launched with the --help argument, this attribute
     * is retrieved and displayed to the user (on stdout). The text should
     * have embedded newlines which wrap at 76 columns, and should include
     * a newline at the end. By convention, the right column which contains flag
     * descriptions begins at the 24th character.
     */
    readonly helpInfo: IDLAUTF8String;
  }

  export interface nsIExternalHelperAppServiceRef {
    readonly name: "nsIExternalHelperAppService";
    readonly number: "{1e4f3ae1-b737-431f-a95d-31fa8da70199}";
  }

  /**
   * The external helper app service is used for finding and launching
   * platform specific external applications for a given mime content type.
   */
  export interface nsIExternalHelperAppService extends nsISupports {

    /**
     * Binds an external helper application to a stream listener. The caller
     * should pump data into the returned stream listener. When the OnStopRequest
     * is issued, the stream listener implementation will launch the helper app
     * with this data.
     * @param aMimeContentType The content type of the incoming data
     * @param aRequest The request corresponding to the incoming data
     * @param aContentContext Used in processing content document refresh
     *  headers after target content is downloaded. Note in e10s land
     *  this is likely a CPOW that points to a window in the child process.
     * @param aForceSave True to always save this content to disk, regardless of
     *  nsIMIMEInfo and other such influences.
     * @param aWindowContext Used in parenting helper app dialogs, usually
     *  points to the parent browser window. This parameter may be null,
     *  in which case dialogs will be parented to aContentContext.
     * @return A nsIStreamListener which the caller should pump the data into.
     */
    readonly doContent: (aMimeContentType: IDLACString, aRequest: (nsIRequest | null), aContentContext: (nsIInterfaceRequestor | null), aForceSave: boolean, aWindowContext?: (nsIInterfaceRequestor | null)) => (nsIStreamListener | null);

    /**
     * Returns true if data from a URL with this extension combination
     * is to be decoded from aEncodingType prior to saving or passing
     * off to helper apps, false otherwise.
     */
    readonly applyDecodingForExtension: (aExtension: IDLAUTF8String, aEncodingType: IDLACString) => boolean;
  }

  export interface nsIUrlClassifierPositiveCacheEntryRef {
    readonly name: "nsIUrlClassifierPositiveCacheEntry";
    readonly number: "{b3c27f8c-7db8-4f3f-97a5-5a94d781e565}";
  }

  /**
   * nsIUrlClassifierPositiveCacheEntry Represents a positive cache entry.
   */
  export interface nsIUrlClassifierPositiveCacheEntry extends nsISupports {

    /**
     * Fullhash for the positive cache entry.
     */
    readonly fullhash: IDLACString;

    /**
     * Positive cache expiry.
     */
    readonly expiry: number;
  }

  export interface nsISafeOutputStreamRef {
    readonly name: "nsISafeOutputStream";
    readonly number: "{5f914307-5c34-4e1f-8e32-ec749d25b27a}";
  }

  /**
   * This interface provides a mechanism to control an output stream
   * that takes care not to overwrite an existing target until it is known
   * that all writes to the destination succeeded.
   *
   * An object that supports this interface is intended to also support
   * nsIOutputStream.
   *
   * For example, a file output stream that supports this interface writes to
   * a temporary file, and moves it over the original file when |finish| is
   * called only if the stream can be successfully closed and all writes
   * succeeded.  If |finish| is called but something went wrong during
   * writing, it will delete the temporary file and not touch the original.
   * If the stream is closed by calling |close| directly, or the stream
   * goes away, the original file will not be overwritten, and the temporary
   * file will be deleted.
   *
   * Currently, this interface is implemented only for file output streams.
   */
  export interface nsISafeOutputStream extends nsISupports {

    /**
     * Call this method to close the stream and cause the original target
     * to be overwritten. Note: if any call to |write| failed to write out
     * all of the data given to it, then calling this method will |close| the
     * stream and return failure. Further, if closing the stream fails, this
     * method will return failure. The original target will be overwritten only
     * if all calls to |write| succeeded and the stream was successfully closed.
     */
    readonly finish: () => void;
  }

  export interface nsIControllerRef {
    readonly name: "nsIController";
    readonly number: "{d5b61b82-1da4-11d3-bf87-00105a1b0627}";
  }

  export interface nsIController extends nsISupports {

    readonly isCommandEnabled: (command: string) => boolean;

    readonly supportsCommand: (command: string) => boolean;

    readonly doCommand: (command: string) => void;

    readonly onEvent: (eventName: string) => void;
  }

  export interface nsIServiceWorkerInfoRef {
    readonly name: "nsIServiceWorkerInfo";
    readonly number: "{76e357ed-208d-4e4c-9165-1c4059707879}";

    STATE_PARSED: 0;

    STATE_INSTALLING: 1;

    STATE_INSTALLED: 2;

    STATE_ACTIVATING: 3;

    STATE_ACTIVATED: 4;

    STATE_REDUNDANT: 5;

    STATE_UNKNOWN: 6;
  }

  export interface nsIServiceWorkerInfo extends nsISupports {

    readonly id: IDLAString;

    readonly scriptSpec: IDLAString;

    readonly cacheName: IDLAString;

    readonly state: number;

    readonly debugger: (nsIWorkerDebugger | null);

    readonly handlesFetchEvents: boolean;

    readonly installedTime: number;

    readonly activatedTime: number;

    readonly redundantTime: number;

    readonly attachDebugger: () => void;

    readonly detachDebugger: () => void;
  }

  export interface nsIXULAppInfoRef {
    readonly name: "nsIXULAppInfo";
    readonly number: "{ddea4f31-3c5e-4769-ac68-21ab4b3d7845}";
  }

  /**
   * A scriptable interface to the nsXULAppAPI structure. See nsXULAppAPI.h for
   * a detailed description of each attribute.
   */
  export interface nsIXULAppInfo extends nsIPlatformInfo {

    /**
     * @see XREAppData.vendor
     * @returns an empty string if XREAppData.vendor is not set.
     */
    readonly vendor: IDLACString;

    /**
     * @see XREAppData.name
     */
    readonly name: IDLACString;

    /**
     * @see XREAppData.ID
     * @returns an empty string if XREAppData.ID is not set.
     */
    readonly ID: IDLACString;

    /**
     * The version of the XUL application. It is different than the
     * version of the XULRunner platform. Be careful about which one you want.
     *
     * @see XREAppData.version
     * @returns an empty string if XREAppData.version is not set.
     */
    readonly version: IDLACString;

    /**
     * The build ID/date of the application. For xulrunner applications,
     * this will be different than the build ID of the platform. Be careful
     * about which one you want.
     */
    readonly appBuildID: IDLACString;

    /**
     * @see XREAppData.UAName
     * @returns an empty string if XREAppData.UAName is not set.
     */
    readonly UAName: IDLACString;

    /**
     * @see XREAppData.sourceURL
     * @returns an empty string if XREAppData.sourceURL is not set.
     */
    readonly sourceURL: IDLACString;
  }

  export interface nsIPresentationSessionTransportBuilderRef {
    readonly name: "nsIPresentationSessionTransportBuilder";
    readonly number: "{2fdbe67d-80f9-48dc-8237-5bef8fa19801}";
  }

  export interface nsIPresentationSessionTransportBuilder extends nsISupports {
  }

  export interface nsIWakeLockRef {
    readonly name: "nsIWakeLock";
    readonly number: "{e27e57ce-fa63-4035-b9ef-27c5dc0cc3ae}";
  }

  export interface nsIWakeLock extends nsISupports {

    readonly unlock: () => void;
  }

  export interface nsIUrlClassifierInfoRef {
    readonly name: "nsIUrlClassifierInfo";
    readonly number: "{411bbff4-1b88-4687-aa36-e2bbdd93f6e8}";
  }

  type nsIUrlClassifierInfoFunction = (table: IDLACString, callback: (nsIUrlClassifierGetCacheCallback | null)) => void;

  /**
   * Interface to query url-classifier information.
   */
  export interface nsIUrlClassifierInfo extends nsISupports {

    /**
     * An asynchronous call to return cache information for the table.
     */
    readonly getCacheInfo: (table: IDLACString, callback: (nsIUrlClassifierGetCacheCallback | null)) => void;
  }

  export interface imgIContainerCallbackRef {
    readonly name: "imgIContainerCallback";
    readonly number: "{f195772c-a4c0-47ae-80ca-211e001c67be}";
  }

  type imgIContainerCallbackFunction = (aImage: (imgIContainer | null), aStatus: number) => void;

  export interface imgIContainerCallback extends nsISupports {

    /**
     * This is a companion interface for nsIAsyncInputStream::asyncWait.
     */
    readonly onImageReady: (aImage: (imgIContainer | null), aStatus: number) => void;
  }

  export interface nsIDOMXULButtonElementRef {
    readonly name: "nsIDOMXULButtonElement";
    readonly number: "{6ed53cfb-9e59-424c-af8d-e74582381951}";
  }

  export interface nsIDOMXULButtonElement extends nsIDOMXULControlElement {

    type: IDLAString;

    dlgType: IDLAString;

    open: boolean;

    checked: boolean;

    group: IDLAString;
  }

  export interface nsIXULChromeRegistryRef {
    readonly name: "nsIXULChromeRegistry";
    readonly number: "{93251ddf-5e85-4172-ac2a-31780562974f}";
  }

  export interface nsIXULChromeRegistry extends nsIChromeRegistry {

    readonly getSelectedLocale: (packageName: IDLACString, asBCP47?: boolean) => IDLACString;

    readonly isLocaleRTL: (package: IDLACString) => boolean;

    /**
     * Installable skin XBL is not always granted the same privileges as other
     * chrome. This asks the chrome registry whether scripts are allowed to be
     * run for a particular chrome URI. Do not pass non-chrome URIs to this
     * method.
     */
    readonly allowScriptsForPackage: (url: (nsIURI | null)) => boolean;

    /**
     * Content should only be allowed to load chrome JS from certain packages.
     * This method reflects the contentaccessible flag on packages.
     * Do not pass non-chrome URIs to this method.
     */
    readonly allowContentToAccess: (url: (nsIURI | null)) => boolean;

    /**
     * Returns true if the passed chrome URL is allowed to be loaded in a remote
     * process. This reflects the remoteenabled flag on packages.
     * Do not pass non-chrome URIs to this method.
     */
    readonly canLoadURLRemotely: (url: (nsIURI | null)) => boolean;

    /**
     * Returns true if the passed chrome URL must be loaded in a remote process.
     * This reflects the remoterequired flag on packages.
     * Do not pass non-chrome URIs to this method.
     */
    readonly mustLoadURLRemotely: (url: (nsIURI | null)) => boolean;
  }

  export interface nsIDirectoryServiceProvider2Ref {
    readonly name: "nsIDirectoryServiceProvider2";
    readonly number: "{2f977d4b-5485-11d4-87e2-0010a4e75ef2}";
  }

  /**
   * nsIDirectoryServiceProvider2
   *
   * An extension of nsIDirectoryServiceProvider which allows
   * multiple files to be returned for the given key.
   */
  export interface nsIDirectoryServiceProvider2 extends nsIDirectoryServiceProvider {

    /**
     * getFiles
     *
     * Directory Service calls this when it gets a request for
     * a prop and the requested type is nsISimpleEnumerator.
     *
     * @param prop         The symbolic name of the file list.
     *
     * @return             An enumerator for a list of file locations.
     *                     The elements in the enumeration are nsIFile
     * @returnCode         NS_SUCCESS_AGGREGATE_RESULT if this result should be
     *                     aggregated with other "lower" providers.
     */
    readonly getFiles: (prop: string) => (nsISimpleEnumerator | null);
  }

  export interface nsILoginManagerRef {
    readonly name: "nsILoginManager";
    readonly number: "{38c7f6af-7df9-49c7-b558-2776b24e6cc1}";
  }

  export interface nsILoginManager extends nsISupports {

    /**
     * This promise is resolved when initialization is complete, and is rejected
     * in case initialization failed.  This includes the initial loading of the
     * login data as well as any migration from previous versions.
     *
     * Calling any method of nsILoginManager before this promise is resolved
     * might trigger the synchronous initialization fallback.
     */
    readonly initializationPromise: IDLPromise;

    /**
     * Store a new login in the login manager.
     *
     * @param aLogin
     *        The login to be added.
     * @return a clone of the login info with the guid set (even if it was not provided)
     *
     * Default values for the login's nsILoginMetaInfo properties will be
     * created. However, if the caller specifies non-default values, they will
     * be used instead.
     */
    readonly addLogin: (aLogin: (nsILoginInfo | null)) => (nsILoginInfo | null);

    /**
     * Like addLogin, but asynchronous and for many logins.
     *
     * @param aLogins
     *        A JS Array of nsILoginInfos to add.
     * @return A promise which resolves with a JS Array of cloned logins with
     *         the guids set.
     *
     * Default values for each login's nsILoginMetaInfo properties will be
     * created. However, if the caller specifies non-default values, they will
     * be used instead.
     */
    readonly addLogins: (aLogins: IDLjsval) => IDLPromise;

    /**
     * Remove a login from the login manager.
     *
     * @param aLogin
     *        The login to be removed.
     *
     * The specified login must exactly match a stored login. However, the
     * values of any nsILoginMetaInfo properties are ignored.
     */
    readonly removeLogin: (aLogin: (nsILoginInfo | null)) => void;

    /**
     * Modify an existing login in the login manager.
     *
     * @param oldLogin
     *        The login to be modified.
     * @param newLoginData
     *        The new login values (either a nsILoginInfo or nsIProperyBag)
     *
     * If newLoginData is a nsILoginInfo, all of the old login's nsILoginInfo
     * properties are changed to the values from newLoginData (but the old
     * login's nsILoginMetaInfo properties are unmodified).
     *
     * If newLoginData is a nsIPropertyBag, only the specified properties
     * will be changed. The nsILoginMetaInfo properties of oldLogin can be
     * changed in this manner.
     *
     * If the propertybag contains an item named "timesUsedIncrement", the
     * login's timesUsed property will be incremented by the item's value.
     */
    readonly modifyLogin: (oldLogin: (nsILoginInfo | null), newLoginData: (nsISupports | null)) => void;

    /**
     * Remove all logins known to login manager.
     *
     * The browser sanitization feature allows the user to clear any stored
     * passwords. This interface allows that to be done without getting each
     * login first (which might require knowing the master password).
     */
    readonly removeAllLogins: () => void;

    /**
     * Fetch all logins in the login manager. An array is always returned;
     * if there are no logins the array is empty.
     *
     * @return An array of nsILoginInfo objects.
     */
    readonly getAllLogins: () => (nsILoginInfo | null)[];

    /**
     * Like getAllLogins, but asynchronous. This method is faster when large
     * amounts of logins are present since it will handle decryption in one batch.
     *
     * @return A promise which resolves with a JS Array of nsILoginInfo objects.
     */
    readonly getAllLoginsAsync: () => IDLPromise;

    /**
     * Obtain a list of all origins for which password saving is disabled.
     *
     * @return An array of origin strings. For example: ["https://www.site.com"].
     */
    readonly getAllDisabledHosts: () => IDLAString[];

    /**
     * Check to see if saving logins has been disabled for an origin.
     *
     * @param aHost
     *        The origin to check. For example: "http://foo.com".
     */
    readonly getLoginSavingEnabled: (aHost: IDLAString) => boolean;

    /**
     * Disable (or enable) storing logins for the specified origin. When
     * disabled, the login manager will not prompt to store logins for
     * that origin. Existing logins are not affected.
     *
     * @param aHost
     *        The origin to set. For example: "http://foo.com".
     * @param isEnabled
     *        Specify if saving logins should be enabled (true) or
     *        disabled (false)
     */
    readonly setLoginSavingEnabled: (aHost: IDLAString, isEnabled: boolean) => void;

    /**
     * Search for logins matching the specified criteria. Called when looking
     * for logins that might be applicable to a form or authentication request.
     *
     * @param aOrigin
     *        The origin to restrict searches to. For example: "http://www.site.com".
     *        To find logins for a given nsIURI, you would typically pass in
     *        its prePath (excluding userPass).
     * @param aActionOrigin
     *        For form logins, this argument should be the origin to which the
     *        form will be submitted, not the whole URL.
     *        For HTTP auth. logins, specify null.
     *        An empty string ("") will match any value (except null).
     * @param aHttpRealm
     *        For HTTP auth. logins, this argument should be the HTTP Realm
     *        for which the login applies. This is obtained from the
     *        WWW-Authenticate header. See RFC2617. For form logins,
     *        specify null.
     *        An empty string ("") will match any value (except null).
     * @return An array of nsILoginInfo objects.
     */
    readonly findLogins: (aOrigin: IDLAString, aActionOrigin: IDLAString, aHttpRealm: IDLAString) => (nsILoginInfo | null)[];

    /**
     * Search for logins matching the specified criteria, as with
     * findLogins(). This interface only returns the number of matching
     * logins (and not the logins themselves), which allows a caller to
     * check for logins without causing the user to be prompted for a master
     * password to decrypt the logins.
     *
     * @param aOrigin
     *        The origin to restrict searches to. Specify an empty string
     *        to match all origins. A null value will not match any logins, and
     *        will thus always return a count of 0.
     * @param aActionOrigin
     *        The origin to which a form login will be submitted. To match any
     *        form login, specify an empty string. To not match any form
     *        login, specify null.
     * @param aHttpRealm
     *        The HTTP Realm for which the login applies. To match logins for
     *        any realm, specify an empty string. To not match logins for any
     *        realm, specify null.
     */
    readonly countLogins: (aOrigin: IDLAString, aActionOrigin: IDLAString, aHttpRealm: IDLAString) => number;

    /**
     * Asynchonously search for logins in the login manager. The Promise always
     * resolves to an array; if there are no logins the array is empty.
     *
     * @param {object} matchData
     *        The data used to search as a JS object. This does not follow the same
     *        requirements as findLogins for those fields. Wildcard matches are
     *        simply not specified.
     * @return A promise resolving to an array of nsILoginInfo objects.
     */
    readonly searchLoginsAsync: (matchData: IDLjsval) => IDLPromise;

    /**
     * Search for logins in the login manager. An array is always returned;
     * if there are no logins the array is empty.
     * @deprecated New code should use `searchLoginsAsync`.
     *             Only autocomplete, prompt, and test code still use this.
     *
     * @param matchData
     *        The data used to search. This does not follow the same
     *        requirements as findLogins for those fields. Wildcard matches are
     *        simply not specified.
     * @return An array of nsILoginInfo objects.
     */
    readonly searchLogins: (matchData: (nsIPropertyBag | null)) => (nsILoginInfo | null)[];

    /**
     * True when a master password prompt is being displayed.
     */
    readonly uiBusy: boolean;

    /**
     * True when the master password has already been entered, and so a caller
     * can ask for decrypted logins without triggering a prompt.
     */
    readonly isLoggedIn: boolean;
  }

  export interface nsIWebPageDescriptorRef {
    readonly name: "nsIWebPageDescriptor";
    readonly number: "{6f30b676-3710-4c2c-80b1-0395fb26516e}";

    DISPLAY_AS_SOURCE: 1;

    DISPLAY_NORMAL: 2;
  }

  /**
   * The nsIWebPageDescriptor interface allows content being displayed in one
   * window to be loaded into another window without refetching it from the
   * network.
   */
  export interface nsIWebPageDescriptor extends nsISupports {

    /**
     * Tells the object to load the page specified by the page descriptor
     *
     * @throws NS_ERROR_FAILURE -
     */
    readonly loadPage: (aPageDescriptor: (nsISupports | null), aDisplayType: number) => void;

    /**
     * Retrieves the page descriptor for the curent document.
     */
    readonly currentDescriptor: (nsISupports | null);
  }

  export interface nsIAsyncStreamCopierRef {
    readonly name: "nsIAsyncStreamCopier";
    readonly number: "{5a19ca27-e041-4aca-8287-eb248d4c50c0}";
  }

  export interface nsIAsyncStreamCopier extends nsIRequest {

    /**
     * Initialize the stream copier.
     *
     * @param aSource
     *        contains the data to be copied.
     * @param aSink
     *        specifies the destination for the data.
     * @param aTarget
     *        specifies the thread on which the copy will occur.  a null value
     *        is permitted and will cause the copy to occur on an unspecified
     *        background thread.
     * @param aSourceBuffered
     *        true if aSource implements ReadSegments.
     * @param aSinkBuffered
     *        true if aSink implements WriteSegments.
     * @param aChunkSize
     *        specifies how many bytes to read/write at a time.  this controls
     *        the granularity of the copying.  it should match the segment size
     *        of the "buffered" streams involved.
     * @param aCloseSource
     *        true if aSource should be closed after copying.
     * @param aCloseSink
     *        true if aSink should be closed after copying.
     *
     * NOTE: at least one of the streams must be buffered. If you do not know
     * whether your streams are buffered, you should use nsIAsyncStreamCopier2
     * instead.
     */
    readonly init: (aSource: (nsIInputStream | null), aSink: (nsIOutputStream | null), aTarget: (nsIEventTarget | null), aSourceBuffered: boolean, aSinkBuffered: boolean, aChunkSize: number, aCloseSource: boolean, aCloseSink: boolean) => void;

    /**
     * asyncCopy triggers the start of the copy.  The observer will be notified
     * when the copy completes.
     *
     * @param aObserver
     *        receives notifications.
     * @param aObserverContext
     *        passed to observer methods.
     */
    readonly asyncCopy: (aObserver: (nsIRequestObserver | null), aObserverContext: (nsISupports | null)) => void;
  }

  export interface nsIPresentationControlServiceRef {
    readonly name: "nsIPresentationControlService";
    readonly number: "{55d6b605-2389-4aae-a8fe-60d4440540ea}";
  }

  /**
   * Presentation control service which can be used for both presentation
   * control client and server.
   */
  export interface nsIPresentationControlService extends nsISupports {

    /**
     * This method initializes server socket. Caller should set listener and
     * monitor onServerReady event to get the correct server info.
     * @param   aEncrypted
     *          True for using TLS control channel.
     * @param   aPort
     *          The port of the server socket.  Pass 0 or opt-out to indicate no
     *          preference, and a port will be selected automatically.
     * @throws  NS_ERROR_FAILURE if the server socket has been inited or the
     *          server socket can not be inited.
     */
    readonly startServer: (aEncrypted: boolean, aPort?: number) => void;

    /**
     * Request connection to designated remote presentation control receiver.
     * @param   aDeviceInfo
     *          The remtoe device info for establish connection.
     * @returns The control channel for this session.
     * @throws  NS_ERROR_FAILURE if the Id hasn't been inited.
     */
    readonly connect: (aDeviceInfo: (nsITCPDeviceInfo | null)) => (nsIPresentationControlChannel | null);

    /**
     * Check the compatibility to remote presentation control server.
     * @param  aVersion
     *         The version of remote server.
     */
    readonly isCompatibleServer: (aVersion: number) => boolean;

    /**
     * Close server socket and call |listener.onClose(NS_OK)|
     */
    readonly close: () => void;

    /**
     * Get the listen port of the TCP socket, valid after the server is ready.
     * 0 indicates the server socket is not ready or is closed.
     */
    readonly port: number;

    /**
     * The protocol version implemented by this server.
     */
    readonly version: number;

    /**
     * The id of the TCP presentation server. |requestSession| won't
     * work until the |id| is set.
     */
    id: IDLAUTF8String;

    /**
     * The fingerprint of the TLS server certificate.
     * Empty string indicates the server is not ready or not encrypted.
     */
    certFingerprint: IDLAUTF8String;

    /**
     * The listener for handling events of this presentation control server.
     * Listener must be provided before invoke |startServer| and |close|.
     */
    listener: (nsIPresentationControlServerListener | null);
  }

  export interface nsIHttpProtocolHandlerRef {
    readonly name: "nsIHttpProtocolHandler";
    readonly number: "{c48126d9-2ddd-485b-a51a-378e917e75f8}";
  }

  export interface nsIHttpProtocolHandler extends nsIProxiedProtocolHandler {

    /**
     * Get the HTTP advertised user agent string.
     */
    readonly userAgent: IDLACString;

    /**
     * Get the application name.
     *
     * @return The name of this application (eg. "Mozilla").
     */
    readonly appName: IDLACString;

    /**
     * Get the application version string.
     *
     * @return The complete version (major and minor) string. (eg. "5.0")
     */
    readonly appVersion: IDLACString;

    /**
     * Get the current platform.
     *
     * @return The platform this application is running on
     *         (eg. "Windows", "Macintosh", "X11")
     */
    readonly platform: IDLACString;

    /**
     * Get the current oscpu.
     *
     * @return The oscpu this application is running on
     */
    readonly oscpu: IDLACString;

    /**
     * Get the application comment misc portion.
     */
    readonly misc: IDLACString;

    /**
     * Get the Alt-Svc cache keys (used for testing).
     */
    readonly altSvcCacheKeys: IDLACString[];

    /**
     * This function is used to ensure HSTS data storage is ready to read after
     * the returned promise is resolved.
     * Note that this function should only used for testing.
     * See bug 1521729 for more details.
     */
    readonly EnsureHSTSDataReady: () => IDLPromise;
  }

  export interface nsIScriptSecurityManagerRef {
    readonly name: "nsIScriptSecurityManager";
    readonly number: "{51daad87-3a0c-44cc-b620-7356801c9022}";

    /**
     * Default CheckLoadURI permissions
     */
    STANDARD: 0;

    LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT: 1;

    ALLOW_CHROME: 2;

    DISALLOW_INHERIT_PRINCIPAL: 4;

    DISALLOW_SCRIPT_OR_DATA: 4;

    DISALLOW_SCRIPT: 8;

    DONT_REPORT_ERRORS: 16;

    DEFAULT_USER_CONTEXT_ID: 0;

    DEFAULT_PRIVATE_BROWSING_ID: 0;
  }

  export interface nsIScriptSecurityManager extends nsISupports {

    /**
     * Check that content with principal aPrincipal can load "uri".
     *
     * Will return error code NS_ERROR_DOM_BAD_URI if the load request
     * should be denied.
     *
     * @param aPrincipal the principal identifying the actor causing the load
     * @param uri the URI that is being loaded
     * @param flags the permission set, see above
     * @param innerWindowID the window ID for error reporting.  If this is 0
     *        (which happens automatically if it's not passed from JS), errors
     *        will only appear in the browser console, not window-associated
     *        consoles like the web console.
     */
    readonly checkLoadURIWithPrincipal: (aPrincipal: (nsIPrincipal | null), uri: (nsIURI | null), flags: number, innerWindowID?: number) => void;

    /**
     * Similar to checkLoadURIWithPrincipal but there are two differences:
     *
     * 1) The URI is a string, not a URI object.
     * 2) This function assumes that the URI may still be subject to fixup (and
     * hence will check whether fixed-up versions of the URI are allowed to
     * load as well); if any of the versions of this URI is not allowed, this
     * function will return error code NS_ERROR_DOM_BAD_URI.
     */
    readonly checkLoadURIStrWithPrincipal: (aPrincipal: (nsIPrincipal | null), uri: IDLAUTF8String, flags: number) => void;

    /**
     * Returns true if the URI is from a domain that is allow-listed through
     * prefs to be allowed to use file:// URIs.
     * @param aUri the URI to be tested
     */
    readonly inFileURIAllowlist: (aUri: (nsIURI | null)) => boolean;

    /**
     * Return the all-powerful system principal.
     */
    readonly getSystemPrincipal: () => (nsIPrincipal | null);

    /**
     * Returns a principal that has the OriginAttributes of the load context.
     * @param loadContext to get the OriginAttributes from.
     */
    readonly getLoadContextContentPrincipal: (uri: (nsIURI | null), loadContext: (nsILoadContext | null)) => (nsIPrincipal | null);

    /**
     * Returns a principal that has the OriginAttributes of the docshell.
     * @param docShell to get the OriginAttributes from.
     */
    readonly getDocShellContentPrincipal: (uri: (nsIURI | null), docShell: (nsIDocShell | null)) => (nsIPrincipal | null);

    /**
     * If this is a content principal, return a copy with different
     * origin attributes.
     */
    readonly principalWithOA: (principal: (nsIPrincipal | null), originAttributes: IDLjsval) => (nsIPrincipal | null);

    /**
     * Returns a principal whose origin is composed of |uri| and |originAttributes|.
     * See nsIPrincipal.idl for a description of origin attributes, and
     * ChromeUtils.webidl for a list of origin attributes and their defaults.
     */
    readonly createContentPrincipal: (uri: (nsIURI | null), originAttributes: IDLjsval) => (nsIPrincipal | null);

    /**
     * Returns a principal whose origin is the one we pass in.
     * See nsIPrincipal.idl for a description of origin attributes, and
     * ChromeUtils.webidl for a list of origin attributes and their defaults.
     */
    readonly createContentPrincipalFromOrigin: (origin: IDLACString) => (nsIPrincipal | null);

    /**
     * Takes a principal and returns a string representation of it or a nullptr if it can't be serialized.
     * Example output: `{"1": {"0": "https://mozilla.com", "2": "^privateBrowsingId=1"}}`
     */
    readonly principalToJSON: (principal: (nsIPrincipal | null)) => IDLACString;

    /**
     * Takes a string of the following format:
     * `{"1": {"0": "https://mozilla.com", "2": "^privateBrowsingId=1"}}`
     * and turns it into a principal or a nullptr on error.
     */
    readonly JSONToPrincipal: (json: IDLACString) => (nsIPrincipal | null);

    /**
     * Returns a unique nonce principal with |originAttributes|.
     * See nsIPrincipal.idl for a description of origin attributes, and
     * ChromeUtils.webidl for a list of origin attributes and their defaults.
     */
    readonly createNullPrincipal: (originAttributes: IDLjsval) => (nsIPrincipal | null);

    /**
     * Returns OK if aSourceURI and target have the same "origin"
     * (scheme, host, and port).
     * ReportError flag suppresses error reports for functions that
     * don't need reporting.
     * FromPrivateWindow indicates whether the error occurs in a private
     * window or not.
     */
    readonly checkSameOriginURI: (aSourceURI: (nsIURI | null), aTargetURI: (nsIURI | null), reportError: boolean, fromPrivateWindow: boolean) => void;

    /**
     * Get the principal for the given channel.  This will typically be the
     * channel owner if there is one, and the content principal for the
     * channel's URI otherwise.  aChannel must not be null.
     */
    readonly getChannelResultPrincipal: (aChannel: (nsIChannel | null)) => (nsIPrincipal | null);

    /**
     * Get the storage principal for the given channel.  This is basically the
     * same of getChannelResultPrincipal() execept for trackers, where we
     * return a principal with a different OriginAttributes.
     */
    readonly getChannelResultStoragePrincipal: (aChannel: (nsIChannel | null)) => (nsIPrincipal | null);

    /**
     * This method does getChannelResultPrincipal() +
     * getChannelResultStoragePrincipal().
     * This method is mainly done for Document::Reset(). There are no other
     * reasons to use this method.
     */
    readonly getChannelResultPrincipals: (aChannel: (nsIChannel | null), aPrincipal: Out<(nsIPrincipal | null)>, aStoragePrincipal: Out<(nsIPrincipal | null)>) => void;

    /**
     * Get the content principal for the channel's URI.
     * aChannel must not be null.
     */
    readonly getChannelURIPrincipal: (aChannel: (nsIChannel | null)) => (nsIPrincipal | null);

    /**
     * Per-domain controls to enable and disable script. This system is designed
     * to be used by at most one consumer, and enforces this with its semantics.
     *
     * Initially, domainPolicyActive is false. When activateDomainPolicy() is
     * invoked, domainPolicyActive becomes true, and subsequent calls to
     * activateDomainPolicy() will fail until deactivate() is invoked on the
     * nsIDomainPolicy returned from activateDomainPolicy(). At this point,
     * domainPolicyActive becomes false again, and a new consumer may acquire
     * control of the system by invoking activateDomainPolicy().
     */
    readonly activateDomainPolicy: () => (nsIDomainPolicy | null);

    readonly domainPolicyActive: boolean;

    /**
     * Query mechanism for the above policy.
     *
     * If domainPolicyEnabled is false, this simply returns the current value
     * of javascript.enabled. Otherwise, it returns the same value, but taking
     * the various blocklist/allowlist exceptions into account.
     */
    readonly policyAllowsScript: (aDomain: (nsIURI | null)) => boolean;
  }

  export interface nsIIncrementalStreamLoaderObserverRef {
    readonly name: "nsIIncrementalStreamLoaderObserver";
    readonly number: "{07c3d2cc-5454-4618-9f4f-cd93de9504a4}";
  }

  export interface nsIIncrementalStreamLoaderObserver extends nsISupports {

    /**
     * Called when new data has arrived on the stream.
     *
     * @param loader the stream loader that loaded the stream.
     * @param ctxt the context parameter of the underlying channel
     * @param dataLength the length of the new data received
     * @param data the contents of the new data received.
     *
     * This method will always be called asynchronously by the
     * nsIIncrementalStreamLoader involved, on the thread that called the
     * loader's init() method.
     *
     * If the observer wants to not accumulate all or portional of the data in
     * the internal buffer, the consumedLength shall be set to the value of
     * the dataLength or less. By default the consumedLength value is assumed 0.
     * The data and dataLength reflect the non-consumed data and will be
     * accumulated if consumedLength is not set.
     *
     * In comparison with onStreamComplete(), the data buffer cannot be
     * adopted if this method returns NS_SUCCESS_ADOPTED_DATA.
     */
    readonly onIncrementalData: (loader: (nsIIncrementalStreamLoader | null), ctxt: (nsISupports | null), dataLength: number, data: number[], consumedLength: InOut<number>) => void;

    /**
     * Called when the entire stream has been loaded.
     *
     * @param loader the stream loader that loaded the stream.
     * @param ctxt the context parameter of the underlying channel
     * @param status the status of the underlying channel
     * @param resultLength the length of the data loaded
     * @param result the data
     *
     * This method will always be called asynchronously by the
     * nsIIncrementalStreamLoader involved, on the thread that called the
     * loader's init() method.
     *
     * If the observer wants to take over responsibility for the
     * data buffer (result), it returns NS_SUCCESS_ADOPTED_DATA
     * in place of NS_OK as its success code. The loader will then
     * "forget" about the data and not free() it after
     * onStreamComplete() returns; observer must call free()
     * when the data is no longer required.
     */
    readonly onStreamComplete: (loader: (nsIIncrementalStreamLoader | null), ctxt: (nsISupports | null), status: number, resultLength: number) => void;
  }

  export interface nsICacheMetaDataVisitorRef {
    readonly name: "nsICacheMetaDataVisitor";
    readonly number: "{22f9a49c-3cf8-4c23-8006-54efb11ac562}";
  }

  export interface nsICacheMetaDataVisitor extends nsISupports {

    /**
     * Called for each key/value pair in the meta data for a cache entry
     */
    readonly visitMetaDataElement: (key: string, value: string) => boolean;
  }

  export interface nsIStorageStreamRef {
    readonly name: "nsIStorageStream";
    readonly number: "{44a200fe-6c2b-4b41-b4e3-63e8c14e7c0d}";
  }

  /**
   * The nsIStorageStream interface maintains an internal data buffer that can be
   * filled using a single output stream.  One or more independent input streams
   * can be created to read the data from the buffer non-destructively.
   */
  export interface nsIStorageStream extends nsISupports {

    /**
     *
     * Initialize the stream, setting up the amount of space that will be
     * allocated for the stream's backing-store.
     *
     * @param segmentSize
     *        Size of each segment. Must be a power of two.
     * @param maxSize
     *        Maximum total size of this stream. length will always be less
     *        than or equal to this value. Passing UINT32_MAX is safe.
     */
    readonly init: (segmentSize: number, maxSize: number) => void;

    /**
     * Get a reference to the one and only output stream for this instance.
     * The zero-based startPosition argument is used is used to set the initial
     * write cursor position.  The startPosition cannot be set larger than the
     * current buffer length.  Calling this method has the side-effect of
     * truncating the internal buffer to startPosition bytes.
     */
    readonly getOutputStream: (startPosition: number) => (nsIOutputStream | null);

    /**
     * Create a new input stream to read data (written by the singleton output
     * stream) from the internal buffer.  Multiple, independent input streams
     * can be created.
     */
    readonly newInputStream: (startPosition: number) => (nsIInputStream | null);

    /**
     * The length attribute indicates the total number of bytes stored in the
     * nsIStorageStream internal buffer, regardless of any consumption by input
     * streams.  Assigning to the length field can be used to truncate the
     * buffer data, but can not be used when either the instance's output
     * stream is in use.
     *
     * @See #writeInProgress */
    length: number;

    /**
     * True, when output stream has not yet been Close'ed
     */
    readonly writeInProgress: boolean;
  }

  export interface nsISearchParseSubmissionResultRef {
    readonly name: "nsISearchParseSubmissionResult";
    readonly number: "{0dc93e51-a7bf-4a16-862d-4b3469ff6206}";
  }

  export interface nsISearchParseSubmissionResult extends nsISupports {

    /**
     * The search engine associated with the URL passed in to
     * nsISearchEngine::parseSubmissionURL, or null if the URL does not represent
     * a search submission.
     */
    readonly engine: (nsISearchEngine | null);

    /**
     * String containing the sought terms.  This can be an empty string in case no
     * terms were specified or the URL does not represent a search submission.
     */
    readonly terms: IDLAString;

    /**
     * The offset of the string |terms| in the URL passed in to
     * nsISearchEngine::parseSubmissionURL, or -1 if the URL does not represent
     * a search submission.
     */
    readonly termsOffset: number;

    /**
     * The length of the |terms| in the original encoding of the URL passed in to
     * nsISearchEngine::parseSubmissionURL. If the search term in the original
     * URL is encoded then this will be bigger than |terms.length|.
     */
    readonly termsLength: number;
  }

  export interface nsIThreadRef {
    readonly name: "nsIThread";
    readonly number: "{5801d193-29d1-4964-a6b7-70eb697ddf2b}";
  }

  /**
   * This interface provides a high-level abstraction for an operating system
   * thread.
   *
   * Threads have a built-in event queue, and a thread is an event target that
   * can receive nsIRunnable objects (events) to be processed on the thread.
   *
   * See nsIThreadManager for the API used to create and locate threads.
   */
  export interface nsIThread extends nsISerialEventTarget {

    /**
     * Shutdown the thread.  This method prevents further dispatch of events to
     * the thread, and it causes any pending events to run to completion before
     * the thread joins (see PR_JoinThread) with the current thread.  During this
     * method call, events for the current thread may be processed.
     *
     * This method MAY NOT be executed from the thread itself.  Instead, it is
     * meant to be executed from another thread (usually the thread that created
     * this thread or the main application thread).  When this function returns,
     * the thread will be shutdown, and it will no longer be possible to dispatch
     * events to the thread.
     *
     * @throws NS_ERROR_UNEXPECTED
     *   Indicates that this method was erroneously called when this thread was
     *   the current thread, that this thread was not created with a call to
     *   nsIThreadManager::NewThread, or if this method was called more than once
     *   on the thread object.
     */
    readonly shutdown: () => void;

    /**
     * This method may be called to determine if there are any events ready to be
     * processed.  It may only be called when this thread is the current thread.
     *
     * Because events may be added to this thread by another thread, a "false"
     * result does not mean that this thread has no pending events.  It only
     * means that there were no pending events when this method was called.
     *
     * @returns
     *   A boolean value that if "true" indicates that this thread has one or
     *   more pending events.
     *
     * @throws NS_ERROR_UNEXPECTED
     *   Indicates that this method was erroneously called when this thread was
     *   not the current thread.
     */
    readonly hasPendingEvents: () => boolean;

    /**
     * Similar to above, but checks only possible high priority queue.
     */
    readonly hasPendingHighPriorityEvents: () => boolean;

    /**
     * Process the next event.  If there are no pending events, then this method
     * may wait -- depending on the value of the mayWait parameter -- until an
     * event is dispatched to this thread.  This method is re-entrant but may
     * only be called if this thread is the current thread.
     *
     * @param mayWait
     *   A boolean parameter that if "true" indicates that the method may block
     *   the calling thread to wait for a pending event.
     *
     * @returns
     *   A boolean value that if "true" indicates that an event was processed.
     *
     * @throws NS_ERROR_UNEXPECTED
     *   Indicates that this method was erroneously called when this thread was
     *   not the current thread.
     */
    readonly processNextEvent: (mayWait: boolean) => boolean;

    /**
     * Shutdown the thread asynchronously.  This method immediately prevents
     * further dispatch of events to the thread, and it causes any pending events
     * to run to completion before this thread joins with the current thread.
     *
     * UNLIKE shutdown() this does not process events on the current thread.
     * Instead it merely ensures that the current thread continues running until
     * this thread has shut down.
     *
     * This method MAY NOT be executed from the thread itself.  Instead, it is
     * meant to be executed from another thread (usually the thread that created
     * this thread or the main application thread).  When this function returns,
     * the thread will continue running until it exhausts its event queue.
     *
     * @throws NS_ERROR_UNEXPECTED
     *   Indicates that this method was erroneously called when this thread was
     *   the current thread, that this thread was not created with a call to
     *   nsIThreadManager::NewThread, or if this method was called more than once
     *   on the thread object.
     */
    readonly asyncShutdown: () => void;

    /**
     * Use this attribute to dispatch runnables to the thread. Eventually, the
     * eventTarget attribute will be the only way to dispatch events to a
     * thread--nsIThread will no longer inherit from nsIEventTarget.
     */
    readonly eventTarget: (nsIEventTarget | null);
  }

  export interface nsISerializableRef {
    readonly name: "nsISerializable";
    readonly number: "{91cca981-c26d-44a8-bebe-d9ed4891503a}";
  }

  export interface nsISerializable extends nsISupports {

    /**
     * Initialize the object implementing nsISerializable, which must have
     * been freshly constructed via CreateInstance.  All data members that
     * can't be set to default values must have been serialized by write,
     * and should be read from aInputStream in the same order by this method.
     */
    readonly read: (aInputStream: (nsIObjectInputStream | null)) => void;

    /**
     * Serialize the object implementing nsISerializable to aOutputStream, by
     * writing each data member that must be recovered later to reconstitute
     * a working replica of this object, in a canonical member and byte order,
     * to aOutputStream.
     *
     * NB: a class that implements nsISerializable *must* also implement
     * nsIClassInfo, in particular nsIClassInfo::GetClassID.
     */
    readonly write: (aOutputStream: (nsIObjectOutputStream | null)) => void;
  }

  export interface nsIZipReaderCacheRef {
    readonly name: "nsIZipReaderCache";
    readonly number: "{31179807-9fcd-46c4-befa-2ade209a394b}";
  }

  export interface nsIZipReaderCache extends nsISupports {

    /**
     * Initializes a new zip reader cache.
     * @param cacheSize - the number of released entries to maintain before
     *   beginning to throw some out (note that the number of outstanding
     *   entries can be much greater than this number -- this is the count
     *   for those otherwise unused entries)
     */
    readonly init: (cacheSize: number) => void;

    /**
     * Returns a (possibly shared) nsIZipReader for an nsIFile.
     *
     * If the zip reader for given file is not in the cache, a new zip reader
     * is created, initialized, and opened (see nsIZipReader::init and
     * nsIZipReader::open). Otherwise the previously created zip reader is
     * returned.
     *
     * @note If someone called close() on the shared nsIZipReader, this method
     *       will return the closed zip reader.
     */
    readonly getZip: (zipFile: (nsIFile | null)) => (nsIZipReader | null);

    /**
     * Like getZip(), returns a (possibly shared) nsIZipReader for an nsIFile,
     * but if a zip reader for the given file is not in the cache, returns
     * error NS_ERROR_CACHE_KEY_NOT_FOUND rather than creating a new reader.
     *
     * @note If someone called close() on the shared nsIZipReader, this method
     *       will return the closed zip reader.
     */
    readonly getZipIfCached: (zipFile: (nsIFile | null)) => (nsIZipReader | null);

    /**
     * returns true if this zipreader already has this file cached
     */
    readonly isCached: (zipFile: (nsIFile | null)) => boolean;

    /**
     * Returns a (possibly shared) nsIZipReader for a zip inside another zip
     *
     * See getZip
     */
    readonly getInnerZip: (zipFile: (nsIFile | null), zipEntry: IDLAUTF8String) => (nsIZipReader | null);
  }

  export interface nsIAddonContentPolicyRef {
    readonly name: "nsIAddonContentPolicy";
    readonly number: "{7a4fe60b-9131-45f5-83f3-dc63b5d71a5d}";
  }

  /**
   * This interface exposes functionality related to add-on content policy
   * enforcement.
   */
  export interface nsIAddonContentPolicy extends nsISupports {

    /**
     * Checks a custom content security policy string, to ensure that it meets
     * minimum security requirements. Returns null for valid policies, or a
     * string describing the error for invalid policies.
     */
    readonly validateAddonCSP: (aPolicyString: IDLAString) => IDLAString;
  }

  export interface nsIURLParserRef {
    readonly name: "nsIURLParser";
    readonly number: "{78c5d19f-f5d2-4732-8d3d-d5a7d7133bc0}";
  }

  /**
   * nsIURLParser specifies the interface to an URL parser that attempts to
   * follow the definitions of RFC 2396.
   */
  export interface nsIURLParser extends nsISupports {

    /**
     * The string to parse in the following methods may be given as a null
     * terminated string, in which case the length argument should be -1.
     *
     * Out parameters of the following methods are all optional (ie. the caller
     * may pass-in a NULL value if the corresponding results are not needed).
     * Signed out parameters may hold a value of -1 if the corresponding result
     * is not part of the string being parsed.
     *
     * The parsing routines attempt to be as forgiving as possible.
     */
    /**
     * ParseSpec breaks the URL string up into its 3 major components: a scheme,
     * an authority section (hostname, etc.), and a path.
     *
     * spec = <scheme>://<authority><path>
     */
    readonly parseURL: (spec: string, specLen: number, schemePos: Out<number>, schemeLen: Out<number>, authorityPos: Out<number>, authorityLen: Out<number>, pathPos: Out<number>, pathLen: Out<number>) => void;

    /**
     * ParseAuthority breaks the authority string up into its 4 components:
     * username, password, hostname, and hostport.
     *
     * auth = <username>:<password>@<hostname>:<port>
     */
    readonly parseAuthority: (authority: string, authorityLen: number, usernamePos: Out<number>, usernameLen: Out<number>, passwordPos: Out<number>, passwordLen: Out<number>, hostnamePos: Out<number>, hostnameLen: Out<number>, port: Out<number>) => void;

    /**
     * userinfo = <username>:<password>
     */
    readonly parseUserInfo: (userinfo: string, userinfoLen: number, usernamePos: Out<number>, usernameLen: Out<number>, passwordPos: Out<number>, passwordLen: Out<number>) => void;

    /**
     * serverinfo = <hostname>:<port>
     */
    readonly parseServerInfo: (serverinfo: string, serverinfoLen: number, hostnamePos: Out<number>, hostnameLen: Out<number>, port: Out<number>) => void;

    /**
     * ParsePath breaks the path string up into its 3 major components: a file path,
     * a query string, and a reference string.
     *
     * path = <filepath>?<query>#<ref>
     */
    readonly parsePath: (path: string, pathLen: number, filepathPos: Out<number>, filepathLen: Out<number>, queryPos: Out<number>, queryLen: Out<number>, refPos: Out<number>, refLen: Out<number>) => void;

    /**
     * ParseFilePath breaks the file path string up into: the directory portion,
     * file base name, and file extension.
     *
     * filepath = <directory><basename>.<extension>
     */
    readonly parseFilePath: (filepath: string, filepathLen: number, directoryPos: Out<number>, directoryLen: Out<number>, basenamePos: Out<number>, basenameLen: Out<number>, extensionPos: Out<number>, extensionLen: Out<number>) => void;

    /**
     * filename = <basename>.<extension>
     */
    readonly parseFileName: (filename: string, filenameLen: number, basenamePos: Out<number>, basenameLen: Out<number>, extensionPos: Out<number>, extensionLen: Out<number>) => void;
  }

  export interface imgILoaderRef {
    readonly name: "imgILoader";
    readonly number: "{e61377d2-910e-4c65-a64b-428d150e1fd1}";

    LOAD_CORS_ANONYMOUS: 65536;

    LOAD_CORS_USE_CREDENTIALS: 131072;
  }

  /**
   * imgILoader interface
   *
   * @author Stuart Parmenter <pavlov@netscape.com>
   * @version 0.3
   * @see imagelib2
   */
  export interface imgILoader extends nsISupports {

    /**
     * Start the load and decode of an image.
     * @param aURI the URI to load
     * @param aInitialDocumentURI the URI that 'initiated' the load -- used for
     *           3rd party cookie blocking
     * @param aReferrerInfo the referrer info to compute sending referrer.
     * @param aLoadingPrincipal the principal of the loading document
     * @param aLoadGroup Loadgroup to put the image load into
     * @param aObserver the observer (may be null)
     * @param aCX some random data
     * @param aLoadFlags Load flags for the request
     * @param aCacheKey cache key to use for a load if the original
     *                  image came from a request that had post data
     * @param aContentPolicyType [optional] the nsContentPolicyType to
     *                           use for this load. Defaults to
     *                           nsIContentPolicy::TYPE_IMAGE
     
     
     * ImageLib does NOT keep a strong ref to the observer; this prevents
     * reference cycles.  This means that callers of loadImage should
     * make sure to Cancel() the resulting request before the observer
     * goes away.
     */
    readonly loadImageXPCOM: (aURI: (nsIURI | null), aInitialDocumentURL: (nsIURI | null), aReferrerInfo: (nsIReferrerInfo | null), aLoadingPrincipal: (nsIPrincipal | null), aLoadGroup: (nsILoadGroup | null), aObserver: (imgINotificationObserver | null), aCX: (nsISupports | null), aLoadFlags: number, cacheKey: (nsISupports | null), aContentPolicyType?: number) => (imgIRequest | null);

    /**
     * Start the load and decode of an image.
     * @param aChannel the channel to load the image from.  This must
     *                 already be opened before this method is called, and there
     *                 must have been no OnDataAvailable calls for it yet.
     * @param aObserver the observer (may be null)
     * @param cx some random data
     * @param aListener [out]
     *        A listener that you must send the channel's notifications and data
     *        to.  Can be null, in which case imagelib has found a cached image
     *        and is not interested in the data. @aChannel will be canceled for
     *        you in this case.
     *
     * ImageLib does NOT keep a strong ref to the observer; this prevents
     * reference cycles.  This means that callers of loadImageWithChannel should
     * make sure to Cancel() the resulting request before the observer goes away.
     */
    readonly loadImageWithChannelXPCOM: (aChannel: (nsIChannel | null), aObserver: (imgINotificationObserver | null), cx: (nsISupports | null), aListener: Out<(nsIStreamListener | null)>) => (imgIRequest | null);
  }

  export interface nsIUrlClassifierUtilsRef {
    readonly name: "nsIUrlClassifierUtils";
    readonly number: "{e4f0e59c-b922-48b0-a7b6-1735c1f96fed}";
  }

  export interface nsIUrlClassifierUtils extends nsISupports {

    /**
     * Get the lookup string for a given URI.  This normalizes the hostname,
     * url-decodes the string, and strips off the protocol.
     *
     * @param uri URI to get the lookup key for.
     *
     * @returns String containing the canonicalized URI.
     */
    readonly getKeyForURI: (uri: (nsIURI | null)) => IDLACString;

    /**
     * Get the provider by table name.
     *
     * @param tableName The table name that we want to lookup
     *
     * @returns the provider name that the given table belongs.
     */
    readonly getProvider: (tableName: IDLACString) => IDLACString;

    /**
     * Get the provider used for Telemetry.
     * Because recording Telemetry will leak user-controlled strings,
     * only built-in providers should be recorded.
     *
     * @param tableName The table name that we want to lookup
     *
     * @returns the filtered provider for telemetry.
     *
     */
    readonly getTelemetryProvider: (tableName: IDLACString) => IDLACString;

    /**
     * Get the protocol version for the given provider.
     *
     * @param provider String the provider name. e.g. "google"
     *
     * @returns String to indicate the protocol version. e.g. "2.2"
     */
    readonly getProtocolVersion: (provider: IDLACString) => IDLACString;

    /**
     * Convert threat type to list name.
     *
     * @param Integer to indicate threat type.
     *
     * @returns The list names separated by ','. For example,
     *          'goog-phish-proto,test-phish-proto'.
     */
    readonly convertThreatTypeToListNames: (threatType: number) => IDLACString;

    /**
     * Convert list name to threat type.
     *
     * @param The list name.
     *
     * @returns The threat type in integer.
     */
    readonly convertListNameToThreatType: (listName: IDLACString) => number;

    /**
     * Make update request for given lists and their states.
     *
     * @param aListNames An array of list name represented in string.
     * @param aState An array of states (encoded in base64 format) for each list.
     *
     * The two argument arrays must be the same length.
     *
     * @returns A base64url encoded string.
     */
    readonly makeUpdateRequestV4: (aListNames: IDLACString[], aStatesBase64: IDLACString[]) => IDLACString;

    /**
     * Make "find full hash" request by for the given prefixes.
     *
     * @param aListNames An array of list names represented in string.
     * @param aListStatesBase64 An array of list states represented in base64.
     * @param aPrefixes An array of prefixes for which we'd like to find full hashes..
     *
     * The aListNames and aListStatesBase64 arrays must be the same length.
     *
     * @returns A base64url encoded string.
     */
    readonly makeFindFullHashRequestV4: (aListNames: IDLACString[], aListStatesBase64: IDLACString[], aPrefixes: IDLACString[]) => IDLACString;

    /**
     * Make ThreatHit report request body.
     *
     * @param aChannel channel which encountered the threat.
     * @param aListName listname represented in string.
     * @param aHashBase64 hash-based hit represented in base64.
     *
     * @returns A base64 encoded string.
     */
    readonly makeThreatHitReport: (aChannel: (nsIChannel | null), aListName: IDLACString, aHashBase64: IDLACString) => IDLACString;

    /**
     * Parse V4 FindFullHash response.
     *
     * @param aResponse Byte stream from the server.
     * @param aCallback The callback function on each complete hash parsed.
     *                  Can be called multiple times in one parsing.
     */
    readonly parseFindFullHashResponseV4: (aResponse: IDLACString, aCallback: (nsIUrlClassifierParseFindFullHashCallback | null)) => void;
  }

  export interface nsIScriptableInputStreamRef {
    readonly name: "nsIScriptableInputStream";
    readonly number: "{3fce9015-472a-4080-ac3e-cd875dbe361e}";
  }

  /**
   * nsIScriptableInputStream provides scriptable access to an nsIInputStream
   * instance.
   */
  export interface nsIScriptableInputStream extends nsISupports {

    /**
     * Closes the stream.
     */
    readonly close: () => void;

    /**
     * Wrap the given nsIInputStream with this nsIScriptableInputStream.
     *
     * @param aInputStream parameter providing the stream to wrap
     */
    readonly init: (aInputStream: (nsIInputStream | null)) => void;

    /**
     * Return the number of bytes currently available in the stream
     *
     * @return the number of bytes
     *
     * @throws NS_BASE_STREAM_CLOSED if called after the stream has been closed
     */
    readonly available: () => number;

    /**
     * Read data from the stream.
     *
     * WARNING: If the data contains a null byte, then this method will return
     * a truncated string.
     *
     * @param aCount the maximum number of bytes to read
     *
     * @return the data, which will be an empty string if the stream is at EOF.
     *
     * @throws NS_BASE_STREAM_CLOSED if called after the stream has been closed
     * @throws NS_ERROR_NOT_INITIALIZED if init was not called
     */
    readonly read: (aCount: number) => string;

    /**
     * Read data from the stream, including NULL bytes.
     *
     * @param aCount the maximum number of bytes to read.
     *
     * @return the data from the stream, which will be an empty string if EOF
     *         has been reached.
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if reading from the input stream
     *         would block the calling thread (non-blocking mode only).
     * @throws NS_ERROR_FAILURE if there are not enough bytes available to read
     *         aCount amount of data.
     */
    readonly readBytes: (aCount: number) => IDLACString;
  }

  export interface nsICaptivePortalDetectorRef {
    readonly name: "nsICaptivePortalDetector";
    readonly number: "{2f827c5a-f551-477f-af09-71adbfbd854a}";
  }

  export interface nsICaptivePortalDetector extends nsISupports {

    /**
     * Perform captive portal detection on specific network interface.
     * @param ifname The name of network interface, exception will be thrwon
     *               if the same interface has unfinished request.
     * @param callback Callbacks when detection procedure starts and finishes.
     */
    readonly checkCaptivePortal: (ifname: IDLAString, callback: (nsICaptivePortalCallback | null)) => void;

    /**
     * Abort captive portal detection for specific network interface
     * due to system failure, callback will not be invoked.
     * @param ifname The name of network interface.
     */
    readonly abort: (ifname: IDLAString) => void;

    /**
     * Cancel captive portal login procedure by user, callback will be invoked.
     * @param eventId Login event id provided in |captive-portal-login| event.
     */
    readonly cancelLogin: (eventId: IDLAString) => void;

    /**
     * Notify prepare phase is finished, routing and dns must be ready for sending
     * out XMLHttpRequest. this is callback for CaptivePortalDetector API user.
     * @param ifname The name of network interface, must be unique.
     */
    readonly finishPreparation: (ifname: IDLAString) => void;
  }

  export interface nsIContentPrefService2Ref {
    readonly name: "nsIContentPrefService2";
    readonly number: "{bed98666-d995-470f-bebd-62476d318576}";
  }

  /**
   * Content Preferences
   *
   * Content preferences allow the application to associate arbitrary data, or
   * "preferences", with specific domains, or web "content".  Specifically, a
   * content preference is a structure with three values: a domain with which the
   * preference is associated, a name that identifies the preference within its
   * domain, and a value.  (See nsIContentPref below.)
   *
   * For example, if you want to remember the user's preference for a certain zoom
   * level on www.mozilla.org pages, you might store a preference whose domain is
   * "www.mozilla.org", whose name is "zoomLevel", and whose value is the numeric
   * zoom level.
   *
   * A preference need not have a domain, and in that case the preference is
   * called a "global" preference.  This interface doesn't impart any special
   * significance to global preferences; they're simply name-value pairs that
   * aren't associated with any particular domain.  As a consumer of this
   * interface, you might choose to let a global preference override all non-
   * global preferences of the same name, for example, for whatever definition of
   * "override" is appropriate for your use case.
   *
   *
   * Domain Parameters
   *
   * Many methods of this interface accept a "domain" parameter.  Domains may be
   * specified either exactly, like "example.com", or as full URLs, like
   * "http://example.com/foo/bar".  In the latter case the API extracts the full
   * domain from the URL, so if you specify "http://foo.bar.example.com/baz", the
   * domain is taken to be "foo.bar.example.com", not "example.com".
   *
   *
   * Private-Browsing Context Parameters
   *
   * Many methods also accept a "context" parameter.  This parameter relates to
   * private browsing and determines the kind of storage that a method uses,
   * either the usual permanent storage or temporary storage set aside for private
   * browsing sessions.
   *
   * Pass null to unconditionally use permanent storage.  Pass an nsILoadContext
   * to use storage appropriate to the context's usePrivateBrowsing attribute: if
   * usePrivateBrowsing is true, temporary private-browsing storage is used, and
   * otherwise permanent storage is used.  A context can be obtained from the
   * window or channel whose content pertains to the preferences being modified or
   * retrieved.
   *
   *
   * Callbacks
   *
   * The methods of callback objects are always called asynchronously.
   *
   * Observers are called after callbacks are called, but they are called in the
   * same turn of the event loop as callbacks.
   *
   * See nsIContentPrefCallback2 below for more information about callbacks.
   */
  export interface nsIContentPrefService2 extends nsISupports {

    /**
     * Gets all the preferences with the given name.
     *
     * @param name      The preferences' name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleResult is called once for each preference unless
     *                  no such preferences exist, in which case handleResult
     *                  is not called at all.
     */
    readonly getByName: (name: IDLAString, context: (nsILoadContext | null), callback: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Gets the preference with the given domain and name.
     *
     * @param domain    The preference's domain.
     * @param name      The preference's name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleResult is called once unless no such preference
     *                  exists, in which case handleResult is not called at all.
     */
    readonly getByDomainAndName: (domain: IDLAString, name: IDLAString, context: (nsILoadContext | null), callback: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Gets all preferences with the given name whose domains are either the same
     * as or subdomains of the given domain.
     *
     * @param domain    The preferences' domain.
     * @param name      The preferences' name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleResult is called once for each preference.  If no
     *                  such preferences exist, handleResult is not called at all.
     */
    readonly getBySubdomainAndName: (domain: IDLAString, name: IDLAString, context: (nsILoadContext | null), callback: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Gets the preference with no domain and the given name.
     *
     * @param name      The preference's name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleResult is called once unless no such preference
     *                  exists, in which case handleResult is not called at all.
     */
    readonly getGlobal: (name: IDLAString, context: (nsILoadContext | null), callback: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Synchronously retrieves from the in-memory cache the preference with the
     * given domain and name.
     *
     * In addition to caching preference values, the cache also keeps track of
     * preferences that are known not to exist.  If the preference is known not to
     * exist, the value attribute of the returned object will be undefined
     * (nsIDataType::VTYPE_VOID).
     *
     * If the preference is neither cached nor known not to exist, then null is
     * returned, and get() must be called to determine whether the preference
     * exists.
     *
     * @param domain   The preference's domain.
     * @param name     The preference's name.
     * @param context  The private-browsing context, if any.
     * @return         The preference, or null if no such preference is known to
     *                 exist.
     */
    readonly getCachedByDomainAndName: (domain: IDLAString, name: IDLAString, context: (nsILoadContext | null)) => (nsIContentPref | null);

    /**
     * Synchronously retrieves from the in-memory cache all preferences with the
     * given name whose domains are either the same as or subdomains of the given
     * domain.
     *
     * The preferences are returned in an array through the out-parameter.  If a
     * preference for a particular subdomain is known not to exist, then an object
     * corresponding to that preference will be present in the array, and, as with
     * getCachedByDomainAndName, its value attribute will be undefined.
     *
     * @param domain   The preferences' domain.
     * @param name     The preferences' name.
     * @param context  The private-browsing context, if any.
     * @return         The array of preferences.
     */
    readonly getCachedBySubdomainAndName: (domain: IDLAString, name: IDLAString, context: (nsILoadContext | null)) => (nsIContentPref | null)[];

    /**
     * Synchronously retrieves from the in-memory cache the preference with no
     * domain and the given name.
     *
     * As with getCachedByDomainAndName, if the preference is cached then it is
     * returned; if the preference is known not to exist, then the value attribute
     * of the returned object will be undefined; if the preference is neither
     * cached nor known not to exist, then null is returned.
     *
     * @param name     The preference's name.
     * @param context  The private-browsing context, if any.
     * @return         The preference, or null if no such preference is known to
     *                 exist.
     */
    readonly getCachedGlobal: (name: IDLAString, context: (nsILoadContext | null)) => (nsIContentPref | null);

    /**
     * Sets a preference.
     *
     * @param domain    The preference's domain.
     * @param name      The preference's name.
     * @param value     The preference's value.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the preference has been
     *                  stored.
     */
    readonly set: (domain: IDLAString, name: IDLAString, value: (nsIVariant | null), context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Sets a preference with no domain.
     *
     * @param name      The preference's name.
     * @param value     The preference's value.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the preference has been
     *                  stored.
     */
    readonly setGlobal: (name: IDLAString, value: (nsIVariant | null), context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Removes the preference with the given domain and name.
     *
     * @param domain    The preference's domain.
     * @param name      The preference's name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    readonly removeByDomainAndName: (domain: IDLAString, name: IDLAString, context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Removes all the preferences with the given name whose domains are either
     * the same as or subdomains of the given domain.
     *
     * @param domain    The preferences' domain.
     * @param name      The preferences' name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    readonly removeBySubdomainAndName: (domain: IDLAString, name: IDLAString, context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Removes the preference with no domain and the given name.
     *
     * @param name      The preference's name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    readonly removeGlobal: (name: IDLAString, context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Removes all preferences with the given domain.
     *
     * @param domain    The preferences' domain.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    readonly removeByDomain: (domain: IDLAString, context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Removes all preferences whose domains are either the same as or subdomains
     * of the given domain.
     *
     * @param domain    The preferences' domain.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    readonly removeBySubdomain: (domain: IDLAString, context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Removes all preferences with the given name regardless of domain, including
     * global preferences with the given name.
     *
     * @param name      The preferences' name.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    readonly removeByName: (name: IDLAString, context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Removes all non-global preferences -- in other words, all preferences that
     * have a domain.
     *
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    readonly removeAllDomains: (context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Removes all non-global preferences created after and including |since|.
     *
     * @param since     Timestamp in milliseconds.
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    readonly removeAllDomainsSince: (since: number, context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Removes all global preferences -- in other words, all preferences that have
     * no domain.
     *
     * @param context   The private-browsing context, if any.
     * @param callback  handleCompletion is called when the operation completes.
     */
    readonly removeAllGlobals: (context: (nsILoadContext | null), callback?: (nsIContentPrefCallback2 | null)) => void;

    /**
     * Registers an observer that will be notified whenever a preference with the
     * given name is set or removed.
     *
     * When a set or remove method is called, observers are called after the set
     * or removal completes and after the method's callback is called, and they
     * are called in the same turn of the event loop as the callback.
     *
     * The service holds a strong reference to the observer, so the observer must
     * be removed later to avoid leaking it.
     *
     * @param name      The name of the preferences to observe.  Pass null to
     *                  observe all preference changes regardless of name.
     * @param observer  The observer.
     */
    readonly addObserverForName: (name: IDLAString, observer: (nsIContentPrefObserver | null)) => void;

    /**
     * Unregisters an observer for the given name.
     *
     * @param name      The name for which the observer was registered.  Pass null
     *                  if the observer was added with a null name.
     * @param observer  The observer.
     */
    readonly removeObserverForName: (name: IDLAString, observer: (nsIContentPrefObserver | null)) => void;

    /**
     * Extracts and returns the domain from the given string representation of a
     * URI.  This is how the API extracts domains from URIs passed to it.
     *
     * @param str  The string representation of a URI, like
     *             "http://example.com/foo/bar".
     * @return     If the given string is a valid URI, the domain of that URI is
     *             returned.  Otherwise, the string itself is returned.
     */
    readonly extractDomain: (str: IDLAString) => IDLAString;
  }

  export interface nsIGeolocationUpdateRef {
    readonly name: "nsIGeolocationUpdate";
    readonly number: "{643dc5e9-b911-4b2c-8d44-603162696baf}";
  }

  /**
   
   * Interface provides a way for a geolocation provider to
   * notify the system that a new location is available.
   */
  export interface nsIGeolocationUpdate extends nsISupports {

    /**
     * Notify the geolocation service that a new geolocation
     * has been discovered.
     * This must be called on the main thread
     */
    readonly update: (position: (nsIDOMGeoPosition | null)) => void;

    /**
     * Notify the geolocation service of an error.
     * This must be called on the main thread.
     * The parameter refers to one of the constants in the
     * nsIDOMGeoPositionError interface.
     * Use this to report spurious errors coming from the
     * provider; for errors occurring inside the methods in
     * the nsIGeolocationProvider interface, just use the return
     * value.
     */
    readonly notifyError: (error: number) => void;
  }

  export interface nsIFindServiceRef {
    readonly name: "nsIFindService";
    readonly number: "{5060b801-340e-11d5-be5b-b3e063ec6a3c}";
  }

  export interface nsIFindService extends nsISupports {

    searchString: IDLAString;

    replaceString: IDLAString;

    findBackwards: boolean;

    wrapFind: boolean;

    entireWord: boolean;

    matchCase: boolean;

    matchDiacritics: boolean;
  }

  export interface nsICacheServiceRef {
    readonly name: "nsICacheService";
    readonly number: "{14dbe1e9-f3bc-45af-92f4-2c574fcd4e39}";
  }

  /**
   * @deprecated
   *
   * IMPORTANT NOTE: THIS INTERFACE IS NO LONGER SUPPORTED AND PLANNED TO BE
   * REMOVED SOON. WE STRONGLY ENCORAGE TO MIGRATE THE EXISTING CODE AND FOR
   * THE NEW CODE USE ONLY THE NEW HTTP CACHE API IN netwerk/cache2/.
   */
  export interface nsICacheService extends nsISupports {

    /**
     * @throws NS_ERROR_NOT_IMPLEMENTED when the cache v2 is prefered to use.
     *
     * Create a cache session
     *
     * A cache session represents a client's access into the cache.  The cache
     * session is not "owned" by the cache service.  Hence, it is possible to
     * create duplicate cache sessions.  Entries created by a cache session
     * are invisible to other cache sessions, unless the cache sessions are
     * equivalent.
     *
     * @param clientID - Specifies the name of the client using the cache.
     * @param storagePolicy - Limits the storage policy for all entries
     *   accessed via the returned session.  As a result, devices excluded
     *   by the storage policy will not be searched when opening entries
     *   from the returned session.
     * @param streamBased - Indicates whether or not the data being cached
     *   can be represented as a stream.  The storagePolicy must be
     *   consistent with the value of this field.  For example, a non-stream-
     *   based cache entry can only have a storage policy of STORE_IN_MEMORY.
     * @return new cache session.
     */
    readonly createSession: (clientID: string, storagePolicy: number, streamBased: boolean) => (nsICacheSession | null);

    /**
     * @throws NS_ERROR_NOT_IMPLEMENTED when the cache v2 is prefered to use.
     *
     * Visit entries stored in the cache.  Used to implement about:cache.
     */
    readonly visitEntries: (visitor: (nsICacheVisitor | null)) => void;

    /**
     * @throws NS_ERROR_NOT_IMPLEMENTED when the cache v2 is prefered to use.
     *
     * Evicts all entries in all devices implied by the storage policy.
     *
     * @note This function may evict some items but will throw if it fails to evict
     *       everything.
     */
    readonly evictEntries: (storagePolicy: number) => void;

    /**
     * Event target which is used for I/O operations
     */
    readonly cacheIOTarget: (nsIEventTarget | null);
  }

  export interface nsIContentDispatchChooserRef {
    readonly name: "nsIContentDispatchChooser";
    readonly number: "{456ca3b2-02be-4f97-89a2-08c08d3ad88f}";

    /**
     * This request is passed to the helper app dialog because Gecko can not
     * handle content of this type.
     */
    REASON_CANNOT_HANDLE: 0;
  }

  /**
   * This is used to ask a user what they would like to do with a given piece of
   * content.
   */
  export interface nsIContentDispatchChooser extends nsISupports {

    /**
     * Asks the user what to do with the content.
     *
     * @param aHander
     *        The interface describing the details of how this content should or
     *        can be handled.
     * @param aWindowContext
     *        The parent window context to show this chooser.  This can be null,
     *        and some implementations may not care about it.  Generally, you'll
     *        want to pass an nsIDOMWindow in so the chooser can be properly
     *        parented when opened.
     * @param aURI
     *        The URI of the resource that we are asking about.
     * @param aReason
     *        The reason why we are asking (see above).
     */
    readonly ask: (aHandler: (nsIHandlerInfo | null), aWindowContext: (nsIInterfaceRequestor | null), aURI: (nsIURI | null), aReason: number) => void;
  }

  export interface nsIEffectiveTLDServiceRef {
    readonly name: "nsIEffectiveTLDService";
    readonly number: "{68067eb5-ad8d-43cb-a043-1cc85ebe06e7}";
  }

  export interface nsIEffectiveTLDService extends nsISupports {

    /**
     * Returns the public suffix of a URI. A public suffix is the highest-level domain
     * under which individual domains may be registered; it may therefore contain one
     * or more dots. For example, the public suffix for "www.bbc.co.uk" is "co.uk",
     * because the .uk TLD does not allow the registration of domains at the
     * second level ("bbc.uk" is forbidden).
     *
     * The public suffix will be returned encoded in ASCII/ACE and will be normalized
     * according to RFC 3454, i.e. the same encoding returned by nsIURI::GetAsciiHost().
     * If consumers wish to compare the result of this method against the host from
     * another nsIURI, the host should be obtained using nsIURI::GetAsciiHost().
     * In the case of nested URIs, the innermost URI will be used.
     *
     * @param   aURI   The URI to be analyzed
     *
     * @returns the public suffix
     *
     * @throws NS_ERROR_UNEXPECTED
     *         or other error returned by nsIIDNService::normalize when
     *         the hostname contains characters disallowed in URIs
     * @throws NS_ERROR_HOST_IS_IP_ADDRESS
     *         if the host is a numeric IPv4 or IPv6 address (as determined by
     *         the success of a call to PR_StringToNetAddr()).
     */
    readonly getPublicSuffix: (aURI: (nsIURI | null)) => IDLACString;

    /**
     * Returns the base domain of a URI; that is, the public suffix with a given
     * number of additional domain name parts. For example, the result of this method
     * for "www.bbc.co.uk", depending on the value of aAdditionalParts parameter, will
     * be:
     *
     *    0 (default) -> bbc.co.uk
     *    1           -> www.bbc.co.uk
     *
     * Similarly, the public suffix for "www.developer.mozilla.org" is "org", and the base
     * domain will be:
     *
     *    0 (default) -> mozilla.org
     *    1           -> developer.mozilla.org
     *    2           -> www.developer.mozilla.org
     *
     * The base domain will be returned encoded in ASCII/ACE and will be normalized
     * according to RFC 3454, i.e. the same encoding returned by nsIURI::GetAsciiHost().
     * If consumers wish to compare the result of this method against the host from
     * another nsIURI, the host should be obtained using nsIURI::GetAsciiHost().
     * In the case of nested URIs, the innermost URI will be used.
     *
     * @param   aURI               The URI to be analyzed
     * @param   aAdditionalParts   Number of domain name parts to be
     *                             returned in addition to the public suffix
     *
     * @returns the base domain (public suffix plus the requested number of additional parts)
     *
     * @throws NS_ERROR_UNEXPECTED
     *         or other error returned by nsIIDNService::normalize when
     *         the hostname contains characters disallowed in URIs
     * @throws NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
     *         when there are insufficient subdomain levels in the hostname to satisfy the
     *         requested aAdditionalParts value.
     * @throws NS_ERROR_HOST_IS_IP_ADDRESS
     *         if aHost is a numeric IPv4 or IPv6 address (as determined by
     *         the success of a call to PR_StringToNetAddr()).
     *
     * @see    getPublicSuffix()
     */
    readonly getBaseDomain: (aURI: (nsIURI | null), aAdditionalParts?: number) => IDLACString;

    /**
     * NOTE: It is strongly recommended to use getPublicSuffix() above if a suitable
     * nsIURI is available. Only use this method if this is not the case.
     *
     * Returns the public suffix of a host string. Otherwise identical to getPublicSuffix().
     *
     * @param   aHost   The host to be analyzed. Any additional parts (e.g. scheme,
     *                  port, or path) will cause this method to throw. ASCII/ACE and
     *                  UTF8 encodings are acceptable as input; normalization will
     *                  be performed as specified in getBaseDomain().
     *
     * @see     getPublicSuffix()
     */
    readonly getPublicSuffixFromHost: (aHost: IDLAUTF8String) => IDLACString;

    /**
     * NOTE: It is strongly recommended to use getBaseDomain() above if a suitable
     * nsIURI is available. Only use this method if this is not the case.
     *
     * Returns the base domain of a host string. Otherwise identical to getBaseDomain().
     *
     * @param   aHost   The host to be analyzed. Any additional parts (e.g. scheme,
     *                  port, or path) will cause this method to throw. ASCII/ACE and
     *                  UTF8 encodings are acceptable as input; normalization will
     *                  be performed as specified in getBaseDomain().
     *
     * @see     getBaseDomain()
     */
    readonly getBaseDomainFromHost: (aHost: IDLAUTF8String, aAdditionalParts?: number) => IDLACString;

    /**
     * Returns the parent sub-domain of a host string. If the host is a base
     * domain, it will throw NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS.
     *
     * For example: "player.bbc.co.uk" would return "bbc.co.uk" and
     *              "bbc.co.uk" would throw NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS.
     *
     * @param   aHost   The host to be analyzed. Any additional parts (e.g. scheme,
     *                  port, or path) will cause this method to throw. ASCII/ACE and
     *                  UTF8 encodings are acceptable as input; normalization will
     *                  be performed as specified in getBaseDomain().
     */
    readonly getNextSubDomain: (aHost: IDLAUTF8String) => IDLACString;

    /**
     * Returns true if the |aInput| in is part of the root domain of |aHost|.
     * For example, if |aInput| is "www.mozilla.org", and we pass in
     * "mozilla.org" as |aHost|, this will return true.  It would return false
     * the other way around.
     *
     * @param aInput The host to be analyzed.
     * @param aHost  The host to compare to.
     */
    readonly hasRootDomain: (aInput: IDLAUTF8String, aHost: IDLAUTF8String) => boolean;
  }

  export interface nsIContentSecurityManagerRef {
    readonly name: "nsIContentSecurityManager";
    readonly number: "{3a9a1818-2ae8-4ec5-a340-8b29d31fca3b}";
  }

  /**
   * nsIContentSecurityManager
   * Describes an XPCOM component used to perform security checks.
   */
  export interface nsIContentSecurityManager extends nsISupports {

    /**
     * Checks whether a channel is allowed to access the given URI and
     * whether the channel should be openend or should be blocked consulting
     * internal security checks like Same Origin Policy, Content Security
     * Policy, Mixed Content Blocker, etc.
     *
     * If security checks within performSecurityCheck fail, the function
     * throws an exception.
     *
     * @param aChannel
     *     The channel about to be openend
     * @param aStreamListener
     *     The Streamlistener of the channel potentially wrapped
     *     into CORSListenerProxy.
     * @return
     *     The StreamListener of the channel wrapped into CORSListenerProxy.
     *
     * @throws NS_ERROR_DOM_BAD_URI
     *     If accessing the URI is not allowed (e.g. prohibted by SOP)
     * @throws NS_ERROR_CONTENT_BLOCKED
     *     If any of the security policies (CSP, Mixed content) is violated
     */
    readonly performSecurityCheck: (aChannel: (nsIChannel | null), aStreamListener: (nsIStreamListener | null)) => (nsIStreamListener | null);
  }

  export interface nsIDirectoryServiceProviderRef {
    readonly name: "nsIDirectoryServiceProvider";
    readonly number: "{bbf8cab0-d43a-11d3-8cc2-00609792278c}";
  }

  /**
   * nsIDirectoryServiceProvider
   *
   * Used by Directory Service to get file locations.
   */
  export interface nsIDirectoryServiceProvider extends nsISupports {

    /**
     * getFile
     *
     * Directory Service calls this when it gets the first request for
     * a prop or on every request if the prop is not persistent.
     *
     * @param prop         The symbolic name of the file.
     * @param persistent   TRUE - The returned file will be cached by Directory
     *                     Service. Subsequent requests for this prop will
     *                     bypass the provider and use the cache.
     *                     FALSE - The provider will be asked for this prop
     *                     each time it is requested.
     *
     * @return             The file represented by the property.
     *
     */
    readonly getFile: (prop: string, persistent: Out<boolean>) => (nsIFile | null);
  }

  export interface nsISelectionDisplayRef {
    readonly name: "nsISelectionDisplay";
    readonly number: "{0ddf9e1c-1dd2-11b2-a183-908a08aa75ae}";

    DISPLAY_TEXT: 1;

    DISPLAY_IMAGES: 2;

    DISPLAY_FRAMES: 4;

    DISPLAY_ALL: 7;
  }

  export interface nsISelectionDisplay extends nsISupports {

    readonly setSelectionFlags: (toggle: number) => void;

    readonly getSelectionFlags: () => number;
  }

  export interface mozIStorageConnectionRef {
    readonly name: "mozIStorageConnection";
    readonly number: "{4aa2ac47-8d24-4004-9b31-ec0bd85f0cc3}";
  }

  /**
   * mozIStorageConnection represents a database connection attached to
   * a specific file or to the in-memory data storage.  It is the
   * primary interface for interacting with a database, including
   * creating prepared statements, executing SQL, and examining database
   * errors.
   *
   * @note From the main thread, you should rather use mozIStorageAsyncConnection.
   *
   * @threadsafe
   */
  export interface mozIStorageConnection extends mozIStorageAsyncConnection {

    /**
     * Closes a database connection.  Callers must finalize all statements created
     * for this connection prior to calling this method.  It is illegal to use
     * call this method if any asynchronous statements have been executed on this
     * connection.
     *
     * @throws NS_ERROR_UNEXPECTED
     *         If any statement has been executed asynchronously on this object.
     * @throws NS_ERROR_UNEXPECTED
     *         If is called on a thread other than the one that opened it.
     */
    readonly close: () => void;

    /**
     * Clones a database connection and makes the clone read only if needed.
     * SQL Functions and attached on-disk databases are applied to the new clone.
     *
     * @param aReadOnly
     *        If true, the returned database should be put into read-only mode.
     *        Defaults to false.
     * @return the cloned database connection.
     *
     * @throws NS_ERROR_UNEXPECTED
     *         If this connection is a memory database.
     * @note If your connection is already read-only, you will get a read-only
     *       clone.
     * @note Due to a bug in SQLite, if you use the shared cache (openDatabase),
     *       you end up with the same privileges as the first connection opened
     *       regardless of what is specified in aReadOnly.
     * @note The following pragmas are copied over to a read-only clone:
     *        - cache_size
     *        - temp_store
     *       The following pragmas are copied over to a writeable clone:
     *        - cache_size
     *        - temp_store
     *        - foreign_keys
     *        - journal_size_limit
     *        - synchronous
     *        - wal_autocheckpoint
     *       All SQL functions are copied over to read-only and writeable clones.
     *       Additionally, all temporary tables, triggers, and views, as well as
     *       any indexes on temporary tables, are copied over to writeable clones.
     *       For temporary tables, only the schemas are copied, not their
     *       contents.
     *
     */
    readonly clone: (aReadOnly?: boolean) => (mozIStorageConnection | null);

    /**
     * The default size for SQLite database pages used by mozStorage for new
     * databases.
     */
    readonly defaultPageSize: number;

    /**
     * Indicates if the connection is open and ready to use.  This will be false
     * if the connection failed to open, or it has been closed.
     */
    readonly connectionReady: boolean;

    /**
     * lastInsertRowID returns the row ID from the last INSERT
     * operation.
     */
    readonly lastInsertRowID: number;

    /**
     * affectedRows returns the number of database rows that were changed or
     * inserted or deleted by last operation.
     */
    readonly affectedRows: number;

    /**
     * The last error SQLite error code.
     */
    readonly lastError: number;

    /**
     * The last SQLite error as a string (in english, straight from the
     * sqlite library).
     */
    readonly lastErrorString: IDLAUTF8String;

    /**
     * The schema version of the database.  This should not be used until the
     * database is ready.  The schema will be reported as zero if it is not set.
     */
    schemaVersion: number;

    /**
     * Create a mozIStorageStatement for the given SQL expression.  The
     * expression may use ? to indicate sequential numbered arguments,
     * ?1, ?2 etc. to indicate specific numbered arguments or :name and
     * $var to indicate named arguments.
     *
     * @param aSQLStatement
     *        The SQL statement to execute.
     * @return a new mozIStorageStatement
     */
    readonly createStatement: (aSQLStatement: IDLAUTF8String) => (mozIStorageStatement | null);

    /**
     * Execute a SQL expression, expecting no arguments.
     *
     * @param aSQLStatement  The SQL statement to execute
     */
    readonly executeSimpleSQL: (aSQLStatement: IDLAUTF8String) => void;

    /**
     * Check if the given table exists.
     *
     * @param aTableName
     *        The table to check
     * @return TRUE if table exists, FALSE otherwise.
     */
    readonly tableExists: (aTableName: IDLAUTF8String) => boolean;

    /**
     * Check if the given index exists.
     *
     * @param aIndexName   The index to check
     * @return TRUE if the index exists, FALSE otherwise.
     */
    readonly indexExists: (aIndexName: IDLAUTF8String) => boolean;

    /**
     * Returns true if a transaction is active on this connection.
     */
    readonly transactionInProgress: boolean;

    /**
     * Begin a new transaction. If a transaction is active, throws an error.
     */
    readonly beginTransaction: () => void;

    /**
     * Commits the current transaction.  If no transaction is active,
     * @throws NS_ERROR_UNEXPECTED.
     * @throws NS_ERROR_NOT_INITIALIZED.
     */
    readonly commitTransaction: () => void;

    /**
     * Rolls back the current transaction.  If no transaction is active,
     * @throws NS_ERROR_UNEXPECTED.
     * @throws NS_ERROR_NOT_INITIALIZED.
     */
    readonly rollbackTransaction: () => void;

    /**
     * Create the table with the given name and schema.
     *
     * If the table already exists, NS_ERROR_FAILURE is thrown.
     * (XXX at some point in the future it will check if the schema is
     * the same as what is specified, but that doesn't happen currently.)
     *
     * @param aTableName
     *        The table name to be created, consisting of [A-Za-z0-9_], and
     *        beginning with a letter.
     * @param aTableSchema
     *        The schema of the table; what would normally go between the parens
     *        in a CREATE TABLE statement: e.g., "foo  INTEGER, bar STRING".
     *
     * @throws NS_ERROR_FAILURE
     *         If the table already exists or could not be created for any other
     *         reason.
     */
    readonly createTable: (aTableName: string, aTableSchema: string) => void;

    /**
     * Controls SQLITE_FCNTL_CHUNK_SIZE setting in sqlite. This helps avoid fragmentation
     * by growing/shrinking the database file in SQLITE_FCNTL_CHUNK_SIZE increments. To
     * conserve memory on systems short on storage space, this function will have no effect
     * on mobile devices or if less than 500MiB of space is left available.
     *
     * @param aIncrement
     *        The database file will grow in multiples of chunkSize.
     * @param aDatabaseName
     *        Sqlite database name. "" means pass NULL for zDbName to sqlite3_file_control.
     *        See http://sqlite.org/c3ref/file_control.html for more details.
     * @throws NS_ERROR_FILE_TOO_BIG
     *         If the system is short on storage space.
     */
    readonly setGrowthIncrement: (aIncrement: number, aDatabaseName: IDLAUTF8String) => void;
  }

  export interface nsIClearDataCallbackRef {
    readonly name: "nsIClearDataCallback";
    readonly number: "{e225517b-24c5-498a-b9fb-9993e341a398}";
  }

  type nsIClearDataCallbackFunction = (aFailedFlags: number) => void;

  export interface nsIClearDataCallback extends nsISupports {

    /**
     * This is a companion interface for
     * nsIClearDataService::deleteDataFromPrincipal().
     */
    /**
     * Called to indicate that the data cleaning is completed.
     * @param aFailedFlags this value contains the flags that failed during the
     *                     cleanup. If nothing failed, aFailedFlags will be 0.
     */
    readonly onDataDeleted: (aFailedFlags: number) => void;
  }

  export interface nsILoginManagerAuthPrompterRef {
    readonly name: "nsILoginManagerAuthPrompter";
    readonly number: "{425f73b9-b2db-4e8a-88c5-9ac2512934ce}";
  }

  export interface nsILoginManagerAuthPrompter extends nsISupports {

    /**
     * Initialize the prompter. Must be called before using other interfaces.
     *
     * @param aWindow
     *        The window in which the user is doing some login-related action that's
     *        resulting in a need to prompt them for something. The prompt
     *        will be associated with this window (or, if a notification bar
     *        is being used, topmost opener in some cases).
     *
     *        aWindow can be null if there is no associated window, e.g. in a JSM
     *        or Sandbox. In this case there will be no checkbox to save the login
     *        since the window is needed to know if this is a private context.
     *
     *        If this window is a content window, the corresponding window and browser
     *        elements will be calculated. If this window is a chrome window, the
     *        corresponding browser element needs to be set using setBrowser.
     */
    readonly init: (aWindow: (nsIDOMWindow | null)) => void;

    /**
     * The browser this prompter is being created for.
     * This is required if the init function received a chrome window as argument.
     */
    browser: WebIDL.Element;

    /**
     * The opener browser that was used to open the window passed to init.
     * The opener can be used to determine in which window the prompt
     * should be shown.
     */
    openerBrowser: WebIDL.Element;
  }

  export interface nsIDragServiceRef {
    readonly name: "nsIDragService";
    readonly number: "{ebd6b3a2-af16-43af-a698-3091a087dd62}";

    DRAGDROP_ACTION_NONE: 0;

    DRAGDROP_ACTION_COPY: 1;

    DRAGDROP_ACTION_MOVE: 2;

    DRAGDROP_ACTION_LINK: 4;

    DRAGDROP_ACTION_UNINITIALIZED: 64;
  }

  export interface nsIDragService extends nsISupports {

    /**
     * Starts a modal drag session with an array of transaferables.
     *
     * Note: This method is deprecated for non-native code.
     *
     * @param  aPrincipal - the triggering principal of the drag, or null if
     *                      it's from browser chrome or OS
     * @param aCsp - The csp of the triggering Document
     * @param  aTransferables - an array of transferables to be dragged
     * @param  aActionType - specified which of copy/move/link are allowed
     * @param  aContentPolicyType - the contentPolicyType that will be
     *           passed to the loadInfo when creating a new channel
     *           (defaults to TYPE_OTHER)
     */
    readonly invokeDragSession: (aDOMNode: WebIDL.Node, aPrincipal: (nsIPrincipal | null), aCsp: (nsIContentSecurityPolicy | null), aTransferables: (nsIArray | null), aActionType: number, aContentPolicyType?: number) => void;

    /**
     * Returns the current Drag Session
     */
    readonly getCurrentSession: () => (nsIDragSession | null);

    /**
     * Tells the Drag Service to start a drag session. This is called when
     * an external drag occurs
     */
    readonly startDragSession: () => void;

    /**
     * Similar to startDragSession(), automated tests may want to start
     * session for emulating an external drag.  At that time, this should
     * be used instead of startDragSession().
     *
     * @param aAllowedEffect Set default drag action which means allowed effects
     *                       in the session and every DnD events are initialized
     *                       with one of specified value.  So, the value can be
     *                       DRAGDROP_ACTION_NONE, or one or more values of
     *                       DRAGDROP_ACTION_(MOVE|COPY|LINK).
     */
    readonly startDragSessionForTests: (aAllowedEffect: number) => void;

    /**
     * Tells the Drag Service to end a drag session. This is called when
     * an external drag occurs
     *
     * If aDoneDrag is true, the drag has finished, otherwise the drag has
     * just left the window.
     */
    readonly endDragSession: (aDoneDrag: boolean, aKeyModifiers?: number) => void;

    /**
     * Increase/decrease dragging suppress level by one.
     * If level is greater than one, dragging is disabled.
     */
    readonly suppress: () => void;

    readonly unsuppress: () => void;
  }

  export interface nsPIDNSServiceRef {
    readonly name: "nsPIDNSService";
    readonly number: "{24e598fd-7b1a-436c-9154-14d8b38df8a5}";
  }

  /**
   * This is a private interface used by the internals of the networking library.
   * It will never be frozen.  Do not use it in external code.
   */
  export interface nsPIDNSService extends nsIDNSService {

    /**
     * called to initialize the DNS service.
     */
    readonly init: () => void;

    /**
     * called to shutdown the DNS service.  any pending asynchronous
     * requests will be canceled, and the local cache of DNS records
     * will be cleared.  NOTE: the operating system may still have
     * its own cache of DNS records, which would be unaffected by
     * this method.
     */
    readonly shutdown: () => void;

    /**
     * Whether or not DNS prefetching (aka RESOLVE_SPECULATE) is enabled
     */
    prefetchEnabled: boolean;
  }

  export interface nsIXPCComponentsRef {
    readonly name: "nsIXPCComponents";
    readonly number: "{aa28aaf6-70ce-4b03-9514-afe43c7dfda8}";
  }

  export interface nsIXPCComponents extends nsIXPCComponentsBase {

    readonly classes: (nsIXPCComponents_Classes | null);

    readonly stack: (nsIStackFrame | null);

    readonly manager: (nsIComponentManager | null);

    readonly utils: (nsIXPCComponents_Utils | null);

    readonly ID: (nsIXPCComponents_ID | null);

    readonly Exception: (nsIXPCComponents_Exception | null);

    readonly Constructor: (nsIXPCComponents_Constructor | null);

    returnCode: IDLjsval;
  }

  export interface nsIPaymentActionResponseRef {
    readonly name: "nsIPaymentActionResponse";
    readonly number: "{a607c095-ef60-4a9b-a3d0-0506c60728b3}";

    /**
     *  The response type.
     *  Align type to nsIPaymentActionRequest types,
     *  where 1 is for payment request creation.
     *  the action expects no response from UI module.
     */
    NO_TYPE: 0;

    CANMAKE_ACTION: 2;

    SHOW_ACTION: 3;

    ABORT_ACTION: 4;

    COMPLETE_ACTION: 5;

    /**
     *  The abort status.
     */
    ABORT_SUCCEEDED: 1;

    ABORT_FAILED: 0;

    /**
     *  The payment status.
     */
    PAYMENT_REJECTED: 0;

    PAYMENT_ACCEPTED: 1;

    PAYMENT_NOTSUPPORTED: 2;

    /**
     *  The complete status.
     */
    COMPLETE_SUCCEEDED: 1;

    COMPLETE_FAILED: 0;
  }

  /**
   *  The base interface of user's response.
   *  Payment UI should create different sub-interface of nsIPaymentActionResponse
   *  according to user's action, and call nsIPaymentRequestService::respondPayment
   *  with the created action to inform the merchant.
   */
  export interface nsIPaymentActionResponse extends nsISupports {

    readonly requestId: IDLAString;

    readonly type: number;
  }

  export interface nsISHistoryListenerRef {
    readonly name: "nsISHistoryListener";
    readonly number: "{125c0833-746a-400e-9b89-d2d18545c08a}";
  }

  /**
   * nsISHistoryListener defines the interface one can implement to receive
   * notifications about activities in session history and (for reloads) to be
   * able to cancel them.
   *
   * A session history listener will be notified when pages are added, removed
   * and loaded from session history. In the case of reloads, it can prevent them
   * from happening by returning false from the corresponding callback method.
   *
   * A session history listener can be registered on a particular nsISHistory
   * instance via the nsISHistory::addSHistoryListener() method.
   *
   * Listener methods should not alter the session history. Things are likely to
   * go haywire if they do.
   */
  export interface nsISHistoryListener extends nsISupports {

    /**
     * Called when a new document is added to session history. New documents are
     * added to session history by docshell when new pages are loaded in a frame
     * or content area, for example via nsIWebNavigation::loadURI()
     *
     * @param aNewURI     The URI of the document to be added to session history.
     * @param aOldIndex   The index of the current history item before the
     *                    operation.
     */
    readonly OnHistoryNewEntry: (aNewURI: (nsIURI | null), aOldIndex: number) => void;

    /**
     * Called before the current document is reloaded, for example due to a
     * nsIWebNavigation::reload() call.
     */
    readonly OnHistoryReload: () => boolean;

    /**
     * Called before navigating to a session history entry by index, for example,
     * when nsIWebNavigation::gotoIndex() is called.
     */
    readonly OnHistoryGotoIndex: () => void;

    /**
     * Called before entries are removed from session history. Entries can be
     * removed from session history for various reasons, for example to control
     * the memory usage of the browser, to prevent users from loading documents
     * from history, to erase evidence of prior page loads, etc.
     *
     * To purge documents from session history call nsISHistory::PurgeHistory().
     */
    readonly OnHistoryPurge: () => void;

    /**
     * Called before an entry is replaced in the session history. Entries are
     * replaced when navigating away from non-persistent history entries (such as
     * about pages) and when history.replaceState is called.
     */
    readonly OnHistoryReplaceEntry: () => void;

    /**
     * Called whenever a content viewer is evicted. A content viewer is evicted
     * whenever a bfcache entry has timed out or the number of total content
     * viewers has exceeded the global max. This is used for testing only.
     *
     * @param aNumEvicted - number of content viewers evicted
     */
    readonly OnContentViewerEvicted: (aNumEvicted: number) => void;
  }

  export interface nsIPKCS11ModuleRef {
    readonly name: "nsIPKCS11Module";
    readonly number: "{8a44bdf9-d1a5-4734-bd5a-34ed7fe564c2}";
  }

  export interface nsIPKCS11Module extends nsISupports {

    readonly name: IDLAUTF8String;

    readonly libName: IDLAUTF8String;

    readonly listSlots: () => (nsISimpleEnumerator | null);
  }

  export interface nsIApplicationCacheContainerRef {
    readonly name: "nsIApplicationCacheContainer";
    readonly number: "{bbb80700-1f7f-4258-aff4-1743cc5a7d23}";
  }

  /**
   * Interface used by objects that can be associated with an
   * application cache.
   */
  export interface nsIApplicationCacheContainer extends nsISupports {

    applicationCache: (nsIApplicationCache | null);
  }

  export interface nsILoginReputationServiceRef {
    readonly name: "nsILoginReputationService";
    readonly number: "{1b3f1dfe-ce3a-486b-953e-ce5ac863eff9}";
  }

  export interface nsILoginReputationService extends nsISupports {

    readonly init: () => void;

    readonly queryReputationAsync: (aInput: WebIDL.HTMLInputElement, aCallback: (nsILoginReputationQueryCallback | null)) => void;

    readonly queryReputation: (aQuery: (nsILoginReputationQuery | null), aCallback: (nsILoginReputationQueryCallback | null)) => void;
  }

  export interface nsIArrayRef {
    readonly name: "nsIArray";
    readonly number: "{114744d9-c369-456e-b55a-52fe52880d2d}";
  }

  /**
   * nsIArray
   *
   * An indexed collection of elements. Provides basic functionality for
   * retrieving elements at a specific position, searching for
   * elements. Indexes are zero-based, such that the last element in the
   * array is stored at the index length-1.
   *
   * For an array which can be modified, see nsIMutableArray below.
   *
   * Neither interface makes any attempt to protect the individual
   * elements from modification. The convention is that the elements of
   * the array should not be modified. Documentation within a specific
   * interface should describe variations from this convention.
   *
   * It is also convention that if an interface provides access to an
   * nsIArray, that the array should not be QueryInterfaced to an
   * nsIMutableArray for modification. If the interface in question had
   * intended the array to be modified, it would have returned an
   * nsIMutableArray!
   *
   * null is a valid entry in the array, and as such any nsISupports
   * parameters may be null, except where noted.
   */
  export interface nsIArray extends nsISupports {

    /**
     * length
     *
     * number of elements in the array.
     */
    readonly length: number;

    /**
     * indexOf()
     *
     * Get the position of a specific element. Note that since null is
     * a valid input, exceptions are used to indicate that an element
     * is not found.
     *
     * @param startIndex The initial element to search in the array
     *                   To start at the beginning, use 0 as the
     *                   startIndex
     * @param element    The element you are looking for
     * @returns a number >= startIndex which is the position of the
     *          element in the array.
     * @throws NS_ERROR_FAILURE if the element was not in the array.
     */
    readonly indexOf: (startIndex: number, element: (nsISupports | null)) => number;
  }

  export interface nsISlowScriptDebuggerStartupCallbackRef {
    readonly name: "nsISlowScriptDebuggerStartupCallback";
    readonly number: "{b1c6ecd0-8fa4-11e4-b4a9-0800200c9a66}";
  }

  type nsISlowScriptDebuggerStartupCallbackFunction = () => void;

  export interface nsISlowScriptDebuggerStartupCallback extends nsISupports {

    readonly finishDebuggerStartup: () => void;
  }

  export interface nsIIdentityKeyPairRef {
    readonly name: "nsIIdentityKeyPair";
    readonly number: "{73962dc7-8ee7-4346-a12b-b039e1d9b54d}";
  }

  /**
   * This interface provides a keypair and signing interface for Identity functionality
   */
  export interface nsIIdentityKeyPair extends nsISupports {

    readonly keyType: IDLAUTF8String;

    readonly hexRSAPublicKeyExponent: IDLAUTF8String;

    readonly hexRSAPublicKeyModulus: IDLAUTF8String;

    readonly hexDSAPrime: IDLAUTF8String;

    readonly hexDSASubPrime: IDLAUTF8String;

    readonly hexDSAGenerator: IDLAUTF8String;

    readonly hexDSAPublicValue: IDLAUTF8String;

    readonly sign: (aText: IDLAUTF8String, callback: (nsIIdentitySignCallback | nsIIdentitySignCallbackFunction | null)) => void;
  }

  export interface nsIInputChannelThrottleQueueRef {
    readonly name: "nsIInputChannelThrottleQueue";
    readonly number: "{6b4b96fe-3c67-4587-af7b-58b6b17da411}";
  }

  /**
   * An instance of this interface can be used to throttle the uploads
   * of a group of associated channels.
   */
  export interface nsIInputChannelThrottleQueue extends nsISupports {

    /**
     * Initialize this object with the mean and maximum bytes per
     * second that will be allowed.  Neither value may be zero, and
     * the maximum must not be less than the mean.
     *
     * @param aMeanBytesPerSecond
     *        Mean number of bytes per second.
     * @param aMaxBytesPerSecond
     *        Maximum number of bytes per second.
     */
    readonly init: (aMeanBytesPerSecond: number, aMaxBytesPerSecond: number) => void;

    /**
     * Return the number of bytes that are available to the caller in
     * this time slice.
     *
     * @param aRemaining
     *        The number of bytes available to be processed
     * @return the number of bytes allowed to be processed during this
     *        time slice; this will never be greater than aRemaining.
     */
    readonly available: (aRemaining: number) => number;

    /**
     * Record a successful read.
     *
     * @param aBytesRead
     *        The number of bytes actually read.
     */
    readonly recordRead: (aBytesRead: number) => void;

    /**
     * Return the number of bytes allowed through this queue.  This is
     * the sum of all the values passed to recordRead.  This method is
     * primarily useful for testing.
     */
    readonly bytesProcessed: () => number;

    /**
     * Wrap the given input stream in a new input stream which
     * throttles the incoming data.
     *
     * @param aInputStream the input stream to wrap
     * @return a new input stream that throttles the data.
     */
    readonly wrapStream: (aInputStream: (nsIInputStream | null)) => (nsIAsyncInputStream | null);
  }

  export interface nsIPropertyElementRef {
    readonly name: "nsIPropertyElement";
    readonly number: "{283ee646-1aef-11d4-98b3-00c04fa0ce9a}";
  }

  export interface nsIPropertyElement extends nsISupports {

    key: IDLAUTF8String;

    value: IDLAString;
  }

  export interface nsIDNSRegistrationListenerRef {
    readonly name: "nsIDNSRegistrationListener";
    readonly number: "{e165e4be-abf4-4963-a66d-ed3ca116e5e4}";

    ERROR_SERVICE_NOT_RUNNING: -65563;
  }

  /**
   * The callback interface for service registration
   */
  export interface nsIDNSRegistrationListener extends nsISupports {

    /**
     * Callback when the service is registered successfully.
     * @param   aServiceInfo
     *          the info about the registered service,
     *          where |serviceName|, |aServiceType|, and |domainName| are set.
     */
    readonly onServiceRegistered: (aServiceInfo: (nsIDNSServiceInfo | null)) => void;

    /**
     * Callback when the service is unregistered successfully.
     * @param   aServiceInfo
     *          the info about the unregistered service.
     */
    readonly onServiceUnregistered: (aServiceInfo: (nsIDNSServiceInfo | null)) => void;

    /**
     * Callback when the service cannot be registered.
     * @param   aServiceInfo
     *          the info about the service to be registered.
     * @param   aErrorCode
     *          the error code.
     */
    readonly onRegistrationFailed: (aServiceInfo: (nsIDNSServiceInfo | null), aErrorCode: number) => void;

    /**
     * Callback when the service cannot be unregistered.
     * @param   aServiceInfo
     *          the info about the registered service.
     * @param   aErrorCode
     *          the error code.
     */
    readonly onUnregistrationFailed: (aServiceInfo: (nsIDNSServiceInfo | null), aErrorCode: number) => void;
  }

  export interface nsIInlineSpellCheckerRef {
    readonly name: "nsIInlineSpellChecker";
    readonly number: "{b7b7a77c-40c4-4196-b0b7-b0338243b3fe}";
  }

  export interface nsIInlineSpellChecker extends nsISupports {

    readonly spellChecker: (nsIEditorSpellCheck | null);

    readonly init: (aEditor: (nsIEditor | null)) => void;

    readonly cleanup: (aDestroyingFrames: boolean) => void;

    enableRealTimeSpell: boolean;

    readonly spellCheckRange: (aSelection: WebIDL.Range) => void;

    readonly getMisspelledWord: (aNode: WebIDL.Node, aOffset: number) => WebIDL.Range;

    readonly replaceWord: (aNode: WebIDL.Node, aOffset: number, aNewword: IDLAString) => void;

    readonly addWordToDictionary: (aWord: IDLAString) => void;

    readonly removeWordFromDictionary: (aWord: IDLAString) => void;

    readonly ignoreWord: (aWord: IDLAString) => void;

    readonly ignoreWords: (aWordsToIgnore: IDLAString[]) => void;

    readonly updateCurrentDictionary: () => void;

    readonly spellCheckPending: boolean;
  }

  export interface nsIScriptableBase64EncoderRef {
    readonly name: "nsIScriptableBase64Encoder";
    readonly number: "{9479c864-d1f9-45ab-b7b9-28b907bd2ba9}";
  }

  /**
   * nsIScriptableBase64Encoder efficiently encodes the contents
   * of a nsIInputStream to a Base64 string.  This avoids the need
   * to read the entire stream into a buffer, and only then do the
   * Base64 encoding.
   *
   *  If you already have a buffer full of data, you should use
   *  btoa instead!
   */
  export interface nsIScriptableBase64Encoder extends nsISupports {

    /**
     *  These methods take an nsIInputStream and return a narrow or wide
     *  string with the contents of the nsIInputStream base64 encoded.
     *
     *  The stream passed in must support ReadSegments and must not be
     *  a non-blocking stream that will return NS_BASE_STREAM_WOULD_BLOCK.
     *  If either of these restrictions are violated we will abort.
     */
    readonly encodeToCString: (stream: (nsIInputStream | null), length: number) => IDLACString;

    readonly encodeToString: (stream: (nsIInputStream | null), length: number) => IDLAString;
  }

  export interface nsIConsoleMessageRef {
    readonly name: "nsIConsoleMessage";
    readonly number: "{3aba9617-10e2-4839-83ae-2e6fc4df428b}";

    /** Log level constants. */
    debug: 0;

    info: 1;

    warn: 2;

    error: 3;
  }

  /**
   * This is intended as a base interface; implementations may want to
   * provide an object that can be qi'ed to provide more specific
   * message information.
   */
  export interface nsIConsoleMessage extends nsISupports {

    /**
     * The log level of this message.
     */
    readonly logLevel: number;

    /**
     * The time (in milliseconds from the Epoch) that the message instance
     * was initialised.
     * The timestamp is initialized as JS_now/1000 so that it can be
     * compared to Date.now in Javascript.
     */
    readonly timeStamp: number;

    readonly message: IDLAString;

    readonly toString: () => IDLAUTF8String;
  }

  export interface nsIWebVTTParserWrapperRef {
    readonly name: "nsIWebVTTParserWrapper";
    readonly number: "{8dfe016e-1701-4618-9f5e-9a6154e853f0}";
  }

  /**
   * Interface for a wrapper of a JS WebVTT parser (vtt.js).
   */
  export interface nsIWebVTTParserWrapper extends nsISupports {

    /**
     * Loads the JS WebVTTParser and sets it to use the passed window to create
     * VTTRegions and VTTCues. This function must be called before calling
     * parse, flush, or watch.
     *
     * @param window The window that the parser will use to create VTTCues and
     *               VTTRegions.
     *
     */
    readonly loadParser: (window: (mozIDOMWindow | null)) => void;

    /**
     * Attempts to parse the stream's data as WebVTT format. When it successfully
     * parses a WebVTT region or WebVTT cue it will create a VTTRegion or VTTCue
     * object and pass it back to the callee through its callbacks.
     *
     * @param data   The buffer that contains the WebVTT data received by the
     *               Necko consumer so far.
     */
    readonly parse: (data: IDLACString) => void;

    /**
     * Flush indicates that no more data is expected from the stream. As such the
     * parser should try to parse any kind of partial data it has.
     */
    readonly flush: () => void;

    /**
     * Set this parser object to use an nsIWebVTTListener object for its onCue
     * and onRegion callbacks.
     *
     * @param callback The nsIWebVTTListener object that exposes onCue and
     *                 onRegion callbacks for the parser.
     */
    readonly watch: (callback: (nsIWebVTTListener | null)) => void;

    /**
     * Cancel watching notifications which parser would send.
     */
    readonly cancel: () => void;

    /**
     * Convert the text content of a WebVTT cue to a document fragment so that
     * we can display it on the page.
     *
     * @param window A window object with which the document fragment will be
     *               created.
     * @param cue    The cue whose content will be converted to a document
     *               fragment.
     */
    readonly convertCueToDOMTree: (window: (mozIDOMWindow | null), cue: (nsISupports | null)) => WebIDL.DocumentFragment;

    /**
     * Compute the display state of the VTTCues in cues along with any VTTRegions
     * that they might be in. First, it computes the positioning and styling of
     * the cues and regions passed and converts them into a DOM tree rooted at
     * a containing HTMLDivElement. It then adjusts those computed divs for
     * overlap avoidance using the dimensions of 'overlay'. Finally, it adds the
     * computed divs to the VTTCues display state property for use later.
     *
     * @param window  A window object with which it will create the DOM tree
     *                and containing div element.
     * @param cues    An array of VTTCues who need there display state to be
     *                computed.
     * @param overlay The HTMLElement that the cues will be displayed within.
     * @param controls The video control element that will affect cues position.
     */
    readonly processCues: (window: (mozIDOMWindow | null), cues: (nsIVariant | null), overlay: (nsISupports | null), controls: (nsISupports | null)) => void;
  }

  export interface nsIWindowWatcherRef {
    readonly name: "nsIWindowWatcher";
    readonly number: "{641fe945-6902-4b3f-87c2-0daef32499b3}";
  }

  /**
   * nsIWindowWatcher is the keeper of Gecko/DOM Windows. It maintains
   * a list of open top-level windows, and allows some operations on them.
   
   * Usage notes:
   
   *   This component has an |activeWindow| property. Clients may expect
   * this property to be always current, so to properly integrate this component
   * the application will need to keep it current by setting the property
   * as the active window changes.
   *   This component should not keep a (XPCOM) reference to any windows;
   * the implementation will claim no ownership. Windows must notify
   * this component when they are created or destroyed, so only a weak
   * reference is kept. Note that there is no interface for such notifications
   * (not a public one, anyway). This is taken care of both in Mozilla and
   * by common embedding code. Embedding clients need do nothing special
   * about that requirement.
   *   This component must be initialized at application startup by calling
   * setWindowCreator.
   */
  export interface nsIWindowWatcher extends nsISupports {

    /** Create a new window. It will automatically be added to our list
          (via addWindow()).
          @param aParent parent window, if any. Null if no parent.  If it is
                 impossible to get to an nsIWebBrowserChrome from aParent, this
                 method will effectively act as if aParent were null.
          @param aURL url to which to open the new window. Must already be
                 escaped, if applicable. can be null.
          @param aName window name from JS window.open. can be null.  If a window
                 with this name already exists, the openWindow call may just load
                 aUrl in it (if aUrl is not null) and return it.
          @param aFeatures window features from JS window.open. can be null.
          @param aArguments extra argument(s) to the new window, to be attached
                 as the |arguments| property. An nsIArray will be
                 unwound into multiple arguments (but not recursively!).
                 can be null.
          @return the new window

          @note This method may examine the JS context stack for purposes of
                determining the security context to use for the search for a given
                window named aName.
          @note This method should try to set the default charset for the new
                window to the default charset of aParent.  This is not guaranteed,
                however.
          @note This method may dispatch a "toplevel-window-ready" notification
                via nsIObserverService if the window did not already exist.
      */
    readonly openWindow: (aParent: (mozIDOMWindowProxy | null), aUrl: string, aName: string, aFeatures: string, aArguments: (nsISupports | null)) => (mozIDOMWindowProxy | null);

    /** Clients of this service can register themselves to be notified
          when a window is opened or closed (added to or removed from this
          service). This method adds an aObserver to the list of objects
          to be notified.
          @param aObserver the object to be notified when windows are
                           opened or closed. Its Observe method will be
                           called with the following parameters:

          aObserver::Observe interprets its parameters so:
          aSubject the window being opened or closed, sent as an nsISupports
                   which can be QIed to an nsIDOMWindow.
          aTopic   a wstring, either "domwindowopened" or "domwindowclosed".
          someData not used.
      */
    readonly registerNotification: (aObserver: (nsIObserver | nsIObserverFunction | null)) => void;

    /** Clients of this service can register themselves to be notified
          when a window is opened or closed (added to or removed from this
          service). This method removes an aObserver from the list of objects
          to be notified.
          @param aObserver the observer to be removed.
      */
    readonly unregisterNotification: (aObserver: (nsIObserver | nsIObserverFunction | null)) => void;

    /** Get an iterator for currently open windows in the order they were opened,
          guaranteeing that each will be visited exactly once.
          @return an enumerator which will itself return nsISupports objects which
                  can be QIed to an nsIDOMWindow
      */
    readonly getWindowEnumerator: () => (nsISimpleEnumerator | null);

    /** Return a newly created nsIPrompt implementation.
          @param aParent the parent window used for posing alerts. can be null.
          @return a new nsIPrompt object
      */
    readonly getNewPrompter: (aParent: (mozIDOMWindowProxy | null)) => (nsIPrompt | null);

    /** Return a newly created nsIAuthPrompt implementation.
          @param aParent the parent window used for posing alerts. can be null.
          @return a new nsIAuthPrompt object
      */
    readonly getNewAuthPrompter: (aParent: (mozIDOMWindowProxy | null)) => (nsIAuthPrompt | null);

    /** Set the window creator callback. It must be filled in by the app.
          openWindow will use it to create new windows.
          @param creator the callback. if null, the callback will be cleared
                         and window creation capabilities lost.
      */
    readonly setWindowCreator: (creator: (nsIWindowCreator | null)) => void;

    /** Returns true if a window creator callback has been set, false otherwise.
     */
    readonly hasWindowCreator: () => boolean;

    /** Retrieve the chrome window mapped to the given DOM window. Window
          Watcher keeps a list of all top-level DOM windows currently open,
          along with their corresponding chrome interfaces. Since DOM Windows
          lack a (public) means of retrieving their corresponding chrome,
          this method will do that.
          @param aWindow the DOM window whose chrome window the caller needs
          @return the corresponding chrome window
      */
    readonly getChromeForWindow: (aWindow: (mozIDOMWindowProxy | null)) => (nsIWebBrowserChrome | null);

    /**
          Retrieve an existing window (or frame).
          @param aTargetName the window name
          @param aCurrentWindow a starting point in the window hierarchy to
                                begin the search.  If null, each toplevel window
                                will be searched.

          Note: This method will search all open windows for any window or
          frame with the given window name. Make sure you understand the
          security implications of this before using this method!
      */
    readonly getWindowByName: (aTargetName: IDLAString, aCurrentWindow: (mozIDOMWindowProxy | null)) => (mozIDOMWindowProxy | null);

    /** The Watcher serves as a global storage facility for the current active
          (frontmost non-floating-palette-type) window, storing and returning
          it on demand. Users must keep this attribute current, including after
          the topmost window is closed. This attribute obviously can return null
          if no windows are open, but should otherwise always return a valid
          window.
      */
    activeWindow: (mozIDOMWindowProxy | null);
  }

  export interface nsIInputIteratorRef {
    readonly name: "nsIInputIterator";
    readonly number: "{85585e12-1dd2-11b2-a930-f6929058269a}";
  }

  /**
   * ...
   */
  export interface nsIInputIterator extends nsISupports {

    /**
     * Retrieve (and |AddRef()|) the element this iterator currently points to.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @result a new reference to the element this iterator currently points to (if any)
     */
    readonly getElement: () => (nsISupports | null);

    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    readonly stepForward: () => void;

    /**
     * Test if |anotherIterator| points to the same position in the underlying container or sequence.
     *
     * The result is undefined if |anotherIterator| was not created by or for the same underlying container or sequence.
     *
     * @param anotherIterator another iterator to compare against, created by or for the same underlying container or sequence
     * @result true if |anotherIterator| points to the same position in the underlying container or sequence
     */
    readonly isEqualTo: (anotherIterator: (nsISupports | null)) => boolean;

    /**
     * Create a new iterator pointing to the same position in the underlying container or sequence to which this iterator currently points.
     * The returned iterator is suitable for use in a subsequent call to |isEqualTo()| against this iterator.
     *
     * @result a new iterator pointing at the same position in the same underlying container or sequence as this iterator
     */
    readonly clone: () => (nsISupports | null);
  }

  export interface nsIUrlClassifierDBServiceRef {
    readonly name: "nsIUrlClassifierDBService";
    readonly number: "{7a258022-6765-11e5-b379-b37b1f2354be}";
  }

  /**
   * This is a proxy class that is instantiated and called from the JS thread.
   * It provides async methods for querying and updating the database.  As the
   * methods complete, they call the callback function.
   */
  export interface nsIUrlClassifierDBService extends nsISupports {

    /**
     * Looks up a URI in the specified tables.
     *
     * @param principal: The principal containing the URI to search.
     * @param c: The callback will be called with a comma-separated list
     *        of tables to which the key belongs.
     */
    readonly lookup: (principal: (nsIPrincipal | null), tables: IDLACString, c: (nsIUrlClassifierCallback | nsIUrlClassifierCallbackFunction | null)) => void;

    /**
     * Lists the tables along with their meta info in the following format:
     *
     *   tablename;[metadata]\n
     *   tablename2;[metadata]\n
     *
     * For v2 tables, the metadata is the chunks info such as
     *
     *   goog-phish-shavar;a:10,14,30-40s:56,67
     *   goog-unwanted-shavar;a:1-3,5
     *
     * For v4 tables, base64 encoded state is currently the only info in the
     * metadata (can be extended whenever necessary). For exmaple,
     *
     *   goog-phish-proto;Cg0IARAGGAEiAzAwMTABEKqTARoCGAjT1gDD:oCGAjT1gDD\n
     *   goog-malware-proto;Cg0IAhAGGAEiAzAwMTABENCQARoCGAjx5Yty:BENCQARoCGAj\n
     *
     * Note that the metadata is colon-separated.
     *
     */
    readonly getTables: (c: (nsIUrlClassifierCallback | nsIUrlClassifierCallbackFunction | null)) => void;

    /**
     * Set the nsIUrlClassifierCompleter object for a given table.  This
     * object will be used to request complete versions of partial
     * hashes.
     */
    readonly setHashCompleter: (tableName: IDLACString, completer: (nsIUrlClassifierHashCompleter | null)) => void;

    /**
     * Forget the results that were used in the last DB update.
     */
    readonly clearLastResults: () => void;

    /**
     * Begin an update process.  Will throw NS_ERROR_NOT_AVAILABLE if there
     * is already an update in progress.
     *
     * @param updater The update observer tied to this update.
     * @param tables A comma-separated list of tables included in this update.
     */
    readonly beginUpdate: (updater: (nsIUrlClassifierUpdateObserver | null), tables: IDLACString) => void;

    /**
     * Begin a stream update.  This should be called once per url being
     * fetched.
     *
     * @param table The table the contents of this stream will be associated
     *              with, or empty for the initial stream.
     */
    readonly beginStream: (table: IDLACString) => void;

    /**
     * Update the table incrementally.
     */
    readonly updateStream: (updateChunk: IDLACString) => void;

    /**
     * Finish an individual stream update.  Must be called for every
     * beginStream() call, before the next beginStream() or finishUpdate().
     *
     * The update observer's streamFinished will be called once the
     * stream has been processed.
     */
    readonly finishStream: () => void;

    /**
     * Finish an incremental update.  This will attempt to commit any
     * pending changes and resets the update interface.
     *
     * The update observer's updateSucceeded or updateError methods
     * will be called when the update has been processed.
     */
    readonly finishUpdate: () => void;

    /**
     * Cancel an incremental update.  This rolls back any pending changes.
     * and resets the update interface.
     *
     * The update observer's updateError method will be called when the
     * update has been rolled back.
     */
    readonly cancelUpdate: () => void;

    /**
     * Reset the url-classifier database.  This call will delete the existing
     * database, emptying all tables.  Mostly intended for use in unit tests.
     */
    readonly resetDatabase: () => void;

    /**
     * Reload he url-classifier database. This will empty all cache for
     * completions from gethash, and reload it from database. Mostly intended
     * for use in tests.
     */
    readonly reloadDatabase: () => void;

    /**
     * Empty all the caches.
     */
    readonly clearCache: () => void;
  }

  export interface nsICookieServiceRef {
    readonly name: "nsICookieService";
    readonly number: "{1e94e283-2811-4f43-b947-d22b1549d824}";

    BEHAVIOR_ACCEPT: 0;

    BEHAVIOR_REJECT_FOREIGN: 1;

    BEHAVIOR_REJECT: 2;

    BEHAVIOR_LIMIT_FOREIGN: 3;

    BEHAVIOR_REJECT_TRACKER: 4;

    BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN: 5;

    BEHAVIOR_LAST: 5;

    ACCEPT_NORMALLY: 0;

    ACCEPT_SESSION: 2;
  }

  /**
   * nsICookieService
   *
   * Provides methods for setting and getting cookies in the context of a
   * page load.  See nsICookieManager for methods to manipulate the cookie
   * database directly.  This separation of interface is mainly historical.
   *
   * This service broadcasts the notifications detailed below when the cookie
   * list is changed, or a cookie is rejected.
   *
   * NOTE: observers of these notifications *must* not attempt to change profile
   *       or switch into or out of private browsing mode from within the
   *       observer. Doing so will cause undefined behavior. Mutating the cookie
   *       list (e.g. by calling methods on nsICookieService and friends) is
   *       allowed, but beware that there may be pending notifications you haven't
   *       seen yet -- for instance, a "batch-deleted" notification will likely be
   *       immediately followed by "added". You may check the state of the cookie
   *       list to determine if this is the case.
   *
   * topic  : "cookie-changed"
   *          broadcast whenever the cookie list changes in some way. see
   *          explanation of data strings below.
   * subject: see below.
   * data   : "deleted"
   *          a cookie was deleted. the subject is an nsICookie representing
   *          the deleted cookie.
   *          "added"
   *          a cookie was added. the subject is an nsICookie representing
   *          the added cookie.
   *          "changed"
   *          a cookie was changed. the subject is an nsICookie representing
   *          the new cookie. (note that host, path, and name are invariant
   *          for a given cookie; other parameters may change.)
   *          "batch-deleted"
   *          a set of cookies was purged (typically, because they have either
   *          expired or because the cookie list has grown too large). The subject
   *          is an nsIArray of nsICookie's representing the deleted cookies.
   *          Note that the array could contain a single cookie.
   *          "cleared"
   *          the entire cookie list was cleared. the subject is null.
   *
   * topic  : "cookie-rejected"
   *          broadcast whenever a cookie was rejected from being set as a
   *          result of user prefs.
   * subject: an nsIURI interface pointer representing the URI that attempted
   *          to set the cookie.
   * data   : none.
   */
  export interface nsICookieService extends nsISupports {

    readonly getCookieString: (aURI: (nsIURI | null), aChannel: (nsIChannel | null)) => IDLACString;

    readonly getCookieStringFromHttp: (aURI: (nsIURI | null), aFirstURI: (nsIURI | null), aChannel: (nsIChannel | null)) => IDLACString;

    readonly setCookieString: (aURI: (nsIURI | null), aPrompt: (nsIPrompt | null), aCookie: IDLACString, aChannel: (nsIChannel | null)) => void;

    readonly setCookieStringFromHttp: (aURI: (nsIURI | null), aFirstURI: (nsIURI | null), aPrompt: (nsIPrompt | null), aCookie: IDLACString, aServerTime: IDLACString, aChannel: (nsIChannel | null)) => void;

    readonly runInTransaction: (aCallback: (nsICookieTransactionCallback | nsICookieTransactionCallbackFunction | null)) => void;
  }

  export interface nsIPaymentItemRef {
    readonly name: "nsIPaymentItem";
    readonly number: "{4f78a59f-b5ff-4fb5-ab48-3b37d0101b02}";
  }

  export interface nsIPaymentItem extends nsISupports {

    readonly label: IDLAString;

    readonly amount: (nsIPaymentCurrencyAmount | null);

    readonly pending: boolean;
  }

  export interface nsISpeculativeConnectRef {
    readonly name: "nsISpeculativeConnect";
    readonly number: "{d74a17ac-5b8a-4824-a309-b1f04a3c4aed}";
  }

  export interface nsISpeculativeConnect extends nsISupports {

    /**
     * Called as a hint to indicate a new transaction for the URI is likely coming
     * soon. The implementer may use this information to start a TCP
     * and/or SSL level handshake for that resource immediately so that it is
     * ready and/or progressed when the transaction is actually submitted.
     *
     * No obligation is taken on by the implementer, nor is the submitter obligated
     * to actually open the new channel.
     *
     * @param aURI the URI of the hinted transaction
     * @param aPrincipal the principal that will be used for opening the
     *        channel of the hinted transaction.
     * @param aCallbacks any security callbacks for use with SSL for interfaces.
     *        May be null.
     *
     */
    readonly speculativeConnect: (aURI: (nsIURI | null), aPrincipal: (nsIPrincipal | null), aCallbacks: (nsIInterfaceRequestor | null)) => void;

    readonly speculativeAnonymousConnect: (aURI: (nsIURI | null), aPrincipal: (nsIPrincipal | null), aCallbacks: (nsIInterfaceRequestor | null)) => void;
  }

  export interface nsINetworkInfoServiceRef {
    readonly name: "nsINetworkInfoService";
    readonly number: "{55fc8dae-4a58-4e0f-a49b-901cbabae809}";
  }

  /**
   * Service information
   */
  export interface nsINetworkInfoService extends nsISupports {

    /**
     * Obtain a list of local machine network addresses.  The listener object's
     * onListedNetworkAddresses will be called with the obtained addresses.
     * On failure, the listener object's onListNetworkAddressesFailed() will be called.
     */
    readonly listNetworkAddresses: (aListener: (nsIListNetworkAddressesListener | null)) => void;

    /**
     * Obtain the hostname of the local machine.  The listener object's
     * onGotHostname will be called with the obtained hostname.
     * On failure, the listener object's onGetHostnameFailed() will be called.
     */
    readonly getHostname: (aListener: (nsIGetHostnameListener | null)) => void;
  }

  export interface nsIFactoryRef {
    readonly name: "nsIFactory";
    readonly number: "{00000001-0000-0000-c000-000000000046}";
  }

  /**
   * A class factory allows the creation of nsISupports derived
   * components without specifying a concrete base class.
   */
  export interface nsIFactory extends nsISupports {

    /**
     * LockFactory provides the client a way to keep the component
     * in memory until it is finished with it. The client can call
     * LockFactory(PR_TRUE) to lock the factory and LockFactory(PR_FALSE)
     * to release the factory.
     *
     * @param lock - Must be PR_TRUE or PR_FALSE
     * @throws NS_ERROR* - Method failure.
     */
    readonly lockFactory: (lock: boolean) => void;
  }

  export interface nsIURLMutatorRef {
    readonly name: "nsIURLMutator";
    readonly number: "{25072eb8-f1e6-482f-9ca9-eddd3d65169a}";
  }

  export interface nsIURLMutator extends nsISupports {

    readonly setFileName: (aFileName: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setFileBaseName: (aFileBaseName: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setFileExtension: (aFileExtension: IDLAUTF8String) => (nsIURIMutator | null);
  }

  export interface nsICancelableRef {
    readonly name: "nsICancelable";
    readonly number: "{d94ac0a0-bb18-46b8-844e-84159064b0bd}";
  }

  /**
   * This interface provides a means to cancel an operation that is in progress.
   */
  export interface nsICancelable extends nsISupports {

    /**
     * Call this method to request that this object abort whatever operation it
     * may be performing.
     *
     * @param aReason
     *        Pass a failure code to indicate the reason why this operation is
     *        being canceled.  It is an error to pass a success code.
     */
    readonly cancel: (aReason: number) => void;
  }

  export interface mozIExtensionProcessScriptRef {
    readonly name: "mozIExtensionProcessScript";
    readonly number: "{6b09dc51-6caa-4ca7-9d6d-30c87258a630}";
  }

  export interface mozIExtensionProcessScript extends nsISupports {

    readonly preloadContentScript: (contentScript: (nsISupports | null)) => void;

    readonly loadContentScript: (contentScript: WebIDL.WebExtensionContentScript, window: (mozIDOMWindow | null)) => IDLPromise;

    readonly initExtensionDocument: (extension: (nsISupports | null), doc: WebIDL.Document, privileged: boolean) => void;
  }

  export interface nsIUDPSocketInternalRef {
    readonly name: "nsIUDPSocketInternal";
    readonly number: "{613dd3ad-598b-4da9-ad63-bbda50c20098}";
  }

  export interface nsIUDPSocketInternal extends nsISupports {

    readonly callListenerOpened: () => void;

    readonly callListenerConnected: () => void;

    readonly callListenerClosed: () => void;

    readonly callListenerReceivedData: (host: IDLAUTF8String, port: number, data: number[]) => void;

    readonly callListenerError: (message: IDLAUTF8String, filename: IDLAUTF8String, lineNumber: number) => void;
  }

  export interface nsIObjectInputStreamRef {
    readonly name: "nsIObjectInputStream";
    readonly number: "{6c248606-4eae-46fa-9df0-ba58502368eb}";
  }

  /**
   * @see nsIObjectOutputStream
   * @see nsIBinaryInputStream
   */
  export interface nsIObjectInputStream extends nsIBinaryInputStream {

    /**
     * Read an object from this stream to satisfy a strong or weak reference
     * to one of its interfaces.  If the interface was not along the primary
     * inheritance chain ending in the "root" or XPCOM-identity nsISupports,
     * readObject will QueryInterface from the deserialized object root to the
     * correct interface, which was specified when the object was serialized.
     *
     * @see nsIObjectOutputStream
     */
    readonly readObject: (aIsStrongRef: boolean) => (nsISupports | null);
  }

  export interface nsIURIContentListenerRef {
    readonly name: "nsIURIContentListener";
    readonly number: "{10a28f38-32e8-4c63-8aa1-12eaaebc369a}";
  }

  /**
   * nsIURIContentListener is an interface used by components which
   * want to know (and have a chance to handle) a particular content type.
   * Typical usage scenarios will include running applications which register
   * a nsIURIContentListener for each of its content windows with the uri
   * dispatcher service.
   */
  export interface nsIURIContentListener extends nsISupports {

    /**
     * Gives the original content listener first crack at stopping a load before
     * it happens.
     *
     * @param aURI   URI that is being opened.
     *
     * @return       <code>false</code> if the load can continue;
     *               <code>true</code> if the open should be aborted.
     */
    readonly onStartURIOpen: (aURI: (nsIURI | null)) => boolean;

    /**
     * Notifies the content listener to hook up an nsIStreamListener capable of
     * consuming the data stream.
     *
     * @param aContentType         Content type of the data.
     * @param aIsContentPreferred  Indicates whether the content should be
     *                             preferred by this listener.
     * @param aRequest             Request that is providing the data.
     * @param aContentHandler      nsIStreamListener that will consume the data.
     *                             This should be set to <code>nullptr</code> if
     *                             this content listener can't handle the content
     *                             type; in this case, doContent should also fail
     *                             (i.e., return failure nsresult).
     *
     * @return                     <code>true</code> if the load should
     *                             be aborted and consumer wants to
     *                             handle the load completely by itself.  This
     *                             causes the URI Loader do nothing else...
     *                             <code>false</code> if the URI Loader should
     *                             continue handling the load and call the
     *                             returned streamlistener's methods.
     */
    readonly doContent: (aContentType: IDLACString, aIsContentPreferred: boolean, aRequest: (nsIRequest | null), aContentHandler: Out<(nsIStreamListener | null)>) => boolean;

    /**
     * When given a uri to dispatch, if the URI is specified as 'preferred
     * content' then the uri loader tries to find a preferred content handler
     * for the content type. The thought is that many content listeners may
     * be able to handle the same content type if they have to. i.e. the mail
     * content window can handle text/html just like a browser window content
     * listener. However, if the user clicks on a link with text/html content,
     * then the browser window should handle that content and not the mail
     * window where the user may have clicked the link.  This is the difference
     * between isPreferred and canHandleContent.
     *
     * @param aContentType         Content type of the data.
     * @param aDesiredContentType  Indicates that aContentType must be converted
     *                             to aDesiredContentType before processing the
     *                             data.  This causes a stream converted to be
     *                             inserted into the nsIStreamListener chain.
     *                             This argument can be <code>nullptr</code> if
     *                             the content should be consumed directly as
     *                             aContentType.
     *
     * @return                     <code>true</code> if this is a preferred
     *                             content handler for aContentType;
     *                             <code>false<code> otherwise.
     */
    readonly isPreferred: (aContentType: string, aDesiredContentType: Out<string>) => boolean;

    /**
     * When given a uri to dispatch, if the URI is not specified as 'preferred
     * content' then the uri loader calls canHandleContent to see if the content
     * listener is capable of handling the content.
     *
     * @param aContentType         Content type of the data.
     * @param aIsContentPreferred  Indicates whether the content should be
     *                             preferred by this listener.
     * @param aDesiredContentType  Indicates that aContentType must be converted
     *                             to aDesiredContentType before processing the
     *                             data.  This causes a stream converted to be
     *                             inserted into the nsIStreamListener chain.
     *                             This argument can be <code>nullptr</code> if
     *                             the content should be consumed directly as
     *                             aContentType.
     *
     * @return                     <code>true</code> if the data can be consumed.
     *                             <code>false</code> otherwise.
     *
     * Note: I really envision canHandleContent as a method implemented
     * by the docshell as the implementation is generic to all doc
     * shells. The isPreferred decision is a decision made by a top level
     * application content listener that sits at the top of the docshell
     * hierarchy.
     */
    readonly canHandleContent: (aContentType: string, aIsContentPreferred: boolean, aDesiredContentType: Out<string>) => boolean;

    /**
     * The load context associated with a particular content listener.
     * The URI Loader stores and accesses this value as needed.
     */
    loadCookie: (nsISupports | null);

    /**
     * The parent content listener if this particular listener is part of a chain
     * of content listeners (i.e. a docshell!)
     *
     * @note If this attribute is set to an object that implements
     *       nsISupportsWeakReference, the implementation should get the
     *       nsIWeakReference and hold that.  Otherwise, the implementation
     *       should not refcount this interface; it should assume that a non
     *       null value is always valid.  In that case, the caller is
     *       responsible for explicitly setting this value back to null if the
     *       parent content listener is destroyed.
     */
    parentContentListener: (nsIURIContentListener | null);
  }

  export interface nsIOSReauthenticatorRef {
    readonly name: "nsIOSReauthenticator";
    readonly number: "{4fe082ae-6ff0-4b41-b24f-eaa664f6e46a}";
  }

  export interface nsIOSReauthenticator extends nsISupports {

    /**
     * This interface provides an abstract way to request that the user
     * reauthenticate themselves to the operating system. It may be useful in
     * conjunction with nsIOSKeyStore, whereby consumers of these APIs may
     * consider some secrets too sensitive to access without first
     * reauthenticating the user.
     *
     * Usage:
     *
     * // obtain the singleton nsIOSReauthenticator instance
     * const reauthenticator = Cc["@mozilla.org/security/osreauthenticator;1"]
     *                           .getService(Ci.nsIOSReauthenticator);
     * if (await reauthenticator.asyncReauthenticate()) {
     *   // do something only authenticated users are allowed to do...
     * } else {
     *   // show a "sorry, this isn't allowed" error
     * }
     */
    /**
     * Asynchronously cause the operating system to request that the user
     * reauthenticate. This is typically in the form of a dialog box asking the
     * user for their login password. The actual behaviour of this depends on the
     * OS.
     *
     * @param prompt A short string that may be incorporated in the dialog
     * @return Promise resolving to true if the user successfully authenticated
     *         and false otherwise.
     */
    readonly asyncReauthenticateUser: (prompt: IDLACString) => IDLPromise;
  }

  export interface nsIExceptionRef {
    readonly name: "nsIException";
    readonly number: "{4371b5bf-6845-487f-8d9d-3f1e4a9badd2}";
  }

  export interface nsIException extends nsISupports {
  }

  export interface nsIStringBundleRef {
    readonly name: "nsIStringBundle";
    readonly number: "{d85a17c2-aa7c-11d2-9b8c-00805f8a16d9}";
  }

  export interface nsIStringBundle extends nsISupports {

    readonly GetStringFromID: (aID: number) => IDLAString;

    readonly GetStringFromName: (aName: IDLAUTF8String) => IDLAString;

    readonly formatStringFromID: (aID: number, params: IDLAString[]) => IDLAString;

    readonly formatStringFromName: (aName: IDLAUTF8String, params: IDLAString[]) => IDLAString;

    readonly getSimpleEnumeration: () => (nsISimpleEnumerator | null);

    readonly asyncPreload: () => void;
  }

  export interface nsIControllerContextRef {
    readonly name: "nsIControllerContext";
    readonly number: "{47b82b60-a36f-4167-8072-6f421151ed50}";
  }

  export interface nsIControllerContext extends nsISupports {

    /**
     *  Set a context on this controller, which is passed
     *  to commands to give them some context when they execute.
     *
     * @param aCommandContext  the context passed to commands.
     *                        Note that this is *not* addreffed by the
     *                        controller, and so needs to outlive it,
     *                        or be nulled out.
     */
    readonly setCommandContext: (aCommandContext: (nsISupports | null)) => void;
  }

  export interface nsIClassInfoRef {
    readonly name: "nsIClassInfo";
    readonly number: "{a60569d7-d401-4677-ba63-2aa5971af25d}";

    /**
     * Bitflags for 'flags' attribute.
     */
    SINGLETON: 1;

    THREADSAFE: 2;

    MAIN_THREAD_ONLY: 4;

    DOM_OBJECT: 8;

    PLUGIN_OBJECT: 16;

    SINGLETON_CLASSINFO: 32;

    RESERVED: 2147483648;
  }

  /**
   * Provides information about a specific implementation class.  If you want
   * your class to implement nsIClassInfo, see nsIClassInfoImpl.h for
   * instructions--you most likely do not want to inherit from nsIClassInfo.
   */
  export interface nsIClassInfo extends nsISupports {

    /**
     * A contract ID through which an instance of this class can be created
     * (or accessed as a service, if |flags & SINGLETON|), or null/void.
     */
    readonly contractID: IDLAUTF8String;

    /**
     * A human readable string naming the class, or null/void.
     */
    readonly classDescription: IDLAUTF8String;

    readonly flags: number;
  }

  export interface nsINotificationStorageCallbackRef {
    readonly name: "nsINotificationStorageCallback";
    readonly number: "{c1622232-259c-43b0-b52e-89c39dcd9796}";
  }

  export interface nsINotificationStorageCallback extends nsISupports {

    /**
     * Callback function used to pass single notification back
     * into C++ land for Notification.get return data.
     *
     * @param id: a uuid for this notification
     * @param title: the notification title
     * @param dir: the notification direction,
     *             possible values are "ltr", "rtl", "auto"
     * @param lang: the notification language
     * @param body: the notification body
     * @param tag: the notification tag
     */
    readonly handle: (id: IDLAString, title: IDLAString, dir: IDLAString, lang: IDLAString, body: IDLAString, tag: IDLAString, icon: IDLAString, data: IDLAString, behavior: IDLAString, serviceWorkerRegistrationScope: IDLAString) => void;

    /**
     * Callback function used to notify C++ the we have returned
     * all notification objects for this Notification.get call.
     */
    readonly done: () => void;
  }

  export interface mozIGCTelemetryJSMRef {
    readonly name: "mozIGCTelemetryJSM";
    readonly number: "{93b2a0ca-6306-41c1-b296-c57cad5175c7}";
  }

  export interface mozIGCTelemetryJSM extends nsISupports {

    readonly GCTelemetry: (mozIGCTelemetry | null);
  }

  export interface nsIDirectoryServiceRef {
    readonly name: "nsIDirectoryService";
    readonly number: "{57a66a60-d43a-11d3-8cc2-00609792278c}";
  }

  /**
   * nsIDirectoryService
   */
  export interface nsIDirectoryService extends nsISupports {

    /**
     * init
     *
     * Must be called. Used internally by XPCOM initialization.
     *
     */
    readonly init: () => void;

    /**
     * registerProvider
     *
     * Register a provider with the service.
     *
     * @param prov            The service will keep a strong reference
     *                        to this object. It will be released when
     *                        the service is released.
     *
     */
    readonly registerProvider: (prov: (nsIDirectoryServiceProvider | null)) => void;

    /**
     * unregisterProvider
     *
     * Unregister a provider with the service.
     *
     * @param prov
     *
     */
    readonly unregisterProvider: (prov: (nsIDirectoryServiceProvider | null)) => void;
  }

  export interface nsIThrottledInputChannelRef {
    readonly name: "nsIThrottledInputChannel";
    readonly number: "{0a32a100-c031-45b6-9e8b-0444c7d4a143}";
  }

  /**
   * A throttled input channel can be managed by an
   * nsIInputChannelThrottleQueue to limit how much data is sent during
   * a given time slice.
   */
  export interface nsIThrottledInputChannel extends nsISupports {

    /**
     * The queue that manages this channel.  Multiple channels can
     * share a single queue.  A null value means that no throttling
     * will be done.
     */
    throttleQueue: (nsIInputChannelThrottleQueue | null);
  }

  export interface nsITransportProviderRef {
    readonly name: "nsITransportProvider";
    readonly number: "{6fcec704-cfd2-46ef-a394-a64d5cb1475c}";
  }

  /**
   * An interface which can be used to asynchronously request a nsITransport
   * together with the input and output streams that go together with it.
   */
  export interface nsITransportProvider extends nsISupports {

    readonly setListener: (listener: (nsIHttpUpgradeListener | null)) => void;
  }

  export interface nsISecCheckWrapChannelRef {
    readonly name: "nsISecCheckWrapChannel";
    readonly number: "{9446c5d5-c9fb-4a6e-acf9-ca4fc666efe0}";
  }

  /**
   * nsISecCheckWrapChannel
   * Describes an XPCOM component used to wrap channels for performing
   * security checks. Channels wrapped inside this class can use
   * this interface to query the wrapped inner channel.
   */
  export interface nsISecCheckWrapChannel extends nsISupports {

    /**
     * Returns the wrapped channel inside this class.
     */
    readonly innerChannel: (nsIChannel | null);
  }

  export interface nsIXULBrowserWindowRef {
    readonly name: "nsIXULBrowserWindow";
    readonly number: "{a8675fa9-c8b4-4350-9803-c38f344a9e38}";
  }

  /**
   * The nsIXULBrowserWindow supplies the methods that may be called from the
   * internals of the browser area to tell the containing xul window to update
   * its ui.
   */
  export interface nsIXULBrowserWindow extends nsISupports {

    /**
     * Tells the object implementing this function what link we are currently
     * over.
     */
    readonly setOverLink: (link: IDLAString) => void;

    /**
     * Determines the appropriate target for a link.
     */
    readonly onBeforeLinkTraversal: (originalTarget: IDLAString, linkURI: (nsIURI | null), linkNode: WebIDL.Node, isAppTab: boolean) => IDLAString;

    /**
     * Find the initial browser of the window and set its remote attributes.
     * This can be used to ensure that there is a browser in a new window of the
     * correct type when it first spawns.
     */
    readonly forceInitialBrowserNonRemote: (openerWindow: (mozIDOMWindowProxy | null)) => void;

    /**
     * Determines whether a load should continue.
     *
     * @param aDocShell
     *        The docshell performing the load.
     * @param aURI
     *        The URI being loaded.
     * @param aReferrerInfo
     *        The referrerInfo of the load.
     * @param aHasPostData
     *        True if the load which is being asked about has associated post data
     *        which would be discarded if the load was redirected across process
     *        boundaries.
     * @param aTriggeringPrincipal
     *        The principal that initiated the load of aURI.
     * @param aCsp
     *        The CSP to be used for that load. That is the CSP that e.g. upgrades
     *        the load to HTTPS in case upgrade-insecure-requests is set
     */
    readonly shouldLoadURI: (aDocShell: (nsIDocShell | null), aURI: (nsIURI | null), aReferrerInfo: (nsIReferrerInfo | null), aHasPostData: boolean, aTriggeringPrincipal: (nsIPrincipal | null), aCsp: (nsIContentSecurityPolicy | null)) => boolean;

    /**
     * Show/hide a tooltip (when the user mouses over a link, say).
     */
    readonly showTooltip: (x: number, y: number, tooltip: IDLAString, direction: IDLAString, browser: WebIDL.Element) => void;

    readonly hideTooltip: () => void;

    /**
     * Return the number of tabs in this window.
     */
    readonly getTabCount: () => number;

    /**
     * Navigate the browser to the given history index after restoring the full history
     * from SessionStore. If the browser is currently in GroupedSHistory mode, it will
     * be reverted to a non-grouped history mode. If a process change is required to
     * perform the load, this will also occur.
     */
    readonly navigateAndRestoreByIndex: (aBrowser: (nsIBrowser | null), aIndex: number) => void;
  }

  export interface mozIStorageRowRef {
    readonly name: "mozIStorageRow";
    readonly number: "{62d1b6bd-cbfe-4f9b-aee1-0ead4af4e6dc}";
  }

  export interface mozIStorageRow extends mozIStorageValueArray {

    /**
     * Obtains the result of a given column specified by aIndex.
     *
     * @param aIndex
     *        Zero-based index of the result to get from the tuple.
     * @returns the result of the specified column.
     */
    readonly getResultByIndex: (aIndex: number) => (nsIVariant | null);

    /**
     * Obtains the result of a given column specified by aName.
     *
     * @param aName
     *        Name of the result to get from the tuple.
     * @returns the result of the specified column.
     * @note The name of a result column is the value of the "AS" clause for that
     *       column.  If there is no AS clause then the name of the column is
     *       unspecified and may change from one release to the next.
     */
    readonly getResultByName: (aName: IDLAUTF8String) => (nsIVariant | null);
  }

  export interface nsIDOMRequestServiceRef {
    readonly name: "nsIDOMRequestService";
    readonly number: "{9a57e5de-ce93-45fa-8145-755722834f7c}";
  }

  export interface nsIDOMRequestService extends nsISupports {

    readonly createRequest: (window: (mozIDOMWindow | null)) => WebIDL.DOMRequest;

    readonly fireSuccess: (request: WebIDL.DOMRequest, result: IDLjsval) => void;

    readonly fireError: (request: WebIDL.DOMRequest, error: IDLAString) => void;

    readonly fireSuccessAsync: (request: WebIDL.DOMRequest, result: IDLjsval) => void;

    readonly fireErrorAsync: (request: WebIDL.DOMRequest, error: IDLAString) => void;
  }

  export interface nsIAuthPromptRef {
    readonly name: "nsIAuthPrompt";
    readonly number: "{358089f9-ee4b-4711-82fd-bcd07fc62061}";

    SAVE_PASSWORD_NEVER: 0;

    SAVE_PASSWORD_FOR_SESSION: 1;

    SAVE_PASSWORD_PERMANENTLY: 2;
  }

  export interface nsIAuthPrompt extends nsISupports {

    /**
     * Puts up a text input dialog with OK and Cancel buttons.
     * Note: prompt uses separate args for the "in" and "out" values of the
     *       input field, whereas the other functions use a single inout arg.
     * @param  dialogText    The title for the dialog.
     * @param  text          The text to display in the dialog.
     * @param  passwordRealm The "realm" the password belongs to: e.g.
     *                       ldap://localhost/dc=test
     * @param  savePassword  One of the SAVE_PASSWORD_* options above.
     * @param  defaultText   The default text to display in the text input box.
     * @param  result        The value entered by the user if OK was
     *                       selected.
     * @return true for OK, false for Cancel
     */
    readonly prompt: (dialogTitle: string, text: string, passwordRealm: string, savePassword: number, defaultText: string, result: Out<string>) => boolean;

    /**
     * Puts up a username/password dialog with OK and Cancel buttons.
     * Puts up a password dialog with OK and Cancel buttons.
     * @param  dialogText    The title for the dialog.
     * @param  text          The text to display in the dialog.
     * @param  passwordRealm The "realm" the password belongs to: e.g.
     *                       ldap://localhost/dc=test
     * @param  savePassword  One of the SAVE_PASSWORD_* options above.
     * @param  user          The username entered in the dialog.
     * @param  pwd           The password entered by the user if OK was
     *                       selected.
     * @return true for OK, false for Cancel
     */
    readonly promptUsernameAndPassword: (dialogTitle: string, text: string, passwordRealm: string, savePassword: number, user: InOut<string>, pwd: InOut<string>) => boolean;

    /**
     * Puts up a password dialog with OK and Cancel buttons.
     * @param  dialogText    The title for the dialog.
     * @param  text          The text to display in the dialog.
     * @param  passwordRealm The "realm" the password belongs to: e.g.
     *                       ldap://localhost/dc=test. If a username is
     *                       specified (http://user@site.com) it will be used
     *                       when matching existing logins or saving new ones.
     *                       If no username is specified, only password-only
     *                       logins will be matched or saved.
     *                       Note: if a username is specified, the username
     *                       should be escaped.
     * @param  savePassword  One of the SAVE_PASSWORD_* options above.
     * @param  pwd           The password entered by the user if OK was
     *                       selected.
     * @return true for OK, false for Cancel
     */
    readonly promptPassword: (dialogTitle: string, text: string, passwordRealm: string, savePassword: number, pwd: InOut<string>) => boolean;
  }

  export interface mozIDOMWindowProxyRef {
    readonly name: "mozIDOMWindowProxy";
    readonly number: "{53ca090c-e739-48b9-8911-208c72f9191e}";
  }

  export interface mozIDOMWindowProxy extends nsISupports {
  }

  export interface nsIXPCComponents_ResultsRef {
    readonly name: "nsIXPCComponents_Results";
    readonly number: "{2fc229a0-5860-11d3-9899-006008962422}";
  }

  /**
   * interface of Components.results
   * (interesting stuff only reflected into JavaScript)
   */
  export interface nsIXPCComponents_Results extends nsISupports {
  }

  export interface nsIWebBrowserPersistDocumentRef {
    readonly name: "nsIWebBrowserPersistDocument";
    readonly number: "{74aa4918-5d15-46b6-9ccf-74f9696d721d}";
  }

  /**
   * Interface representing a document that can be serialized with
   * nsIWebBrowserPersist; it may or may not be in this process.  Some
   * information is exposed as attributes, which may or may not reflect
   * changes made to the underlying document; most of these are
   * self-explanatory from their names and types.
   */
  export interface nsIWebBrowserPersistDocument extends nsISupports {

    readonly isPrivate: boolean;

    readonly documentURI: IDLAUTF8String;

    readonly baseURI: IDLAUTF8String;

    readonly contentType: IDLACString;

    readonly characterSet: IDLACString;

    readonly title: IDLAString;

    readonly referrerInfo: (nsIReferrerInfo | null);

    readonly contentDisposition: IDLAString;

    readonly postData: (nsIInputStream | null);

    readonly principal: (nsIPrincipal | null);

    /**
     * The cache key.  Unlike in nsISHEntry, where it's wrapped in an
     * nsISupportsPRUint32, this is just the integer.
     */
    readonly cacheKey: number;

    /**
     * This attribute is set by nsIWebBrowserPersist implementations to
     * propagate persist flags that apply to the DOM traversal and
     * serialization (rather than to managing file I/O).
     */
    persistFlags: number;

    /**
     * Walk the DOM searching for external resources needed to render it.
     * The visitor callbacks may be called either before or after
     * readResources returns.
     *
     * @see nsIWebBrowserPersistResourceVisitor
     */
    readonly readResources: (aVisitor: (nsIWebBrowserPersistResourceVisitor | null)) => void;

    /**
     * Serialize the document's DOM.
     *
     * @param aStream       The output stream to write the document to.
     *
     * @param aURIMap       Optional; specifies URI rewriting to perform on
     *                      external references (as read by readResources).
     *                      If given, also causes relative hyperlinks to be
     *                      converted to absolute in the written text.
     *
     * @param aRequestedContentType
     *                      The desired MIME type to save the document as;
     *                      optional and defaults to the document's type.
     *                      (If no encoder exists for that type, "text/html"
     *                      is used instead.)
     *
     * @param aEncoderFlags Flags to pass to the encoder.
     *
     * @param aWrapColumn   Desired text width, ignored if wrapping is not
     *                      specified by the encoding flags, or if 0.
     *
     * @param aCompletion   Callback invoked when writing is complete.
     *                      It may be called either before or after writeContent
     *                      returns.
     *
     * @see nsIDocumentEncoder
     */
    readonly writeContent: (aStream: (nsIOutputStream | null), aURIMap: (nsIWebBrowserPersistURIMap | null), aRequestedContentType: IDLACString, aEncoderFlags: number, aWrapColumn: number, aCompletion: (nsIWebBrowserPersistWriteCompletion | nsIWebBrowserPersistWriteCompletionFunction | null)) => void;
  }

  export interface nsIDocumentLoaderRef {
    readonly name: "nsIDocumentLoader";
    readonly number: "{bbe961ee-59e9-42bb-be50-0331979bb79f}";
  }

  /**
   * An nsIDocumentLoader is an interface responsible for tracking groups of
   * loads that belong together (images, external scripts, etc) and subdocuments
   * (<iframe>, <frame>, etc). It is also responsible for sending
   * nsIWebProgressListener notifications.
   * XXXbz this interface should go away, we think...
   */
  export interface nsIDocumentLoader extends nsISupports {

    readonly stop: () => void;

    readonly container: (nsISupports | null);

    readonly loadGroup: (nsILoadGroup | null);

    readonly documentChannel: (nsIChannel | null);
  }

  export interface nsIPromptRef {
    readonly name: "nsIPrompt";
    readonly number: "{a63f70c0-148b-11d3-9333-00104ba0fd40}";

    BUTTON_POS_0: 1;

    BUTTON_POS_1: 256;

    BUTTON_POS_2: 65536;

    BUTTON_TITLE_OK: 1;

    BUTTON_TITLE_CANCEL: 2;

    BUTTON_TITLE_YES: 3;

    BUTTON_TITLE_NO: 4;

    BUTTON_TITLE_SAVE: 5;

    BUTTON_TITLE_DONT_SAVE: 6;

    BUTTON_TITLE_REVERT: 7;

    BUTTON_TITLE_IS_STRING: 127;

    BUTTON_POS_0_DEFAULT: 0;

    BUTTON_POS_1_DEFAULT: 16777216;

    BUTTON_POS_2_DEFAULT: 33554432;

    BUTTON_DELAY_ENABLE: 67108864;

    STD_OK_CANCEL_BUTTONS: 513;

    STD_YES_NO_BUTTONS: 1027;
  }

  export interface nsIPrompt extends nsISupports {

    readonly alert: (dialogTitle: string, text: string) => void;

    readonly alertCheck: (dialogTitle: string, text: string, checkMsg: string, checkValue: InOut<boolean>) => void;

    readonly confirm: (dialogTitle: string, text: string) => boolean;

    readonly confirmCheck: (dialogTitle: string, text: string, checkMsg: string, checkValue: InOut<boolean>) => boolean;

    readonly confirmEx: (dialogTitle: string, text: string, buttonFlags: number, button0Title: string, button1Title: string, button2Title: string, checkMsg: string, checkValue: InOut<boolean>) => number;

    readonly prompt: (dialogTitle: string, text: string, value: InOut<string>, checkMsg: string, checkValue: InOut<boolean>) => boolean;

    readonly promptPassword: (dialogTitle: string, text: string, password: InOut<string>, checkMsg: string, checkValue: InOut<boolean>) => boolean;

    readonly promptUsernameAndPassword: (dialogTitle: string, text: string, username: InOut<string>, password: InOut<string>, checkMsg: string, checkValue: InOut<boolean>) => boolean;

    readonly select: (dialogTitle: string, text: string, selectList: IDLAString[], outSelection: Out<number>) => boolean;
  }

  export interface nsIGIOServiceRef {
    readonly name: "nsIGIOService";
    readonly number: "{eda22a30-84e1-4e16-9ca0-cd1553c2b34a}";
  }

  export interface nsIGIOService extends nsISupports {

    /*** MIME registry methods ***/
    readonly getMimeTypeFromExtension: (extension: IDLAUTF8String) => IDLAUTF8String;

    readonly getAppForURIScheme: (aURIScheme: IDLAUTF8String) => (nsIHandlerApp | null);

    readonly getAppsForURIScheme: (aURIScheme: IDLAUTF8String) => (nsIMutableArray | null);

    readonly getAppForMimeType: (mimeType: IDLAUTF8String) => (nsIHandlerApp | null);

    readonly createAppFromCommand: (cmd: IDLAUTF8String, appName: IDLAUTF8String) => (nsIGIOMimeApp | null);

    readonly findAppFromCommand: (cmd: IDLAUTF8String) => (nsIGIOMimeApp | null);

    readonly getDescriptionForMimeType: (mimeType: IDLAUTF8String) => IDLAUTF8String;

    /*** Misc. methods ***/
    readonly showURI: (uri: (nsIURI | null)) => void;
  }

  export interface nsIPresentationLocalDeviceRef {
    readonly name: "nsIPresentationLocalDevice";
    readonly number: "{dd239720-cab6-4fb5-9025-cba23f1bbc2d}";
  }

  export interface nsIPresentationLocalDevice extends nsIPresentationDevice {

    readonly windowId: IDLAUTF8String;
  }

  export interface nsIDOMXULMenuListElementRef {
    readonly name: "nsIDOMXULMenuListElement";
    readonly number: "{36c16a17-c0e9-4b35-951b-81a147314ef1}";
  }

  export interface nsIDOMXULMenuListElement extends nsIDOMXULSelectControlElement {

    editable: boolean;

    open: boolean;

    readonly label: IDLAString;

    crop: IDLAString;

    image: IDLAString;

    readonly inputField: WebIDL.Element;
  }

  export interface nsICycleCollectorListenerRef {
    readonly name: "nsICycleCollectorListener";
    readonly number: "{703b53b6-24f6-40c6-9ea9-aeb2dc53d170}";
  }

  /**
   * This interface is used to configure some reporting options for the cycle
   * collector. This interface cannot be implemented by JavaScript code, as it
   * is called while the cycle collector is running.
   *
   * To analyze cycle collection data in JS:
   *
   * - Create an instance of nsICycleCollectorListener, which implements this
   *   interface. In C++, this can be done by calling
   *   nsCycleCollector_createLogger(). In JS, this can be done by calling
   *   Components.utils.createCCLogger().
   *
   * - Set its |disableLog| property to true. This prevents the logger from
   *   printing messages about each method call to a temporary log file.
   *
   * - Set its |wantAfterProcessing| property to true. This tells the logger
   *   to record calls to its methods in memory. The |processNext| method
   *   returns events from this record.
   *
   * - Perform a collection using the logger. For example, call
   *   |nsIDOMWindowUtils|'s |garbageCollect| method, passing the logger as
   *   the |aListener| argument.
   *
   * - When the collection is complete, loop calling the logger's
   *   |processNext| method, passing a JavaScript object that implements
   *   nsICycleCollectorHandler. This JS code is free to allocate and operate
   *   on objects however it pleases: the cycle collector has finished its
   *   work, and the JS code is simply consuming recorded data.
   */
  export interface nsICycleCollectorListener extends nsISupports {

    readonly allTraces: () => (nsICycleCollectorListener | null);

    readonly wantAllTraces: boolean;

    disableLog: boolean;

    logSink: (nsICycleCollectorLogSink | null);

    wantAfterProcessing: boolean;

    readonly processNext: (aHandler: (nsICycleCollectorHandler | null)) => boolean;
  }

  export interface nsIQuotaEstimateResultRef {
    readonly name: "nsIQuotaEstimateResult";
    readonly number: "{9827fc69-7ea9-48ef-b30d-2e2ae0451ec0}";
  }

  export interface nsIQuotaEstimateResult extends nsISupports {

    readonly usage: number;

    readonly limit: number;
  }

  export interface nsIOutputIteratorRef {
    readonly name: "nsIOutputIterator";
    readonly number: "{7330650e-1dd2-11b2-a0c2-9ff86ee97bed}";
  }

  /**
   * ...
   */
  export interface nsIOutputIterator extends nsISupports {

    /**
     * Put |anElementToPut| into the underlying container or sequence at the position currently pointed to by this iterator.
     * The iterator and the underlying container or sequence cooperate to |Release()|
     * the replaced element, if any and if necessary, and to |AddRef()| the new element.
     *
     * The result is undefined if this iterator currently points outside the
     * useful range of the underlying container or sequence.
     *
     * @param anElementToPut the element to place into the underlying container or sequence
     */
    readonly putElement: (anElementToPut: (nsISupports | null)) => void;

    /**
     * Advance this iterator to the next position in the underlying container or sequence.
     */
    readonly stepForward: () => void;
  }

  export interface nsIProtocolHandlerWithDynamicFlagsRef {
    readonly name: "nsIProtocolHandlerWithDynamicFlags";
    readonly number: "{65a8e823-0591-4fc0-a56a-03265e0a4ce8}";
  }

  /**
   * nsIProtocolHandlerWithDynamicFlags
   *
   * Protocols that wish to return different flags depending on the URI should
   * implement this interface.
   */
  export interface nsIProtocolHandlerWithDynamicFlags extends nsISupports {

    readonly getFlagsForURI: (aURI: (nsIURI | null)) => number;
  }

  export interface nsIUnicharOutputStreamRef {
    readonly name: "nsIUnicharOutputStream";
    readonly number: "{2d00b1bb-8b21-4a63-bcc6-7213f513ac2e}";
  }

  /**
   * An interface that allows writing unicode data.
   */
  export interface nsIUnicharOutputStream extends nsISupports {

    /**
     * Write a single character to the stream. When writing many characters,
     * prefer the string-taking write method.
     *
     * @retval true The character was written successfully
     * @retval false Not all bytes of the character could be written.
     */
    readonly write: (aCount: number) => boolean;

    /**
     * Write a string to the stream.
     *
     * @retval true The string was written successfully
     * @retval false Not all bytes of the string could be written.
     */
    readonly writeString: (str: IDLAString) => boolean;

    /**
     * Flush the stream. This finishes the conversion and writes any bytes that
     * finish the current byte sequence.
     *
     * It does NOT flush the underlying stream.
     */
    readonly flush: () => void;

    /**
     * Close the stream and free associated resources. This also closes the
     * underlying stream.
     */
    readonly close: () => void;
  }

  export interface rrIReplayRef {
    readonly name: "rrIReplay";
    readonly number: "{8b86b71f-8471-472e-9997-c5f21f9d0598}";
  }

  export interface rrIReplay extends nsISupports {

    readonly ManifestStart: (manifest: IDLjsval) => void;

    readonly HitCheckpoint: (checkpoint: number) => void;

    readonly NewTimeWarpTarget: () => number;

    readonly ScriptResumeFrame: (script: number) => void;
  }

  export interface nsIServiceManagerRef {
    readonly name: "nsIServiceManager";
    readonly number: "{8bb35ed9-e332-462d-9155-4a002ab5c958}";
  }

  /**
   * The nsIServiceManager manager interface provides a means to obtain
   * global services in an application. The service manager depends on the
   * repository to find and instantiate factories to obtain services.
   *
   * Users of the service manager must first obtain a pointer to the global
   * service manager by calling NS_GetServiceManager. After that,
   * they can request specific services by calling GetService. When they are
   * finished they can NS_RELEASE() the service as usual.
   *
   * A user of a service may keep references to particular services indefinitely
   * and only must call Release when it shuts down.
   */
  export interface nsIServiceManager extends nsISupports {
  }

  export interface nsIGeneralChangeDetailsRef {
    readonly name: "nsIGeneralChangeDetails";
    readonly number: "{e031267e-bec8-4f3c-b0b1-396b77ca260c}";
  }

  /**
   * The general purpose method change details.
   */
  export interface nsIGeneralChangeDetails extends nsIMethodChangeDetails {

    /**
     *  The stringified change details.
     */
    readonly details: IDLAString;

    /**
     *  The initial method for nsIGeneralChangeDetails.
     *  @param aData - the javascript object of the content.
     */
    readonly initData: (aDetails: IDLjsval) => void;
  }

  export interface rrIConnectionRef {
    readonly name: "rrIConnection";
    readonly number: "{df6d8e96-4cba-4a1d-893a-1ee19e8d8468}";
  }

  export interface rrIConnection extends nsISupports {

    readonly Initialize: (callback: IDLjsval) => void;

    readonly Connect: (channelId: number, address: IDLAString) => number;

    readonly SendMessage: (connectionId: number, buf: IDLjsval) => void;
  }

  export interface nsICookieManagerRef {
    readonly name: "nsICookieManager";
    readonly number: "{aaab6710-0f2c-11d5-a53b-0010a401eb10}";
  }

  /**
   * An optional interface for accessing or removing the cookies
   * that are in the cookie list
   */
  export interface nsICookieManager extends nsISupports {

    /**
     * Called to remove all cookies from the cookie list
     */
    readonly removeAll: () => void;

    /**
     * Returns an array of cookies in the cookie list.
     * The objects in the array are of type nsICookie
     * This array only contains non-private browsing cookies.
     * To retrieve an array of private browsing cookies, use
     * getCookiesWithOriginAttributes.
     */
    readonly cookies: (nsICookie | null)[];

    /**
     * Returns an array of session cookies in the cookie list.
     * The objects in the array are of type nsICookie
     * This array only contains non-private browsing cookies.
     */
    readonly sessionCookies: (nsICookie | null)[];

    /**
     * Called to remove an individual cookie from the cookie list, specified
     * by host, name, and path. If the cookie cannot be found, no exception
     * is thrown. Typically, the arguments to this method will be obtained
     * directly from the desired nsICookie object.
     *
     * @param aHost The host or domain for which the cookie was set. @see
     *              nsICookieManager::add for a description of acceptable host
     *              strings. If the target cookie is a domain cookie, a leading
     *              dot must be present.
     * @param aName The name specified in the cookie
     * @param aPath The path for which the cookie was set
     * @param aOriginAttributes The originAttributes of this cookie.
     *
     */
    readonly remove: (aHost: IDLAUTF8String, aName: IDLACString, aPath: IDLAUTF8String, aOriginAttributes: IDLjsval) => void;

    /**
     * Add a cookie. nsICookieService is the normal way to do this. This
     * method is something of a backdoor.
     *
     * @param aHost
     *        the host or domain for which the cookie is set. presence of a
     *        leading dot indicates a domain cookie; otherwise, the cookie
     *        is treated as a non-domain cookie (see RFC2109). The host string
     *        will be normalized to ASCII or ACE; any trailing dot will be
     *        stripped. To be a domain cookie, the host must have at least two
     *        subdomain parts (e.g. '.foo.com', not '.com'), otherwise an
     *        exception will be thrown. An empty string is acceptable
     *        (e.g. file:// URI's).
     * @param aPath
     *        path within the domain for which the cookie is valid
     * @param aName
     *        cookie name
     * @param aValue
     *        cookie data
     * @param aIsSecure
     *        true if the cookie should only be sent over a secure connection.
     * @param aIsHttpOnly
     *        true if the cookie should only be sent to, and can only be
     *        modified by, an http connection.
     * @param aIsSession
     *        true if the cookie should exist for the current session only.
     *        see aExpiry.
     * @param aExpiry
     *        expiration date, in seconds since midnight (00:00:00), January 1,
     *        1970 UTC. note that expiry time will also be honored for session cookies;
     *        in this way, the more restrictive of the two will take effect.
     * @param aOriginAttributes
     *        the originAttributes of this cookie.
     * @param aSameSite
     *        the SameSite attribute.
     */
    readonly add: (aHost: IDLAUTF8String, aPath: IDLAUTF8String, aName: IDLACString, aValue: IDLAUTF8String, aIsSecure: boolean, aIsHttpOnly: boolean, aIsSession: boolean, aExpiry: number, aOriginAttributes: IDLjsval, aSameSite: number) => void;

    /**
     * Find whether a given cookie already exists.
     *
     * @param aHost
     *        the cookie's host to look for
     * @param aPath
     *        the cookie's path to look for
     * @param aName
     *        the cookie's name to look for
     * @param aOriginAttributes
     *        the cookie's originAttributes to look for
     *
     * @return true if a cookie was found which matches the host, path, name and
     *         originAttributes fields of aCookie
     */
    readonly cookieExists: (aHost: IDLAUTF8String, aPath: IDLAUTF8String, aName: IDLACString, aOriginAttributes: IDLjsval) => boolean;

    /**
     * Count how many cookies exist within the base domain of 'aHost'.
     * Thus, for a host "weather.yahoo.com", the base domain would be "yahoo.com",
     * and any host or domain cookies for "yahoo.com" and its subdomains would be
     * counted.
     *
     * @param aHost
     *        the host string to search for, e.g. "google.com". this should consist
     *        of only the host portion of a URI. see @add for a description of
     *        acceptable host strings.
     *
     * @return the number of cookies found.
     */
    readonly countCookiesFromHost: (aHost: IDLAUTF8String) => number;

    /**
     * Returns an array of cookies that exist within the base domain of
     * 'aHost'. Thus, for a host "weather.yahoo.com", the base domain would be
     * "yahoo.com", and any host or domain cookies for "yahoo.com" and its
     * subdomains would be returned.
     *
     * @param aHost
     *        the host string to search for, e.g. "google.com". this should consist
     *        of only the host portion of a URI. see @add for a description of
     *        acceptable host strings.
     * @param aOriginAttributes The originAttributes of cookies that would be
     *                          retrived.
     *
     * @return an array of nsICookie objects.
     *
     * @see countCookiesFromHost
     */
    readonly getCookiesFromHost: (aHost: IDLAUTF8String, aOriginAttributes: IDLjsval) => (nsICookie | null)[];

    /**
     * Import an old-style cookie file. Imported cookies will be added to the
     * existing database. If the database contains any cookies the same as those
     * being imported (i.e. domain, name, and path match), they will be replaced.
     *
     * @param aCookieFile the file to import, usually cookies.txt
     */
    readonly importCookies: (aCookieFile: (nsIFile | null)) => void;

    /**
     * Returns an array of all cookies whose origin attributes matches aPattern
     *
     * @param aPattern origin attribute pattern in JSON format
     *
     * @param aHost
     *        the host string to search for, e.g. "google.com". this should consist
     *        of only the host portion of a URI. see @add for a description of
     *        acceptable host strings. This attribute is optional. It will search
     *        all hosts if this attribute is not given.
     */
    readonly getCookiesWithOriginAttributes: (aPattern: IDLAString, aHost?: IDLAUTF8String) => (nsICookie | null)[];

    /**
     * Remove all the cookies whose origin attributes matches aPattern
     *
     * @param aPattern origin attribute pattern in JSON format
     */
    readonly removeCookiesWithOriginAttributes: (aPattern: IDLAString, aHost?: IDLAUTF8String) => void;

    /**
     * Remove all the cookies whose origin attributes matches aPattern and the
     * host is exactly aHost (without subdomain matching).
     *
     * @param aHost the host to match
     * @param aPattern origin attribute pattern in JSON format
     */
    readonly removeCookiesFromExactHost: (aHost: IDLAUTF8String, aPattern: IDLAString) => void;

    /**
     * Removes all cookies that were created on or after aSinceWhen, and returns
     * a Promise which will be resolved when the last such cookie has been
     * removed.
     *
     * @param aSinceWhen the starting point in time after which no cookies should
     *        be created when the Promise returned from this method is resolved.
     */
    readonly removeAllSince: (aSinceWhen: number) => IDLPromise;
  }

  export interface nsIProcessRef {
    readonly name: "nsIProcess";
    readonly number: "{609610de-9954-4a63-8a7c-346350a86403}";
  }

  export interface nsIProcess extends nsISupports {

    /**
     * Initialises the process with an executable to be run. Call the run method
     * to run the executable.
     * @param executable The executable to run.
     */
    readonly init: (executable: (nsIFile | null)) => void;

    /**
     * Kills the running process. After exiting the process will either have
     * been killed or a failure will have been returned.
     */
    readonly kill: () => void;

    /**
       * Executes the file this object was initialized with
       * @param blocking   Whether to wait until the process terminates before
                           returning or not.
       * @param args       An array of arguments to pass to the process in the
       *                   native character set.
       * @param count      The length of the args array.
       */
    readonly run: (blocking: boolean, args: string[], count: number) => void;

    /**
     * Executes the file this object was initialized with optionally calling
     * an observer after the process has finished running.
     * @param args       An array of arguments to pass to the process in the
     *                   native character set.
     * @param count      The length of the args array.
     * @param observer   An observer to notify when the process has completed. It
     *                   will receive this process instance as the subject and
     *                   "process-finished" or "process-failed" as the topic. The
     *                   observer will be notified on the main thread.
     * @param holdWeak   Whether to use a weak reference to hold the observer.
     */
    readonly runAsync: (args: string[], count: number, observer?: (nsIObserver | nsIObserverFunction | null), holdWeak?: boolean) => void;

    /**
       * Executes the file this object was initialized with
       * @param blocking   Whether to wait until the process terminates before
                           returning or not.
       * @param args       An array of arguments to pass to the process in UTF-16
       * @param count      The length of the args array.
       */
    readonly runw: (blocking: boolean, args: string[], count: number) => void;

    /**
     * Executes the file this object was initialized with optionally calling
     * an observer after the process has finished running.
     * @param args       An array of arguments to pass to the process in UTF-16
     * @param count      The length of the args array.
     * @param observer   An observer to notify when the process has completed. It
     *                   will receive this process instance as the subject and
     *                   "process-finished" or "process-failed" as the topic. The
     *                   observer will be notified on the main thread.
     * @param holdWeak   Whether to use a weak reference to hold the observer.
     */
    readonly runwAsync: (args: string[], count: number, observer?: (nsIObserver | nsIObserverFunction | null), holdWeak?: boolean) => void;

    /**
     * When set to true the process will not open a new window when started and
     * will run hidden from the user. This currently affects only the Windows
     * platform.
     */
    startHidden: boolean;

    /**
     * When set to true the process will be launched directly without using the
     * shell. This currently affects only the Windows platform.
     */
    noShell: boolean;

    /**
     * The process identifier of the currently running process. This will only
     * be available after the process has started and may not be available on
     * some platforms.
     */
    readonly pid: number;

    /**
     * The exit value of the process. This is only valid after the process has
     * exited.
     */
    readonly exitValue: number;

    /**
     * Returns whether the process is currently running or not.
     */
    readonly isRunning: boolean;
  }

  export interface imgIContainerRef {
    readonly name: "imgIContainer";
    readonly number: "{a8dbee24-ff86-4755-b40e-51175caf31af}";

    /**
     * Enumerated values for the 'type' attribute (below).
     */
    TYPE_RASTER: 0;

    TYPE_VECTOR: 1;

    /**
     * Flags for imgIContainer operations.
     *
     * Meanings:
     *
     * FLAG_NONE: Lack of flags.
     *
     * FLAG_SYNC_DECODE: Forces synchronous/non-progressive decode of all
     * available data before the call returns.
     *
     * FLAG_SYNC_DECODE_IF_FAST: Like FLAG_SYNC_DECODE, but requests a sync decode
     * be performed only if ImageLib estimates it can be completed very quickly.
     *
     * FLAG_ASYNC_NOTIFY: Send notifications asynchronously, even if we decode
     * synchronously because of FLAG_SYNC_DECODE or FLAG_SYNC_DECODE_IF_FAST.
     *
     * FLAG_DECODE_NO_PREMULTIPLY_ALPHA: Do not premultiply alpha if
     * it's not already premultiplied in the image data.
     *
     * FLAG_DECODE_NO_COLORSPACE_CONVERSION: Do not do any colorspace conversion;
     * ignore any embedded profiles, and don't convert to any particular
     * destination space.
     *
     * FLAG_CLAMP: Extend the image to the fill area by clamping image sample
     * coordinates instead of by tiling. This only affects 'draw'.
     *
     * FLAG_HIGH_QUALITY_SCALING: A hint as to whether this image should be
     * scaled using the high quality scaler. Do not set this if not drawing to
     * a window or not listening to invalidations. Passing this flag will do two
     * things: 1) request a decode of the image at the size asked for by the
     * caller if one isn't already started or complete, and 2) allows a decoded
     * frame of any size (it could be neither the requested size, nor the
     * intrinsic size) to be substituted.
     *
     * FLAG_WANT_DATA_SURFACE: Can be passed to GetFrame when the caller wants a
     * DataSourceSurface instead of a hardware accelerated surface. This can be
     * important for performance (by avoiding an upload to/readback from the GPU)
     * when the caller knows they want a SourceSurface of type DATA.
     *
     * FLAG_BYPASS_SURFACE_CACHE: Forces drawing to happen rather than taking
     * cached rendering from the surface cache. This is used when we are printing,
     * for example, where we want the vector commands from VectorImages to end up
     * in the PDF output rather than a cached rendering at screen resolution.
     *
     * FLAG_FORCE_PRESERVEASPECTRATIO_NONE: Force scaling this image
     * non-uniformly if necessary. This flag is for vector image only. A raster
     * image should ignore this flag. While drawing a vector image with this
     * flag, do not force uniform scaling even if its root <svg> node has a
     * preserveAspectRatio attribute that would otherwise require uniform
     * scaling , such as xMinYMin/ xMidYMin. Always scale the graphic content of
     * the given image non-uniformly if necessary such that the image's
     * viewBox (if specified or implied by height/width attributes) exactly
     * matches the viewport rectangle.
     *
     * FLAG_FORCE_UNIFORM_SCALING: Signal to ClippedImage::OptimalSizeForDest that
     * its returned size can only scale the image's size *uniformly* (by the same
     * factor in each dimension). We need this flag when painting border-image
     * section with SVG image source-data, if the SVG image has no viewBox and no
     * intrinsic size. In such a case, we synthesize a viewport for the SVG image
     * (a "window into SVG space") based on the border image area, and we need to
     * be sure we don't subsequently scale that viewport in a way that distorts
     * its contents by stretching them more in one dimension than the other.
     *
     * FLAG_AVOID_REDECODE_FOR_SIZE: If there is already a raster surface
     * available for this image, but it is not the same size as requested, skip
     * starting a new decode for said size.
     */
    FLAG_NONE: 0;

    FLAG_SYNC_DECODE: 1;

    FLAG_SYNC_DECODE_IF_FAST: 2;

    FLAG_ASYNC_NOTIFY: 4;

    FLAG_DECODE_NO_PREMULTIPLY_ALPHA: 8;

    FLAG_DECODE_NO_COLORSPACE_CONVERSION: 16;

    FLAG_CLAMP: 32;

    FLAG_HIGH_QUALITY_SCALING: 64;

    FLAG_WANT_DATA_SURFACE: 128;

    FLAG_BYPASS_SURFACE_CACHE: 256;

    FLAG_FORCE_PRESERVEASPECTRATIO_NONE: 512;

    FLAG_FORCE_UNIFORM_SCALING: 1024;

    FLAG_AVOID_REDECODE_FOR_SIZE: 2048;

    /**
     * A constant specifying the default set of decode flags (i.e., the default
     * values for FLAG_DECODE_*).
     */
    DECODE_FLAGS_DEFAULT: 0;

    /**
     * Constants for specifying various "special" frames.
     *
     * FRAME_FIRST: The first frame
     * FRAME_CURRENT: The current frame
     *
     * FRAME_MAX_VALUE should be set to the value of the maximum constant above,
     * as it is used for ensuring that a valid value was passed in.
     */
    FRAME_FIRST: 0;

    FRAME_CURRENT: 1;

    FRAME_MAX_VALUE: 1;

    /**
     * Animation mode Constants
     *   0 = normal
     *   1 = don't animate
     *   2 = loop once
     */
    kNormalAnimMode: 0;

    kDontAnimMode: 1;

    kLoopOnceAnimMode: 2;
  }

  /**
   * imgIContainer is the interface that represents an image. It allows
   * access to frames as Thebes surfaces. It also allows drawing of images
   * onto Thebes contexts.
   *
   * Internally, imgIContainer also manages animation of images.
   */
  export interface imgIContainer extends nsISupports {

    /**
     * The width of the container rectangle.  In the case of any error,
     * zero is returned, and an exception will be thrown.
     */
    readonly width: number;

    /**
     * The height of the container rectangle.  In the case of any error,
     * zero is returned, and an exception will be thrown.
     */
    readonly height: number;

    /**
     * The type of this image (one of the TYPE_* values above).
     */
    readonly type: number;

    /**
     * Whether this image is animated. You can only be guaranteed that querying
     * this will not throw if STATUS_DECODE_COMPLETE is set on the imgIRequest.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if the animated state cannot be determined.
     */
    readonly animated: boolean;

    /**
     * Producer ID for image containers created by this image.
     */
    readonly producerId: number;

    /**
     * Increments the lock count on the image. An image will not be discarded
     * as long as the lock count is nonzero. Note that it is still possible for
     * the image to be undecoded if decode-on-draw is enabled and the image
     * was never drawn.
     *
     * Upon instantiation images have a lock count of zero.
     */
    readonly lockImage: () => void;

    /**
     * Decreases the lock count on the image. If the lock count drops to zero,
     * the image is allowed to discard its frame data to save memory.
     *
     * Upon instantiation images have a lock count of zero. It is an error to
     * call this method without first having made a matching lockImage() call.
     * In other words, the lock count is not allowed to be negative.
     */
    readonly unlockImage: () => void;

    /**
     * If this image is unlocked, discard its decoded data.  If the image is
     * locked or has already been discarded, do nothing.
     */
    readonly requestDiscard: () => void;

    animationMode: number;

    readonly resetAnimation: () => void;
  }

  export interface nsPIExternalAppLauncherRef {
    readonly name: "nsPIExternalAppLauncher";
    readonly number: "{6613e2e7-feab-4e3a-bb1f-b03200d544ec}";
  }

  /**
   * This is a private interface shared between external app handlers and the platform specific
   * external helper app service
   */
  export interface nsPIExternalAppLauncher extends nsISupports {

    /**
     * mscott --> eventually I should move this into a new service so other
     * consumers can add temporary files they want deleted on exit.
     * @param aTemporaryFile A temporary file we should delete on exit.
     */
    readonly deleteTemporaryFileOnExit: (aTemporaryFile: (nsIFile | null)) => void;

    /**
     * Delete a temporary file created inside private browsing mode when
     * the private browsing mode has ended.
     */
    readonly deleteTemporaryPrivateFileWhenPossible: (aTemporaryFile: (nsIFile | null)) => void;
  }

  export interface nsIPaymentResponseDataRef {
    readonly name: "nsIPaymentResponseData";
    readonly number: "{2a338575-c688-40ee-a157-7488ab292ef2}";

    /**
     *  The consts for representing the response data type.
     *  GENERAL_RESPONSE is the general purpose response data type. Except basic
     *  card response data, all response data should belong to this type.
     *  BASICCARD_RESPONSE is a special response data type for basic card response.
     */
    GENERAL_RESPONSE: 0;

    BASICCARD_RESPONSE: 1;
  }

  /**
   *  The base interface of response data for the specified payment method.
   *  The response data is the content of the PaymentResponse's detail attribute.
   */
  export interface nsIPaymentResponseData extends nsISupports {

    /**
     *  The response data type.
     *  Using the above defined consts(GENERAL_RESPONSE or BASICCARD_RESPONSE).
     */
    readonly type: number;

    /**
     *  The initial method.
     *  @param aType - the response data type.
     */
    readonly init: (aType: number) => void;
  }

  export interface nsICacheStorageRef {
    readonly name: "nsICacheStorage";
    readonly number: "{35d104a6-d252-4fd4-8a56-3c14657cad3b}";

    /**
     * Placeholder for specifying "no special flags" during open.
     */
    OPEN_NORMALLY: 0;

    /**
     * Rewrite any existing data when opening a URL.
     */
    OPEN_TRUNCATE: 1;

    /**
     * Only open an existing entry.  Don't create a new one.
     */
    OPEN_READONLY: 2;

    /**
     * Use for first-paint blocking loads.
     */
    OPEN_PRIORITY: 4;

    /**
     * Bypass the cache load when write is still in progress.
     */
    OPEN_BYPASS_IF_BUSY: 8;

    /**
     * Perform the cache entry check (onCacheEntryCheck invocation) on any thread
     * for optimal perfomance optimization.  If this flag is not specified it is
     * ensured that onCacheEntryCheck is called on the same thread as respective
     * asyncOpen has been called.
     */
    CHECK_MULTITHREADED: 16;

    /**
     * Don't automatically update any 'last used' metadata of the entry.
     */
    OPEN_SECRETLY: 32;

    /**
     * Entry is being opened as part of a service worker interception.  Do not
     * allow the cache to be disabled in this case.
     */
    OPEN_INTERCEPTED: 64;
  }

  /**
   * Representation of a cache storage. There can be just-in-mem,
   * in-mem+on-disk, in-mem+on-disk+app-cache or just a specific
   * app-cache storage.
   */
  export interface nsICacheStorage extends nsISupports {

    /**
     * Asynchronously opens a cache entry for the specified URI.
     * Result is fetched asynchronously via the callback.
     *
     * @param aURI
     *    The URI to search in cache or to open for writting.
     * @param aIdExtension
     *    Any string that will extend (distinguish) the entry.  Two entries
     *    with the same aURI but different aIdExtension will be comletely
     *    different entries.  If you don't know what aIdExtension should be
     *    leave it empty.
     * @param aFlags
     *    OPEN_NORMALLY - open cache entry normally for read and write
     *    OPEN_TRUNCATE - delete any existing entry before opening it
     *    OPEN_READONLY - don't create an entry if there is none
     *    OPEN_PRIORITY - give this request a priority over others
     *    OPEN_BYPASS_IF_BUSY - backward compatibility only, LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
     *    CHECK_MULTITHREADED - onCacheEntryCheck may be called on any thread, consumer
     *                          implementation is thread-safe
     * @param aCallback
     *    The consumer that receives the result.
     *    IMPORTANT: The callback may be called sooner the method returns.
     */
    readonly asyncOpenURI: (aURI: (nsIURI | null), aIdExtension: IDLACString, aFlags: number, aCallback: (nsICacheEntryOpenCallback | null)) => void;

    /**
     * Immediately opens a new and empty cache entry in the storage, any existing
     * entries are immediately doomed.  This is similar to the recreate() method
     * on nsICacheEntry.
     *
     * Storage may not implement this method and throw NS_ERROR_NOT_IMPLEMENTED.
     * In that case consumer must use asyncOpen with OPEN_TRUNCATE flag and get
     * the new entry via a callback.
     *
     * @param aURI @see asyncOpenURI
     * @param aIdExtension @see asyncOpenURI
     */
    readonly openTruncate: (aURI: (nsIURI | null), aIdExtension: IDLACString) => (nsICacheEntry | null);

    /**
     * Synchronously check on existance of an entry.  In case of disk entries
     * this uses information from the cache index.  When the index data are not
     * up to date or index is still building, NS_ERROR_NOT_AVAILABLE is thrown.
     * The same error may throw any storage implementation that cannot determine
     * entry state without blocking the caller.
     */
    readonly exists: (aURI: (nsIURI | null), aIdExtension: IDLACString) => boolean;

    /**
     * Synchronously check on existance of alternative data and size of the
     * content. When the index data are not up to date or index is still building,
     * NS_ERROR_NOT_AVAILABLE is thrown. The same error may throw any storage
     * implementation that cannot determine entry state without blocking the caller.
     */
    readonly getCacheIndexEntryAttrs: (aURI: (nsIURI | null), aIdExtension: IDLACString, aHasAltData: Out<boolean>, aSizeInKB: Out<number>) => void;

    /**
     * Asynchronously removes an entry belonging to the URI from the cache.
     */
    readonly asyncDoomURI: (aURI: (nsIURI | null), aIdExtension: IDLACString, aCallback: (nsICacheEntryDoomCallback | null)) => void;

    /**
     * Asynchronously removes all cached entries under this storage.
     * NOTE: Disk storage also evicts memory storage.
     */
    readonly asyncEvictStorage: (aCallback: (nsICacheEntryDoomCallback | null)) => void;

    /**
     * Visits the storage and its entries.
     * NOTE: Disk storage also visits memory storage.
     */
    readonly asyncVisitStorage: (aVisitor: (nsICacheStorageVisitor | null), aVisitEntries: boolean) => void;
  }

  export interface nsIOfflineCacheUpdateObserverRef {
    readonly name: "nsIOfflineCacheUpdateObserver";
    readonly number: "{47360d57-8ef4-4a5d-8865-1a27a739ad1a}";

    STATE_ERROR: 1;

    STATE_CHECKING: 2;

    STATE_NOUPDATE: 3;

    STATE_OBSOLETE: 4;

    STATE_DOWNLOADING: 5;

    STATE_ITEMSTARTED: 6;

    STATE_ITEMCOMPLETED: 7;

    STATE_ITEMPROGRESS: 8;

    STATE_FINISHED: 10;
  }

  export interface nsIOfflineCacheUpdateObserver extends nsISupports {

    /**
     * aUpdate has changed its state.
     *
     * @param aUpdate
     *        The nsIOfflineCacheUpdate being processed.
     * @param event
     *        See enumeration above
     */
    readonly updateStateChanged: (aUpdate: (nsIOfflineCacheUpdate | null), state: number) => void;

    /**
     * Informs the observer about an application being available to associate.
     *
     * @param applicationCache
     *        The application cache instance that has been created or found by the
     *        update to associate with
     */
    readonly applicationCacheAvailable: (applicationCache: (nsIApplicationCache | null)) => void;
  }

  export interface nsIEditorSpellCheckRef {
    readonly name: "nsIEditorSpellCheck";
    readonly number: "{a171c25f-e4a8-4d08-adef-b797e6377bdc}";

    FILTERTYPE_NORMAL: 1;

    FILTERTYPE_MAIL: 2;
  }

  export interface nsIEditorSpellCheck extends nsISupports {

    /**
     * Returns true if we can enable spellchecking. If there are no available
     * dictionaries, this will return false.
     */
    readonly canSpellCheck: () => boolean;

    /**
     * Turns on the spell checker for the given editor. enableSelectionChecking
     * set means that we only want to check the current selection in the editor,
     * (this controls the behavior of GetNextMisspelledWord). For spellchecking
     * clients with no modal UI (such as inline spellcheckers), this flag doesn't
     * matter.  Initialization is asynchronous and is not complete until the given
     * callback is called.
     */
    readonly InitSpellChecker: (editor: (nsIEditor | null), enableSelectionChecking: boolean, callback?: (nsIEditorSpellCheckCallback | nsIEditorSpellCheckCallbackFunction | null)) => void;

    /**
     * When interactively spell checking the document, this will return the
     * value of the next word that is misspelled. This also computes the
     * suggestions which you can get by calling GetSuggestedWord.
     *
     * @see mozSpellChecker::GetNextMisspelledWord
     */
    readonly GetNextMisspelledWord: () => IDLAString;

    /**
     * Used to get suggestions for the last word that was checked and found to
     * be misspelled. The first call will give you the first (best) suggestion.
     * Subsequent calls will iterate through all the suggestions, allowing you
     * to build a list. When there are no more suggestions, an empty string
     * (not a null pointer) will be returned.
     *
     * @see mozSpellChecker::GetSuggestedWord
     */
    readonly GetSuggestedWord: () => IDLAString;

    /**
     * Check a given word. In spite of the name, this function checks the word
     * you give it, returning true if the word is misspelled. If the word is
     * misspelled, it will compute the suggestions which you can get from
     * GetSuggestedWord().
     *
     * @see mozSpellChecker::CheckCurrentWord
     */
    readonly CheckCurrentWord: (suggestedWord: IDLAString) => boolean;

    /**
     * Use when modally checking the document to replace a word.
     *
     * @see mozSpellChecker::CheckCurrentWord
     */
    readonly ReplaceWord: (misspelledWord: IDLAString, replaceWord: IDLAString, allOccurrences: boolean) => void;

    /**
     * @see mozSpellChecker::IgnoreAll
     */
    readonly IgnoreWordAllOccurrences: (word: IDLAString) => void;

    /**
     * Fills an internal list of words added to the personal dictionary. These
     * words can be retrieved using GetPersonalDictionaryWord()
     *
     * @see mozSpellChecker::GetPersonalDictionary
     * @see GetPersonalDictionaryWord
     */
    readonly GetPersonalDictionary: () => void;

    /**
     * Used after you call GetPersonalDictionary() to iterate through all the
     * words added to the personal dictionary. Will return the empty string when
     * there are no more words.
     */
    readonly GetPersonalDictionaryWord: () => IDLAString;

    /**
     * Adds a word to the current personal dictionary.
     *
     * @see mozSpellChecker::AddWordToDictionary
     */
    readonly AddWordToDictionary: (word: IDLAString) => void;

    /**
     * Removes a word from the current personal dictionary.
     *
     * @see mozSpellChecker::RemoveWordFromPersonalDictionary
     */
    readonly RemoveWordFromDictionary: (word: IDLAString) => void;

    /**
     * Retrieves a list of the currently available dictionaries. The strings will
     * typically be language IDs, like "en-US".
     *
     * @see mozISpellCheckingEngine::GetDictionaryList
     */
    readonly GetDictionaryList: () => IDLAString[];

    /**
     * @see mozSpellChecker::GetCurrentDictionary
     */
    readonly GetCurrentDictionary: () => IDLAString;

    /**
     * @see mozSpellChecker::SetCurrentDictionary
     */
    readonly SetCurrentDictionary: (dictionary: IDLAString) => void;

    /**
     * Call this to free up the spell checking object. It will also save the
     * current selected language as the default for future use.
     *
     * If you have called CanSpellCheck but not InitSpellChecker, you can still
     * call this function to clear the cached spell check object, and no
     * preference saving will happen.
     */
    readonly UninitSpellChecker: () => void;

    /**
     * Used to filter the content (for example, to skip blockquotes in email from
     * spellchecking. Call this before calling InitSpellChecker; calling it
     * after initialization will have no effect.
     */
    readonly setFilterType: (filterType: number) => void;

    /**
     * Update the dictionary in use to be sure it corresponds to what the editor
     * needs.  The update is asynchronous and is not complete until the given
     * callback is called.
     */
    readonly UpdateCurrentDictionary: (callback?: (nsIEditorSpellCheckCallback | nsIEditorSpellCheckCallbackFunction | null)) => void;
  }

  export interface mozIJSSubScriptLoaderRef {
    readonly name: "mozIJSSubScriptLoader";
    readonly number: "{19533e7b-f321-4ef1-bc59-6e812dc2a733}";
  }

  /**
   * Interface for synchronous script loads from local file: or jar: sources.
   * For asynchronous script loads, ChromeUtils.compileScript() should be used
   * instead.
   */
  export interface mozIJSSubScriptLoader extends nsISupports {

    /**
     * This method should only be called from JS!
     * In JS, the signature looks like:
     * rv loadSubScript (url [, obj] [, charset]);
     * @param url the url of the UTF-8-encoded sub-script, it MUST be either a
     *            file:, resource:, blob:, or chrome: url, and MUST be local.
     * @param obj an optional object to evaluate the script onto, it
     *            defaults to the global object of the caller.
     * @retval rv the value returned by the sub-script
     */
    readonly loadSubScript: (url: IDLAString, obj?: IDLjsval) => IDLjsval;

    /**
     * This method should only be called from JS!
     * In JS, the signature looks like:
     * rv = loadSubScript (url, optionsObject)
     * @param url the url of the UTF-8-encoded sub-script, which MUST be either
     *            a file:, resource:, blob:, or chrome: url, and MUST be local.
     * @param optionsObject an object with parameters. Valid parameters are:
     *                      - target:  an object to evaluate onto (default: global object of the caller)
     *                      - ignoreCache: if set to true, will bypass the cache for reading the file.
     *                      - async: if set to true, the script will be loaded
     *                        asynchronously, and a Promise is returned which
     *                        resolves to its result when execution is complete.
     *                      - wantReturnValue: If true, the script will return
     *                        the value of the last statement that it evaluated.
     *                        This option disables most optimizations in the
     *                        top-level scope, and should be avoided if at all
     *                        possible. Defaults to false.
     * @retval rv the value returned by the sub-script
     */
    readonly loadSubScriptWithOptions: (url: IDLAString, options: IDLjsval) => IDLjsval;
  }

  export interface nsICommandParamsRef {
    readonly name: "nsICommandParams";
    readonly number: "{b1fdf3c4-74e3-4f7d-a14d-2b76bcf53482}";

    eNoType: 0;

    eBooleanType: 1;

    eLongType: 2;

    eDoubleType: 3;

    eWStringType: 4;

    eISupportsType: 5;

    eStringType: 6;
  }

  export interface nsICommandParams extends nsISupports {

    readonly getValueType: (name: string) => number;

    readonly getBooleanValue: (name: string) => boolean;

    readonly getLongValue: (name: string) => number;

    readonly getDoubleValue: (name: string) => number;

    readonly getStringValue: (name: string) => IDLAString;

    readonly getCStringValue: (name: string) => IDLACString;

    readonly getISupportsValue: (name: string) => (nsISupports | null);

    readonly setBooleanValue: (name: string, value: boolean) => void;

    readonly setLongValue: (name: string, value: number) => void;

    readonly setDoubleValue: (name: string, value: number) => void;

    readonly setStringValue: (name: string, value: IDLAString) => void;

    readonly setCStringValue: (name: string, value: IDLACString) => void;

    readonly setISupportsValue: (name: string, value: (nsISupports | null)) => void;

    readonly removeValue: (name: string) => void;
  }

  export interface nsIClientAuthDialogsRef {
    readonly name: "nsIClientAuthDialogs";
    readonly number: "{fa4c7520-1433-11d5-ba24-00108303b117}";
  }

  /**
   * Provides UI for SSL client-auth dialogs.
   */
  export interface nsIClientAuthDialogs extends nsISupports {

    /**
     * Called when a user is asked to choose a certificate for client auth.
     *
     * @param hostname Hostname of the server.
     * @param port Port of the server.
     * @param organization Organization field of the server cert.
     * @param issuerOrg Organization field of the issuer cert of the server cert.
     * @param certList List of certificates the user can choose from.
     * @param selectedIndex Index of the cert in |certList| that the user chose.
     *                      Ignored if the return value is false.
     * @param rememberClientAuthCertificate Whether to remember selection.
     * @return true if a certificate was chosen. false if the user canceled.
     */
    readonly chooseCertificate: (hostname: IDLAUTF8String, port: number, organization: IDLAUTF8String, issuerOrg: IDLAUTF8String, certList: (nsIArray | null), selectedIndex: Out<number>, rememberClientAuthCertificate: Out<boolean>) => boolean;
  }

  export interface nsIControllerCommandTableRef {
    readonly name: "nsIControllerCommandTable";
    readonly number: "{c847f90e-b8f3-49db-a4df-8867831f2800}";
  }

  /**
   * nsIControllerCommandTable
   *
   * An interface via which a controller can maintain a series of commands,
   * and efficiently dispatch commands to their respective handlers.
   *
   * Controllers that use an nsIControllerCommandTable should support
   * nsIInterfaceRequestor, and be able to return an interface to their
   * controller command table via getInterface().
   *
   */
  export interface nsIControllerCommandTable extends nsISupports {

    /**
     * Make this command table immutable, so that commands cannot
     * be registered or unregistered. Some command tables are made
     * mutable after command registration so that they can be
     * used as singletons.
     */
    readonly makeImmutable: () => void;

    /**
     * Register and unregister commands with the command table.
     *
     * @param aCommandName  the name of the command under which to register or
     *                      unregister the given command handler.
     *
     * @param aCommand      the handler for this command.
     */
    readonly registerCommand: (aCommandName: string, aCommand: (nsIControllerCommand | null)) => void;

    readonly unregisterCommand: (aCommandName: string, aCommand: (nsIControllerCommand | null)) => void;

    /**
     * Find the command handler which has been registered to handle the named command.
     *
     * @param aCommandName  the name of the command to find the handler for.
     */
    readonly findCommandHandler: (aCommandName: string) => (nsIControllerCommand | null);

    /**
     * Get whether the named command is enabled.
     *
     * @param aCommandName    the name of the command to test
     * @param aCommandRefCon  the command context data
     */
    readonly isCommandEnabled: (aCommandName: string, aCommandRefCon: (nsISupports | null)) => boolean;

    /**
     * Tell the command to update its state (if it is a state updating command)
     *
     * @param aCommandName    the name of the command to update
     * @param aCommandRefCon  the command context data
     */
    readonly updateCommandState: (aCommandName: string, aCommandRefCon: (nsISupports | null)) => void;

    /**
     * Get whether the named command is supported.
     *
     * @param aCommandName    the name of the command to test
     * @param aCommandRefCon  the command context data
     */
    readonly supportsCommand: (aCommandName: string, aCommandRefCon: (nsISupports | null)) => boolean;

    /**
     * Execute the named command.
     *
     * @param aCommandName    the name of the command to execute
     * @param aCommandRefCon  the command context data
     */
    readonly doCommand: (aCommandName: string, aCommandRefCon: (nsISupports | null)) => void;

    readonly doCommandParams: (aCommandName: string, aParam: (nsICommandParams | null), aCommandRefCon: (nsISupports | null)) => void;

    readonly getCommandState: (aCommandName: string, aParam: (nsICommandParams | null), aCommandRefCon: (nsISupports | null)) => void;

    readonly getSupportedCommands: () => IDLACString[];
  }

  export interface imgIEncoderRef {
    readonly name: "imgIEncoder";
    readonly number: "{4baa2d6e-fee7-42df-ae3f-5fbebc0c267c}";

    INPUT_FORMAT_RGB: 0;

    INPUT_FORMAT_RGBA: 1;

    INPUT_FORMAT_HOSTARGB: 2;
  }

  /**
   * imgIEncoder interface
   */
  export interface imgIEncoder extends nsIAsyncInputStream {

    readonly initFromData: (data: number[], length: number, width: number, height: number, stride: number, inputFormat: number, outputOptions: IDLAString) => void;

    readonly startImageEncode: (width: number, height: number, inputFormat: number, outputOptions: IDLAString) => void;

    readonly addImageFrame: (data: number[], length: number, width: number, height: number, stride: number, frameFormat: number, frameOptions: IDLAString) => void;

    readonly endImageEncode: () => void;
  }

  export interface nsIStyleSheetServiceRef {
    readonly name: "nsIStyleSheetService";
    readonly number: "{4de68896-e8eb-41de-8237-a797b570ac4a}";

    AGENT_SHEET: 0;

    USER_SHEET: 1;

    AUTHOR_SHEET: 2;
  }

  export interface nsIStyleSheetService extends nsISupports {

    /**
     * Synchronously loads a style sheet from |sheetURI| and adds it to the list
     * of user or agent style sheets.
     *
     * A user sheet loaded via this API will come before userContent.css and
     * userChrome.css in the cascade (so the rules in it will have lower
     * precedence than rules in those sheets).
     *
     * An agent sheet loaded via this API will come after ua.css in the cascade
     * (so the rules in it will have higher precedence than rules in ua.css).
     *
     * The relative ordering of two user or two agent sheets loaded via
     * this API is undefined.
     *
     * Sheets added via this API take effect on all documents, including
     * already-loaded ones, immediately.
     */
    readonly loadAndRegisterSheet: (sheetURI: (nsIURI | null), type: number) => void;

    /**
     * Returns true if a style sheet at |sheetURI| has previously been
     * added to the list of style sheets specified by |type|.
     */
    readonly sheetRegistered: (sheetURI: (nsIURI | null), type: number) => boolean;

    /**
     * Synchronously loads a style sheet from |sheetURI| and returns the
     * new style sheet object. Can be used with nsIDOMWindowUtils.addSheet.
     */
    readonly preloadSheet: (sheetURI: (nsIURI | null), type: number) => (nsIPreloadedStyleSheet | null);

    /**
     * Asynchronously loads a style sheet from |sheetURI| and returns a Promise
     * which resolves to the new style sheet object, which can be used with
     * nsIDOMWindowUtils.addSheet, when it has completed loading.
     */
    readonly preloadSheetAsync: (sheetURI: (nsIURI | null), type: number) => IDLjsval;

    /**
     * Remove the style sheet at |sheetURI| from the list of style sheets
     * specified by |type|.  The removal takes effect immediately, even for
     * already-loaded documents.
     */
    readonly unregisterSheet: (sheetURI: (nsIURI | null), type: number) => void;
  }

  /**
   * Get an array of this docShell and its children.
   *
   * @param aItemType  - Only include docShells of this type, or if typeAll,
   *                     include all child shells.
   *                     Uses types from nsIDocShellTreeItem.
   * @param aDirection - Whether to enumerate forwards or backwards.
   */
  export enum nsIDocShell_DocShellEnumeratorDirection {
    ENUMERATE_FORWARDS = 0,
    ENUMERATE_BACKWARDS = 1,
  }

  /**
   * The type of application that created this window.
   *
   * DO NOT DELETE, see bug 176166. For firefox, this value will always be
   * UNKNOWN. However, it is used heavily in Thunderbird/comm-central and we
   * don't really have a great replacement at the moment, so we'll just leave it
   * here.
   */
  export enum nsIDocShell_AppType {
    APP_TYPE_UNKNOWN = 0,
    APP_TYPE_MAIL = 1,
    APP_TYPE_EDITOR = 2,
  }

  /**
   * Current busy state for DocShell
   */
  export enum nsIDocShell_BusyFlags {
    BUSY_FLAGS_NONE = 0,
    BUSY_FLAGS_BUSY = 1,
    BUSY_FLAGS_BEFORE_PAGE_LOAD = 2,
    BUSY_FLAGS_PAGE_LOADING = 4,
  }

  /**
   * Load commands for the document
   */
  export enum nsIDocShell_LoadCommand {
    LOAD_CMD_NORMAL = 1,
    LOAD_CMD_RELOAD = 2,
    LOAD_CMD_HISTORY = 4,
    LOAD_CMD_PUSHSTATE = 8,
  }

  /**
   * The type of iframe that this docshell lives.
   */
  export enum nsIDocShell_FrameType {
    FRAME_TYPE_REGULAR = 0,
    FRAME_TYPE_BROWSER = 1,
  }

  export enum nsIDocShell_TouchEventsOverride {
    TOUCHEVENTS_OVERRIDE_DISABLED = 0,
    TOUCHEVENTS_OVERRIDE_ENABLED = 1,
    TOUCHEVENTS_OVERRIDE_NONE = 2,
  }

  export enum nsIDocShell_MetaViewportOverride {
    META_VIEWPORT_OVERRIDE_DISABLED = 0,
    META_VIEWPORT_OVERRIDE_ENABLED = 1,
    META_VIEWPORT_OVERRIDE_NONE = 2,
  }

  /**
   * Allowed CSS display modes. This needs to be kept in
   * sync with similar values in ServoStyleConsts.h
   */
  export enum nsIDocShell_DisplayMode {
    DISPLAY_MODE_BROWSER = 0,
    DISPLAY_MODE_MINIMAL_UI = 1,
    DISPLAY_MODE_STANDALONE = 2,
    DISPLAY_MODE_FULLSCREEN = 3,
  }

  export interface nsIDocShellRef {
    readonly name: "nsIDocShell";
    readonly number: "{049234fe-da10-478b-bc5d-bc6f9a1ba63d}";

    ENUMERATE_FORWARDS: 0;
    ENUMERATE_BACKWARDS: 1;

    APP_TYPE_UNKNOWN: 0;
    APP_TYPE_MAIL: 1;
    APP_TYPE_EDITOR: 2;

    BUSY_FLAGS_NONE: 0;
    BUSY_FLAGS_BUSY: 1;
    BUSY_FLAGS_BEFORE_PAGE_LOAD: 2;
    BUSY_FLAGS_PAGE_LOADING: 4;

    LOAD_CMD_NORMAL: 1;
    LOAD_CMD_RELOAD: 2;
    LOAD_CMD_HISTORY: 4;
    LOAD_CMD_PUSHSTATE: 8;

    FRAME_TYPE_REGULAR: 0;
    FRAME_TYPE_BROWSER: 1;

    TOUCHEVENTS_OVERRIDE_DISABLED: 0;
    TOUCHEVENTS_OVERRIDE_ENABLED: 1;
    TOUCHEVENTS_OVERRIDE_NONE: 2;

    META_VIEWPORT_OVERRIDE_DISABLED: 0;
    META_VIEWPORT_OVERRIDE_ENABLED: 1;
    META_VIEWPORT_OVERRIDE_NONE: 2;

    DISPLAY_MODE_BROWSER: 0;
    DISPLAY_MODE_MINIMAL_UI: 1;
    DISPLAY_MODE_STANDALONE: 2;
    DISPLAY_MODE_FULLSCREEN: 3;
  }

  export interface nsIDocShell extends nsIDocShellTreeItem {

    readonly setCancelContentJSEpoch: (aEpoch: number) => void;

    /**
     * Do either a history.pushState() or history.replaceState() operation,
     * depending on the value of aReplace.
     */
    readonly addState: (aData: IDLjsval, aTitle: IDLAString, aURL: IDLAString, aReplace: boolean) => void;

    /**
     * Helper for addState and document.open that does just the
     * history-manipulation guts.
     *
     * Arguments the spec defines:
     *
     * @param aDocument the document we're manipulating.  This will get the new URI.
     * @param aNewURI the new URI.
     * @param aData The serialized state data.  May be null.
     * @param aTitle The new title.  May be empty.
     * @param aReplace whether this should replace the exising SHEntry.
     *
     * Arguments we need internally because deriving them from the
     * others is a bit complicated:
     *
     * @param aCurrentURI the current URI we're working with.  Might be null.
     * @param aEqualURIs whether the two URIs involved are equal.
     */
    readonly updateURLAndHistory: (aDocument: WebIDL.Document, aNewURI: (nsIURI | null), aData: (nsIStructuredCloneContainer | null), aTitle: IDLAString, aReplace: boolean, aCurrentURI: (nsIURI | null), aEqualURIs: boolean) => void;

    /**
     * Reset state to a new content model within the current document and the document
     * viewer.  Called by the document before initiating an out of band document.write().
     */
    readonly prepareForNewContentModel: () => void;

    /**
     * For editors and suchlike who wish to change the URI associated with the
     * document. Note if you want to get the current URI, use the read-only
     * property on nsIWebNavigation.
     */
    readonly setCurrentURI: (aURI: (nsIURI | null)) => void;

    /**
     * Content Viewer that is currently loaded for this DocShell.  This may
     * change as the underlying content changes.
     */
    readonly contentViewer: (nsIContentViewer | null);

    /**
     * Get the id of the outer window that is or will be in this docshell.
     */
    readonly outerWindowID: number;

    /**
     * This attribute allows chrome to tie in to handle DOM events that may
     * be of interest to chrome.
     */
    chromeEventHandler: WebIDL.EventTarget;

    /**
     * This allows chrome to set a custom User agent on a specific docshell
     */
    customUserAgent: IDLAString;

    /**
     * Whether CSS error reporting is enabled.
     */
    cssErrorReportingEnabled: boolean;

    /**
     * Whether to allow plugin execution
     */
    allowPlugins: boolean;

    /**
     * Whether to allow Javascript execution
     */
    allowJavascript: boolean;

    /**
     * Attribute stating if refresh based redirects can be allowed
     */
    allowMetaRedirects: boolean;

    /**
     * Attribute stating if it should allow subframes (framesets/iframes) or not
     */
    allowSubframes: boolean;

    /**
     * Attribute stating whether or not images should be loaded.
     */
    allowImages: boolean;

    /**
     * Attribute stating whether or not media (audio/video) should be loaded.
     */
    allowMedia: boolean;

    /**
     * Attribute that determines whether DNS prefetch is allowed for this subtree
     * of the docshell tree.  Defaults to true.  Setting this will make it take
     * effect starting with the next document loaded in the docshell.
     */
    allowDNSPrefetch: boolean;

    /**
     * Attribute that determines whether window control (move/resize) is allowed.
     */
    allowWindowControl: boolean;

    /**
     * True if the docshell allows its content to be handled by a content listener
     * other than the docshell itself, including the external helper app service,
     * and false otherwise.  Defaults to true.
     */
    allowContentRetargeting: boolean;

    /**
     * True if new child docshells should allow content retargeting.
     * Setting allowContentRetargeting also overwrites this value.
     */
    allowContentRetargetingOnChildren: boolean;

    /**
     * True if this docShell should inherit the private browsing ID from
     * its parent when reparented.
     *
     * NOTE: This should *not* be set false in new code, or for docShells
     * inserted anywhere other than as children of panels.
     */
    inheritPrivateBrowsingId: boolean;

    readonly getAllDocShellsInSubtree: (aItemType: number, aDirection: nsIDocShell_DocShellEnumeratorDirection) => (nsIDocShell | null)[];

    appType: nsIDocShell_AppType;

    /**
     * certain docshells (like the message pane)
     * should not throw up auth dialogs
     * because it can act as a password trojan
     */
    allowAuth: boolean;

    /**
     * Set/Get the document scale factor.  When setting this attribute, a
     * NS_ERROR_NOT_IMPLEMENTED error may be returned by implementations
     * not supporting zoom.  Implementations not supporting zoom should return
     * 1.0 all the time for the Get operation.  1.0 by the way is the default
     * of zoom.  This means 100% of normal scaling or in other words normal size
     * no zoom.
     */
    zoom: number;

    readonly tabToTreeOwner: (forward: boolean, forDocumentNavigation: boolean) => boolean;

    readonly busyFlags: nsIDocShell_BusyFlags;

    loadType: number;

    defaultLoadFlags: number;

    readonly isBeingDestroyed: () => boolean;

    readonly isExecutingOnLoadHandler: boolean;

    layoutHistoryState: (nsILayoutHistoryState | null);

    /**
     * The SecureBrowserUI object for this docshell.  This is set by XUL
     * <browser> or nsWebBrowser for their root docshell.
     */
    securityUI: (nsISecureBrowserUI | null);

    /**
     * Object used to delegate URI loading to an upper context.
     * Currently only set for GeckoView to allow handling of load requests
     * at the application level.
     */
    readonly loadURIDelegate: (nsILoadURIDelegate | null);

    /**
     * Cancel the XPCOM timers for each meta-refresh URI in this docshell,
     * and this docshell's children, recursively. The meta-refresh timers can be
     * restarted using resumeRefreshURIs().  If the timers are already suspended,
     * this has no effect.
     */
    readonly suspendRefreshURIs: () => void;

    /**
     * Restart the XPCOM timers for each meta-refresh URI in this docshell,
     * and this docshell's children, recursively.  If the timers are already
     * running, this has no effect.
     */
    readonly resumeRefreshURIs: () => void;

    /**
     * Begin firing WebProgressListener notifications for restoring a page
     * presentation. |viewer| is the content viewer whose document we are
     * starting to load.  If null, it defaults to the docshell's current content
     * viewer, creating one if necessary.  |top| should be true for the toplevel
     * docshell that is being restored; it will be set to false when this method
     * is called for child docshells.  This method will post an event to
     * complete the simulated load after returning to the event loop.
     */
    readonly beginRestore: (viewer: (nsIContentViewer | null), top: boolean) => void;

    /**
     * Finish firing WebProgressListener notifications and DOM events for
     * restoring a page presentation.  This should only be called via
     * beginRestore().
     */
    readonly finishRestore: () => void;

    readonly restoringDocument: boolean;

    useErrorPages: boolean;

    /**
     * Display a load error in a frame while keeping that frame's currentURI
     * pointing correctly to the page where the error ocurred, rather than to
     * the error document page. You must provide either the aURI or aURL parameter.
     *
     * @param  aError         The error code to be displayed
     * @param  aURI           nsIURI of the page where the error happened
     * @param  aURL           wstring of the page where the error happened
     * @param  aFailedChannel The channel related to this error
     *
     * Returns whether or not we displayed an error page (note: will always
     * return false if in-content error pages are disabled!)
     */
    readonly displayLoadError: (aError: number, aURI: (nsIURI | null), aURL: string, aFailedChannel?: (nsIChannel | null)) => boolean;

    /**
     * The channel that failed to load and resulted in an error page.
     * May be null. Relevant only to error pages.
     */
    readonly failedChannel: (nsIChannel | null);

    /**
     * Keeps track of the previous nsISHEntry index and the current
     * nsISHEntry index at the time that the doc shell begins to load.
     * Used for ContentViewer eviction.
     */
    readonly previousEntryIndex: number;

    readonly loadedEntryIndex: number;

    /**
     * Notification that entries have been removed from the beginning of a
     * nsSHistory which has this as its rootDocShell.
     *
     * @param numEntries - The number of entries removed
     */
    readonly historyPurged: (numEntries: number) => void;

    /**
     * Gets the channel for the currently loaded document, if any.
     * For a new document load, this will be the channel of the previous document
     * until after OnLocationChange fires.
     */
    readonly currentDocumentChannel: (nsIChannel | null);

    /**
     * Find out whether the docshell is currently in the middle of a page
     * transition. This is set just before the pagehide/unload events fire.
     */
    readonly isInUnload: boolean;

    /**
     * This attribute determines whether Mixed Active Content is loaded on the
     * document. When it is true, mixed active content was not blocked and has
     * loaded (or is about to load) on the page. When it is false, mixed active content
     * has not loaded on the page, either because there was no mixed active content
     * requests on the page or such requests were blocked by nsMixedContentBlocker.
     * This boolean is set to true in nsMixedContentBlocker if Mixed Active Content
     * is allowed (either explicitly on the page by the user or when the about:config
     * setting security.mixed_content.block_active_content is set to false).
     */
    readonly hasMixedActiveContentLoaded: boolean;

    /**
     * This attribute determines whether a document has Mixed Active Content
     * that has been blocked from loading. When it is true, there is definitely
     * mixed active content on a page that has been blocked by
     * nsMixedContentBlocker.  When it is false, there may or may not be mixed
     * active content on a page, but if there is, it will load. Note that if the
     * about:config setting security.mixed_content.block_active_content is set
     * false, this boolean will be false, since blocking active content has been
     * disabled.
     */
    readonly hasMixedActiveContentBlocked: boolean;

    /**
     * This attribute determines whether Mixed Display Content is loaded on the
     * document. When it is true, mixed display content was not blocked and has
     * loaded (or is about to load) on the page. Similar behavior to
     * hasMixedActiveContentLoaded.
     */
    readonly hasMixedDisplayContentLoaded: boolean;

    /**
     * This attribute determines whether a document has Mixed Display Content
     * that has been blocked from loading. Similar behavior to
     * hasMixedActiveContentBlocked.
     */
    readonly hasMixedDisplayContentBlocked: boolean;

    /**
     * This attribute determines whether a document has Tracking Content
     * that has been blocked from loading.
     */
    readonly hasTrackingContentBlocked: boolean;

    /**
     * If true, this browser is not visible in the traditional sense, but
     * is actively being rendered to the screen (ex. painted on a canvas)
     * and should be treated accordingly.
     **/
    isOffScreenBrowser: boolean;

    /**
     * This method should only be called on a docShell that has been specifically
     * created to display a print preview document.  If the current document
     * viewer isn't initialized for print preview when this method is called, it
     * is replaced with a new viewer with an about:blank document (with the URL
     * about:printpreview).  The viewer is then returned, ready for the print
     * preview document to be constructed when viewer.printPreview() is called.
     *
     * The same viewer will be returned on subsequent calls since various bits of
     * code assume that, once created, the viewer is never replaced.  Note,
     * however, that the viewer's document will be replaced with a new document
     * each time printPreview() is called on it (which is what we do to take
     * account of print preview settings changes).  Replacing the document
     * viewer's document breaks the normally unchanging 1:1 relationship between
     * a document and its viewer, but that seems to be okay.
     */
    readonly initOrReusePrintPreviewViewer: () => (nsIWebBrowserPrint | null);

    /**
     * Propagated to the print preview document viewer.  Must only be called on
     * a document viewer that has been initialized for print preview.
     */
    readonly exitPrintPreview: () => void;

    /**
     * Whether this docshell can execute scripts based on its hierarchy.
     * The rule of thumb here is that we disable js if this docshell or any
     * of its parents disallow scripting.
     */
    readonly canExecuteScripts: boolean;

    /**
     * Sets whether a docshell is active. An active docshell is one that is
     * visible, and thus is not a good candidate for certain optimizations
     * like image frame discarding. Docshells are active unless told otherwise.
     */
    isActive: boolean;

    /**
     * Sets whether a docshell is an app tab. An app tab docshell may behave
     * differently than a non-app tab docshell in some cases, such as when
     * handling link clicks. Docshells are not app tabs unless told otherwise.
     */
    isAppTab: boolean;

    /**
     * Create a new about:blank document and content viewer.
     * @param aPrincipal the principal to use for the new document.
     * @param aStoragePrincipal the storage principal to use for the new document.
     * @param aCsp the CSP to use for the new document.
     */
    readonly createAboutBlankContentViewer: (aPrincipal: (nsIPrincipal | null), aStoragePrincipal: (nsIPrincipal | null), aCSP?: (nsIContentSecurityPolicy | null)) => void;

    /**
     * Upon getting, returns the canonical encoding label of the document
     * currently loaded into this docshell.
     *
     * Upon setting, sets forcedCharset for compatibility with legacy callers.
     */
    charset: IDLACString;

    /**
     * Called when the user chose an encoding override from the character
     * encoding menu. Separate from the setter for the charset property to avoid
     * extensions adding noise to the data.
     */
    readonly gatherCharsetMenuTelemetry: () => void;

    /**
     * The charset forced by the user.
     */
    forcedCharset: IDLACString;

    /**
     * Whether the docShell records profile timeline markers at the moment
     */
    recordProfileTimelineMarkers: boolean;

    /**
     * Return a DOMHighResTimeStamp representing the number of
     * milliseconds from an arbitrary point in time.  The reference
     * point is shared by all DocShells and is also used by timestamps
     * on markers.
     */
    readonly now: () => number;

    /**
     * Returns and flushes the profile timeline markers gathered by the docShell
     */
    readonly popProfileTimelineMarkers: () => IDLjsval;

    /**
     * Add an observer to the list of parties to be notified when this docshell's
     * private browsing status is changed. |obs| must support weak references.
     */
    readonly addWeakPrivacyTransitionObserver: (obs: (nsIPrivacyTransitionObserver | nsIPrivacyTransitionObserverFunction | null)) => void;

    /**
     * Add an observer to the list of parties to be notified when reflows are
     * occurring. |obs| must support weak references.
     */
    readonly addWeakReflowObserver: (obs: (nsIReflowObserver | null)) => void;

    /**
     * Remove an observer from the list of parties to be notified about reflows.
     */
    readonly removeWeakReflowObserver: (obs: (nsIReflowObserver | null)) => void;

    frameType: nsIDocShell_FrameType;

    /**
     * Returns true if this docshell corresponds to an <iframe mozbrowser>.
     * <xul:browser> returns false here.
     */
    readonly isMozBrowser: boolean;

    /**
     * Returns true if this docshell corresponds to an <iframe mozbrowser>, or
     * if this docshell is contained in an <iframe mozbrowser>. <xul:browser>
     * returns false here.
     *
     * To compute this value, we walk up the docshell hierarchy.  If we encounter
     * a docshell with isMozBrowser before we hit the end of the hierarchy,
     * we return true.  Otherwise, we return false.
     */
    readonly isInMozBrowser: boolean;

    /**
     * Returns true if this docshell is the top level content docshell.
     */
    readonly isTopLevelContentDocShell: boolean;

    /**
     * Like nsIDocShellTreeItem::GetSameTypeParent, except this ignores <iframe
     * mozbrowser> boundaries.
     *
     * @deprecated: Use `BrowsingContext::GetParent()` in the future.
     */
    readonly getSameTypeParentIgnoreBrowserBoundaries: () => (nsIDocShell | null);

    /**
     * Like nsIDocShellTreeItem::GetSameTypeRootTreeItem, except this ignores
     * <iframe mozbrowser> boundaries.
     *
     * @deprecated: Use `BrowsingContext::Top()` in the future.
     */
    readonly getSameTypeRootTreeItemIgnoreBrowserBoundaries: () => (nsIDocShell | null);

    /**
     * True iff asynchronous panning and zooming is enabled for this
     * docshell.
     */
    readonly asyncPanZoomEnabled: boolean;

    /**
     * This member variable determines whether a document has Mixed Active Content that
     * was initially blocked from loading, but the user has choosen to override the
     * block and allow the content to load. mMixedContentChannel is set to the document's
     * channel when the user allows mixed content. The nsMixedContentBlocker content policy
     * checks if the document's root channel matches the mMixedContentChannel.  If it matches,
     * then Mixed Content is loaded.  If it does match, mixed content is blocked.
     *
     * A match implies that there is definitely mixed active content on a page that was
     * initially blocked by nsMixedContentBlocker and then allowed and loaded by the user.
     * A miss imples that IF there is mixed active content on the page AND it was
     * blocked by nsMixedContentBlocker.cpp, the user has not choosen to override
     * the block. Note that if the about:config setting
     * security.mixed_content.block_active_content is set to false, this boolean
     * will be false, mMixedContentChannel will remain null since blocking active content has
     * been disabled and hence mMixedContentChannel will never be set.
     */
    mixedContentChannel: (nsIChannel | null);

    /**
     * Checks whether the channel associated with the root docShell is equal to
     * mMixedContentChannel. If they are the same, allowMixedContent is set to true.
     * Checks if the root document has a secure connection. If it is, sets
     * rootHasSecureConnection to true. If the docShell is the root doc shell,
     * isRootDocShell is set to true.
     */
    readonly GetAllowMixedContentAndConnectionData: (rootHasSecureConnection: Out<boolean>, allowMixedContent: Out<boolean>, isRootDocShell: Out<boolean>) => void;

    /**
     * Attribute that determines whether fullscreen is allowed to be entered for
     * this subtree of the docshell tree. This is true when all iframes containing
     * this docshell have their "allowfullscreen" attribute set to "true".
     * fullscreenAllowed is only writable at content boundaries, where it is used
     * to propagate the value of the cross process parent's iframe's
     * "allowfullscreen" attribute to the child process. Setting
     * fullscreenAllowed on docshells which aren't content boundaries throws an
     * exception.
     */
    readonly fullscreenAllowed: boolean;

    readonly setFullscreenAllowed: (allowed: boolean) => void;

    /**
     * Indicates whether the UI may enable the character encoding menu. The UI
     * must disable the menu when this property is false.
     */
    readonly mayEnableCharacterEncodingMenu: boolean;

    /**
     * Indicates that the character encoding was autodetected.
     */
    readonly charsetAutodetected: boolean;

    editor: (nsIEditor | null);

    readonly editable: boolean;

    readonly hasEditingSession: boolean;

    /**
     * Make this docShell editable, setting a flag that causes
     * an editor to get created, either immediately, or after
     * a url has been loaded.
     *      @param  inWaitForUriLoad    true to wait for a URI before
     *                                  creating the editor.
     */
    readonly makeEditable: (inWaitForUriLoad: boolean) => void;

    /**
     * Add a Child SHEntry for a frameset page, given the child's loadtype.
     * If aCloneChildren is true, then aCloneReference's children will be
     * cloned onto aHistoryEntry.
     */
    readonly addChildSHEntry: (aCloneReference: (nsISHEntry | null), aHistoryEntry: (nsISHEntry | null), aChildOffset: number, aLoadType: number, aCloneChilden: boolean) => void;

    /**
     * Whether this docshell should save entries in global history.
     */
    useGlobalHistory: boolean;

    /**
     * Removes nsISHEntry objects related to this docshell from session history.
     * Use this only with subdocuments, like iframes.
     */
    readonly removeFromSessionHistory: () => void;

    /**
     * Set when an iframe/frame is added dynamically.
     */
    createdDynamically: boolean;

    /**
     * Returns false for mLSHE, true for mOSHE
     */
    readonly getCurrentSHEntry: (aEntry: Out<(nsISHEntry | null)>) => boolean;

    /**
     * Cherry picked parts of nsIController.
     * They are here, because we want to call these functions
     * from JS.
     */
    readonly isCommandEnabled: (command: string) => boolean;

    readonly doCommand: (command: string) => void;

    readonly doCommandWithParams: (command: string, aParams: (nsICommandParams | null)) => void;

    /**
     * If deviceSizeIsPageSize is set to true, device-width/height media queries
     * will be calculated from the page size, not the device size.
     *
     * Used by the Responsive Design Mode and B2G Simulator.
     *
     * Default is False.
     * Default value can be overriden with
     * docshell.device_size_is_page_size pref.
     */
    deviceSizeIsPageSize: boolean;

    /**
     * This attribute determines whether a document which is not about:blank has
     * already be loaded by this docShell.
     */
    readonly hasLoadedNonBlankURI: boolean;

    /**
     * Allow usage of -moz-window-dragging:drag for content docshells.
     * True for top level chrome docshells. Throws if set to false with
     * top level chrome docshell.
     */
    windowDraggingAllowed: boolean;

    /**
     * Sets/gets the current scroll restoration mode.
     * @see https://html.spec.whatwg.org/#dom-history-scroll-restoration
     */
    currentScrollRestorationIsManual: boolean;

    /**
     * Setter and getter for the origin attributes living on this docshell.
     */
    readonly getOriginAttributes: () => IDLjsval;

    readonly setOriginAttributes: (aAttrs: IDLjsval) => void;

    /**
     * The editing session for this docshell.
     */
    readonly editingSession: (nsIEditingSession | null);

    /**
     * The browser child for this docshell.
     */
    readonly browserChild: (nsIBrowserChild | null);

    /**
     * This allows chrome to override the default choice of whether touch events
     * are available on a specific docshell. Possible values are listed below.
     */
    touchEventsOverride: nsIDocShell_TouchEventsOverride;

    /**
     * This allows chrome to override the default choice of whether the
     * <meta name="viewport"> tag is respected in a specific docshell.
     * Possible values are listed above.
     */
    metaViewportOverride: nsIDocShell_MetaViewportOverride;

    /**
     * Returns `true` if this docshell was created due to a Large-Allocation
     * header, and has not seen the initiating load yet.
     */
    readonly awaitingLargeAlloc: boolean;

    /**
     * Attribute that determines whether tracking protection is enabled.
     */
    useTrackingProtection: boolean;

    readonly setColorMatrix: (aMatrix: number[]) => void;

    /**
     * Returns true if the current load is a forced reload,
     * e.g. started by holding shift whilst triggering reload.
     */
    readonly isForceReloading: boolean;

    readonly getColorMatrix: () => number[];

    /**
     * Initialize session history for this docshell. The docshell must be the root
     * docshell.
     */
    readonly initSessionHistory: () => void;

    /**
     * Display mode for this docshell. Defaults to DISPLAY_MODE_BROWSER.
     * Media queries only look at the value in the top-most docshell.
     */
    displayMode: nsIDocShell_DisplayMode;

    /**
     * The message manager for this docshell.  This does not throw, but
     * can return null if the docshell has no message manager.
     */
    readonly messageManager: WebIDL.ContentFrameMessageManager;

    /**
     * Asynchronously retrieve a JSON string representing a log of the
     * content blocking events happened so far in the current tab from the
     * content process.
     *
     * This returns a Promise which resolves to a string on success, and is
     * rejected on failure.  For documentation on the string format, please
     * see nsISecureBrowserUI.contentBlockingLogJSON.
     */
    readonly getContentBlockingLog: () => IDLPromise;

    /**
     * Whether developer tools are watching activity in this docshell.
     */
    watchedByDevtools: boolean;

    readonly isNavigating: boolean;

    /**
     * @see nsISHEntry synchronizeLayoutHistoryState().
     */
    readonly synchronizeLayoutHistoryState: () => void;
  }

  export interface nsIDOMXULMultiSelectControlElementRef {
    readonly name: "nsIDOMXULMultiSelectControlElement";
    readonly number: "{40654a10-8204-4f06-9f21-7baa31c7b1dd}";
  }

  export interface nsIDOMXULMultiSelectControlElement extends nsIDOMXULSelectControlElement {

    selType: IDLAString;

    currentItem: WebIDL.Element;

    currentIndex: number;

    readonly selectedItems: WebIDL.NodeList;

    readonly addItemToSelection: (item: (nsIDOMXULSelectControlItemElement | null)) => void;

    readonly removeItemFromSelection: (item: (nsIDOMXULSelectControlItemElement | null)) => void;

    readonly toggleItemSelection: (item: (nsIDOMXULSelectControlItemElement | null)) => void;

    readonly selectItem: (item: (nsIDOMXULSelectControlItemElement | null)) => void;

    readonly selectItemRange: (startItem: (nsIDOMXULSelectControlItemElement | null), item: (nsIDOMXULSelectControlItemElement | null)) => void;

    readonly selectAll: () => void;

    readonly clearSelection: () => void;

    readonly selectedCount: number;

    readonly getSelectedItem: (index: number) => WebIDL.Element;
  }

  export interface nsIAppShellServiceRef {
    readonly name: "nsIAppShellService";
    readonly number: "{19266025-354c-4bb9-986b-3483b2b1cdef}";

    /**
     * Create a window, which will be initially invisible.
     * @param aParent the parent window.  Can be null.
     * @param aUrl the contents of the new window.
     * @param aChromeMask chrome flags affecting the kind of OS border
     *                    given to the window. see nsIBrowserWindow for
     *                    bit/flag definitions.
     * @param aCallbacks interface providing C++ hooks for window initialization
     *                   before the window is made visible.  Can be null.
     *                   Deprecated.
     * @param aInitialWidth width, in pixels, of the window.  Width of window
     *                      at creation.  Can be overridden by the "width"
     *                      tag in the XUL.  Set to NS_SIZETOCONTENT to force
     *                      the window to wrap to its contents.
     * @param aInitialHeight like aInitialWidth, but subtly different.
     * @param aOpeningTab The RemoteTab that requested that this window be opened.
     *                    Can be left null.
     * @param aOpenerWindow The Window Proxy which requested that this window be opened.
     *                      Can be left null.
     */
    SIZE_TO_CONTENT: -1;
  }

  export interface nsIAppShellService extends nsISupports {

    readonly createTopLevelWindow: (aParent: (nsIAppWindow | null), aUrl: (nsIURI | null), aChromeMask: number, aInitialWidth: number, aInitialHeight: number, aOpeningTab: (nsIRemoteTab | null), aOpenerWindow: (mozIDOMWindowProxy | null)) => (nsIAppWindow | null);

    /**
     * This is the constructor for creating an invisible DocShell.
     * It is used to simulate DOM windows without an actual physical
     * representation.
     * @param aIsChrome Set true if you want to use it for chrome content.
     */
    readonly createWindowlessBrowser: (aIsChrome?: boolean) => (nsIWindowlessBrowser | null);

    readonly destroyHiddenWindow: () => void;

    /**
     * Return the (singleton) application hidden window, automatically created
     * and maintained by this AppShellService.
     * @param aResult the hidden window.  Do not unhide hidden window.
     *                Do not taunt hidden window.
     */
    readonly hiddenWindow: (nsIAppWindow | null);

    /**
     * Return the (singleton) application hidden window, automatically created
     * and maintained by this AppShellService.
     * @param aResult the hidden window.  Do not unhide hidden window.
     *                Do not taunt hidden window.
     */
    readonly hiddenDOMWindow: (mozIDOMWindowProxy | null);

    /**
     * Return true if the application hidden window was provided by the
     * application. If it wasn't, the default hidden window was used. This will
     * usually be false on all non-mac platforms.
     */
    readonly applicationProvidedHiddenWindow: boolean;

    /**
     * Add a window to the application's registry of windows.  These windows
     * are generally shown in the Windows taskbar, and the application
     * knows it can't quit until it's out of registered windows.
     * @param aWindow the window to register
     * @note When this method is successful, it fires the global notification
     *       "xul-window-registered"
     */
    readonly registerTopLevelWindow: (aWindow: (nsIAppWindow | null)) => void;

    /**
     * Remove a window from the application's window registry. Note that
     * this method won't automatically attempt to quit the app when
     * the last window is unregistered. For that, see Quit().
     * @param aWindow you see the pattern
     */
    readonly unregisterTopLevelWindow: (aWindow: (nsIAppWindow | null)) => void;

    /**
     * Whether the hidden window has been lazily created.
     */
    readonly hasHiddenWindow: boolean;

    /**
     * Start/stop tracking lags in the event loop.
     * If the event loop gets unresponsive, a "event-loop-lag" notification
     * is sent. Note that calling `startEventLoopLagTracking` when tracking
     * is already enabled has no effect.
     * @return true if tracking succeeded.
     */
    readonly startEventLoopLagTracking: () => boolean;

    readonly stopEventLoopLagTracking: () => void;
  }

  export interface nsIPresentationControlChannelRef {
    readonly name: "nsIPresentationControlChannel";
    readonly number: "{e60e208c-a9f5-4bc6-9a3e-47f3e4ae9c57}";
  }

  export interface nsIPresentationControlChannel extends nsISupports {

    listener: (nsIPresentationControlChannelListener | null);

    readonly sendOffer: (offer: (nsIPresentationChannelDescription | null)) => void;

    readonly sendAnswer: (answer: (nsIPresentationChannelDescription | null)) => void;

    readonly sendIceCandidate: (candidate: IDLAString) => void;

    readonly launch: (presentationId: IDLAString, url: IDLAString) => void;

    readonly terminate: (presentationId: IDLAString) => void;

    readonly disconnect: (reason: number) => void;

    readonly reconnect: (presentationId: IDLAString, url: IDLAString) => void;
  }

  export interface nsIFakePluginTagRef {
    readonly name: "nsIFakePluginTag";
    readonly number: "{6d22c968-226d-4156-b230-da6ad6bbf6e8}";
  }

  /**
   * An interface representing a "fake" plugin: one implemented in JavaScript, not
   * as a NPAPI plug-in.  See nsIPluginHost.registerFakePlugin and the
   * documentation for the FakePluginTagInit dictionary.
   */
  export interface nsIFakePluginTag extends nsIPluginTag {

    /**
     * The URI that should be loaded into the tag (as a frame) to handle the
     * plugin. Note that the original data/src value for the plugin is not loaded
     * and will need to be requested by the handler via XHR or similar if desired.
     */
    readonly handlerURI: (nsIURI | null);

    /**
     * Optional script to run in a sandbox when instantiating a plugin. If this
     * value is an empty string then no such script will be run.
     * The script runs in a sandbox with system principal in the process that
     * contains the element that instantiates the plugin (ie the EMBED or OBJECT
     * element). The sandbox global has a 'pluginElement' property that the script
     * can use to access the element that instantiates the plugin.
     */
    readonly sandboxScript: IDLAString;
  }

  export interface nsIXPCComponentsBaseRef {
    readonly name: "nsIXPCComponentsBase";
    readonly number: "{eeeada2f-86c0-4609-b2bf-4bf2351b1ce6}";
  }

  /**
   * Interface for the 'Components' object.
   *
   * The first interface contains things that are available to non-chrome XBL code
   * that runs in a scope with an ExpandedPrincipal. The second interface
   * includes members that are only exposed to chrome.
   */
  export interface nsIXPCComponentsBase extends nsISupports {

    readonly interfaces: (nsIXPCComponents_Interfaces | null);

    readonly results: (nsIXPCComponents_Results | null);

    readonly isSuccessCode: (result: number) => boolean;
  }

  export interface nsIHTMLInlineTableEditorRef {
    readonly name: "nsIHTMLInlineTableEditor";
    readonly number: "{eda2e65c-a758-451f-9b05-77cb8de74ed2}";
  }

  export interface nsIHTMLInlineTableEditor extends nsISupports {

    /**
     * boolean indicating if inline table editing is enabled in the editor.
     * When inline table editing is enabled, and when the selection is
     * contained in a table cell, special buttons allowing to add/remove
     * a line/column are available on the cell's border.
     */
    inlineTableEditingEnabled: boolean;

    /**
     * Refresh already visible inline table editing UI.
     * If inline table editing UI is not visible, this does nothing.
     * If the set of inline table editing UI is hidden or replaced with new
     * one while this is called, this throws an exception.
     * FYI: Current user in script is only BlueGriffon.
     */
    readonly refreshInlineTableEditingUI: () => void;
  }

  export interface nsIPaymentShippingOptionRef {
    readonly name: "nsIPaymentShippingOption";
    readonly number: "{68341551-3605-4381-b936-41e830aa88fb}";
  }

  export interface nsIPaymentShippingOption extends nsISupports {

    readonly id: IDLAString;

    readonly label: IDLAString;

    readonly amount: (nsIPaymentCurrencyAmount | null);

    selected: boolean;
  }

  export interface nsIDOMXULCommandDispatcherRef {
    readonly name: "nsIDOMXULCommandDispatcher";
    readonly number: "{a9fa9fd3-8d62-4f94-9ed8-3ea9c3cf0773}";
  }

  export interface nsIDOMXULCommandDispatcher extends nsISupports {

    focusedElement: WebIDL.Element;

    focusedWindow: (mozIDOMWindowProxy | null);

    readonly addCommandUpdater: (updater: WebIDL.Element, events: IDLAString, targets: IDLAString) => void;

    readonly removeCommandUpdater: (updater: WebIDL.Element) => void;

    readonly updateCommands: (eventName: IDLAString) => void;

    readonly getControllerForCommand: (command: string) => (nsIController | null);

    readonly getControllers: () => (nsIControllers | null);

    readonly advanceFocus: () => void;

    readonly rewindFocus: () => void;

    readonly advanceFocusIntoSubtree: (elt: WebIDL.Element) => void;

    readonly lock: () => void;

    readonly unlock: () => void;
  }

  export interface nsISHEntryRef {
    readonly name: "nsISHEntry";
    readonly number: "{0dad26b8-a259-42c7-93f1-2fa7fc076e45}";
  }

  export interface nsISHEntry extends nsISupports {

    /**
     * The URI of the current entry.
     */
    URI: (nsIURI | null);

    /**
     * The original URI of the current entry. If an entry is the result of a
     * redirect this attribute holds the original URI.
     */
    originalURI: (nsIURI | null);

    /**
     * URL as stored from nsILoadInfo.resultPrincipalURI.  See nsILoadInfo
     * for more details.
     */
    resultPrincipalURI: (nsIURI | null);

    /**
     *  This flag remembers whether channel has LOAD_REPLACE set.
     */
    loadReplace: boolean;

    /**
     * The title of the current entry.
     */
    title: IDLAString;

    /**
     * Was the entry created as a result of a subframe navigation?
     * - Will be 'false' when a frameset page is visited for the first time.
     * - Will be 'true' for all history entries created as a result of a
     *   subframe navigation.
     */
    isSubFrame: boolean;

    /** Referrer Info*/
    referrerInfo: (nsIReferrerInfo | null);

    /** Content viewer, for fast restoration of presentation */
    contentViewer: (nsIContentViewer | null);

    /** Whether the content viewer is marked "sticky" */
    sticky: boolean;

    /** Saved state of the global window object */
    windowState: (nsISupports | null);

    /** Saved refresh URI list for the content viewer */
    refreshURIList: (nsIMutableArray | null);

    /** Post Data for the document */
    postData: (nsIInputStream | null);

    /** LayoutHistoryState for scroll position and form values */
    layoutHistoryState: (nsILayoutHistoryState | null);

    /** parent of this entry */
    parent: (nsISHEntry | null);

    /**
     * The loadType for this entry. This is typically loadHistory except
     * when reload is pressed, it has the appropriate reload flag
     */
    loadType: number;

    /**
     * An ID to help identify this entry from others during
     * subframe navigation
     */
    ID: number;

    /** The cache key for the entry */
    cacheKey: number;

    /** Should the layoutHistoryState be saved? */
    saveLayoutStateFlag: boolean;

    /** Has the page already expired in cache? */
    expirationStatus: boolean;

    /**
     * attribute to indicate the content-type of the document that this
     * is a session history entry for
     */
    contentType: IDLACString;

    /**
     * If we created this SHEntry via history.pushState or modified it via
     * history.replaceState, and if we changed the SHEntry's URI via the
     * push/replaceState call, and if the SHEntry's new URI differs from its
     * old URI by more than just the hash, then we set this field to true.
     *
     * Additionally, if this SHEntry was created by calling pushState from a
     * SHEntry whose URI was modified, this SHEntry's URIWasModified field is
     * true.
     */
    URIWasModified: boolean;

    /**
     * Get the principal, if any, that was associated with the channel
     * that the document that was loaded to create this history entry
     * came from.
     */
    triggeringPrincipal: (nsIPrincipal | null);

    /**
     * Get the principal, if any, that is used when the inherit flag
     * is set.
     */
    principalToInherit: (nsIPrincipal | null);

    /**
     * Get the storage principal, if any, that is used when the inherit flag is
     * set.
     */
    storagePrincipalToInherit: (nsIPrincipal | null);

    /**
     * Get the csp, if any, that was used for this document load. That
     * is not the CSP that was applied to subresource loads within the
     * document, but the CSP that was applied to this document load.
     */
    csp: (nsIContentSecurityPolicy | null);

    /**
     * Get/set data associated with this history state via a pushState() call,
     * serialized using structured clone.
     **/
    stateData: (nsIStructuredCloneContainer | null);

    /**
     * True if this SHEntry corresponds to a document created by a srcdoc
     * iframe. Set when a value is assigned to srcdocData.
     */
    readonly isSrcdocEntry: boolean;

    /**
     * Contents of the srcdoc attribute in a srcdoc iframe to be loaded instead
     * of the URI.  Similar to a Data URI, this information is needed to
     * recreate the document at a later stage.
     * Setting this sets isSrcdocEntry to true
     */
    srcdocData: IDLAString;

    /**
     * When isSrcdocEntry is true, this contains the baseURI of the srcdoc
     * document for use in situations where it cannot otherwise be determined,
     * for example with view-source.
     */
    baseURI: (nsIURI | null);

    /**
     * Sets/gets the current scroll restoration state,
     * if true == "manual", false == "auto".
     */
    scrollRestorationIsManual: boolean;

    /**
     * Flag to indicate that the history entry was originally loaded in the
     * current process. This flag does not survive a browser process switch.
     */
    readonly loadedInThisProcess: boolean;

    /**
     * The session history it belongs to.
     */
    readonly shistory: (nsISHistory | null);

    /**
     * The current number of nsISHEntries which are immediate children of this
     * SHEntry.
     */
    readonly childCount: number;

    /**
     * When an entry is serving is within nsISHistory's array of entries, this
     * property specifies if it should persist. If not it will be replaced by
     * new additions to the list.
     */
    persist: boolean;

    /**
     * Set/Get the visual viewport scroll position if session history is
     * changed through anchor navigation or pushState.
     */
    readonly setScrollPosition: (x: number, y: number) => void;

    readonly getScrollPosition: (x: Out<number>, y: Out<number>) => void;

    /**
     * Initialises `layoutHistoryState` if it doesn't already exist
     * and returns a reference to it.
     */
    readonly initLayoutHistoryState: () => (nsILayoutHistoryState | null);

    readonly clone: () => (nsISHEntry | null);

    /**
     * Returns true if any of the child entries returns true
     * when isDynamicallyAdded is called on it.
     */
    readonly hasDynamicallyAddedChild: () => boolean;

    /**
     * Adopt aEntry's BFCacheEntry, so now both this and aEntry point to
     * aEntry's BFCacheEntry.
     */
    readonly adoptBFCacheEntry: (aEntry: (nsISHEntry | null)) => void;

    /**
     * Create a new BFCache entry and drop our reference to our old one. This
     * call unlinks this SHEntry from any other SHEntries for its document.
     */
    readonly abandonBFCacheEntry: () => void;

    /**
     * Does this SHEntry correspond to the same document as aEntry? This is
     * true iff the two SHEntries have the same BFCacheEntry. So in particular,
     * sharesDocumentWith(aEntry) is guaranteed to return true if it's
     * preceded by a call to adoptBFCacheEntry(aEntry).
     */
    readonly sharesDocumentWith: (aEntry: (nsISHEntry | null)) => boolean;

    /**
     * Sets an SHEntry to reflect that it is a history type load. As
     * nsIDocShellLoadInfo and its LoadType enum were removed, this is the
     * equivalent to doing
     *
     * shEntry.loadType = 4;
     *
     * in js, but easier to maintain and less opaque.
     */
    readonly setLoadTypeAsHistory: () => void;

    /**
     * Add a new child SHEntry. If offset is -1 adds to the end of the list.
     */
    readonly AddChild: (aChild: (nsISHEntry | null), aOffset: number, aUseRemoteSubframes?: boolean) => void;

    /**
     * Get child at an index.
     */
    readonly GetChildAt: (aIndex: number) => (nsISHEntry | null);

    readonly bfcacheID: number;

    /**
     * synchronizeLayoutHistoryState() can be used to synchronize
     * layoutHistoryState object to the parent process in case session history
     * lives there. With in-process session history this method is no-op.
     */
    readonly synchronizeLayoutHistoryState: () => void;
  }

  export interface nsIPresentationRespondingListenerRef {
    readonly name: "nsIPresentationRespondingListener";
    readonly number: "{27f101d7-9ed1-429e-b4f8-43b00e8e111c}";
  }

  export interface nsIPresentationRespondingListener extends nsISupports {

    readonly notifySessionConnect: (windowId: number, sessionId: IDLAString) => void;
  }

  export interface nsIKeyValueVariantCallbackRef {
    readonly name: "nsIKeyValueVariantCallback";
    readonly number: "{174ebfa1-74ea-42a7-aa90-85bbaf1da4bf}";
  }

  export interface nsIKeyValueVariantCallback extends nsISupports {

    /**
     * A callback for the nsIKeyValueDatabase.has() and .get() methods.
     *
     * The result is an nsIVariant, which is always a boolean for the has() method
     * and can be any supported data type for the get() method.
     */
    readonly resolve: (result: (nsIVariant | null)) => void;

    readonly reject: (message: IDLAUTF8String) => void;
  }

  /**
   * Unfortunately we can not query the ReferrerPolicy values defined within
   * ReferrerPolicy.webidl directly from xpidl. Hence we define the enum value
   * ReferrerPolicyIDL to set up the ReferrerInfo object from JS. If you need
   * ReferrerPolicy in native code, please directly query it from
   * ReferrerPolicy.webidl.
   */
  export enum nsIReferrerInfo_ReferrerPolicyIDL {
    EMPTY = 0,
    NO_REFERRER_WHEN_DOWNGRADE = 1,
    NO_REFERRER = 2,
    ORIGIN = 3,
    ORIGIN_WHEN_CROSS_ORIGIN = 4,
    UNSAFE_URL = 5,
    SAME_ORIGIN = 6,
    STRICT_ORIGIN = 7,
    STRICT_ORIGIN_WHEN_CROSS_ORIGIN = 8,
  }

  export interface nsIReferrerInfoRef {
    readonly name: "nsIReferrerInfo";
    readonly number: "{081cdc36-f2e2-4f94-87bf-78578f06f1eb}";

    EMPTY: 0;
    NO_REFERRER_WHEN_DOWNGRADE: 1;
    NO_REFERRER: 2;
    ORIGIN: 3;
    ORIGIN_WHEN_CROSS_ORIGIN: 4;
    UNSAFE_URL: 5;
    SAME_ORIGIN: 6;
    STRICT_ORIGIN: 7;
    STRICT_ORIGIN_WHEN_CROSS_ORIGIN: 8;
  }

  export interface nsIReferrerInfo extends nsISerializable {

    /**
     * The original referrer URI which indicates the full referrer before applying
     * referrer policy
     */
    readonly originalReferrer: (nsIURI | null);

    /**
     * Referrer policy which is applied to the referrer
     */
    readonly referrerPolicy: nsIReferrerInfo_ReferrerPolicyIDL;

    /**
     * Get referrer policy as string
     */
    readonly getReferrerPolicyString: () => IDLACString;

    /**
     * Indicates if the referrer should not be sent or not even when it's available.
     */
    readonly sendReferrer: boolean;

    /**
     * Indicates if the referrer should not be sent or not even when it's available.
     */
    readonly computedReferrerSpec: IDLAString;

    /**
     * Returns whether the other referrerInfo is equivalent to this referrerInfo.
     */
    readonly equals: (other: (nsIReferrerInfo | null)) => boolean;

    /**
     * Initialize method to create ReferrerInfo object from JS
     * @param aReferrerPolicy referrer policy of the created object
     * @param aSendReferrer sendReferrer of the created object, defaults to false
     * @param aOriginalReferrer the original referrer, defaults to null.
     */
    readonly init: (aReferrerPolicy: nsIReferrerInfo_ReferrerPolicyIDL, aSendReferrer?: boolean, aOriginalReferrer?: (nsIURI | null)) => void;

    /**
     * Initialize with a given document.
     * @param aDocument the document to init referrerInfo object
     */
    readonly initWithDocument: (aDocument: WebIDL.Document) => void;

    /**
     * Initialize with a given node. It you are working with node which supports
     * referrerpolicy attribute: <a>, <img>, <area>, <script>, <iframe>, please
     * try to use this init instead of initWithDocument, because referrer policy
     * from rel and attribute has a higher priority.
     * @param aNode the element to init referrerInfo object
     */
    readonly initWithNode: (aNode: WebIDL.Node) => void;
  }

  export interface mozIGCTelemetryRef {
    readonly name: "mozIGCTelemetry";
    readonly number: "{6ab1c3c1-31cf-4a32-8484-97b5ef0627af}";
  }

  export interface mozIGCTelemetry extends nsISupports {

    readonly init: () => void;

    readonly shutdown: () => void;
  }

  export interface nsIProxiedProtocolHandlerRef {
    readonly name: "nsIProxiedProtocolHandler";
    readonly number: "{3756047a-fa2b-4b45-9948-3b5f8fc375e7}";
  }

  export interface nsIProxiedProtocolHandler extends nsIProtocolHandler {

    /** Create a new channel with the given proxyInfo
     *
     * @param uri the channel uri
     * @param proxyInfo any proxy information that has already been determined,
     *        or null if channel should later determine the proxy on its own using
     *        proxyResolveFlags/proxyURI
     * @param proxyResolveFlags used if the proxy is later determined
     *        from nsIProtocolProxyService::asyncResolve
     * @param proxyURI used if the proxy is later determined from
     *        nsIProtocolProxyService::asyncResolve with this as the proxyURI name.
     *        Generally this is the same as uri (or null which has the same
     *        effect), except in the case of websockets which wants to bootstrap
     *        to an http:// channel but make its proxy determination based on
     *        a ws:// uri.
     * @param aLoadInfo used to evaluate who initated the resource request.
     */
    readonly newProxiedChannel: (uri: (nsIURI | null), proxyInfo: (nsIProxyInfo | null), proxyResolveFlags: number, proxyURI: (nsIURI | null), aLoadInfo: (nsILoadInfo | null)) => (nsIChannel | null);
  }

  export interface nsIPresentationSessionTransportCallbackRef {
    readonly name: "nsIPresentationSessionTransportCallback";
    readonly number: "{9f158786-41a6-4a10-b29b-9497f25d4b67}";
  }

  export interface nsIPresentationSessionTransportCallback extends nsISupports {

    readonly notifyTransportReady: () => void;

    readonly notifyTransportClosed: (reason: number) => void;

    readonly notifyData: (data: IDLACString, isBinary: boolean) => void;
  }

  export interface nsILoginAutoCompleteSearchRef {
    readonly name: "nsILoginAutoCompleteSearch";
    readonly number: "{2bdac17c-53f1-4896-a521-682ccdeef3a8}";
  }

  export interface nsILoginAutoCompleteSearch extends nsISupports {

    /**
     * Stop a previously-started search.
     */
    readonly stopSearch: () => void;
  }

  export interface nsIPushNotifierRef {
    readonly name: "nsIPushNotifier";
    readonly number: "{b00dfdeb-14e5-425b-adc7-b531442e3216}";
  }

  /**
   * Fires XPCOM observer notifications and service worker events for
   * messages sent to push subscriptions.
   */
  export interface nsIPushNotifier extends nsISupports {

    /**
     * Fires a `push-message` observer notification, and sends a `push` event to
     * the service worker registered for the |scope|. |messageId| is an opaque ID
     * used to report errors if the worker fails to handle the message.
     */
    readonly notifyPush: (scope: IDLACString, principal: (nsIPrincipal | null), messageId: IDLAString) => void;

    /**
     * Same as `notifyPush`, except the subject of the observer notification
     * receives an `nsIPushMessage` instance containing the |data|. Service
     * workers can access the |data| via the `PushMessageData` WebIDL interface.
     */
    readonly notifyPushWithData: (scope: IDLACString, principal: (nsIPrincipal | null), messageId: IDLAString, data: number[]) => void;

    /**
     * Fires a `push-subscription-change` observer notification, and sends a
     * `pushsubscriptionchange` event to the service worker registered for the
     * |scope|.
     */
    readonly notifySubscriptionChange: (scope: IDLACString, principal: (nsIPrincipal | null)) => void;

    /**
     * Fires a `push-subscription-modified` observer notification. Chrome code
     * can listen for this notification to see when a subscription is added,
     * updated, removed, or expired for any |scope|.
     *
     * This is useful for Dev Tools and debugging add-ons that passively observe
     * when subscriptions are created or dropped. Other callers should listen for
     * `push-subscription-change` and resubscribe instead.
     */
    readonly notifySubscriptionModified: (scope: IDLACString, principal: (nsIPrincipal | null)) => void;

    readonly notifyError: (scope: IDLACString, principal: (nsIPrincipal | null), message: IDLAString, flags: number) => void;
  }

  export interface nsITextInputProcessorRef {
    readonly name: "nsITextInputProcessor";
    readonly number: "{47ae2181-2e98-4d58-84a2-b8db6764ce9a}";

    ATTR_RAW_CLAUSE: 2;

    ATTR_SELECTED_RAW_CLAUSE: 3;

    ATTR_CONVERTED_CLAUSE: 4;

    ATTR_SELECTED_CLAUSE: 5;

    KEY_DEFAULT_PREVENTED: 1;

    KEY_NON_PRINTABLE_KEY: 2;

    KEY_FORCE_PRINTABLE_KEY: 4;

    KEY_KEEP_KEY_LOCATION_STANDARD: 8;

    KEY_KEEP_KEYCODE_ZERO: 16;

    KEY_DONT_DISPATCH_MODIFIER_KEY_EVENT: 32;

    KEY_DONT_MARK_KEYDOWN_AS_PROCESSED: 64;

    KEY_MARK_KEYUP_AS_PROCESSED: 128;

    KEYEVENT_NOT_CONSUMED: 0;

    KEYDOWN_IS_CONSUMED: 1;

    KEYPRESS_IS_CONSUMED: 2;
  }

  /**
   * An nsITextInputProcessor instance is associated with a top level widget which
   * handles native IME.  It's associated by calling beginInputTransaction() or
   * beginInputTransactionForTests().  While an instance has composition, nobody
   * can steal the rights to make composition on the top level widget.  In other
   * words, if another instance is composing on a top level widget, either
   * beginInputTransaction() or beginInputTransactionForTests() returns false
   * (i.e., not throws an exception).
   *
   * NOTE: See nsITextInputProcessorCallback.idl for examples of |callback| in
   *       following examples,
   *
   * Example #1 JS-IME can start composition like this:
   *
   *   var TIP = Components.classes["@mozilla.org/text-input-processor;1"].
   *               createInstance(Components.interfaces.nsITextInputProcessor);
   *   if (!TIP.beginInputTransaction(window, callback)) {
   *     return; // You failed to get the rights to make composition
   *   }
   *   // Create a keyboard event if the following compositionc change is caused
   *   // by a key event.
   *   var keyEvent =
   *     new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
   *   // Set new composition string first
   *   TIP.setPendingCompositionString("some-words-are-inputted");
   *   // Set clause information.
   *   TIP.appendClauseToPendingComposition(23, TIP.ATTR_RAW_CLAUSE);
   *   // Set caret position, this is optional.
   *   TIP.setCaretInPendingComposition(23);
   *   // Flush the pending composition
   *   if (!TIP.flushPendingComposition(keyEvent)) {
   *     // If it returns false, it fails to start composition.
   *     return;
   *   }
   *
   * Example #2 JS-IME can separate composition string to two or more clauses:
   *
   *   // Create a keyboard event if the following compositionc change is caused
   *   // by a key event.
   *   var keyEvent =
   *     new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
   *   // First, set composition string again
   *   TIP.setPendingCompositionString("some-words-are-inputted");
   *   // Then, if "are" is selected to convert, there are 3 clauses:
   *   TIP.appendClauseToPendingComposition(11, TIP.ATTR_CONVERTED_CLAUSE);
   *   TIP.appendClauseToPendingComposition(3,  TIP.ATTR_SELECTED_CLAUSE);
   *   TIP.appendClauseToPendingComposition(9,  TIP.ATTR_CONVERTED_CLAUSE);
   *   // Show caret at the beginning of the selected clause
   *   TIP.setCaretInPendingComposition(11);
   *   // Flush the pending composition.  Note that if there is a composition,
   *   // flushPendingComposition() won't return false.
   *   TIP.flushPendingComposition(keyEvent);
   *
   * Example #3 JS-IME can commit composition with specific string with this:
   *
   *   // Create a keyboard event if the following compositionc change is caused
   *   // by a key event.
   *   var keyEvent1 =
   *     new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
   *   // First, there is a composition.
   *   TIP.setPendingCompositionString("some-words-directly-inputted");
   *   TIP.appendClauseToPendingComposition(28, TIP.ATTR_RAW_CLAUSE);
   *   TIP.flushPendingComposition(keyEvent1);
   *   // Create a keyboard event if the following commit composition is caused
   *   // by a key event.
   *   var keyEvent2 =
   *     new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
   *   // This is useful when user selects a commit string from candidate list UI
   *   // which is provided by JS-IME.
   *   TIP.commitCompositionWith("selected-words-from-candidate-list", keyEvent2);
   *
   * Example #4 JS-IME can commit composition with the last composition string
   *            without specifying commit string:
   *
   *   // Create a keyboard event if the following compositionc change is caused
   *   // by a key event.
   *   var keyEvent1 =
   *     new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
   *   // First, there is a composition.
   *   TIP.setPendingCompositionString("some-words-will-be-commited");
   *   TIP.appendClauseToPendingComposition(27, TIP.ATTR_RAW_CLAUSE);
   *   TIP.flushPendingComposition(keyEvent1);
   *   // Create a keyboard event if the following commit is caused by a key
   *   // event.
   *   var keyEvent2 =
   *     new KeyboardEvent("", { key: "Enter", code: "Enter",
                                 keyCode: KeyboardEvent.DOM_VK_RETURN });
   *   // This is useful when user just type Enter key.
   *   TIP.commitComposition(keyEvent2);
   *
   * Example #5 JS-IME can cancel composition with this:
   *
   *   // Create a keyboard event if the following composition change is caused
   *   // by a key event.
   *   var keyEvent1 =
   *     new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
   *   // First, there is a composition.
   *   TIP.setPendingCompositionString("some-words-will-be-canceled");
   *   TIP.appendClauseToPendingComposition(27, TIP.ATTR_RAW_CLAUSE);
   *   TIP.flushPendingComposition(keyEvent1);
   *   // Create a keyboard event if the following canceling composition is
   *   // caused by a key event.
   *   var keyEvent2 =
   *     new KeyboardEvent("", { key: "Escape", code: "Escape",
                                 keyCode: KeyboardEvent.DOM_VK_ESCAPE });
   *   // This is useful when user doesn't want to commit the composition.
   *   // FYI: This is same as TIP.commitCompositionWith("") for now.
   *   TIP.cancelComposition(keyEvent2);
   *
   * Example #6 JS-IME can insert text only with commitCompositionWith():
   *
   *   // Create a keyboard event if the following inserting text is caused by a
   *   // key event.
   *   var keyEvent1 =
   *     new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
   *   if (!TIP.beginInputTransaction(window, callback)) {
   *     return; // You failed to get the rights to make composition
   *   }
   *   TIP.commitCompositionWith("Some words", keyEvent1);
   *
   * Example #7 JS-IME can start composition explicitly:
   *
   *   if (!TIP.beginInputTransaction(window, callback)) {
   *     return; // You failed to get the rights to make composition
   *   }
   *   // Create a keyboard event if the following starting composition is caused
   *   // by a key event.
   *   var keyEvent1 =
   *     new KeyboardEvent("", { key: "foo", code: "bar", keyCode: buzz });
   *   // If JS-IME don't want to show composing string in the focused editor,
   *   // JS-IME can dispatch only compositionstart event with this.
   *   if (!TIP.startComposition(keyEvent1)) {
   *     // Failed to start composition.
   *     return;
   *   }
   *   // And when user selects a result from UI of JS-IME, commit with it.
   *   // Then, the key event should be null.
   *   TIP.commitCompositionWith("selected-words");
   *
   * Example #8 JS-IME or JS-Keyboard should dispatch key events even during
   *            composition (non-printable key case):
   *
   *   if (!TIP.beginInputTransaction(window, callback)) {
   *     return; // You failed to get the rights to dispatch key events
   *   }
   *
   *   // You don't need to specify .keyCode value if it's non-printable key
   *   // because it can be computed from .key value.
   *   // If you specify non-zero value to .keyCode, it'll be used.
   *   var keyEvent = new KeyboardEvent("", { code: "Enter", key: "Enter" });
   *   if (TIP.keydown(keyEvent)) {
   *     // Handle its default action
   *   }
   *
   *   // Even if keydown event was consumed, keyup event should be dispatched.
   *   if (TIP.keyup(keyEvent)) {
   *     // Handle its default action
   *   }
   *
   * Example #9 JS-IME or JS-Keyboard should dispatch key events even during
   *            composition (printable key case):
   *
   *   if (!TIP.beginInputTransaction(window, callback)) {
   *     return; // You failed to get the rights to dispatch key events
   *   }
   *
   *   // You need to specify .keyCode value if it's printable key.
   *   // The rules of .keyCode value is documented in MDN:
   *   //   https://developer.mozilla.org/docs/Web/API/KeyboardEvent.keyCode
   *   //
   *   //   #1 If the key location is DOM_KEY_LOCATION_NUMPAD and NumLock is
   *   //      active, you should specify DOM_VK_NUMPAD[0-9], DOM_VK_MULTIPLY,
   *   //      DOM_VK_ADD, DOM_VK_SEPARATOR, DOM_VK_SUBTRACT, DOM_VK_DECIMAL or
   *   //      DOM_VK_DIVIDE.
   *   //   #2 If the key is Spacebar, use DOM_VK_SPACE.
   *   //
   *   //   Following rules are printable keys in DOM_KEY_LOCATION_STANDARD.
   *   //   .keyCode value for a key shouldn't be changed by modifier states:
   *   //     #1 If the key can input [0-9] with any modifier state (except
   *   //        NumLock state), the value should be DOM_VK_[0-9].
   *   //     #2 Otherwise, and if the key inputs an ASCII alphabet with no
   *   //        active modifiers, use DOM_VK_[A-Z].
   *   //     #3 Otherwise, and if the key inputs an ASCII alphabet with no
   *   //        active modifiers except Shift key state, use DOM_VK_[A-Z] for
   *   //        the shifted character.  E.g., if a key causes non-alphabet
   *   //        character such as "@" or a Unicode character without Shift key
   *   //        but "a" is inputted when Shift key is pressed, the proper
   *   //        keyCode is DOM_VK_A.
   *   //     #4 Otherwise, and if the key inputs another ASCII character with
   *   //        no modifier states, use a proper value for the character.  E.g.,
   *   //        if the key inputs "*" without Shift key state, it should be
   *   //        DOM_VK_ASTERISK.
   *   //     #5 Otherwise, and if the key inputs another ASCII character with
   *   //        Shift key state, use a proper value for the character.  E.g.,
   *   //        if a key causes a Unicode character without Shift key but "&"
   *   //        is inputted when Shift key is pressed, the proper keyCode is
   *   //        DOM_VK_AMPERSAND.
   *   //     See above document for the other cases.
   *   //
   *   // NOTE: If the software keyboard is 10-key like simple phone,
   *   //       We don't have common rules to decide its .keyCode value.
   *   //       Above rules should be used when the JS-Keyboard emulates PC
   *   //       keyboard.
   *   // .key value should be inputting character by the key with current
   *   // modifier state.
   *   // .code value should be empty string if the JS-Keyboard isn't emulating
   *   // physical keyboard.  Otherwise, use same value with physical keyboard's
   *   // same key.
   *   var keyEvent = new KeyboardEvent("", { code: "KeyA", key: "a",
   *                                          keyCode: KeyboardEvent.DOM_VK_A });
   *   if (TIP.keydown(keyEvent)) {
   *     // Handle its default action
   *   }
   *
   *   // Even if keydown event was consumed, keyup event should be dispatched.
   *   if (TIP.keyup(keyEvent)) {
   *     // Handle its default action
   *   }
   *
   * Example #10 JS-Keyboard doesn't need to initialize modifier states at
   *             calling either keydown() or keyup().
   *
   *   // Neither beginInputTransaction() nor beginInputTransactionForTests()
   *   // resets modifier state.
   *   if (!TIP.beginInputTransaction(window, callback)) {
   *     return; // You failed to get the rights to dispatch key events
   *   }
   *
   *   var leftShift = new KeyboardEvent("", { code: "ShiftLeft", key: "Shift" });
   *
   *   // This causes following key events will be shifted automatically.
   *   TIP.keydown(leftShift);
   *
   *   var rightShift =
   *     new KeyboardEvent("", { code: "ShiftRight", key: "Shift" });
   *
   *   TIP.keydown(rightShift);
   *
   *   // keyup of one of shift key doesn't cause inactivating "Shift" state.
   *   TIP.keyup(rightShift);
   *
   *   // This causes inactivating "Shift" state completely.
   *   TIP.keyup(leftShift);
   */
  export interface nsITextInputProcessor extends nsISupports {

    /**
     * Returns true if this instance was dispatched compositionstart but hasn't
     * dispatched compositionend yet.
     */
    readonly hasComposition: boolean;

    /**
     * When you create an instance, you must call beginInputTransaction() first
     * except when you created the instance for automated tests.
     *
     * @param aWindow         A DOM window.  The instance will look for a top
     *                        level widget from this.
     * @param aCallback       Callback interface which handles requests to
     *                        IME and notifications to IME.  This must not be
     *                        null.
     * @return                If somebody uses internal text input service for a
     *                        composition, this returns false.  Otherwise, returns
     *                        true.  I.e., only your TIP can create composition
     *                        when this returns true.  If this returns false,
     *                        your TIP should wait next chance.
     */
    readonly beginInputTransaction: (aWindow: (mozIDOMWindow | null), aCallback: (nsITextInputProcessorCallback | nsITextInputProcessorCallbackFunction | null)) => boolean;

    /**
     * When you create an instance for automated test, you must call
     * beginInputTransaction(), first.  See beginInputTransaction() for more
     * detail of this.
     * Note that aCallback can be null.  If it's null, nsITextInputProcessor
     * implementation will handle them automatically.
     */
    readonly beginInputTransactionForTests: (aWindow: (mozIDOMWindow | null), aCallback?: (nsITextInputProcessorCallback | nsITextInputProcessorCallbackFunction | null)) => boolean;

    /**
     * startComposition() dispatches compositionstart event explicitly.
     * IME does NOT need to call this typically since compositionstart event
     * is automatically dispatched by sendPendingComposition() if
     * compositionstart event hasn't been dispatched yet.  If this is called
     * when compositionstart has already been dispatched, this throws an
     * exception.
     *
     * @param aKeyboardEvent  Key event which causes starting composition.
     *                        If its type value is "keydown", this method
     *                        dispatches only keydown event first.  Otherwise,
     *                        dispatches keydown first and keyup at last.
     *                        key value and keyCode values of keydown event
     *                        are set to "Process" and DOM_VK_PROCESSKEY
     *                        automatically.  You can prevent this behavior
     *                        with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     * @return                Returns true if composition starts normally.
     *                        Otherwise, returns false because it might be
     *                        canceled by the web application.
     */
    readonly startComposition: (aKeyboardEvent?: WebIDL.Event, aKeyFlags?: number) => boolean;

    /**
     * Set new composition string.  Pending composition will be flushed by
     * a call of flushPendingComposition().  However, if the new composition
     * string isn't empty, you need to call appendClauseToPendingComposition() to
     * fill all characters of aString with one or more clauses before flushing.
     * Note that if you need to commit or cancel composition, use
     * commitComposition(), commitCompositionWith() or cancelComposition().
     */
    readonly setPendingCompositionString: (aString: IDLAString) => void;

    /**
     * Append a clause to the pending composition.
     *
     * If you need to fill the pending composition string with a clause, you
     * should call this once.  For example:
     *   appendClauseToPendingComposition(compositionString.length,
     *                                    ATTR_RAW_CLAUSE);
     * is enough.  If you need to separate the pending composition string to
     * multiple clauses, you need to call this multiple times. For example,
     * if your pending composition string has three clauses and the second clause
     * is being converted:
     *  appendClauseToPendingComposition(firstClauseLength,
     *                                   ATTR_CONVERTED_CLAUSE);
     *  appendClauseToPendingComposition(secondClauseLength,
     *                                   ATTR_SELECTED_CLAUSE);
     *  appendClauseToPendingComposition(thirdClauseLength,
     *                                   ATTR_CONVERTED_CLAUSE);
     * Note that if sum of aLength mismatches length of the pending composition
     * string, flushPendingComposition() will throw an exception.  I.e.,
     * |firstClauseLength + secondClauseLength + thirdClauseLength| must be
     * same as the length of pending composition string.
     *
     * TODO: Should be able to specify custom clause style.
     *
     * @param aLength         Length of the clause.
     * @param aAttribute      One of ATTR_* constants.
     */
    readonly appendClauseToPendingComposition: (aLength: number, aAttribute: number) => void;

    /**
     * Set caret offset in the pending composition string.  If you don't need to
     * show a caret, you don't need to call this.
     *
     * @param aOffset         Caret offset in the pending composition string.
     *                        This must be between 0 and length of the pending
     *                        composition string.
     */
    readonly setCaretInPendingComposition: (aOffset: number) => void;

    /**
     * flushPendingComposition() must be called after
     * setPendingCompositionString() and appendClauseToPendingComposition()
     * (setCaretInPendingComposition() is optional) are called.
     *
     * Note that compositionstart will be automatically dispatched if this is
     * called when there is no composition.
     *
     * Note that if sum of lengths of appended clauses are not same as composition
     * string or caret offset is larger than the composition string length, this
     * throws an exception.
     *
     * @param aKeyboardEvent  Key event which causes the composition string.
     *                        If its type value is "keydown", this method
     *                        dispatches only keydown event first.  Otherwise,
     *                        dispatches keydown first and keyup at last.
     *                        key value and keyCode values of keydown event
     *                        are set to "Process" and DOM_VK_PROCESSKEY
     *                        automatically.  You can prevent this behavior
     *                        with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     * @return                Returns true if there is a composition already or
     *                        starting composition automatically.
     *                        Otherwise, i.e., if it cannot start composition
     *                        automatically, e.g., canceled by web apps, returns
     *                        false.
     */
    readonly flushPendingComposition: (aKeyboardEvent?: WebIDL.Event, aKeyFlags?: number) => boolean;

    /**
     * commitComposition() will commit composition with the last composition
     * string.  If there is no composition, this will throw an exception.
     *
     * @param aKeyboardEvent  Key event which causes the commit composition.
     *                        If its type value is "keydown", this method
     *                        dispatches only keydown event first.  Otherwise,
     *                        dispatches keydown first and keyup at last.
     *                        key value and keyCode values of keydown event
     *                        are set to "Process" and DOM_VK_PROCESSKEY
     *                        automatically.  You can prevent this behavior
     *                        with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     */
    readonly commitComposition: (aKeyboardEvent?: WebIDL.Event, aKeyFlags?: number) => void;

    /**
     * commitCompositionWith() will commit composition with the specific string.
     * If there is no composition, this will start composition and commit it
     * with the specified string.
     *
     * @param aCommitString   The string to be committed.
     * @param aKeyboardEvent  Key event which causes the commit composition.
     *                        If its type value is "keydown", this method
     *                        dispatches only keydown event first.  Otherwise,
     *                        dispatches keydown first and keyup at last.
     *                        key value and keyCode values of keydown event
     *                        are set to "Process" and DOM_VK_PROCESSKEY
     *                        automatically.  You can prevent this behavior
     *                        with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     * @return                Returns true if there is a composition already or
     *                        starting composition automatically.
     *                        Otherwise, i.e., if it cannot start composition
     *                        automatically, e.g., canceled by web apps, returns
     *                        false.
     */
    readonly commitCompositionWith: (aCommitString: IDLAString, aKeyboardEvent?: WebIDL.Event, aKeyFlags?: number) => boolean;

    /**
     * cancelComposition() will cancel composition.  This is for now the same as
     * calling commitComposition("").  However, in the future, this might work
     * better.  If your IME needs to cancel composition, use this instead of
     * commitComposition().
     *
     * Note that if you tries to cancel composition when there is no composition,
     * this throws an exception.
     *
     * @param aKeyboardEvent  Key event which causes the canceling composition.
     *                        If its type value is "keydown", this method
     *                        dispatches only keydown event first.  Otherwise,
     *                        dispatches keydown first and keyup at last.
     *                        key value and keyCode values of keydown event
     *                        are set to "Process" and DOM_VK_PROCESSKEY
     *                        automatically.  You can prevent this behavior
     *                        with KEY_DONT_MARK_KEYDOWN_AS_PROCESSED.
     * @param aKeyFlags       See KEY_* constants.
     */
    readonly cancelComposition: (aKeyboardEvent?: WebIDL.Event, aKeyFlags?: number) => void;

    /**
     * keydown() may dispatch a keydown event and some keypress events if
     * preceding keydown event isn't consumed and they are necessary.
     * Note that even if this is called during composition, key events may not
     * be dispatched.  In this case, this returns false.
     *
     * You should initialize at least .key value and .code value of the event.
     * Additionally, if you try to emulate a printable key, .keyCode value should
     * be specified if there is proper key value.  See the comment of above
     * example how to decide .keyCode value of a printable key.  On the other
     * hand, .keyCode value is automatically computed when you try to emulate
     * non-printable key.  However, if you try to emulate physical keyboard of
     * desktop platform, you need to specify proper value explicitly because
     * the mapping table of this API isn't enough to emulate the behavior of
     * Gecko for desktop platforms.
     *
     * NOTE: Even if this has composition, JS-Keyboard should call keydown() and
     *       keyup().  Although, with the default preferences and normal
     *       conditions, DOM key events won't be fired during composition.
     *       However, they MAY be dispatched for some reasons, e.g., the web
     *       content listens only key events, or if the standard DOM event spec
     *       will be changed in the future.
     *
     * @param aKeyboardEvent  Must be a keyboard event which should be dispatched
     *                        as a keydown event and keypress events.
     *                        #1 Note that you don't need to set charCode value
     *                        because it's computed from its key value.
     *                        #2 If code value is set properly and location value
     *                        isn't specified (i.e., 0), the location value will
     *                        be guessed from the code value.
     *                        #3 Non-defined code names are not allowed. If your
     *                        key isn't registered, file a bug. If your key isn't
     *                        defined by any standards, use "" (empty string).
     *                        #4 .keyCode is guessed from .key value if the key
     *                        name is registered and .keyCode isn't initialized.
     *                        #5 modifier key states, e.g., .shiftKey, are
     *                        ignored.  Instead, modifier states are managed by
     *                        each instance and set automatically.
     * @param aKeyFlags       Special flags.  The values can be some of KEY_*
     *                        constants.
     * @return                KEYEVENT_NOT_CONSUMED, if the keydown event nor
     *                        the following keypress event(s) are consumed.
     *                        KEYDOWN_IS_CONSUMED, if the keydown event is
     *                        consumed. No keypress event will be dispatched in
     *                        this case.
     *                        KEYPRESS_IS_CONSUMED, if the keypress event(s) is
     *                        consumed when dispatched.
     *                        Note that keypress event is always consumed by
     *                        native code for the printable keys (indicating the
     *                        default action has been taken).
     */
    readonly keydown: (aKeyboardEvent: WebIDL.Event, aKeyFlags?: number) => number;

    /**
     * Similar to keydown(), but this dispatches only a keyup event.
     */
    readonly keyup: (aKeyboardEvent: WebIDL.Event, aKeyFlags?: number) => boolean;

    /**
     * getModifierState() returns modifier state managed by this instance.
     *
     * @param aModifier       One of modifier key names.  This doesn't support
     *                        virtual modifiers like "Accel".
     * @return                true if the modifier key is active.  Otherwise,
     *                        false.
     */
    readonly getModifierState: (aModifierKey: IDLAString) => boolean;

    /**
     * shareModifierStateOf() makes the instance shares modifier state of
     * another instance.  When this is called, the instance refers the modifier
     * state of another instance.  After that, changes to either this and the
     * other instance's modifier state is synchronized.
     *
     * @param aOther          Another instance which will be referred by the
     *                        instance.  If this is null, the instance restarts
     *                        to manage modifier state independently.
     */
    readonly shareModifierStateOf: (aOther: (nsITextInputProcessor | null)) => void;

    /**
     * Helper method to get usual |.code| value of non-printable keys.
     *
     * @param aKeyValue       A predefined key value such as "Enter".
     *                        If this is not a proper non-printable key value
     *                        or a proper key value but not in usual keyboard of
     *                        the platform, this returns empty string.
     * @param aLocation       The |.location| value.  This is important if
     *                        the key may be in different location.
     *                        E.g., Left vs. Right or Standard vs. Numpad.
     *                        If this is undefined or null, it'll be treated
     *                        as Standard or Left.
     * @return                One of a code value of well-known key on usual
     *                        keyboard on the platform, or empty string.
     */
    readonly computeCodeValueOfNonPrintableKey: (aKeyValue: IDLAString, aLocation?: IDLjsval) => IDLAString;

    /**
     * Helper method to guess |.code| value of a printable key which is in usual
     * keyboard of the platform and when active keyboard layout is US-English.
     * Note that this is not aware of option key mapping on macOS.
     *
     * @param aKeyValue          The key value. Must be a character which can
     *                           be inputted with US-English keyboard layout.
     * @param aLocation          The location of the key.  This is important
     *                           to distinguish whether the key is in Standard
     *                           or Numpad. If this is undefined or null, will
     *                           be treated as Standard.
     * @return                   Returns empty string if there is no proper key.
     */
    readonly guessCodeValueOfPrintableKeyInUSEnglishKeyboardLayout: (aKeyValue: IDLAString, aLocation?: IDLjsval) => IDLAString;

    /**
     * Helper method to guess |.keyCode| value of a printable key which is in
     * usual keyboard of the platform and when active keyboard layout is
     * US-English.
     * Note that this is not aware of option key mapping on macOS.
     *
     * @param aKeyValue          The key value.  Must be a character which can
     *                           be inputted with US-English keyboard layout.
     * @param aLocation          The location of the key.  This is important
     *                           to distinguish whether the key is in Standard
     *                           our Numpad.  If this is undefined or null,
     *                           will be treated as Standard.
     * @return                   Returns 0 if there is no proper key to input
     *                           aKeyValue with US-English keyboard layout.
     */
    readonly guessKeyCodeValueOfPrintableKeyInUSEnglishKeyboardLayout: (aKeyValue: IDLAString, aLocation?: IDLjsval) => number;
  }

  export interface nsINavHistoryQueryOptionsRef {
    readonly name: "nsINavHistoryQueryOptions";
    readonly number: "{8198dfa7-8061-4766-95cb-fa86b3c00a47}";

    /**
     * This object represents the global options for executing a query.
     */
    /**
     * You can ask for the results to be pre-sorted. Since the DB has indices
     * of many items, it can produce sorted results almost for free. These should
     * be self-explanatory.
     *
     * Note: re-sorting is slower, as is sorting by title or when you have a
     * host name.
     *
     * For bookmark items, SORT_BY_NONE means sort by the natural bookmark order.
     */
    SORT_BY_NONE: 0;

    SORT_BY_TITLE_ASCENDING: 1;

    SORT_BY_TITLE_DESCENDING: 2;

    SORT_BY_DATE_ASCENDING: 3;

    SORT_BY_DATE_DESCENDING: 4;

    SORT_BY_URI_ASCENDING: 5;

    SORT_BY_URI_DESCENDING: 6;

    SORT_BY_VISITCOUNT_ASCENDING: 7;

    SORT_BY_VISITCOUNT_DESCENDING: 8;

    SORT_BY_DATEADDED_ASCENDING: 11;

    SORT_BY_DATEADDED_DESCENDING: 12;

    SORT_BY_LASTMODIFIED_ASCENDING: 13;

    SORT_BY_LASTMODIFIED_DESCENDING: 14;

    SORT_BY_TAGS_ASCENDING: 17;

    SORT_BY_TAGS_DESCENDING: 18;

    SORT_BY_FRECENCY_ASCENDING: 21;

    SORT_BY_FRECENCY_DESCENDING: 22;

    /**
     * "URI" results, one for each URI visited in the range. Individual result
     * nodes will be of type "URI".
     */
    RESULTS_AS_URI: 0;

    /**
     * "Visit" results, with one for each time a page was visited (this will
     * often give you multiple results for one URI). Individual result nodes will
     * have type "Visit"
     *
     * @note This result type is only supported by QUERY_TYPE_HISTORY.
     */
    RESULTS_AS_VISIT: 1;

    /**
     * This returns query nodes for each predefined date range where we
     * had visits. The node contains information how to load its content:
     * - visits for the given date range will be loaded.
     *
     * @note This result type is only supported by QUERY_TYPE_HISTORY.
     */
    RESULTS_AS_DATE_QUERY: 3;

    /**
     * This returns nsINavHistoryQueryResultNode nodes for each site where we
     * have visits. The node contains information how to load its content:
     * - last visit for each url in the given host will be loaded.
     *
     * @note This result type is only supported by QUERY_TYPE_HISTORY.
     */
    RESULTS_AS_SITE_QUERY: 4;

    /**
     * This returns nsINavHistoryQueryResultNode nodes for each day where we
     * have visits. The node contains information how to load its content:
     * - list of hosts visited in the given period will be loaded.
     *
     * @note This result type is only supported by QUERY_TYPE_HISTORY.
     */
    RESULTS_AS_DATE_SITE_QUERY: 5;

    /**
     * This returns nsINavHistoryQueryResultNode nodes for each tag.
     * The node contains information how to load its content:
     * - list of bookmarks with the given tag will be loaded.
     *
     * @note Setting this resultType will force queryType to QUERY_TYPE_BOOKMARKS.
     */
    RESULTS_AS_TAGS_ROOT: 6;

    /**
     * DEPRECATED: This exists for Sync and also to avoid reusing this number.
     */
    RESULTS_AS_TAG_CONTENTS: 7;

    /**
     * This returns nsINavHistoryQueryResultNode nodes for each top-level bookmark
     * root.
     *
     * @note Setting this resultType will force queryType to QUERY_TYPE_BOOKMARKS.
     */
    RESULTS_AS_ROOTS_QUERY: 8;

    /**
     * This returns nsINavHistoryQueryResultNode for each left-pane root.
     */
    RESULTS_AS_LEFT_PANE_QUERY: 9;

    QUERY_TYPE_HISTORY: 0;

    QUERY_TYPE_BOOKMARKS: 1;

    QUERY_TYPE_UNIFIED: 2;
  }

  export interface nsINavHistoryQueryOptions extends nsISupports {

    /**
     * The sorting mode to be used for this query.
     * mode is one of SORT_BY_*
     */
    sortingMode: number;

    /**
     * Sets the result type. One of RESULT_TYPE_* which includes how URIs are
     * represented.
     */
    resultType: number;

    /**
     * This option excludes all URIs and separators from a bookmarks query.
     * This would be used if you just wanted a list of bookmark folders and
     * queries (such as the left pane of the places page).
     * Defaults to false.
     */
    excludeItems: boolean;

    /**
     * Set to true to exclude queries ("place:" URIs) from the query results.
     * Simple folder queries (bookmark folder symlinks) will still be included.
     * Defaults to false.
     */
    excludeQueries: boolean;

    /**
     * When set, allows items with "place:" URIs to appear as containers,
     * with the container's contents filled in from the stored query.
     * If not set, these will appear as normal items. Doesn't do anything if
     * excludeQueries is set. Defaults to false.
     *
     * Note that this has no effect on folder links, which are place: URIs
     * returned by nsINavBookmarkService.GetFolderURI. These are always expanded
     * and will appear as bookmark folders.
     */
    expandQueries: boolean;

    /**
     * Some pages in history are marked "hidden" and thus don't appear by default
     * in queries.  These include automatic framed visits and redirects.  Setting
     * this attribute will return all pages, even hidden ones.  Does nothing for
     * bookmark queries. Defaults to false.
     */
    includeHidden: boolean;

    /**
     * This is the maximum number of results that you want. The query is executed,
     * the results are sorted, and then the top 'maxResults' results are taken
     * and returned. Set to 0 (the default) to get all results.
     *
     * THIS DOES NOT WORK IN CONJUNCTION WITH SORTING BY TITLE. This is because
     * sorting by title requires us to sort after using locale-sensetive sorting
     * (as opposed to letting the database do it for us).
     *
     * Instead, we get the result ordered by date, pick the maxResult most recent
     * ones, and THEN sort by title.
     */
    maxResults: number;

    /**
     * The type of search to use when querying the DB; This attribute is only
     * honored by query nodes. It is silently ignored for simple folder queries.
     */
    queryType: number;

    /**
     * When this is true, the root container node generated by these options and
     * its descendant containers will be opened asynchronously if they support it.
     * This is false by default.
     *
     * @note Currently only bookmark folder containers support being opened
     *       asynchronously.
     */
    asyncEnabled: boolean;

    /**
     * Creates a new options item with the same parameters of this one.
     */
    readonly clone: () => (nsINavHistoryQueryOptions | null);
  }

  export interface nsITransportRef {
    readonly name: "nsITransport";
    readonly number: "{2a8c6334-a5e6-4ec3-9865-1256541446fb}";

    /**
     * Open flags.
     */
    OPEN_BLOCKING: 1;

    OPEN_UNBUFFERED: 2;

    /**
     * Generic nsITransportEventSink status codes.  nsITransport
     * implementations may override these status codes with their own more
     * specific status codes (e.g., see nsISocketTransport).
     *
     * In C++, these constants have a type of uint32_t, so C++ callers must use
     * the NS_NET_STATUS_* constants defined below, which have a type of
     * nsresult.
     */
    STATUS_READING: 2152398856;

    STATUS_WRITING: 2152398857;
  }

  /**
   * nsITransport
   *
   * This interface provides a common way of accessing i/o streams connected
   * to some resource.  This interface does not in any way specify the resource.
   * It provides methods to open blocking or non-blocking, buffered or unbuffered
   * streams to the resource.  The name "transport" is meant to connote the
   * inherent data transfer implied by this interface (i.e., data is being
   * transfered in some fashion via the streams exposed by this interface).
   *
   * A transport can have an event sink associated with it.  The event sink
   * receives transport-specific events as the transfer is occuring.  For a
   * socket transport, these events can include status about the connection.
   * See nsISocketTransport for more info about socket transport specifics.
   */
  export interface nsITransport extends nsISupports {

    /**
     * Open an input stream on this transport.
     *
     * Flags have the following meaning:
     *
     * OPEN_BLOCKING
     *   If specified, then the resulting stream will have blocking stream
     *   semantics.  This means that if the stream has no data and is not
     *   closed, then reading from it will block the calling thread until
     *   at least one byte is available or until the stream is closed.
     *   If this flag is NOT specified, then the stream has non-blocking
     *   stream semantics.  This means that if the stream has no data and is
     *   not closed, then reading from it returns NS_BASE_STREAM_WOULD_BLOCK.
     *   In addition, in non-blocking mode, the stream is guaranteed to
     *   support nsIAsyncInputStream.  This interface allows the consumer of
     *   the stream to be notified when the stream can again be read.
     *
     * OPEN_UNBUFFERED
     *   If specified, the resulting stream may not support ReadSegments.
     *   ReadSegments is only gauranteed to be implemented when this flag is
     *   NOT specified.
     *
     * @param aFlags
     *        optional transport specific flags.
     * @param aSegmentSize
     *        if OPEN_UNBUFFERED is not set, then this parameter specifies the
     *        size of each buffer segment (pass 0 to use default value).
     * @param aSegmentCount
     *        if OPEN_UNBUFFERED is not set, then this parameter specifies the
     *        maximum number of buffer segments (pass 0 to use default value).
     */
    readonly openInputStream: (aFlags: number, aSegmentSize: number, aSegmentCount: number) => (nsIInputStream | null);

    /**
     * Open an output stream on this transport.
     *
     * Flags have the following meaning:
     *
     * OPEN_BLOCKING
     *   If specified, then the resulting stream will have blocking stream
     *   semantics.  This means that if the stream is full and is not closed,
     *   then writing to it will block the calling thread until ALL of the
     *   data can be written or until the stream is closed.  If this flag is
     *   NOT specified, then the stream has non-blocking stream semantics.
     *   This means that if the stream is full and is not closed, then writing
     *   to it returns NS_BASE_STREAM_WOULD_BLOCK.  In addition, in non-
     *   blocking mode, the stream is guaranteed to support
     *   nsIAsyncOutputStream.  This interface allows the consumer of the
     *   stream to be notified when the stream can again accept more data.
     *
     * OPEN_UNBUFFERED
     *   If specified, the resulting stream may not support WriteSegments and
     *   WriteFrom.  WriteSegments and WriteFrom are only guaranteed to be
     *   implemented when this flag is NOT specified.
     *
     * @param aFlags
     *        optional transport specific flags.
     * @param aSegmentSize
     *        if OPEN_UNBUFFERED is not set, then this parameter specifies the
     *        size of each buffer segment (pass 0 to use default value).
     * @param aSegmentCount
     *        if OPEN_UNBUFFERED is not set, then this parameter specifies the
     *        maximum number of buffer segments (pass 0 to use default value).
     */
    readonly openOutputStream: (aFlags: number, aSegmentSize: number, aSegmentCount: number) => (nsIOutputStream | null);

    /**
     * Close the transport and any open streams.
     *
     * @param aReason
     *        the reason for closing the stream.
     */
    readonly close: (aReason: number) => void;

    /**
     * Set the transport event sink.
     *
     * @param aSink
     *        receives transport layer notifications
     * @param aEventTarget
     *        indicates the event target to which the notifications should
     *        be delivered.  if NULL, then the notifications may occur on
     *        any thread.
     */
    readonly setEventSink: (aSink: (nsITransportEventSink | null), aEventTarget: (nsIEventTarget | null)) => void;
  }

  export interface nsIWebBrowserChromeRef {
    readonly name: "nsIWebBrowserChrome";
    readonly number: "{e8c414c4-dc38-4ba3-ab4e-ec4cbbe22907}";

    /**
     * Definitions for the chrome flags
     */
    CHROME_DEFAULT: 1;

    CHROME_WINDOW_BORDERS: 2;

    CHROME_WINDOW_CLOSE: 4;

    CHROME_WINDOW_RESIZE: 8;

    CHROME_MENUBAR: 16;

    CHROME_TOOLBAR: 32;

    CHROME_LOCATIONBAR: 64;

    CHROME_STATUSBAR: 128;

    CHROME_PERSONAL_TOOLBAR: 256;

    CHROME_SCROLLBARS: 512;

    CHROME_TITLEBAR: 1024;

    CHROME_EXTRA: 2048;

    CHROME_WITH_SIZE: 4096;

    CHROME_WITH_POSITION: 8192;

    CHROME_WINDOW_MIN: 16384;

    CHROME_WINDOW_POPUP: 32768;

    CHROME_PRIVATE_WINDOW: 65536;

    CHROME_NON_PRIVATE_WINDOW: 131072;

    CHROME_PRIVATE_LIFETIME: 262144;

    CHROME_ALWAYS_ON_TOP: 524288;

    CHROME_REMOTE_WINDOW: 1048576;

    CHROME_FISSION_WINDOW: 2097152;

    CHROME_SUPPRESS_ANIMATION: 16777216;

    CHROME_WINDOW_RAISED: 33554432;

    CHROME_WINDOW_LOWERED: 67108864;

    CHROME_CENTER_SCREEN: 134217728;

    CHROME_DEPENDENT: 268435456;

    CHROME_MODAL: 536870912;

    CHROME_OPENAS_DIALOG: 1073741824;

    CHROME_OPENAS_CHROME: 2147483648;

    CHROME_ALL: 4094;
  }

  /**
   * nsIWebBrowserChrome corresponds to the top-level, outermost window
   * containing an embedded Gecko web browser.
   */
  export interface nsIWebBrowserChrome extends nsISupports {

    /**
     * Called when the link hover status is being changed.
     * @param status status string. empty string is an acceptable value
     *               meaning no link is hovered.
     */
    readonly setLinkStatus: (status: IDLAString) => void;

    /**
     * The chrome flags for this browser chrome. The implementation should
     * reflect the value of this attribute by hiding or showing its chrome
     * appropriately.
     */
    chromeFlags: number;

    /**
     * Shows the window as a modal window.
     */
    readonly showAsModal: () => void;

    /**
     * Is the window modal (that is, currently executing a modal loop)?
     * @return true if it's a modal window
     */
    readonly isWindowModal: () => boolean;
  }

  export interface nsIOutputStreamCallbackRef {
    readonly name: "nsIOutputStreamCallback";
    readonly number: "{40dbcdff-9053-42c5-a57c-3ec910d0f148}";
  }

  type nsIOutputStreamCallbackFunction = (aStream: (nsIAsyncOutputStream | null)) => void;

  export interface nsIOutputStreamCallback extends nsISupports {

    /**
     * This is a companion interface for nsIAsyncOutputStream::asyncWait.
     */
    /**
     * Called to indicate that the stream is either writable or closed.
     *
     * @param aStream
     *        The stream whose asyncWait method was called.
     */
    readonly onOutputStreamReady: (aStream: (nsIAsyncOutputStream | null)) => void;
  }

  export interface nsIPresentationControlServerListenerRef {
    readonly name: "nsIPresentationControlServerListener";
    readonly number: "{09bddfaf-fcc2-4dc9-b33e-a509a1c2fb6d}";
  }

  export interface nsIPresentationControlServerListener extends nsISupports {

    /**
     * Callback while the server is ready or restarted.
     * @param   aPort
     *          The port of the server socket.
     * @param   aCertFingerprint
     *          The SHA-256 fingerprint of TLS server certificate.
     *          Empty string represents server started without encryption.
     */
    readonly onServerReady: (aPort: number, aCertFingerprint: IDLAUTF8String) => void;

    /**
     * Callback while the server is stopped or fails to start.
     * @param   aResult
     *          The error cause of server stopped or the reason of
     *          start failure.
     *          NS_OK means the server is stopped by close.
     */
    readonly onServerStopped: (aResult: number) => void;

    /**
     * Callback while the remote host is requesting to start a presentation session.
     * @param aDeviceInfo The device information related to the remote host.
     * @param aUrl The URL requested to open by remote device.
     * @param aPresentationId The Id for representing this session.
     * @param aControlChannel The control channel for this session.
     */
    readonly onSessionRequest: (aDeviceInfo: (nsITCPDeviceInfo | null), aUrl: IDLAString, aPresentationId: IDLAString, aControlChannel: (nsIPresentationControlChannel | null)) => void;

    /**
     * Callback while the remote host is requesting to terminate a presentation session.
     * @param aDeviceInfo The device information related to the remote host.
     * @param aPresentationId The Id for representing this session.
     * @param aControlChannel The control channel for this session.
     * @param aIsFromReceiver true if termination is initiated by receiver.
     */
    readonly onTerminateRequest: (aDeviceInfo: (nsITCPDeviceInfo | null), aPresentationId: IDLAString, aControlChannel: (nsIPresentationControlChannel | null), aIsFromReceiver: boolean) => void;

    /**
     * Callback while the remote host is requesting to reconnect a presentation session.
     * @param aDeviceInfo The device information related to the remote host.
     * @param aUrl The URL requested to open by remote device.
     * @param aPresentationId The Id for representing this session.
     * @param aControlChannel The control channel for this session.
     */
    readonly onReconnectRequest: (aDeviceInfo: (nsITCPDeviceInfo | null), url: IDLAString, aPresentationId: IDLAString, aControlChannel: (nsIPresentationControlChannel | null)) => void;
  }

  export interface nsIChannelRef {
    readonly name: "nsIChannel";
    readonly number: "{2c389865-23db-4aa7-9fe5-60cc7b00697e}";

    /**************************************************************************
     * Channel specific load flags:
     *
     * Bits 16-31 are reserved for future use by this interface or one of its
     * derivatives (e.g., see nsICachingChannel).
     */
    /**
     * Set (e.g., by the docshell) to indicate whether or not the channel
     * corresponds to a document URI.
     * While setting this flag is sufficient to mark a channel as a document
     * load, _checking_ whether the channel is a document load requires the use
     * of the new channel.isDocument
     */
    LOAD_DOCUMENT_URI: 65536;

    /**
     * If the end consumer for this load has been retargeted after discovering
     * its content, this flag will be set:
     */
    LOAD_RETARGETED_DOCUMENT_URI: 131072;

    /**
     * This flag is set to indicate that this channel is replacing another
     * channel.  This means that:
     *
     * 1) the stream listener this channel will be notifying was initially
     *    passed to the asyncOpen method of some other channel
     *
     *   and
     *
     * 2) this channel's URI is a better identifier of the resource being
     *    accessed than this channel's originalURI.
     *
     * This flag can be set, for example, for redirects or for cases when a
     * single channel has multiple parts to it (and thus can follow
     * onStopRequest with another onStartRequest/onStopRequest pair, each pair
     * for a different request).
     */
    LOAD_REPLACE: 262144;

    /**
     * Set (e.g., by the docshell) to indicate whether or not the channel
     * corresponds to an initial document URI load (e.g., link click).
     */
    LOAD_INITIAL_DOCUMENT_URI: 524288;

    /**
     * Set (e.g., by the URILoader) to indicate whether or not the end consumer
     * for this load has been determined.
     */
    LOAD_TARGETED: 1048576;

    /**
     * If this flag is set, the channel should call the content sniffers as
     * described in nsNetCID.h about NS_CONTENT_SNIFFER_CATEGORY.
     *
     * Note: Channels may ignore this flag; however, new channel implementations
     * should only do so with good reason.
     */
    LOAD_CALL_CONTENT_SNIFFERS: 2097152;

    /**
     * This flag tells the channel to bypass URL classifier service check
     * when opening the channel.
     */
    LOAD_BYPASS_URL_CLASSIFIER: 4194304;

    /**
     * If this flag is set, the media-type content sniffer will be allowed
     * to override any server-set content-type. Otherwise it will only
     * be allowed to override "no content type" and application/octet-stream.
     */
    LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE: 8388608;

    /**
     * Set to let explicitely provided credentials be used over credentials
     * we have cached previously. In some situations like form login using HTTP
     * auth via XMLHttpRequest we need to let consumers override the cached
     * credentials explicitely. For form login 403 response instead of 401 is
     * usually used to prevent an auth dialog. But any code other then 401/7
     * will leave original credentials in the cache and there is then no way
     * to override them for the same user name.
     */
    LOAD_EXPLICIT_CREDENTIALS: 16777216;

    /**
     * Set to force bypass of any service worker interception of the channel.
     */
    LOAD_BYPASS_SERVICE_WORKER: 33554432;

    DISPOSITION_INLINE: 0;

    DISPOSITION_ATTACHMENT: 1;
  }

  export interface nsIChannel extends nsIRequest {

    /**
     * The nsIChannel interface allows clients to construct "GET" requests for
     * specific protocols, and manage them in a uniform way.  Once a channel is
     * created (via nsIIOService::newChannel), parameters for that request may
     * be set by using the channel attributes, or by QI'ing to a subclass of
     * nsIChannel for protocol-specific parameters.  Then, the URI can be fetched
     * by calling nsIChannel::open or nsIChannel::asyncOpen.
     *
     * After a request has been completed, the channel is still valid for accessing
     * protocol-specific results.  For example, QI'ing to nsIHttpChannel allows
     * response headers to be retrieved for the corresponding http transaction.
     *
     * This interface must be used only from the XPCOM main thread.
     */
    /**
     * The original URI used to construct the channel. This is used in
     * the case of a redirect or URI "resolution" (e.g. resolving a
     * resource: URI to a file: URI) so that the original pre-redirect
     * URI can still be obtained.  This is never null.  Attempts to
     * set it to null must throw.
     *
     * NOTE: this is distinctly different from the http Referer (referring URI),
     * which is typically the page that contained the original URI (accessible
     * from nsIHttpChannel).
     */
    originalURI: (nsIURI | null);

    /**
     * The URI corresponding to the channel.  Its value is immutable.
     */
    readonly URI: (nsIURI | null);

    /**
     * The owner, corresponding to the entity that is responsible for this
     * channel.  Used by the security manager to grant or deny privileges to
     * mobile code loaded from this channel.
     *
     * NOTE: this is a strong reference to the owner, so if the owner is also
     * holding a strong reference to the channel, care must be taken to
     * explicitly drop its reference to the channel.
     */
    owner: (nsISupports | null);

    /**
     * The notification callbacks for the channel.  This is set by clients, who
     * wish to provide a means to receive progress, status and protocol-specific
     * notifications.  If this value is NULL, the channel implementation may use
     * the notification callbacks from its load group.  The channel may also
     * query the notification callbacks from its load group if its notification
     * callbacks do not supply the requested interface.
     *
     * Interfaces commonly requested include: nsIProgressEventSink, nsIPrompt,
     * and nsIAuthPrompt/nsIAuthPrompt2.
     *
     * When the channel is done, it must not continue holding references to
     * this object.
     *
     * NOTE: A channel implementation should take care when "caching" an
     * interface pointer queried from its notification callbacks.  If the
     * notification callbacks are changed, then a cached interface pointer may
     * become invalid and may therefore need to be re-queried.
     */
    notificationCallbacks: (nsIInterfaceRequestor | null);

    /**
     * Transport-level security information (if any) corresponding to the
     * channel.
     *
     * NOTE: In some circumstances TLS information is propagated onto
     * non-nsIHttpChannel objects to indicate that their contents were likely
     * delivered over TLS all the same.
     *
     * FIXME(bz, bug 1528449) is that still true now that
     * document.open() doesn't do this?
     */
    readonly securityInfo: (nsISupports | null);

    /**
     * The MIME type of the channel's content if available.
     *
     * NOTE: the content type can often be wrongly specified (e.g., wrong file
     * extension, wrong MIME type, wrong document type stored on a server, etc.),
     * and the caller most likely wants to verify with the actual data.
     *
     * Setting contentType before the channel has been opened provides a hint
     * to the channel as to what the MIME type is.  The channel may ignore this
     * hint in deciding on the actual MIME type that it will report.
     *
     * Setting contentType after onStartRequest has been fired or after open()
     * is called will override the type determined by the channel.
     *
     * Setting contentType between the time that asyncOpen() is called and the
     * time when onStartRequest is fired has undefined behavior at this time.
     *
     * The value of the contentType attribute is a lowercase string.  A value
     * assigned to this attribute will be parsed and normalized as follows:
     *  1- any parameters (delimited with a ';') will be stripped.
     *  2- if a charset parameter is given, then its value will replace the
     *     the contentCharset attribute of the channel.
     *  3- the stripped contentType will be lowercased.
     * Any implementation of nsIChannel must follow these rules.
     */
    contentType: IDLACString;

    /**
     * The character set of the channel's content if available and if applicable.
     * This attribute only applies to textual data.
     *
     * The value of the contentCharset attribute is a mixedcase string.
     */
    contentCharset: IDLACString;

    /**
     * The length of the data associated with the channel if available.  A value
     * of -1 indicates that the content length is unknown. Note that this is a
     * 64-bit value and obsoletes the "content-length" property used on some
     * channels.
     */
    contentLength: number;

    /**
     * Synchronously open the channel.
     *
     * @return blocking input stream to the channel's data.
     *
     * NOTE: nsIChannel implementations are not required to implement this
     * method.  Moreover, since this method may block the calling thread, it
     * should not be called on a thread that processes UI events.  Like any
     * other nsIChannel method it must not be called on any thread other
     * than the XPCOM main thread.
     *
     * NOTE: Implementations should throw NS_ERROR_IN_PROGRESS if the channel
     * is reopened.
     */
    readonly open: () => (nsIInputStream | null);

    /**
     * Asynchronously open this channel.  Data is fed to the specified stream
     * listener as it becomes available.  The stream listener's methods are
     * called on the thread that calls asyncOpen and are not called until
     * after asyncOpen returns.  If asyncOpen returns successfully, the
     * channel promises to call at least onStartRequest and onStopRequest.
     *
     * If the nsIRequest object passed to the stream listener's methods is not
     * this channel, an appropriate onChannelRedirect notification needs to be
     * sent to the notification callbacks before onStartRequest is called.
     * Once onStartRequest is called, all following method calls on aListener
     * will get the request that was passed to onStartRequest.
     *
     * If the channel's and loadgroup's notification callbacks do not provide
     * an nsIChannelEventSink when onChannelRedirect would be called, that's
     * equivalent to having called onChannelRedirect.
     *
     * If asyncOpen returns successfully, the channel is responsible for
     * keeping itself alive until it has called onStopRequest on aListener or
     * called onChannelRedirect.
     *
     * Implementations are allowed to synchronously add themselves to the
     * associated load group (if any).
     *
     * NOTE: Implementations should throw NS_ERROR_ALREADY_OPENED if the
     * channel is reopened.
     * NOTE: Implementations should throw an error if the channel has been
     * cancelled prior asyncOpen being called.
     *
     * @param aListener the nsIStreamListener implementation
     * @see nsIChannelEventSink for onChannelRedirect
     */
    readonly asyncOpen: (aListener: (nsIStreamListener | null)) => void;

    /**
     * True if the channel has been canceled.
     */
    readonly canceled: boolean;

    /**
     * Access to the type implied or stated by the Content-Disposition header
     * if available and if applicable. This allows determining inline versus
     * attachment.
     *
     * Setting contentDisposition provides a hint to the channel about the
     * disposition.  If a normal Content-Disposition header is present its
     * value will always be used.  If it is missing the hinted value will
     * be used if set.
     *
     * Implementations should throw NS_ERROR_NOT_AVAILABLE if the header either
     * doesn't exist for this type of channel or is empty, and return
     * DISPOSITION_ATTACHMENT if an invalid/noncompliant value is present.
     */
    contentDisposition: number;

    /**
     * Access to the filename portion of the Content-Disposition header if
     * available and if applicable. This allows getting the preferred filename
     * without having to parse it out yourself.
     *
     * Setting contentDispositionFilename provides a hint to the channel about
     * the disposition.  If a normal Content-Disposition header is present its
     * value will always be used.  If it is missing the hinted value will be
     * used if set.
     *
     * Implementations should throw NS_ERROR_NOT_AVAILABLE if the header doesn't
     * exist for this type of channel, if the header is empty, if the header
     * doesn't contain a filename portion, or the value of the filename
     * attribute is empty/missing.
     */
    contentDispositionFilename: IDLAString;

    /**
     * Access to the raw Content-Disposition header if available and applicable.
     *
     * Implementations should throw NS_ERROR_NOT_AVAILABLE if the header either
     * doesn't exist for this type of channel or is empty.
     *
     * @deprecated Use contentDisposition/contentDispositionFilename instead.
     */
    readonly contentDispositionHeader: IDLACString;

    /**
     * The LoadInfo object contains information about a network load, why it
     * was started, and how we plan on using the resulting response.
     * If a network request is redirected, the new channel will receive a new
     * LoadInfo object. The new object will contain mostly the same
     * information as the pre-redirect one, but updated as appropriate.
     * For detailed information about what parts of LoadInfo are updated on
     * redirect, see documentation on individual properties.
     */
    loadInfo: (nsILoadInfo | null);

    /**
     * Returns true if the channel is used to create a document.
     * It returns true if the loadFlags have LOAD_DOCUMENT_URI set, or if
     * LOAD_HTML_OBJECT_DATA is set and the channel has the appropriate
     * MIME type.
     * Note: May have the wrong value if called before OnStartRequest as we
     * don't know the MIME type yet.
     */
    readonly isDocument: boolean;
  }

  export interface nsIPaymentCompleteActionResponseRef {
    readonly name: "nsIPaymentCompleteActionResponse";
    readonly number: "{62c01e69-9ca4-4060-99e4-b95f628c8e6d}";
  }

  export interface nsIPaymentCompleteActionResponse extends nsIPaymentActionResponse {

    /**
     *  The complete action status.
     *  Using the defined consts(COMPLETE_XXX) in nsIPaymentActionResponse.
     */
    readonly completeStatus: number;

    /**
     *  The Initial method.
     *  @param aRequestId - the request identifier of payment request.
     *  @param aCompleteStatus - the complete action result.
     */
    readonly init: (aRequestId: IDLAString, aCompleteStatus: number) => void;

    /**
     *  Check if the complete action is succeeded.
     */
    readonly isCompleted: () => boolean;
  }

  export interface imgICacheRef {
    readonly name: "imgICache";
    readonly number: "{bfdf23ff-378e-402e-8a6c-840f0c82b6c3}";
  }

  /**
   * imgICache interface
   *
   * @author Stuart Parmenter <pavlov@netscape.com>
   * @version 0.1
   * @see imagelib2
   */
  export interface imgICache extends nsISupports {

    /**
     * Evict images from the cache.
     *
     * @param chrome If TRUE,  evict only chrome images.
     *               If FALSE, evict everything except chrome images.
     */
    readonly clearCache: (chrome: boolean) => void;

    /**
     * Evict images from the cache with the same origin and the same
     * originAttributes of the passed principal.
     *
     * @param aPrincipal The principal
     */
    readonly removeEntriesFromPrincipal: (aPrincipal: (nsIPrincipal | null)) => void;

    /**
     * Find Properties
     * Used to get properties such as 'type' and 'content-disposition'
     * 'type' is a nsISupportsCString containing the images' mime type such as
     * 'image/png'
     * 'content-disposition' will be a nsISupportsCString containing the header
     * If you call this before any data has been loaded from a URI, it will
     * succeed, but come back empty.
     *
     * Hopefully this will be removed with bug 805119
     *
     * @param uri The URI to look up.
     * @param doc Optional pointer to the document that the cache entry belongs to.
     * @returns NULL if the URL was not found in the cache
     */
    readonly findEntryProperties: (uri: (nsIURI | null), doc?: WebIDL.Document) => (nsIProperties | null);

    /**
     * Make this cache instance respect private browsing notifications. This
     * entails clearing the chrome and content caches whenever the
     * last-pb-context-exited notification is observed.
     */
    readonly respectPrivacyNotifications: () => void;
  }

  export interface nsIINIParserWriterRef {
    readonly name: "nsIINIParserWriter";
    readonly number: "{b67bb24b-31a3-4a6a-a5d9-0485c9af5a04}";
  }

  export interface nsIINIParserWriter extends nsISupports {

    /**
     * Set the value of a string for a particular section and key.
     */
    readonly setString: (aSection: IDLAUTF8String, aKey: IDLAUTF8String, aValue: IDLAUTF8String) => void;

    /**
     * Write to the INI file.
     */
    readonly writeFile: (aINIFile: (nsIFile | null)) => void;
  }

  export interface nsIGetHostnameListenerRef {
    readonly name: "nsIGetHostnameListener";
    readonly number: "{3ebdcb62-2df4-4042-8864-3fa81abd4693}";
  }

  /**
   * Listener for getting hostname.
   */
  export interface nsIGetHostnameListener extends nsISupports {

    readonly onGotHostname: (aHostname: IDLAUTF8String) => void;

    readonly onGetHostnameFailed: () => void;
  }

  export interface nsIKeyValuePairCallbackRef {
    readonly name: "nsIKeyValuePairCallback";
    readonly number: "{50f65485-ec1e-4307-812b-b8a15e1f382e}";
  }

  export interface nsIKeyValuePairCallback extends nsISupports {

    /**
     * A callback for the nsIKeyValueEnumerator.getNext() method.
     *
     * The result is the next key/value pair, expressed as separate key and value
     * parameters.
     */
    readonly resolve: (pair: (nsIKeyValuePair | null)) => void;

    readonly reject: (message: IDLAUTF8String) => void;
  }

  export interface nsIXPCComponents_UtilsRef {
    readonly name: "nsIXPCComponents_Utils";
    readonly number: "{86003fe3-ee9a-4620-91dc-eef8b1e58815}";
  }

  /**
   * interface of Components.utils
   */
  export interface nsIXPCComponents_Utils extends nsISupports {

    readonly reportError: (error: IDLjsval, stack?: IDLjsval) => void;

    readonly Sandbox: (nsIXPCComponents_utils_Sandbox | null);

    readonly evalInSandbox: (source: IDLAString, sandbox: IDLjsval, version?: IDLjsval, filename?: IDLAUTF8String, lineNo?: number, enforceFilenameRestrictions?: boolean) => IDLjsval;

    readonly getUAWidgetScope: (principal: (nsIPrincipal | null)) => IDLjsval;

    readonly getSandboxMetadata: (sandbox: IDLjsval) => IDLjsval;

    readonly setSandboxMetadata: (sandbox: IDLjsval, metadata: IDLjsval) => void;

    readonly import: (aResourceURI: IDLAUTF8String, targetObj?: IDLjsval) => IDLjsval;

    /**
     * Returns true if the js file located at 'registryLocation' location has
     * been loaded previously via the import method above. Returns false
     * otherwise.
     *
     * @param resourceURI A resource:// URI string representing the location of
     *        the js file to be checked if it is already loaded or not.
     * @returns boolean, true if the js file has been loaded via import. false
     *          otherwise
     */
    readonly isModuleLoaded: (aResourceURI: IDLAUTF8String) => boolean;

    readonly unload: (registryLocation: IDLAUTF8String) => void;

    readonly importGlobalProperties: (aPropertyList: IDLjsval) => void;

    readonly getWeakReference: (obj: IDLjsval) => (xpcIJSWeakReference | null);

    readonly forceGC: () => void;

    readonly forceCC: (aListener?: (nsICycleCollectorListener | null)) => void;

    readonly createCCLogger: () => (nsICycleCollectorListener | null);

    readonly finishCC: () => void;

    readonly ccSlice: (budget: number) => void;

    readonly getMaxCCSliceTimeSinceClear: () => number;

    readonly clearMaxCCTime: () => void;

    readonly forceShrinkingGC: () => void;

    readonly schedulePreciseGC: (callback: (nsIScheduledGCCallback | nsIScheduledGCCallbackFunction | null)) => void;

    readonly schedulePreciseShrinkingGC: (callback: (nsIScheduledGCCallback | nsIScheduledGCCallbackFunction | null)) => void;

    readonly unlinkGhostWindows: () => void;

    readonly intentionallyLeak: () => void;

    readonly getJSTestingFunctions: () => IDLjsval;

    /**
     * Returns an object containing `filename` and `lineNumber` properties
     * describing the source location of the given function.
     */
    readonly getFunctionSourceLocation: (func: IDLjsval) => IDLjsval;

    readonly callFunctionWithAsyncStack: (aFunction: IDLjsval, stack: (nsIStackFrame | null), asyncCause: IDLAString) => IDLjsval;

    readonly getGlobalForObject: (obj: IDLjsval) => IDLjsval;

    readonly isProxy: (vobject: IDLjsval) => boolean;

    readonly exportFunction: (vfunction: IDLjsval, vscope: IDLjsval, voptions?: IDLjsval) => IDLjsval;

    readonly createObjectIn: (vobj: IDLjsval, voptions?: IDLjsval) => IDLjsval;

    readonly makeObjectPropsNormal: (vobj: IDLjsval) => void;

    /**
     * Determines whether this object is backed by a DeadObjectProxy.
     *
     * Dead-wrapper objects hold no other objects alive (they have no outgoing
     * reference edges) and will throw if you touch them (e.g. by
     * reading/writing a property).
     */
    readonly isDeadWrapper: (obj: IDLjsval) => boolean;

    /**
     * Determines whether this value is a remote object proxy, such as
     * RemoteWindowProxy or RemoteLocationProxy, for an out-of-process frame.
     *
     * Remote object proxies do not grant chrome callers the same exemptions
     * to the same-origin-policy that in-process wrappers typically do, so
     * this can be used to determine whether access to cross-origin proxies is
     * safe:
     *
     *   if (!Cu.isRemoteProxy(frame.contentWindow)) {
     *     frame.contentWindow.doCrossOriginThing();
     *   }
     */
    readonly isRemoteProxy: (val: IDLjsval) => boolean;

    /**
     * Determines whether this object is a cross-process wrapper.
     */
    readonly isCrossProcessWrapper: (obj: IDLjsval) => boolean;

    /**
     * CPOWs can have user data attached to them. This data originates
     * in the local process via the
     * nsIRemoteTagService.getRemoteObjectTag method. It's sent along
     * with the CPOW to the remote process, where it can be fetched
     * with this function, getCrossProcessWrapperTag.
     */
    readonly getCrossProcessWrapperTag: (obj: IDLjsval) => IDLACString;

    /**
     * If CPOWs are disabled for browser code via the
     * dom.ipc.cpows.forbid-unsafe-from-browser preferences, then only
     * add-ons can use CPOWs. This function allows a non-addon scope
     * to opt into CPOWs. It's necessary for the implementation of
     * RemoteAddonsParent.jsm.
     */
    readonly permitCPOWsInScope: (obj: IDLjsval) => void;

    readonly recomputeWrappers: (vobj?: IDLjsval) => void;

    readonly setWantXrays: (vscope: IDLjsval) => void;

    readonly forcePermissiveCOWs: () => void;

    readonly dispatch: (runnable: IDLjsval, scope?: IDLjsval) => void;

    strict: boolean;

    werror: boolean;

    strict_mode: boolean;

    readonly isInAutomation: boolean;

    readonly crashIfNotInAutomation: () => void;

    readonly setGCZeal: (zeal: number) => void;

    readonly nukeSandbox: (obj: IDLjsval) => void;

    readonly blockScriptForGlobal: (global: IDLjsval) => void;

    readonly unblockScriptForGlobal: (global: IDLjsval) => void;

    /**
     * Check whether the given object is an XrayWrapper.
     */
    readonly isXrayWrapper: (obj: IDLjsval) => boolean;

    /**
     * Waive Xray on a given value. Identity op for primitives.
     */
    readonly waiveXrays: (aVal: IDLjsval) => IDLjsval;

    /**
     * Strip off Xray waivers on a given value. Identity op for primitives.
     */
    readonly unwaiveXrays: (aVal: IDLjsval) => IDLjsval;

    /**
     * Gets the name of the JSClass of the object.
     *
     * if |aUnwrap| is true, all wrappers are unwrapped first. Unless you're
     * specifically trying to detect whether the object is a proxy, this is
     * probably what you want.
     */
    readonly getClassName: (aObj: IDLjsval, aUnwrap: boolean) => string;

    /**
     * Get a DOM classinfo for the given classname.  Only some class
     * names are supported.
     */
    readonly getDOMClassInfo: (aClassName: IDLAString) => (nsIClassInfo | null);

    /**
     * Gets the incument global for the execution of this function. For internal
     * and testing use only.
     *
     * If |callback| is passed, it is invoked with the incumbent global as its
     * sole argument. This allows the incumbent global to be measured in callback
     * environments with no scripted frames on the stack.
     */
    readonly getIncumbentGlobal: (callback?: IDLjsval) => IDLjsval;

    /**
     * Forces the generation of an XPCWrappedJS for a given object. For internal
     * and testing use only. This is only useful to set up wrapper map conditions
     * for a testcase. The return value is not an XPCWrappedJS itself, but an
     * opaque nsISupports holder that keeps the underlying XPCWrappedJS alive.
     *
     * if |scope| is passed, the XPCWrappedJS is generated in the scope of that object.
     */
    readonly generateXPCWrappedJS: (obj: IDLjsval, scope?: IDLjsval) => (nsISupports | null);

    /**
     * Retrieve the last time, in microseconds since epoch, that a given
     * watchdog-related event occured.
     *
     * Valid categories:
     *   "ContextStateChange"      - Context switching between active and inactive states
     *   "WatchdogWakeup"          - Watchdog waking up from sleeping
     *   "WatchdogHibernateStart"  - Watchdog begins hibernating
     *   "WatchdogHibernateStop"   - Watchdog stops hibernating
     */
    readonly getWatchdogTimestamp: (aCategory: IDLAString) => number;

    readonly getJSEngineTelemetryValue: () => IDLjsval;

    readonly cloneInto: (value: IDLjsval, scope: IDLjsval, options?: IDLjsval) => IDLjsval;

    readonly getWebIDLCallerPrincipal: () => (nsIPrincipal | null);

    readonly getObjectPrincipal: (obj: IDLjsval) => (nsIPrincipal | null);

    readonly getRealmLocation: (obj: IDLjsval) => IDLACString;

    readonly now: () => number;

    readonly readUTF8File: (file: (nsIFile | null)) => IDLAUTF8String;

    readonly readUTF8URI: (url: (nsIURI | null)) => IDLAUTF8String;

    readonly createSpellChecker: () => (nsIEditorSpellCheck | null);

    readonly createCommandLine: () => (nsISupports | null);

    readonly createCommandParams: () => (nsICommandParams | null);

    readonly createLoadContext: () => (nsILoadContext | null);

    readonly createPrivateLoadContext: () => (nsILoadContext | null);

    readonly createPersistentProperties: () => (nsIPersistentProperties | null);

    readonly createDocumentEncoder: (contentType: string) => (nsIDocumentEncoder | null);

    readonly createHTMLCopyEncoder: () => (nsIDocumentEncoder | null);

    readonly loadedModules: IDLACString[];

    readonly loadedComponents: IDLACString[];

    readonly getModuleImportStack: (aLocation: IDLAUTF8String) => IDLACString;

    readonly getComponentLoadStack: (aLocation: IDLAUTF8String) => IDLACString;
  }

  export interface nsIApplicationCacheChannelRef {
    readonly name: "nsIApplicationCacheChannel";
    readonly number: "{6fa816b1-6d5f-4380-9704-054d0908cfa3}";
  }

  /**
   * Interface implemented by channels that support application caches.
   */
  export interface nsIApplicationCacheChannel extends nsIApplicationCacheContainer {

    /**
     * TRUE when the resource came from the application cache. This
     * might be false even there is assigned an application cache
     * e.g. in case of fallback of load of an entry matching bypass
     * namespace.
     */
    readonly loadedFromApplicationCache: boolean;

    /**
     * When true, the channel will ask its notification callbacks for
     * an application cache if one is not explicitly provided.  Default
     * value is true.
     *
     * NS_ERROR_ALREADY_OPENED will be thrown if set after AsyncOpen()
     * is called.
     */
    inheritApplicationCache: boolean;

    /**
     * When true, the channel will choose an application cache if one
     * was not explicitly provided and none is available from the
     * notification callbacks.  Default value is false.
     *
     * This attribute will not be transferred through a redirect.
     *
     * NS_ERROR_ALREADY_OPENED will be thrown if set after AsyncOpen()
     * is called.
     */
    chooseApplicationCache: boolean;

    /**
     * A shortcut method to mark the cache item of this channel as 'foreign'.
     * See the 'cache selection algorithm' and CACHE_SELECTION_RELOAD
     * action handling in nsContentSink.
     */
    readonly markOfflineCacheEntryAsForeign: () => void;

    /**
     * Set offline application cache object to instruct the channel
     * to cache for offline use using this application cache.
     */
    applicationCacheForWrite: (nsIApplicationCache | null);
  }

  export interface mozIDOMWindowRef {
    readonly name: "mozIDOMWindow";
    readonly number: "{75fbabd6-7a2e-4787-aa33-449a33512135}";
  }

  export interface mozIDOMWindow extends nsISupports {
  }

  export interface nsIIncrementalStreamLoaderRef {
    readonly name: "nsIIncrementalStreamLoader";
    readonly number: "{a023b060-ba23-431a-b449-2dd63e220554}";
  }

  export interface nsIIncrementalStreamLoader extends nsIStreamListener {

    /**
     * Asynchronously loads a channel into a memory buffer.
     *
     * To use this interface, first call init() with a nsIIncrementalStreamLoaderObserver
     * that will be notified when the data has been loaded. Then call asyncOpen()
     * on the channel with the nsIIncrementalStreamLoader as the listener. The context
     * argument in the asyncOpen() call will be passed to the onStreamComplete()
     * callback.
     *
     * XXX define behaviour for sizes >4 GB
     */
    /**
     * Initialize this stream loader, and start loading the data.
     *
     * @param aObserver
     *        An observer that will be notified when the data is complete.
     */
    readonly init: (aObserver: (nsIIncrementalStreamLoaderObserver | null)) => void;

    /**
     * Gets the number of bytes read so far.
     */
    readonly numBytesRead: number;

    /**
     * Gets the request that loaded this file.
     * null after the request has finished loading.
     */
    readonly request: (nsIRequest | null);
  }

  export interface nsICacheTestingRef {
    readonly name: "nsICacheTesting";
    readonly number: "{4e8ba935-92e1-4a74-944b-b1a2f02a7480}";
  }

  /**
   * This is an internal interface used only for testing purposes.
   *
   * THIS IS NOT AN API TO BE USED BY EXTENSIONS! ONLY USED BY MOZILLA TESTS.
   */
  export interface nsICacheTesting extends nsISupports {

    readonly suspendCacheIOThread: (aLevel: number) => void;

    readonly resumeCacheIOThread: () => void;

    readonly flush: (aObserver: (nsIObserver | nsIObserverFunction | null)) => void;
  }

  export interface nsIFlavorDataProviderRef {
    readonly name: "nsIFlavorDataProvider";
    readonly number: "{7e225e5f-711c-11d7-9fae-000393636592}";
  }

  export interface nsIFlavorDataProvider extends nsISupports {

    /**
     * Retrieve the data from this data provider.
     *
     * @param  aTransferable (in parameter) the transferable we're being called for.
     * @param  aFlavor (in parameter) the flavor of data to retrieve
     * @param  aData the data. Some variant of class in nsISupportsPrimitives.idl
     */
    readonly getFlavorData: (aTransferable: (nsITransferable | null), aFlavor: string, aData: Out<(nsISupports | null)>) => void;
  }

  export interface nsISlowScriptDebugRemoteCallbackRef {
    readonly name: "nsISlowScriptDebugRemoteCallback";
    readonly number: "{dbee14b0-8fa0-11e4-b4a9-0800200c9a66}";
  }

  type nsISlowScriptDebugRemoteCallbackFunction = (aBrowser: WebIDL.EventTarget, aCallback: (nsISlowScriptDebuggerStartupCallback | nsISlowScriptDebuggerStartupCallbackFunction | null)) => void;

  export interface nsISlowScriptDebugRemoteCallback extends nsISupports {

    readonly handleSlowScriptDebug: (aBrowser: WebIDL.EventTarget, aCallback: (nsISlowScriptDebuggerStartupCallback | nsISlowScriptDebuggerStartupCallbackFunction | null)) => void;
  }

  export interface nsICacheEntryRef {
    readonly name: "nsICacheEntry";
    readonly number: "{607c2a2c-0a48-40b9-a956-8cf2bb9857cf}";

    CONTENT_TYPE_UNKNOWN: 0;

    CONTENT_TYPE_OTHER: 1;

    CONTENT_TYPE_JAVASCRIPT: 2;

    CONTENT_TYPE_IMAGE: 3;

    CONTENT_TYPE_MEDIA: 4;

    CONTENT_TYPE_STYLESHEET: 5;

    CONTENT_TYPE_WASM: 6;

    /**
     * Content type that is used internally to check whether the value parsed
     * from disk is within allowed limits. Don't pass CONTENT_TYPE_LAST to
     * setContentType method.
     */
    CONTENT_TYPE_LAST: 7;

    /**
     * Placeholder for the initial value of expiration time.
     */
    NO_EXPIRATION_TIME: 4294967295;
  }

  export interface nsICacheEntry extends nsISupports {

    /**
     * Get the key identifying the cache entry.
     */
    readonly key: IDLACString;

    /**
     * The unique ID for every nsICacheEntry instance, which can be used to check
     * whether two pieces of information are from the same nsICacheEntry instance.
     */
    readonly cacheEntryId: number;

    /**
     * Whether the entry is memory/only or persisted to disk.
     * Note: private browsing entries are reported as persistent for consistency
     * while are not actually persisted to disk.
     */
    readonly persistent: boolean;

    /**
     * Get the number of times the cache entry has been opened.
     */
    readonly fetchCount: number;

    /**
     * Get the last time the cache entry was opened (in seconds since the Epoch).
     */
    readonly lastFetched: number;

    /**
     * Get the last time the cache entry was modified (in seconds since the Epoch).
     */
    readonly lastModified: number;

    /**
     * Get the expiration time of the cache entry (in seconds since the Epoch).
     */
    readonly expirationTime: number;

    /**
     * Set the time at which the cache entry should be considered invalid (in
     * seconds since the Epoch).
     */
    readonly setExpirationTime: (expirationTime: number) => void;

    /**
     * Get the last network response times for onStartReqeust/onStopRequest (in ms).
     * @throws
     *    - NS_ERROR_NOT_AVAILABLE if onStartTime/onStopTime does not exist.
     */
    readonly onStartTime: number;

    readonly onStopTime: number;

    /**
     * Set the network response times for onStartReqeust/onStopRequest (in ms).
     */
    readonly setNetworkTimes: (onStartTime: number, onStopTime: number) => void;

    /**
     * Set content type. Available types are defined at the begining of this file.
     * The content type is used internally for cache partitioning and telemetry
     * purposes so there is no getter.
     */
    readonly setContentType: (contentType: number) => void;

    /**
     * Stores information about an access from site identified by unique siteID.
     * It's used for first party cache isolation telemetry.
     */
    readonly addBaseDomainAccess: (siteID: number) => void;

    /**
     * This method is intended to override the per-spec cache validation
     * decisions for a duration specified in seconds. The current state can
     * be examined with isForcedValid (see below). This value is not persisted,
     * so it will not survive session restart. Cache entries that are forced valid
     * will not be evicted from the cache for the duration of forced validity.
     * This means that there is a potential problem if the number of forced valid
     * entries grows to take up more space than the cache size allows.
     *
     * NOTE: entries that have been forced valid will STILL be ignored by HTTP
     * channels if they have expired AND the resource in question requires
     * validation after expiring. This is to avoid using known-stale content.
     *
     * @param aSecondsToTheFuture
     *        the number of seconds the default cache validation behavior will be
     *        overridden before it returns to normal
     */
    readonly forceValidFor: (aSecondsToTheFuture: number) => void;

    /**
     * The state variable for whether this entry is currently forced valid.
     * Defaults to false for normal cache validation behavior, and will return
     * true if the number of seconds set by forceValidFor() has yet to be reached.
     */
    readonly isForcedValid: boolean;

    /**
     * Open blocking input stream to cache data.  Use the stream transport
     * service to asynchronously read this stream on a background thread.
     * The returned stream MAY implement nsISeekableStream.
     *
     * @param offset
     *        read starting from this offset into the cached data.  an offset
     *        beyond the end of the stream has undefined consequences.
     *
     * @return non-blocking, buffered input stream.
     */
    readonly openInputStream: (offset: number) => (nsIInputStream | null);

    /**
     * Open non-blocking output stream to cache data.  The returned stream
     * MAY implement nsISeekableStream.
     *
     * If opening an output stream to existing cached data, the data will be
     * truncated to the specified offset.
     *
     * @param offset
     *        write starting from this offset into the cached data.  an offset
     *        beyond the end of the stream has undefined consequences.
     * @param predictedSize
     *        Predicted size of the data that will be written. It's used to decide
     *        whether the resulting entry would exceed size limit, in which case
     *        an error is thrown. If the size isn't known in advance, -1 should be
     *        passed.
     *
     * @return blocking, buffered output stream.
     */
    readonly openOutputStream: (offset: number, predictedSize: number) => (nsIOutputStream | null);

    /**
     * Get/set security info on the cache entry for this descriptor.
     */
    securityInfo: (nsISupports | null);

    /**
     * Get the size of the cache entry data, as stored. This may differ
     * from the entry's dataSize, if the entry is compressed.
     */
    readonly storageDataSize: number;

    /**
     * Asynchronously doom an entry. Listener will be notified about the status
     * of the operation. Null may be passed if caller doesn't care about the
     * result.
     */
    readonly asyncDoom: (listener: (nsICacheEntryDoomCallback | null)) => void;

    /**
     * Methods for accessing meta data.  Meta data is a table of key/value
     * string pairs.  The strings do not have to conform to any particular
     * charset, but they must be null terminated.
     */
    readonly getMetaDataElement: (key: string) => string;

    readonly setMetaDataElement: (key: string, value: string) => void;

    /**
     * Obtain the list of metadata keys this entry keeps.
     *
     * NOTE: The callback is invoked under the CacheFile's lock.  It means
     * there should not be made any calls to the entry from the visitor and
     * if the values need to be processed somehow, it's better to cache them
     * and process outside the callback.
     */
    readonly visitMetaData: (visitor: (nsICacheEntryMetaDataVisitor | null)) => void;

    /**
     * Claims that all metadata on this entry are up-to-date and this entry
     * now can be delivered to other waiting consumers.
     *
     * We need such method since metadata must be delivered synchronously.
     */
    readonly metaDataReady: () => void;

    /**
     * Called by consumer upon 304/206 response from the server.  This marks
     * the entry content as positively revalidated.
     * Consumer uses this method after the consumer has returned ENTRY_NEEDS_REVALIDATION
     * result from onCacheEntryCheck and after successfull revalidation with the server.
     */
    readonly setValid: () => void;

    /**
     * Explicitly tell the cache backend this consumer is no longer going to modify
     * this cache entry data or metadata.  In case the consumer was responsible to
     * either of writing the cache entry or revalidating it, calling this method
     * reverts the state to initial (as never written) or as not-validated and
     * immediately notifies the next consumer in line waiting for this entry.
     * This is the way to prevent deadlocks when someone else than the responsible
     * channel references the cache entry being in a non-written or revalidating
     * state.
     */
    readonly dismiss: () => void;

    /**
     * Returns the size in kilobytes used to store the cache entry on disk.
     */
    readonly diskStorageSizeInKB: number;

    /**
     * Doom this entry and open a new, empty, entry for write.  Consumer has
     * to exchange the entry this method is called on for the newly created.
     * Used on 200 responses to conditional requests.
     *
     * @param aMemoryOnly
     *    - whether the entry is to be created as memory/only regardless how
     *      the entry being recreated persistence is set
     * @returns
     *    - an entry that can be used to write to
     * @throws
     *    - NS_ERROR_NOT_AVAILABLE when the entry cannot be from some reason
     *      recreated for write
     */
    readonly recreate: (aMemoryOnly?: boolean) => (nsICacheEntry | null);

    /**
     * Returns the length of data this entry holds.
     * @throws
     *    NS_ERROR_IN_PROGRESS when the write is still in progress.
     */
    readonly dataSize: number;

    /**
      * Returns the length of data this entry holds.
      * @throws
      *    - NS_ERROR_IN_PROGRESS when a write is still in progress (either real
                                  content or alt data).
      *    - NS_ERROR_NOT_AVAILABLE if alt data does not exist.
      */
    readonly altDataSize: number;

    /**
     * Returns the type of the saved alt data.
     * @throws
     *    - NS_ERROR_NOT_AVAILABLE if alt data does not exist.
     */
    readonly altDataType: IDLACString;

    /**
     * Opens and returns an output stream that a consumer may use to save an
     * alternate representation of the data.
     *
     * @param type
     *        type of the alternative data representation
     * @param predictedSize
     *        Predicted size of the data that will be written. It's used to decide
     *        whether the resulting entry would exceed size limit, in which case
     *        an error is thrown. If the size isn't known in advance, -1 should be
     *        passed.
     *
     * @throws
     *    - NS_ERROR_NOT_AVAILABLE if the real data hasn't been written.
     *    - NS_ERROR_IN_PROGRESS when the writing regular content or alt-data to
     *      the cache entry is still in progress.
     *
     * If there is alt-data already saved, it will be overwritten.
     */
    readonly openAlternativeOutputStream: (type: IDLACString, predictedSize: number) => (nsIAsyncOutputStream | null);

    /**
     * Opens and returns an input stream that can be used to read the alternative
     * representation previously saved in the cache.
     * If this call is made while writing alt-data is still in progress, it is
     * still possible to read content from the input stream as it's being written.
     * @throws
     *    - NS_ERROR_NOT_AVAILABLE if the alt-data representation doesn't exist at
     *      all or if alt-data of the given type doesn't exist.
     */
    readonly openAlternativeInputStream: (type: IDLACString) => (nsIInputStream | null);

    /**
     * Get the nsILoadContextInfo of the cache entry
     */
    readonly loadContextInfo: (nsILoadContextInfo | null);

    /****************************************************************************
     * The following methods might be added to some nsICacheEntryInternal
     * interface since we want to remove them as soon as the old cache backend is
     * completely removed.
     */
    /**
     * @deprecated
     * FOR BACKWARD COMPATIBILITY ONLY
     * When the old cache backend is eventually removed, this method
     * can be removed too.
     *
     * In the new backend: this method is no-op
     * In the old backend: this method delegates to nsICacheEntryDescriptor.close()
     */
    readonly close: () => void;

    /**
     * @deprecated
     * FOR BACKWARD COMPATIBILITY ONLY
     * Marks the entry as valid so that others can use it and get only readonly
     * access when the entry is held by the 1st writer.
     */
    readonly markValid: () => void;

    /**
     * @deprecated
     * FOR BACKWARD COMPATIBILITY ONLY
     * Marks the entry as valid when write access is acquired.
     */
    readonly maybeMarkValid: () => void;

    /**
     * @deprecated
     * FOR BACKWARD COMPATIBILITY ONLY / KINDA HACK
     * @param aWriteAllowed
     *    Consumer indicates whether write to the entry is allowed for it.
     *    Depends on implementation how the flag is handled.
     * @returns
     *    true when write access is acquired for this entry,
     *    false otherwise
     */
    readonly hasWriteAccess: (aWriteAllowed: boolean) => boolean;
  }

  export interface nsIU2FTokenManagerRef {
    readonly name: "nsIU2FTokenManager";
    readonly number: "{745e1eac-e449-4342-bca1-ee0e6ead09fc}";
  }

  /**
   * nsIU2FTokenManager
   *
   * An interface to the U2FTokenManager singleton.
   *
   * This should be used only by the WebAuthn browser UI prompts.
   */
  export interface nsIU2FTokenManager extends nsISupports {

    /**
     * Resumes the current WebAuthn/U2F transaction if that matches the given
     * transaction ID. This is used only when direct attestation was requested
     * and we have to wait for user input to proceed.
     *
     * @param aTransactionID : The ID of the transaction to resume.
     * @param aForceNoneAttestation : The user might enforce none attestation.
     */
    readonly resumeRegister: (aTransactionID: number, aForceNoneAttestation: boolean) => void;

    /**
     * Cancels the current WebAuthn/U2F transaction if that matches the given
     * transaction ID.
     *
     * @param aTransactionID : The ID of the transaction to cancel.
     */
    readonly cancel: (aTransactionID: number) => void;
  }

  export interface nsIIOServiceRef {
    readonly name: "nsIIOService";
    readonly number: "{4286de5a-b2ea-446f-8f70-e2a461f42694}";
  }

  /**
   * nsIIOService provides a set of network utility functions.  This interface
   * duplicates many of the nsIProtocolHandler methods in a protocol handler
   * independent way (e.g., NewURI inspects the scheme in order to delegate
   * creation of the new URI to the appropriate protocol handler).  nsIIOService
   * also provides a set of URL parsing utility functions.  These are provided
   * as a convenience to the programmer and in some cases to improve performance
   * by eliminating intermediate data structures and interfaces.
   */
  export interface nsIIOService extends nsISupports {

    /**
     * Returns a protocol handler for a given URI scheme.
     *
     * @param aScheme the URI scheme
     * @return reference to corresponding nsIProtocolHandler
     */
    readonly getProtocolHandler: (aScheme: string) => (nsIProtocolHandler | null);

    /**
     * Returns the protocol flags for a given scheme.
     *
     * @param aScheme the URI scheme
     * @return value of corresponding nsIProtocolHandler::protocolFlags
     */
    readonly getProtocolFlags: (aScheme: string) => number;

    /**
     * This method constructs a new URI by determining the scheme of the
     * URI spec, and then delegating the construction of the URI to the
     * protocol handler for that scheme. QueryInterface can be used on
     * the resulting URI object to obtain a more specific type of URI.
     *
     * @see nsIProtocolHandler::newURI
     */
    readonly newURI: (aSpec: IDLAUTF8String, aOriginCharset?: string, aBaseURI?: (nsIURI | null)) => (nsIURI | null);

    /**
     * This method constructs a new URI from a nsIFile.
     *
     * @param aFile specifies the file path
     * @return reference to a new nsIURI object
     *
     * Note: in the future, for perf reasons we should allow
     * callers to specify whether this is a file or directory by
     * splitting this  into newDirURI() and newActualFileURI().
     */
    readonly newFileURI: (aFile: (nsIFile | null)) => (nsIURI | null);

    /**
     * Creates a channel for a given URI.
     *
     * @param aURI
     *        nsIURI from which to make a channel
     * @param aLoadingNode
     * @param aLoadingPrincipal
     * @param aTriggeringPrincipal
     * @param aSecurityFlags
     * @param aContentPolicyType
     *        These will be used as values for the nsILoadInfo object on the
     *        created channel. For details, see nsILoadInfo in nsILoadInfo.idl
     * @return reference to the new nsIChannel object
     *
     * Please note, if you provide both a loadingNode and a loadingPrincipal,
     * then loadingPrincipal must be equal to loadingNode->NodePrincipal().
     * But less error prone is to just supply a loadingNode.
     *
     * Keep in mind that URIs coming from a webpage should *never* use the
     * systemPrincipal as the loadingPrincipal.
     */
    readonly newChannelFromURI: (aURI: (nsIURI | null), aLoadingNode: WebIDL.Node, aLoadingPrincipal: (nsIPrincipal | null), aTriggeringPrincipal: (nsIPrincipal | null), aSecurityFlags: number, aContentPolicyType: number) => (nsIChannel | null);

    /**
     * Equivalent to newChannelFromURI(aURI, aLoadingNode, ...)
     */
    readonly newChannelFromURIWithLoadInfo: (aURI: (nsIURI | null), aLoadInfo: (nsILoadInfo | null)) => (nsIChannel | null);

    /**
     * Equivalent to newChannelFromURI(newURI(...))
     */
    readonly newChannel: (aSpec: IDLAUTF8String, aOriginCharset: string, aBaseURI: (nsIURI | null), aLoadingNode: WebIDL.Node, aLoadingPrincipal: (nsIPrincipal | null), aTriggeringPrincipal: (nsIPrincipal | null), aSecurityFlags: number, aContentPolicyType: number) => (nsIChannel | null);

    /**
     * Returns true if networking is in "offline" mode. When in offline mode,
     * attempts to access the network will fail (although this does not
     * necessarily correlate with whether there is actually a network
     * available -- that's hard to detect without causing the dialer to
     * come up).
     *
     * Changing this fires observer notifications ... see below.
     */
    offline: boolean;

    /**
     * Returns false if there are no interfaces for a network request
     */
    readonly connectivity: boolean;

    /**
     * Checks if a port number is banned. This involves consulting a list of
     * unsafe ports, corresponding to network services that may be easily
     * exploitable. If the given port is considered unsafe, then the protocol
     * handler (corresponding to aScheme) will be asked whether it wishes to
     * override the IO service's decision to block the port. This gives the
     * protocol handler ultimate control over its own security policy while
     * ensuring reasonable, default protection.
     *
     * @see nsIProtocolHandler::allowPort
     */
    readonly allowPort: (aPort: number, aScheme: string) => boolean;

    /**
     * Utility to extract the scheme from a URL string, consistently and
     * according to spec (see RFC 2396).
     *
     * NOTE: Most URL parsing is done via nsIURI, and in fact the scheme
     * can also be extracted from a URL string via nsIURI.  This method
     * is provided purely as an optimization.
     *
     * @param aSpec the URL string to parse
     * @return URL scheme, lowercase
     *
     * @throws NS_ERROR_MALFORMED_URI if URL string is not of the right form.
     */
    readonly extractScheme: (urlString: IDLAUTF8String) => IDLACString;

    /**
     * Checks if a URI host is a local IPv4 or IPv6 address literal.
     *
     * @param nsIURI the URI that contains the hostname to check
     * @return true if the URI hostname is a local IP address
     */
    readonly hostnameIsLocalIPAddress: (aURI: (nsIURI | null)) => boolean;

    /**
     * Checks if a URI host is a shared IPv4 address literal.
     *
     * @param nsIURI the URI that contains the hostname to check
     * @return true if the URI hostname is a shared IP address
     */
    readonly hostnameIsSharedIPAddress: (aURI: (nsIURI | null)) => boolean;

    /**
     * While this is set, IOService will monitor an nsINetworkLinkService
     * (if available) and set its offline status to "true" whenever
     * isLinkUp is false.
     *
     * Applications that want to control changes to the IOService's offline
     * status should set this to false, watch for network:link-status-changed
     * broadcasts, and change nsIIOService::offline as they see fit. Note
     * that this means during application startup, IOService may be offline
     * if there is no link, until application code runs and can turn off
     * this management.
     */
    manageOfflineStatus: boolean;

    /**
     * Creates a channel for a given URI.
     *
     * @param aURI
     *        nsIURI from which to make a channel
     * @param aProxyURI
     *        nsIURI to use for proxy resolution. Can be null in which
     *        case aURI is used
     * @param aProxyFlags flags from nsIProtocolProxyService to use
     *        when resolving proxies for this new channel
     * @param aLoadingNode
     * @param aLoadingPrincipal
     * @param aTriggeringPrincipal
     * @param aSecurityFlags
     * @param aContentPolicyType
     *        These will be used as values for the nsILoadInfo object on the
     *        created channel. For details, see nsILoadInfo in nsILoadInfo.idl
     * @return reference to the new nsIChannel object
     *
     * Please note, if you provide both a loadingNode and a loadingPrincipal,
     * then loadingPrincipal must be equal to loadingNode->NodePrincipal().
     * But less error prone is to just supply a loadingNode.
     */
    readonly newChannelFromURIWithProxyFlags: (aURI: (nsIURI | null), aProxyURI: (nsIURI | null), aProxyFlags: number, aLoadingNode: WebIDL.Node, aLoadingPrincipal: (nsIPrincipal | null), aTriggeringPrincipal: (nsIPrincipal | null), aSecurityFlags: number, aContentPolicyType: number) => (nsIChannel | null);
  }

  export interface nsIUUIDGeneratorRef {
    readonly name: "nsIUUIDGenerator";
    readonly number: "{138ad1b2-c694-41cc-b201-333ce936d8b8}";
  }

  /**
   * nsIUUIDGenerator is implemented by a service that can generate
   * universally unique identifiers, ideally using any platform-native
   * method for generating UUIDs.
   */
  export interface nsIUUIDGenerator extends nsISupports {
  }

  export interface nsICacheEntryDoomCallbackRef {
    readonly name: "nsICacheEntryDoomCallback";
    readonly number: "{2f8896be-232f-4140-afb3-1faffb56f3c6}";
  }

  export interface nsICacheEntryDoomCallback extends nsISupports {

    /**
     * Callback invoked after an entry or entries has/have been
     * doomed from the cache.
     */
    readonly onCacheEntryDoomed: (aResult: number) => void;
  }

  export interface nsIDocumentStateListenerRef {
    readonly name: "nsIDocumentStateListener";
    readonly number: "{050cdc00-3b8e-11d3-9ce4-a458f454fcbc}";
  }

  export interface nsIDocumentStateListener extends nsISupports {

    readonly NotifyDocumentCreated: () => void;

    readonly NotifyDocumentWillBeDestroyed: () => void;

    readonly NotifyDocumentStateChanged: (nowDirty: boolean) => void;
  }

  export interface nsIRedirectHistoryEntryRef {
    readonly name: "nsIRedirectHistoryEntry";
    readonly number: "{133b2905-0eba-411c-a8bb-f59787142aa2}";
  }

  /**
   * This nsIRedirectHistoryEntry defines an interface for specifying channel
   * redirect information
   */
  export interface nsIRedirectHistoryEntry extends nsISupports {

    /**
     * The principal of this redirect entry
     */
    readonly principal: (nsIPrincipal | null);

    /**
     * The referring URI of this redirect entry.  This may be null.
     */
    readonly referrerURI: (nsIURI | null);

    /**
     * The remote address of this redirect entry.
     */
    readonly remoteAddress: IDLACString;
  }

  export interface nsIQuotaUsageRequestRef {
    readonly name: "nsIQuotaUsageRequest";
    readonly number: "{166e28e6-cf6d-4927-a6d7-b51bca9d3469}";
  }

  export interface nsIQuotaUsageRequest extends nsIQuotaRequestBase {

    readonly result: (nsIVariant | null);

    callback: (nsIQuotaUsageCallback | null);

    readonly cancel: () => void;
  }

  export interface nsIEnterprisePoliciesRef {
    readonly name: "nsIEnterprisePolicies";
    readonly number: "{6a568972-cc91-4bf5-963e-3768f3319b8a}";

    UNINITIALIZED: -1;

    INACTIVE: 0;

    ACTIVE: 1;

    FAILED: 2;
  }

  export interface nsIEnterprisePolicies extends nsISupports {

    readonly status: number;

    readonly isAllowed: (feature: IDLACString) => boolean;

    /**
     * Get the active policies that have been successfully parsed.
     *
     * @returns A JS object that contains the policies names and
     *          their corresponding parameters.
     */
    readonly getActivePolicies: () => IDLjsval;

    /**
     * Get the contents of the support menu (if applicable)
     *
     * @returns A JS object that contains the url and label or null.
     */
    readonly getSupportMenu: () => IDLjsval;

    /**
     * Get the policy for a given extensionID (if available)
     *
     * @returns A JS object that contains the storage or null if unavailable.
     */
    readonly getExtensionPolicy: (extensionID: IDLACString) => IDLjsval;

    /**
     * Retrieves the ExtensionSettings policy for the given extensionID.
     *
     * If there is no policy for the extension, it returns the global policy.
     *
     * If there is no global policy, it returns null.
     *
     * @returns A JS object that settings or null if unavailable.
     */
    readonly getExtensionSettings: (extensionID: IDLACString) => IDLjsval;

    /**
     * Uses the whitelist, blacklist and settings to determine if an extension
     * may be installed.
     *
     * @returns A boolean - true of the extension may be installed.
     */
    readonly mayInstallAddon: (addon: IDLjsval) => boolean;

    /**
     * Uses install_sources to determine if an extension can be installed
     * from the given URI.
     *
     * @returns A boolean - true of the extension may be installed.
     */
    readonly allowedInstallSource: (uri: (nsIURI | null)) => boolean;
  }

  export interface nsIUploadChannel2Ref {
    readonly name: "nsIUploadChannel2";
    readonly number: "{2f712b52-19c5-4e0c-9e8f-b5c7c3b67049}";
  }

  export interface nsIUploadChannel2 extends nsISupports {

    /**
     * Sets a stream to be uploaded by this channel with the specified
     * Content-Type and Content-Length header values.
     *
     * Most implementations of this interface require that the stream:
     *   (1) implement threadsafe addRef and release
     *   (2) implement nsIInputStream::readSegments
     *   (3) implement nsISeekableStream::seek
     *
     * @param aStream
     *        The stream to be uploaded by this channel.
     * @param aContentType
     *        This value will replace any existing Content-Type
     *        header on the HTTP request, regardless of whether
     *        or not its empty.
     * @param aContentLength
     *        A value of -1 indicates that the length of the stream should be
     *        determined by calling the stream's |available| method.
     * @param aMethod
     *        The HTTP request method to set on the stream.
     * @param aStreamHasHeaders
     *        True if the stream already contains headers for the HTTP request.
     */
    readonly explicitSetUploadStream: (aStream: (nsIInputStream | null), aContentType: IDLACString, aContentLength: number, aMethod: IDLACString, aStreamHasHeaders: boolean) => void;

    /**
     * Value of aStreamHasHeaders from the last successful call to
     * explicitSetUploadStream.  TRUE indicates the attached upload stream
     * contains request headers.
     */
    readonly uploadStreamHasHeaders: boolean;
  }

  export interface nsIReflowObserverRef {
    readonly name: "nsIReflowObserver";
    readonly number: "{832e692c-c4a6-11e2-8fd1-dce678957a39}";
  }

  export interface nsIReflowObserver extends nsISupports {

    /**
     * Called when an uninterruptible reflow has occurred.
     *
     * @param start timestamp when reflow ended, in milliseconds since
     *              navigationStart (accurate to 1/1000 of a ms)
     * @param end   timestamp when reflow ended, in milliseconds since
     *              navigationStart (accurate to 1/1000 of a ms)
     */
    readonly reflow: (start: number, end: number) => void;

    /**
     * Called when an interruptible reflow has occurred.
     *
     * @param start timestamp when reflow ended, in milliseconds since
     *              navigationStart (accurate to 1/1000 of a ms)
     * @param end   timestamp when reflow ended, in milliseconds since
     *              navigationStart (accurate to 1/1000 of a ms)
     */
    readonly reflowInterruptible: (start: number, end: number) => void;
  }

  export interface nsICacheServiceInternalRef {
    readonly name: "nsICacheServiceInternal";
    readonly number: "{d0fc8d38-db80-4928-bf1c-b0085ddfa9dc}";
  }

  export interface nsICacheServiceInternal extends nsICacheService {

    /**
     * This is an internal interface. It changes so frequently that it probably
     * went away while you were reading this.
     */
    /**
     * Milliseconds for which the service lock has been held. 0 if unlocked.
     */
    readonly lockHeldTime: number;
  }

  export interface nsILocalStorageManagerRef {
    readonly name: "nsILocalStorageManager";
    readonly number: "{d4f534da-2744-4db3-8774-8b187c64ade9}";
  }

  /**
   * Methods specific to LocalStorage, see nsIDOMStorageManager for methods shared
   * with SessionStorage.  Methods may migrate there as SessionStorage is
   * overhauled.
   */
  export interface nsILocalStorageManager extends nsISupports {

    readonly nextGenLocalStorageEnabled: boolean;

    /**
     * Trigger preload of LocalStorage for the given principal.  For use by
     * ContentParent::AboutToLoadHttpFtpDocumentForChild to maximize the
     * amount of time we have to load the data off disk before the page might
     * attempt to touch LocalStorage.
     *
     * This method will not create a QuotaManager-managed directory on disk if
     * one does not already exist for the principal.
     */
    readonly preload: (aPrincipal: (nsIPrincipal | null)) => (nsISupports | null);

    readonly isPreloaded: (aPrincipal: (nsIPrincipal | null)) => (nsISupports | null);
  }

  export interface nsIColorPickerRef {
    readonly name: "nsIColorPicker";
    readonly number: "{de229d37-a8a6-46f1-969a-0c1de33d0ad7}";
  }

  export interface nsIColorPicker extends nsISupports {

    /**
     * Initialize the color picker widget. The color picker will not be shown until
     * open() is called.
     * If the backend doesn't support setting a title to the native color picker
     * widget, the title parameter might be ignored.
     * If the initialColor parameter does not follow the format specified on top of
     * this file, the behavior will be unspecified. The initialColor could be the
     * one used by the underlying backend or an arbitrary one. The backend could
     * also assert.
     *
     * @param      parent       nsIDOMWindow parent. This dialog will be dependent
     *                          on this parent. parent must be non-null.
     * @param      title        The title for the color picker widget.
     * @param      initialColor The color to show when the widget is opened. The
     *                          parameter has to follow the format specified on top
     *                          of this file.
     */
    readonly init: (parent: (mozIDOMWindowProxy | null), title: IDLAString, initialColor: IDLAString) => void;

    /**
     * Opens the color dialog asynchrounously.
     * The results are provided via the callback object.
     */
    readonly open: (aColorPickerShownCallback: (nsIColorPickerShownCallback | null)) => void;
  }

  export interface nsIWorkerDebuggerManagerListenerRef {
    readonly name: "nsIWorkerDebuggerManagerListener";
    readonly number: "{d2aa74ee-6b98-4d5d-8173-4e23422daf1e}";
  }

  export interface nsIWorkerDebuggerManagerListener extends nsISupports {

    readonly onRegister: (aDebugger: (nsIWorkerDebugger | null)) => void;

    readonly onUnregister: (aDebugger: (nsIWorkerDebugger | null)) => void;
  }

  export interface nsIDeviceSensorDataRef {
    readonly name: "nsIDeviceSensorData";
    readonly number: "{0462247e-fe8c-4aa5-b675-3752547e485f}";

    TYPE_ORIENTATION: 0;

    TYPE_ACCELERATION: 1;

    TYPE_PROXIMITY: 2;

    TYPE_LINEAR_ACCELERATION: 3;

    TYPE_GYROSCOPE: 4;

    TYPE_LIGHT: 5;

    TYPE_ROTATION_VECTOR: 6;

    TYPE_GAME_ROTATION_VECTOR: 7;
  }

  export interface nsIDeviceSensorData extends nsISupports {

    readonly type: number;

    readonly x: number;

    readonly y: number;

    readonly z: number;
  }

  export interface nsIAsyncShutdownBarrierRef {
    readonly name: "nsIAsyncShutdownBarrier";
    readonly number: "{50fa8a86-9c91-4256-8389-17d310adec90}";
  }

  /**
   * A stage of shutdown that supports blocker registration.
   */
  export interface nsIAsyncShutdownBarrier extends nsISupports {

    /**
     * The blocker registration capability.  Most services may wish to
     * publish this capability to let services that depend on it register
     * blockers.
     */
    readonly client: (nsIAsyncShutdownClient | null);

    /**
     * The state of all the blockers of the barrier.
     *
     * See the documentation of `nsIAsyncShutdownBlocker` for the
     * format.
     */
    readonly state: (nsIPropertyBag | null);

    /**
     * Wait for all blockers to complete.
     *
     * Method `aOnReady` will be called once all blockers have finished.
     * The callback always receives NS_OK.
     */
    readonly wait: (aOnReady: (nsIAsyncShutdownCompletionCallback | nsIAsyncShutdownCompletionCallbackFunction | null)) => void;
  }

  export interface nsITLSServerSecurityObserverRef {
    readonly name: "nsITLSServerSecurityObserver";
    readonly number: "{1f62e1ae-e546-4a38-8917-d428472ed736}";
  }

  export interface nsITLSServerSecurityObserver extends nsISupports {

    /**
     * onHandsakeDone
     *
     * This method is called once the TLS handshake is completed.  This takes
     * place after |onSocketAccepted| has been called, which typically opens the
     * streams to keep things moving along. It's important to be aware that the
     * handshake has not completed at the point that |onSocketAccepted| is called,
     * so no security verification can be done until this method is called.
     */
    readonly onHandshakeDone: (aServer: (nsITLSServerSocket | null), aStatus: (nsITLSClientStatus | null)) => void;
  }

  export interface nsILocalCertServiceRef {
    readonly name: "nsILocalCertService";
    readonly number: "{9702fdd4-4c2c-439c-ba2e-19cda018eb99}";
  }

  export interface nsILocalCertService extends nsISupports {

    /**
     * Get or create a new self-signed X.509 cert to represent this device over a
     * secure transport, like TLS.
     *
     * The cert is stored permanently in the profile's key store after first use,
     * and is valid for 1 year.  If an expired or otherwise invalid cert is found
     * with the nickname supplied here, it is removed and a new one is made.
     *
     * @param nickname Nickname that identifies the cert
     * @param cb       Callback to be notified with the result
     */
    readonly getOrCreateCert: (nickname: IDLACString, cb: (nsILocalCertGetCallback | null)) => void;

    /**
     * Remove a X.509 cert with the given nickname.
     *
     * @param nickname Nickname that identifies the cert
     * @param cb       Callback to be notified with the result
     */
    readonly removeCert: (nickname: IDLACString, cb: (nsILocalCertCallback | null)) => void;

    /**
     * Whether calling |getOrCreateCert| or |removeCert| will trigger a login
     * prompt to be displayed.  Generally this happens if the user has set a
     * master password, but has not yet logged in.
     */
    readonly loginPromptRequired: boolean;
  }

  export interface nsIApplicationCacheNamespaceRef {
    readonly name: "nsIApplicationCacheNamespace";
    readonly number: "{96e4c264-2065-4ce9-93bb-43734c62c4eb}";

    /**
     * Items matching this namespace can be fetched from the network
     * when loading from this cache.  The "data" attribute is unused.
     */
    NAMESPACE_BYPASS: 1;

    /**
     * Items matching this namespace can be fetched from the network
     * when loading from this cache.  If the load fails, the cache entry
     * specified by the "data" attribute should be loaded instead.
     */
    NAMESPACE_FALLBACK: 2;

    /**
     * Items matching this namespace should be cached
     * opportunistically.  Successful toplevel loads of documents
     * in this namespace should be placed in the application cache.
     * Namespaces specifying NAMESPACE_OPPORTUNISTIC may also specify
     * NAMESPACE_FALLBACK to supply a fallback entry.
     */
    NAMESPACE_OPPORTUNISTIC: 4;
  }

  /**
   * Application caches can store a set of namespace entries that affect
   * loads from the application cache.  If a load from the cache fails
   * to match an exact cache entry, namespaces entries will be searched
   * for a substring match, and should be applied appropriately.
   */
  export interface nsIApplicationCacheNamespace extends nsISupports {

    /**
     * Initialize the namespace.
     */
    readonly init: (itemType: number, namespaceSpec: IDLACString, data: IDLACString) => void;

    /**
     * The namespace type.
     */
    readonly itemType: number;

    /**
     * The prefix of this namespace.  This should be the asciiSpec of the
     * URI prefix.
     */
    readonly namespaceSpec: IDLACString;

    /**
     * Data associated with this namespace, such as a fallback.  URI data should
     * use the asciiSpec of the URI.
     */
    readonly data: IDLACString;
  }

  export interface nsIDOMGeoPositionCallbackRef {
    readonly name: "nsIDOMGeoPositionCallback";
    readonly number: "{527e8b53-6f29-4b6a-8d04-5c1666a4c4c1}";
  }

  type nsIDOMGeoPositionCallbackFunction = (position: (nsIDOMGeoPosition | null)) => void;

  export interface nsIDOMGeoPositionCallback extends nsISupports {

    readonly handleEvent: (position: (nsIDOMGeoPosition | null)) => void;
  }

  export interface nsICookiePermissionRef {
    readonly name: "nsICookiePermission";
    readonly number: "{11ddd4ed-8f5b-40b3-b2a0-27c20ea1c88d}";

    /**
     * nsCookieAccess values
     */
    ACCESS_DEFAULT: 0;

    ACCESS_ALLOW: 1;

    ACCESS_DENY: 2;

    /**
     * additional values for nsCookieAccess which may not match
     * nsIPermissionManager. Keep 3-7 available to allow nsIPermissionManager to
     * add values without colliding. ACCESS_SESSION is not directly returned by
     * any methods on this interface.
     */
    ACCESS_SESSION: 8;
  }

  /**
   * An interface to test for cookie permissions
   */
  export interface nsICookiePermission extends nsISupports {

    /**
     * Don't use values 9 and 10! They used to be ACCESS_ALLOW_FIRST_PARTY_ONLY
     * and ACCESS_LIMIT_THIRD_PARTY, now removed, but maybe still stored in some
     * ancient user profiles.
     */
    /**
     * canSetCookie
     *
     * this method is called to test whether or not the given URI/channel may
     * set a specific cookie.  this method is always preceded by a call to
     * canAccess. it may modify the isSession and expiry attributes of the
     * cookie via the aIsSession and aExpiry parameters, in order to limit
     * or extend the lifetime of the cookie. this is useful, for instance, to
     * downgrade a cookie to session-only if it fails to meet certain criteria.
     *
     * @param aURI
     *        the URI trying to set the cookie
     * @param aChannel
     *        the channel corresponding to aURI
     * @param aCookie
     *        the cookie being added to the cookie database
     * @param aIsSession
     *        when canSetCookie is invoked, this is the current isSession attribute
     *        of the cookie. canSetCookie may leave this value unchanged to
     *        preserve this attribute of the cookie.
     * @param aExpiry
     *        when canSetCookie is invoked, this is the current expiry time of
     *        the cookie. canSetCookie may leave this value unchanged to
     *        preserve this attribute of the cookie.
     *
     * @return true if the cookie can be set.
     */
    readonly canSetCookie: (aURI: (nsIURI | null), aChannel: (nsIChannel | null), aCookie: (nsICookie | null), aIsSession: InOut<boolean>, aExpiry: InOut<number>) => boolean;
  }

  export interface nsIRoutedSocketTransportServiceRef {
    readonly name: "nsIRoutedSocketTransportService";
    readonly number: "{c5204623-5b58-4a16-8b2e-67c34dd02e3f}";
  }

  export interface nsIRoutedSocketTransportService extends nsISocketTransportService {

    readonly createRoutedTransport: (aSocketTypes: IDLACString[], aHost: IDLAUTF8String, aPort: number, aHostRoute: IDLAUTF8String, aPortRoute: number, aProxyInfo: (nsIProxyInfo | null)) => (nsISocketTransport | null);
  }

  export interface nsIMultiPartChannelRef {
    readonly name: "nsIMultiPartChannel";
    readonly number: "{4fefb490-5567-11e5-a837-0800200c9a66}";
  }

  /**
   * An interface to access the the base channel
   * associated with a MultiPartChannel.
   */
  export interface nsIMultiPartChannel extends nsISupports {

    /**
     * readonly attribute to access the underlying channel
     */
    readonly baseChannel: (nsIChannel | null);

    /**
     * Attribute guaranteed to be different for different parts of
     * the same multipart document.
     */
    readonly partID: number;

    /**
     * Set to true when onStopRequest is received from the base channel.
     * The listener can check this from its onStopRequest to determine
     * whether more data can be expected.
     */
    readonly isLastPart: boolean;
  }

  export interface nsIDOMGeoPositionCoordsRef {
    readonly name: "nsIDOMGeoPositionCoords";
    readonly number: "{b31702d0-6dac-4fa0-b93b-f043e71c8f9a}";
  }

  export interface nsIDOMGeoPositionCoords extends nsISupports {

    readonly latitude: number;

    readonly longitude: number;

    readonly altitude: number;

    readonly accuracy: number;

    readonly altitudeAccuracy: number;

    readonly heading: number;

    readonly speed: number;
  }

  export interface nsILoadURIDelegateRef {
    readonly name: "nsILoadURIDelegate";
    readonly number: "{78e42d37-a34c-4d96-b901-25385669aba4}";
  }

  /**
   * The nsILoadURIDelegate interface.
   * Used for delegating URI loads to GeckoView's application, e.g., Custom Tabs
   * or Progressive Web Apps.
   */
  export interface nsILoadURIDelegate extends nsISupports {

    /**
     * Delegates the URI load. This should only be called for top-level loads.
     *
     * @param aURI The URI to load.
     * @param aWhere See possible values described in nsIBrowserDOMWindow.
     * @param aFlags Flags which control the behavior of the load.
     * @param aTriggeringPrincipal The principal that triggered the load of aURI.
     *
     * Returns whether the load has been successfully handled.
     */
    readonly loadURI: (aURI: (nsIURI | null), aWhere: number, aFlags: number, aTriggeringPrincipal: (nsIPrincipal | null)) => boolean;

    /**
     * Delegates page load error handling. This may be called for either top-level
     * loads or subframes.
     *
     * @param aURI The URI that failed to load.
     * @param aError The error code.
     * @param aErrorModule The error module code.
     
     * Returns an error page URL to load, or null to show the default error page.
     * No error page is shown at all if an error is thrown.
     */
    readonly handleLoadError: (aURI: (nsIURI | null), aError: number, aErrorModule: number) => (nsIURI | null);
  }

  export interface mozIStorageAsyncConnectionRef {
    readonly name: "mozIStorageAsyncConnection";
    readonly number: "{8bfd34d5-4ddf-4e4b-89dd-9b14f33534c6}";

    /**
     * Transaction behavior constants.
     */
    TRANSACTION_DEFAULT: -1;

    TRANSACTION_DEFERRED: 0;

    TRANSACTION_IMMEDIATE: 1;

    TRANSACTION_EXCLUSIVE: 2;
  }

  /**
   * mozIStorageAsyncConnection represents an asynchronous database
   * connection attached to a specific file or to an in-memory data
   * storage.  It is the primary interface for interacting with a
   * database from the main thread, including creating prepared
   * statements, executing SQL, and examining database errors.
   */
  export interface mozIStorageAsyncConnection extends nsISupports {

    /**
     * The default behavior for all transactions run on this connection. Defaults
     * to `TRANSACTION_DEFERRED`, and can be overridden for individual
     * transactions.
     */
    defaultTransactionType: number;

    /**
     * The maximum number of bound parameters for statements executed on this
     * connection. If your statement has more params than this limit, you'll
     * need to chunk them into multiple statements. See `PlacesUtils.chunkArray`
     * and its callers in Places for examples of how to do this, or read on for
     * an overview.
     *
     * Keep in mind that the variable limit is for the _total_ number of
     * parameters, including ones bound by name (using the `:VVV`, `@VVV`, or
     * `?VVV` syntax) and index (`?` and `?NNN`).
     *
     * This means, when chunking:
     *
     * - If you're binding 1 param per 1 value per chunk (for example, if you
     *   have a list of GUIDs and a clause like `WHERE guid IN (?, ?, ?, ...)`,
     *   your chunk length is just `variableLimit`.
     * - If you're binding 1 param per 1 value per chunk, but using that
     *   param in multiple positions in the query (for example, `WHERE url_hash
     *   IN (hash(?1), hash(?2), ...) AND url IN (?1, ?2, ...)`), you can use the
     *   `?NNN` syntax with a chunk length of `variableLimit`.
     * - If you're binding N params per 1 value per chunk (for example, if you
     *   have a list of items with GUIDs and parent GUIDs, and you want to bind
     *   both), your chunk length is `variableLimit / N`, since you're binding
     *   two params for each element.
     * - If you're binding K params per L values per chunk, plus M fixed ones
     *   (for example, `WHERE parentGuid = :parentGuid AND guid IN (?, ?, ...)`),
     *   your chunk length is `variableLimit - M`, to ensure there's space for the
     *   fixed variables.
     *
     * If you bind more params than this limit, `create{Async}Statement` will
     * fail with a "too many SQL variables" error.
     */
    readonly variableLimit: number;

    /**
     * Close this database connection, allowing all pending statements
     * to complete first.
     *
     * @param aCallback [optional]
     *        A callback that will be notified when the close is completed,
     *        with the following arguments:
     *        - status: the status of the call
     *        - value: |null|
     *
     * @throws NS_ERROR_NOT_SAME_THREAD
     *         If called on a thread other than the one that opened it.  The
     *         callback will not be dispatched.
     * @throws NS_ERROR_NOT_INITIALIZED
     *         If called on a connection that has already been closed or was
     *         never properly opened.  The callback will still be dispatched
     *         to the main thread despite the returned error.
     * @note If this call should fail, the callback won't be invoked.
     */
    readonly asyncClose: (aCallback?: (mozIStorageCompletionCallback | mozIStorageCompletionCallbackFunction | null)) => void;

    /**
     * Clone a database and make the clone read only if needed.
     * SQL Functions and attached on-disk databases are applied to the new clone.
     *
     * @param aReadOnly
     *        If true, the returned database should be put into read-only mode.
     *
     * @param aCallback
     *        A callback that will be notified when the operation is complete,
     *        with the following arguments:
     *        - status: the status of the operation
     *        - value: in case of success, an intance of
     *             mozIStorageAsyncConnection cloned from this one.
     *
     * @throws NS_ERROR_NOT_SAME_THREAD
     *         If is called on a thread other than the one that opened it.
     * @throws NS_ERROR_UNEXPECTED
     *         If this connection is a memory database.
     *
     * @note If your connection is already read-only, you will get a read-only
     *       clone.
     * @note The resulting connection will implement `mozIStorageConnection`, but
     *       all synchronous methods will throw if called from the main thread.
     * @note Due to a bug in SQLite, if you use the shared cache
     *       (see mozIStorageService), you end up with the same privileges as the
     *       first connection opened regardless of what is specified in aReadOnly.
     * @note The following pragmas are copied over to a read-only clone:
     *        - cache_size
     *        - temp_store
     *       The following pragmas are copied over to a writeable clone:
     *        - cache_size
     *        - temp_store
     *        - foreign_keys
     *        - journal_size_limit
     *        - synchronous
     *        - wal_autocheckpoint
     *       All SQL functions are copied over to read-only and writeable clones.
     *       Additionally, all temporary tables, triggers, and views, as well as
     *       any indexes on temporary tables, are copied over to writeable clones.
     *       For temporary tables, only the schemas are copied, not their
     *       contents.
     */
    readonly asyncClone: (aReadOnly: boolean, aCallback: (mozIStorageCompletionCallback | mozIStorageCompletionCallbackFunction | null)) => void;

    /**
     * The current database nsIFile.  Null if the database
     * connection refers to an in-memory database.
     */
    readonly databaseFile: (nsIFile | null);

    /**
     * Causes any pending database operation to abort and return at the first
     * opportunity.
     * This can only be used on read-only connections that don't implement
     * the mozIStorageConnection interface.
     * @note operations that are nearly complete may still be able to complete.
     * @throws if used on an unsupported connection type, or a closed connection.
     */
    readonly interrupt: () => void;

    /**
     * Create an asynchronous statement for the given SQL. An
     * asynchronous statement can only be used to dispatch asynchronous
     * requests to the asynchronous execution thread and cannot be used
     * to take any synchronous actions on the database.
     *
     * The expression may use ? to indicate sequential numbered arguments,
     * ?1, ?2 etc. to indicate specific numbered arguments or :name and
     * $var to indicate named arguments.
     *
     * @param aSQLStatement
     *        The SQL statement to execute.
     * @return a new mozIStorageAsyncStatement
     * @note The statement is created lazily on first execution.
     */
    readonly createAsyncStatement: (aSQLStatement: IDLAUTF8String) => (mozIStorageAsyncStatement | null);

    /**
     * Execute an array of statements created with this connection using
     * any currently bound parameters. When the array contains multiple
     * statements, the execution is wrapped in a single
     * transaction. These statements can be reused immediately, and
     * reset does not need to be called.
     *
     * @param aStatements
     *        The array of statements to execute asynchronously, in the order they
     *        are given in the array.
     * @param aCallback [optional]
     *        The callback object that will be notified of progress, errors, and
     *        completion.
     * @return an object that can be used to cancel the statements execution.
     *
     * @note If you have any custom defined functions, they must be
     *        re-entrant since they can be called on multiple threads.
     */
    readonly executeAsync: (aStatements: (mozIStorageBaseStatement | null)[], aCallback?: (mozIStorageStatementCallback | null)) => (mozIStoragePendingStatement | null);

    /**
     * Execute asynchronously an SQL expression, expecting no arguments.
     *
     * @param aSQLStatement
     *        The SQL statement to execute
     * @param aCallback [optional]
     *        The callback object that will be notified of progress, errors, and
     *        completion.
     * @return an object that can be used to cancel the statement execution.
     */
    readonly executeSimpleSQLAsync: (aSQLStatement: IDLAUTF8String, aCallback?: (mozIStorageStatementCallback | null)) => (mozIStoragePendingStatement | null);

    /**
     * Create a new SQL function.  If you use your connection on multiple threads,
     * your function needs to be threadsafe, or it should only be called on one
     * thread.
     *
     * @param aFunctionName
     *        The name of function to create, as seen in SQL.
     * @param aNumArguments
     *        The number of arguments the function takes. Pass -1 for
     *        variable-argument functions.
     * @param aFunction
     *        The instance of mozIStorageFunction, which implements the function
     *        in question.
     */
    readonly createFunction: (aFunctionName: IDLAUTF8String, aNumArguments: number, aFunction: (mozIStorageFunction | mozIStorageFunctionFunction | null)) => void;

    /**
     * Create a new SQL aggregate function.  If you use your connection on
     * multiple threads, your function needs to be threadsafe, or it should only
     * be called on one thread.
     *
     * @param aFunctionName
     *        The name of aggregate function to create, as seen in SQL.
     * @param aNumArguments
     *        The number of arguments the function takes. Pass -1 for
     *        variable-argument functions.
     * @param aFunction
     *        The instance of mozIStorageAggreagteFunction, which implements the
     *        function in question.
     */
    readonly createAggregateFunction: (aFunctionName: IDLAUTF8String, aNumArguments: number, aFunction: (mozIStorageAggregateFunction | null)) => void;

    /**
     * Delete custom SQL function (simple or aggregate one).
     *
     * @param aFunctionName
     *        The name of function to remove.
     */
    readonly removeFunction: (aFunctionName: IDLAUTF8String) => void;

    /**
     * Sets a progress handler. Only one handler can be registered at a time.
     * If you need more than one, you need to chain them yourself.  This progress
     * handler should be threadsafe if you use this connection object on more than
     * one thread.
     *
     * @param aGranularity
     *        The number of SQL virtual machine steps between progress handler
     *        callbacks.
     * @param aHandler
     *        The instance of mozIStorageProgressHandler.
     * @return previous registered handler.
     */
    readonly setProgressHandler: (aGranularity: number, aHandler: (mozIStorageProgressHandler | null)) => (mozIStorageProgressHandler | null);

    /**
     * Remove a progress handler.
     *
     * @return previous registered handler.
     */
    readonly removeProgressHandler: () => (mozIStorageProgressHandler | null);
  }

  export interface nsIInterceptedChannelRef {
    readonly name: "nsIInterceptedChannel";
    readonly number: "{f4b82975-6a86-4cc4-87fe-9a1fd430c86d}";
  }

  /**
   * Interface to allow implementors of nsINetworkInterceptController to control the behaviour
   * of intercepted channels without tying implementation details of the interception to
   * the actual channel. nsIInterceptedChannel is expected to be implemented by objects
   * which do not implement nsIChannel.
   */
  export interface nsIInterceptedChannel extends nsISupports {

    /**
     * Instruct a channel that has been intercepted to continue with the original
     * network request.
     */
    readonly resetInterception: () => void;

    /**
     * Set the status and reason for the forthcoming synthesized response.
     * Multiple calls overwrite existing values.
     */
    readonly synthesizeStatus: (status: number, reason: IDLACString) => void;

    /**
     * Attach a header name/value pair to the forthcoming synthesized response.
     * Overwrites any existing header value.
     */
    readonly synthesizeHeader: (name: IDLACString, value: IDLACString) => void;

    /**
     * Instruct a channel that has been intercepted that a response is
     * starting to be synthesized.  No further header modification is allowed
     * after this point.  There are a few parameters:
     * - A body stream may be optionally passed.  If nullptr, then an
     *   empty body is assumed.
     * - A callback may be optionally passed.  It will be invoked
     *   when the body is complete.  For a nullptr body this may be
     *   synchronously on the current thread.  Otherwise it will be invoked
     *   asynchronously on the current thread.
     * - A cacheInfoChannel may be optionally passed. If the body stream is
     *   from alternative data cache, this cacheInfoChannel provides needed
     *   cache information.
     * - The caller may optionally pass a spec for a URL that this response
     *   originates from; an empty string will cause the original
     *   intercepted request's URL to be used instead.
     * - The responseRedirected flag is false will cause the channel do an
     *   internal redirect when the original intercepted reauest's URL is
     *   different from the response's URL. The flag is true will cause the
     *   chaanel do a non-internal redirect when the URLs are different.
     */
    readonly startSynthesizedResponse: (body: (nsIInputStream | null), callback: (nsIInterceptedBodyCallback | null), channel: (nsICacheInfoChannel | null), finalURLSpec: IDLACString, responseRedirected: boolean) => void;

    /**
     * Instruct a channel that has been intercepted that response synthesis
     * has completed and all outstanding resources can be closed.
     */
    readonly finishSynthesizedResponse: () => void;

    /**
     * Cancel the pending intercepted request.
     * @return NS_ERROR_FAILURE if the response has already been synthesized or
     *         the original request has been instructed to continue.
     */
    readonly cancelInterception: (status: number) => void;

    /**
     * The underlying channel object that was intercepted.
     */
    readonly channel: (nsIChannel | null);

    /**
     * The URL of the underlying channel object, corrected for a potential
     * secure upgrade.
     */
    readonly secureUpgradedChannelURI: (nsIURI | null);
  }

  export interface nsICollationRef {
    readonly name: "nsICollation";
    readonly number: "{b0132cc0-3786-4557-9874-910d7def5f93}";

    kCollationStrengthDefault: 0;

    kCollationCaseInsensitiveAscii: 1;

    kCollationAccentInsenstive: 2;

    kCollationCaseSensitive: 0;

    kCollationCaseInSensitive: 3;
  }

  export interface nsICollation extends nsISupports {

    readonly initialize: (locale: IDLACString) => void;

    readonly compareString: (strength: number, string1: IDLAString, string2: IDLAString) => number;
  }

  export interface nsIServiceWorkerUnregisterCallbackRef {
    readonly name: "nsIServiceWorkerUnregisterCallback";
    readonly number: "{52ee2c9d-ee87-4caf-9588-23ae77ff8798}";
  }

  export interface nsIServiceWorkerUnregisterCallback extends nsISupports {

    readonly unregisterSucceeded: (aState: boolean) => void;

    readonly unregisterFailed: () => void;
  }

  export interface nsILoginMetaInfoRef {
    readonly name: "nsILoginMetaInfo";
    readonly number: "{20d8eb40-c494-497f-b2a6-aaa32f807ebd}";
  }

  /**
   * An object containing metainfo for a login stored by the login manager.
   *
   * Code using login manager can generally ignore this interface. When adding
   * logins, default value will be created. When modifying logins, these
   * properties will be unchanged unless a change is explicitly requested [by
   * using modifyLogin() with a nsIPropertyBag]. When deleting a login or
   * comparing logins, these properties are ignored.
   */
  export interface nsILoginMetaInfo extends nsISupports {

    /**
     * The GUID to uniquely identify the login. This can be any arbitrary
     * string, but a format as created by nsIUUIDGenerator is recommended.
     * For example, "{d4e1a1f6-5ea0-40ee-bff5-da57982f21cf}"
     *
     * addLogin will generate a random value unless a value is provided.
     *
     * addLogin and modifyLogin will throw if the GUID already exists.
     */
    guid: IDLAString;

    /**
     * The time, in Unix Epoch milliseconds, when the login was first created.
     */
    timeCreated: number;

    /**
     * The time, in Unix Epoch milliseconds, when the login was last submitted
     * in a form or used to begin an HTTP auth session.
     */
    timeLastUsed: number;

    /**
     * The time, in Unix Epoch milliseconds, when the login was last modified.
     *
     * Contrary to what the name may suggest, this attribute takes into account
     * not only the password but also the username attribute.
     */
    timePasswordChanged: number;

    /**
     * The number of times the login was submitted in a form or used to begin
     * an HTTP auth session.
     */
    timesUsed: number;
  }

  export interface nsIContentSignatureVerifierRef {
    readonly name: "nsIContentSignatureVerifier";
    readonly number: "{45a5fe2f-c350-4b86-962d-02d5aaaa955a}";
  }

  /**
   * An interface for verifying content-signatures, inspired by
   * https://tools.ietf.org/html/draft-thomson-http-content-signature-00
   * described here https://github.com/franziskuskiefer/content-signature/tree/pki
   */
  export interface nsIContentSignatureVerifier extends nsISupports {

    /**
       * Verifies that the data matches the data that was used to generate the
       * signature.
       *
       * @param aData                   The data to be tested.
       * @param aContentSignatureHeader The content-signature header,
       *                                url-safe base64 encoded.
       * @param aCertificateChain       The certificate chain to use for verification.
       *                                PEM encoded string.
       * @param aHostname               The hostname for which the end entity must
                                        be valid.
       * @returns Promise that resolves with the value true if the signature
       *          matches the data and aCertificateChain is valid within aContext,
       *          and false if not. Rejects if another error occurred.
       */
    readonly asyncVerifyContentSignature: (aData: IDLACString, aContentSignatureHeader: IDLACString, aCertificateChain: IDLACString, aHostname: IDLACString) => IDLPromise;
  }

  export interface nsISiteHPKPStateRef {
    readonly name: "nsISiteHPKPState";
    readonly number: "{ae395078-c7d0-474d-b147-f4aa203a9b2c}";
  }

  export interface nsISiteHPKPState extends nsISiteSecurityState {

    readonly sha256Keys: (nsISimpleEnumerator | null);
  }

  export interface nsIURIClassifierCallbackRef {
    readonly name: "nsIURIClassifierCallback";
    readonly number: "{8face46e-0c96-470f-af40-0037dcd797bd}";
  }

  type nsIURIClassifierCallbackFunction = (aErrorCode: number, aList: IDLACString, aProvider: IDLACString, aFullHash: IDLACString) => void;

  /**
   * Callback function for nsIURIClassifier lookups.
   */
  export interface nsIURIClassifierCallback extends nsISupports {

    /**
     * Called by the URI classifier service when it is done checking a URI.
     *
     * Clients are responsible for associating callback objects with classify()
     * calls.
     *
     * @param aErrorCode
     *        The error code with which the channel should be cancelled, or
     *        NS_OK if the load should continue normally.
     * @param aList
     *        Name of the list that matched
     * @param aProvider
     *        Name of provider that matched
     * @param aFullHash
     *        Full hash of URL that matched
     */
    readonly onClassifyComplete: (aErrorCode: number, aList: IDLACString, aProvider: IDLACString, aFullHash: IDLACString) => void;
  }

  export interface xpcIJSWeakReferenceRef {
    readonly name: "xpcIJSWeakReference";
    readonly number: "{75767928-ecb1-4e6c-9f55-c118b297fcef}";
  }

  export interface xpcIJSWeakReference extends nsISupports {

    /**
     * To be called from JS only.
     *
     * Returns the referenced JS object or null if the JS object has
     * been garbage collected.
     */
    readonly get: () => IDLjsval;
  }

  export interface nsIAlertNotificationRef {
    readonly name: "nsIAlertNotification";
    readonly number: "{cf2e4cb6-4b8f-4eca-aea9-d51a8f9f7a50}";
  }

  export interface nsIAlertNotification extends nsISupports {

    /** Initializes an alert notification. */
    readonly init: (aName?: IDLAString, aImageURL?: IDLAString, aTitle?: IDLAString, aText?: IDLAString, aTextClickable?: boolean, aCookie?: IDLAString, aDir?: IDLAString, aLang?: IDLAString, aData?: IDLAString, aPrincipal?: (nsIPrincipal | null), aInPrivateBrowsing?: boolean, aRequireInteraction?: boolean) => void;

    /**
     * The name of the notification. On Android, the name is hashed and used as
     * a notification ID. Notifications will replace previous notifications with
     * the same name.
     */
    readonly name: IDLAString;

    /**
     * A URL identifying the image to put in the alert. The OS X backend limits
     * the amount of time it will wait for the image to load to six seconds. After
     * that time, the alert will show without an image.
     */
    readonly imageURL: IDLAString;

    /** The title for the alert. */
    readonly title: IDLAString;

    /** The contents of the alert. */
    readonly text: IDLAString;

    /**
     * Controls the click behavior. If true, the alert listener will be notified
     * when the user clicks on the alert.
     */
    readonly textClickable: boolean;

    /**
     * An opaque cookie that will be passed to the alert listener for each
     * callback.
     */
    readonly cookie: IDLAString;

    /**
     * Bidi override for the title and contents. Valid values are "auto", "ltr",
     * or "rtl". Ignored if the backend doesn't support localization.
     */
    readonly dir: IDLAString;

    /**
     * Language of the title and text. Ignored if the backend doesn't support
     * localization.
     */
    readonly lang: IDLAString;

    /**
     * A Base64-encoded structured clone buffer containing data associated with
     * this alert. Only used for web notifications. Chrome callers should use a
     * cookie instead.
     */
    readonly data: IDLAString;

    /**
     * The principal of the page that created the alert. Used for IPC security
     * checks, and to determine whether the alert is actionable.
     */
    readonly principal: (nsIPrincipal | null);

    /**
     * The URI of the page that created the alert. |null| if the alert is not
     * actionable.
     */
    readonly URI: (nsIURI | null);

    /**
     * Controls the image loading behavior. If true, the image request will be
     * loaded anonymously (without cookies or authorization tokens).
     */
    readonly inPrivateBrowsing: boolean;

    /**
     * Indicates that the notification should remain readily available until
     * the user activates or dismisses the notification.
     */
    readonly requireInteraction: boolean;

    /**
     * Indicates whether this alert should show the source string and action
     * buttons. False for system alerts (which can omit the principal), or
     * expanded, system, and null principals.
     */
    readonly actionable: boolean;

    /**
     * The host and port of the originating page, or an empty string if the alert
     * is not actionable.
     */
    readonly source: IDLAString;

    /**
     * Loads the image associated with this alert.
     *
     * @param aTimeout  The number of milliseconds to wait before cancelling the
     *                  image request. If zero, there is no timeout.
     * @param aListener An |nsIAlertNotificationImageListener| implementation,
     *                  notified when the image loads. The listener is kept alive
     *                  until the request completes.
     * @param aUserData An opaque parameter passed to the listener's methods.
     *                  Not used by the libnotify backend, but the OS X backend
     *                  passes the pending notification.
     */
    readonly loadImage: (aTimeout: number, aListener: (nsIAlertNotificationImageListener | null), aUserData?: (nsISupports | null)) => (nsICancelable | null);
  }

  export interface nsIProtocolProxyFilterRef {
    readonly name: "nsIProtocolProxyFilter";
    readonly number: "{f424abd3-32b4-456c-9f45-b7e3376cb0d1}";
  }

  /**
   * This interface is used to apply filters to the proxies selected for a given
   * URI.  Use nsIProtocolProxyService::registerFilter to hook up instances of
   * this interface. See also nsIProtocolProxyChannelFilter.
   */
  export interface nsIProtocolProxyFilter extends nsISupports {

    /**
     * This method is called to apply proxy filter rules for the given URI
     * and proxy object (or list of proxy objects).
     *
     * @param aProxyService
     *        A reference to the Protocol Proxy Service.  This is passed so that
     *        implementations may easily access methods such as newProxyInfo.
     * @param aURI
     *        The URI for which these proxy settings apply.
     * @param aProxy
     *        The proxy (or list of proxies) that would be used by default for
     *        the given URI.  This may be null.
     *
     * @param aCallback
     *        An object that the implementer is obligated to call on with
     *        the result (from within applyFilter() or asynchronously) when
     *        applyFilter didn't throw.  The argument passed to onProxyFilterResult
     *        is the proxy (or list of proxies) that should be used in place of
     *        aProxy.  This can be just be aProxy if the filter chooses not to
     *        modify the proxy.  It can also be null to indicate that a direct
     *        connection should be used.  Use aProxyService.newProxyInfo to
     *        construct nsIProxyInfo objects.
     */
    readonly applyFilter: (aProxyService: (nsIProtocolProxyService | null), aURI: (nsIURI | null), aProxy: (nsIProxyInfo | null), aCallback: (nsIProxyProtocolFilterResult | null)) => void;
  }

  export interface nsIDragSessionRef {
    readonly name: "nsIDragSession";
    readonly number: "{25bce737-73f0-43c7-bc20-c71044a73c5a}";
  }

  export interface nsIDragSession extends nsISupports {

    /**
     * Set the current state of the drag, whether it can be dropped or not.
     * usually the target "frame" sets this so the native system can render the correct feedback
     */
    canDrop: boolean;

    /**
     * Indicates if the drop event should be dispatched only to chrome.
     */
    onlyChromeDrop: boolean;

    /**
     * Sets the action (copy, move, link, et.c) for the current drag
     */
    dragAction: number;

    /**
     * Get the number of items that were dropped
     */
    readonly numDropItems: number;

    /**
     * The document where the drag was started, which will be null if the
     * drag originated outside the application. Useful for determining if a drop
     * originated in the same document.
     */
    readonly sourceDocument: WebIDL.Document;

    /**
     * The dom node that was originally dragged to start the session, which will be null if the
     * drag originated outside the application.
     */
    readonly sourceNode: WebIDL.Node;

    /**
     * the triggering principal.  This may be different than sourceNode's
     * principal when sourceNode is xul:browser and the drag is
     * triggered in a browsing context inside it.
     */
    triggeringPrincipal: (nsIPrincipal | null);

    /**
     * the triggering csp.  This may be different than sourceNode's
     * csp when sourceNode is xul:browser and the drag is
     * triggered in a browsing context inside it.
     */
    csp: (nsIContentSecurityPolicy | null);

    /**
     * The data transfer object for the current drag.
     */
    dataTransfer: WebIDL.DataTransfer;

    /**
     * Get data from a Drag&Drop. Can be called while the drag is in process
     * or after the drop has completed.
     *
     * @param  aTransferable the transferable for the data to be put into
     * @param  aItemIndex which of multiple drag items, zero-based
     */
    readonly getData: (aTransferable: (nsITransferable | null), aItemIndex: number) => void;

    /**
     * Check to set if any of the native data on the clipboard matches this data flavor
     */
    readonly isDataFlavorSupported: (aDataFlavor: string) => boolean;

    readonly userCancelled: () => void;

    readonly dragEventDispatchedToChildProcess: () => void;

    readonly updateDragEffect: () => void;

    readonly updateDragImage: (aImage: WebIDL.Node, aImageX: number, aImageY: number) => void;

    /**
     * Sets drag end point of synthesized session when the test does not dispatch
     * "drop" event.
     */
    readonly setDragEndPointForTests: (aScreenX: number, aScreenY: number) => void;
  }

  export interface nsIDirectoryEnumeratorRef {
    readonly name: "nsIDirectoryEnumerator";
    readonly number: "{31f7f4ae-6916-4f2d-a81e-926a4e3022ee}";
  }

  /**
   * This interface provides a means for enumerating the contents of a directory.
   * It is similar to nsISimpleEnumerator except the retrieved entries are QI'ed
   * to nsIFile, and there is a mechanism for closing the directory when the
   * enumeration is complete.
   */
  export interface nsIDirectoryEnumerator extends nsISimpleEnumerator {

    /**
     * Retrieves the next file in the sequence. The "nextFile" element is the
     * first element upon the first call. This attribute is null if there is no
     * next element.
     */
    readonly nextFile: (nsIFile | null);

    /**
     * Closes the directory being enumerated, releasing the system resource.
     * @throws NS_OK if the call succeeded and the directory was closed.
     *         NS_ERROR_FAILURE if the directory close failed.
     *         It is safe to call this function many times.
     */
    readonly close: () => void;
  }

  export interface nsIKeyValueVoidCallbackRef {
    readonly name: "nsIKeyValueVoidCallback";
    readonly number: "{0c17497a-ccf8-451a-838d-9dfa7f846379}";
  }

  export interface nsIKeyValueVoidCallback extends nsISupports {

    /**
     * A callback for the nsIKeyValueDatabase.put() and .delete() methods.
     *
     * There is no result, but the resolve() method is still called when those
     * async operations complete, to notify consumers of completion.
     */
    readonly resolve: () => void;

    readonly reject: (message: IDLAUTF8String) => void;
  }

  export interface nsIURISettersRef {
    readonly name: "nsIURISetters";
    readonly number: "{5403a6ec-99d7-405e-8b45-9f805bbdfcef}";
  }

  /**
   * These methods allow the mutator to change various parts of the URI.
   * They return the same nsIURIMutator so that we may chain setter operations:
   * Example:
   * let newURI = uri.mutate()
   *                 .setSpec("http://example.com")
   *                 .setQuery("hello")
   *                 .finalize();
   */
  export interface nsIURISetters extends nsIURISetSpec {

    /**
     * Setting the scheme outside of a protocol handler implementation is highly
     * discouraged since that will generally lead to incorrect results.
     */
    readonly setScheme: (aScheme: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setUserPass: (aUserPass: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setUsername: (aUsername: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setPassword: (aPassword: IDLAUTF8String) => (nsIURIMutator | null);

    /**
     * If you setHostPort to a value that only has a host part, the port
     * will not be reset. To reset the port set it to -1 beforehand.
     * If setting the host succeeds, this method will return NS_OK, even if
     * setting the port fails (error in parsing the port, or value out of range)
     */
    readonly setHostPort: (aHostPort: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setHost: (aHost: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setPort: (aPort: number) => (nsIURIMutator | null);

    readonly setPathQueryRef: (aPathQueryRef: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setRef: (aRef: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setFilePath: (aFilePath: IDLAUTF8String) => (nsIURIMutator | null);

    readonly setQuery: (aQuery: IDLAUTF8String) => (nsIURIMutator | null);
  }

  export interface nsIDOMMozWakeLockListenerRef {
    readonly name: "nsIDOMMozWakeLockListener";
    readonly number: "{4e258af8-cffb-47bc-b16d-e8241243426e}";
  }

  type nsIDOMMozWakeLockListenerFunction = (aTopic: IDLAString, aState: IDLAString) => void;

  export interface nsIDOMMozWakeLockListener extends nsISupports {

    /**
     * The callback will be called when a lock topic changes its lock
     * state.
     *
     * Possible states are:
     *
     *  - "unlocked" - nobody holds the wake lock.
     *
     *  - "locked-foreground" - at least one window holds the wake lock,
     *    and it is visible.
     *
     *  - "locked-background" - at least one window holds the wake lock,
     *    but all of them are hidden.
     *
     * @param aTopic The resource name related to the wake lock.
     * @param aState The wake lock state
     */
    readonly callback: (aTopic: IDLAString, aState: IDLAString) => void;
  }

  export interface txIEXSLTFunctionsRef {
    readonly name: "txIEXSLTFunctions";
    readonly number: "{21b1cfa4-00ce-4cc1-bfc1-92af1d00e580}";
  }

  export interface txIEXSLTFunctions extends nsISupports {

    readonly match: (str: IDLAString, regex: IDLAString, flags: IDLAString, doc: WebIDL.Document) => WebIDL.DocumentFragment;

    readonly replace: (str: IDLAString, regex: IDLAString, flags: IDLAString, replace: IDLAString) => IDLAString;

    readonly test: (str: IDLAString, regex: IDLAString, flags: IDLAString) => boolean;
  }

  export interface nsITransactionListenerRef {
    readonly name: "nsITransactionListener";
    readonly number: "{58e330c4-7b48-11d2-98b9-00805f297d89}";
  }

  /**
   * The nsITransactionListener interface.
   * <P>
   * This interface is implemented by an object that tracks transactions.
   */
  export interface nsITransactionListener extends nsISupports {

    /**
     * Called before a transaction manager calls a transaction's
     * doTransaction() method.
     * @param aManager the transaction manager doing the transaction.
     * @param aTransaction the transaction being executed.
     * @result boolean value returned by listener which indicates
     * its desire to interrupt normal control flow. Listeners should
     * return true if they want to interrupt normal control flow, without
     * throwing an error.
     */
    readonly willDo: (aManager: (nsITransactionManager | null), aTransaction: (nsITransaction | null)) => boolean;

    /**
     * Called after a transaction manager calls the doTransaction() method of
     * a transaction.
     * @param aManager the transaction manager that did the transaction.
     * @param aTransaction the transaction that was executed.
     * @param aDoResult the nsresult returned after executing
     * the transaction.
     */
    readonly didDo: (aManager: (nsITransactionManager | null), aTransaction: (nsITransaction | null), aDoResult: number) => void;

    /**
     * Called before a transaction manager calls the Undo() method of
     * a transaction.
     * @param aManager the transaction manager undoing the transaction.
     * @param aTransaction the transaction being undone.
     * @result boolean value returned by listener which indicates
     * its desire to interrupt normal control flow. Listeners should
     * return true if they want to interrupt normal control flow, without
     * throwing an error. Note that listeners can also interrupt normal
     * control flow by throwing an nsresult that indicates an error.
     */
    readonly willUndo: (aManager: (nsITransactionManager | null), aTransaction: (nsITransaction | null)) => boolean;

    /**
     * Called after a transaction manager calls the Undo() method of
     * a transaction.
     * @param aManager the transaction manager undoing the transaction.
     * @param aTransaction the transaction being undone.
     * @param aUndoResult the nsresult returned after undoing the transaction.
     */
    readonly didUndo: (aManager: (nsITransactionManager | null), aTransaction: (nsITransaction | null), aUndoResult: number) => void;

    /**
     * Called before a transaction manager calls the Redo() method of
     * a transaction.
     * @param aManager the transaction manager redoing the transaction.
     * @param aTransaction the transaction being redone.
     * @result boolean value returned by listener which indicates
     * its desire to interrupt normal control flow. Listeners should
     * return true if they want to interrupt normal control flow, without
     * throwing an error. Note that listeners can also interrupt normal
     * control flow by throwing an nsresult that indicates an error.
     */
    readonly willRedo: (aManager: (nsITransactionManager | null), aTransaction: (nsITransaction | null)) => boolean;

    /**
     * Called after a transaction manager calls the Redo() method of
     * a transaction.
     * @param aManager the transaction manager redoing the transaction.
     * @param aTransaction the transaction being redone.
     * @param aRedoResult the nsresult returned after redoing the transaction.
     */
    readonly didRedo: (aManager: (nsITransactionManager | null), aTransaction: (nsITransaction | null), aRedoResult: number) => void;

    /**
     * Called before a transaction manager begins a batch.
     * @param aManager the transaction manager beginning a batch.
     * @result boolean value returned by listener which indicates
     * its desire to interrupt normal control flow. Listeners should
     * return true if they want to interrupt normal control flow, without
     * throwing an error. Note that listeners can also interrupt normal
     * control flow by throwing an nsresult that indicates an error.
     */
    readonly willBeginBatch: (aManager: (nsITransactionManager | null)) => boolean;

    /**
     * Called after a transaction manager begins a batch.
     * @param aManager the transaction manager that began a batch.
     * @param aResult the nsresult returned after beginning a batch.
     */
    readonly didBeginBatch: (aManager: (nsITransactionManager | null), aResult: number) => void;

    /**
     * Called before a transaction manager ends a batch.
     * @param aManager the transaction manager ending a batch.
     * @result boolean value returned by listener which indicates
     * its desire to interrupt normal control flow. Listeners should
     * return true if they want to interrupt normal control flow, without
     * throwing an error. Note that listeners can also interrupt normal
     * control flow by throwing an nsresult that indicates an error.
     */
    readonly willEndBatch: (aManager: (nsITransactionManager | null)) => boolean;

    /**
     * Called after a transaction manager ends a batch.
     * @param aManager the transaction manager ending a batch.
     * @param aResult the nsresult returned after ending a batch.
     */
    readonly didEndBatch: (aManager: (nsITransactionManager | null), aResult: number) => void;

    /**
     * Called before a transaction manager tries to merge
     * a transaction, that was just executed, with the
     * transaction at the top of the undo stack.
     * @param aManager the transaction manager ending a batch.
     * @param aTopTransaction the transaction at the top of the undo stack.
     * @param aTransactionToMerge the transaction to merge.
     * @result boolean value returned by listener which indicates
     * its desire to interrupt normal control flow. Listeners should
     * return true if they want to interrupt normal control flow, without
     * throwing an error. Note that listeners can also interrupt normal
     * control flow by throwing an nsresult that indicates an error.
     */
    readonly willMerge: (aManager: (nsITransactionManager | null), aTopTransaction: (nsITransaction | null), aTransactionToMerge: (nsITransaction | null)) => boolean;

    /**
     * Called after a transaction manager tries to merge
     * a transaction, that was just executed, with the
     * transaction at the top of the undo stack.
     * @param aManager the transaction manager ending a batch.
     * @param aTopTransaction the transaction at the top of the undo stack.
     * @param aTransactionToMerge the transaction to merge.
     * @param aDidMerge true if transaction was merged, else false.
     * @param aMergeResult the nsresult returned after the merge attempt.
     * @param aInterrupt listeners should set this to PR_TRUE if they
     * want to interrupt normal control flow, without throwing an error.
     */
    readonly didMerge: (aManager: (nsITransactionManager | null), aTopTransaction: (nsITransaction | null), aTransactionToMerge: (nsITransaction | null), aDidMerge: boolean, aMergeResult: number) => void;
  }

  export interface nsIUDPMessageRef {
    readonly name: "nsIUDPMessage";
    readonly number: "{afdc743f-9cc0-40d8-b442-695dc54bbb74}";
  }

  export interface nsIUDPMessage extends nsISupports {

    /**
     * nsIUDPMessage
     *
     * This interface is used to encapsulate an incomming UDP message
     */
    /**
     * Address of the source of the message
     */
    readonly fromAddr: (nsINetAddr | null);

    /**
     * Data of the message
     */
    readonly data: IDLACString;

    /**
     * Stream to send a response
     */
    readonly outputStream: (nsIOutputStream | null);

    /**
     * Raw Data of the message
     */
    readonly rawData: IDLjsval;
  }

  export interface nsISearchEngineRef {
    readonly name: "nsISearchEngine";
    readonly number: "{620bd920-0491-48c8-99a8-d6047e64802d}";
  }

  export interface nsISearchEngine extends nsISupports {

    /**
     * Gets a nsISearchSubmission object that contains information about what to
     * send to the search engine, including the URI and postData, if applicable.
     *
     * @param  data
     *         Data to add to the submission object.
     *         i.e. the search terms.
     *
     * @param  responseType [optional]
     *         The MIME type that we'd like to receive in response
     *         to this submission.  If null, will default to "text/html".
     *
     * @param purpose [optional]
     *        A string meant to indicate the context of the search request. This
     *        allows the search service to provide a different nsISearchSubmission
     *        depending on e.g. where the search is triggered in the UI.
     *
     * @returns A nsISearchSubmission object that contains information about what
     *          to send to the search engine.  If no submission can be
     *          obtained for the given responseType, returns null.
     */
    readonly getSubmission: (data: IDLAString, responseType?: IDLAString, purpose?: IDLAString) => (nsISearchSubmission | null);

    /**
     * Adds a parameter to the search engine's submission data. This should only
     * be called on engines created via addEngineWithDetails.
     *
     * @param name
     *        The parameter's name. Must not be null.
     *
     * @param value
     *        The value to pass. If value is "{searchTerms}", it will be
     *        substituted with the user-entered data when retrieving the
     *        submission. Must not be null.
     *
     * @param responseType
     *        Since an engine can have several different request URLs,
     *        differentiated by response types, this parameter selects
     *        a request to add parameters to.  If null, will default
     *        to "text/html"
     *
     * @throws NS_ERROR_FAILURE if the search engine is read-only.
     * @throws NS_ERROR_INVALID_ARG if name or value are null.
     */
    readonly addParam: (name: IDLAString, value: IDLAString, responseType: IDLAString) => void;

    /**
     * Determines whether the engine can return responses in the given
     * MIME type.  Returns true if the engine spec has a URL with the
     * given responseType, false otherwise.
     *
     * @param responseType
     *        The MIME type to check for
     */
    readonly supportsResponseType: (responseType: IDLAString) => boolean;

    /**
     * Returns a string with the URL to an engine's icon matching both width and
     * height. Returns null if icon with specified dimensions is not found.
     *
     * @param width
     *        Width of the requested icon.
     * @param height
     *        Height of the requested icon.
     */
    readonly getIconURLBySize: (width: number, height: number) => IDLAString;

    /**
     * Gets an array of all available icons. Each entry is an object with
     * width, height and url properties. width and height are numeric and
     * represent the icon's dimensions. url is a string with the URL for
     * the icon.
     */
    readonly getIcons: () => IDLjsval;

    /**
     * Opens a speculative connection to the engine's search URI
     * (and suggest URI, if different) to reduce request latency
     *
     * @param  options
     *         An object that must contain the following fields:
     *         {window} the content window for the window performing the search
     *         {originAttributes} the originAttributes for performing the search
     *
     * @throws NS_ERROR_INVALID_ARG if options is omitted or lacks required
     *         elemeents
     */
    readonly speculativeConnect: (options: IDLjsval) => void;

    /**
     * An optional shortcut alias for the engine.
     * When non-null, this is a unique identifier.
     */
    alias: IDLAString;

    /**
     * A text description describing the engine.
     */
    readonly description: IDLAString;

    /**
     * Whether the engine should be hidden from the user.
     */
    hidden: boolean;

    /**
     * A nsIURI corresponding to the engine's icon, stored locally. May be null.
     */
    readonly iconURI: (nsIURI | null);

    /**
     * The display name of the search engine. This is a unique identifier.
     */
    readonly name: IDLAString;

    /**
     * A URL string pointing to the engine's search form.
     */
    readonly searchForm: IDLAString;

    /**
     * An optional unique identifier for this search engine within the context of
     * the distribution, as provided by the distributing entity.
     */
    readonly identifier: IDLAString;

    /**
     * Gets a string representing the hostname from which search results for a
     * given responseType are returned.  This can be specified as an url attribute
     * in the engine description file, but will default to host from the <Url>'s
     * template otherwise.
     *
     * @param  responseType [optional]
     *         The MIME type to get resultDomain for.  Defaults to "text/html".
     *
     * @return the resultDomain for the given responseType.
     */
    readonly getResultDomain: (responseType?: IDLAString) => IDLAString;
  }

  /**
   * When a downgrade is detected UI is presented to the user to ask how to
   * proceed. These flags are used to pass some information to the UI.
   */
  export enum nsIToolkitProfileService_downgradeUIFlags {
    hasSync = 1,
  }

  /**
   * When a downgrade is detected UI is presented to the user to ask how to
   * proceed. These are the possible options the user can choose.
   */
  export enum nsIToolkitProfileService_downgradeUIChoice {
    quit = 0,
    createNewProfile = 1,
  }

  export enum nsIToolkitProfileService_profileManagerResult {
    exit = 0,
    launchWithProfile = 1,
    restart = 2,
  }

  export interface nsIToolkitProfileServiceRef {
    readonly name: "nsIToolkitProfileService";
    readonly number: "{1947899b-f369-48fa-89da-f7c37bb1e6bc}";

    hasSync: 1;

    quit: 0;
    createNewProfile: 1;

    exit: 0;
    launchWithProfile: 1;
    restart: 2;
  }

  export interface nsIToolkitProfileService extends nsISupports {

    /**
     * Tests whether the profile lists on disk have changed since they were
     * loaded. When this is true attempts to flush changes to disk will fail.
     */
    readonly isListOutdated: boolean;

    startWithLastProfile: boolean;

    readonly profiles: (nsISimpleEnumerator | null);

    /**
     * The profile currently in use if it is a named profile. This will return
     * null if the current profile path doesn't match a profile in the database.
     */
    readonly currentProfile: (nsIToolkitProfile | null);

    /**
     * The default profile for this build.
     * On startup this is the profile selected unless overridden by command line
     * arguments or environment variables. Setting this will change the profile
     * used by default the next time the application is started.
     * Attempting to change the default may throw an exception on builds that do
     * not support changing the default profile, such as developer edition.
     */
    defaultProfile: (nsIToolkitProfile | null);

    /**
     * True if during startup a new profile was created for this install instead
     * of using the profile that was the default for older versions.
     */
    readonly createdAlternateProfile: boolean;

    /**
     * Selects or creates a profile to use based on the profiles database, any
     * environment variables and any command line arguments. Will not create
     * a profile if aIsResetting is true. The profile is selected based on this
     * order of preference:
     * * Environment variables (set when restarting the application).
     * * --profile command line argument.
     * * --createprofile command line argument (this also causes the app to exit).
     * * -p command line argument.
     * * A new profile created if this is the first run of the application.
     * * The default profile.
     * aRootDir and aLocalDir are set to the data and local directories for the
     * profile data. If a profile from the database was selected it will be
     * returned in aProfile.
     * This returns true if a new profile was created.
     * This method is primarily for testing. It can be called only once.
     */
    readonly selectStartupProfile: (aArgv: IDLACString[], aIsResetting: boolean, aUpdateChannel: IDLAUTF8String, aLegacyInstallHash: IDLAUTF8String, aRootDir: Out<(nsIFile | null)>, aLocalDir: Out<(nsIFile | null)>, aProfile: Out<(nsIToolkitProfile | null)>) => boolean;

    /**
     * Get a profile by name. This is mainly for use by the -P
     * commandline flag.
     *
     * @param aName The profile name to find.
     */
    readonly getProfileByName: (aName: IDLAUTF8String) => (nsIToolkitProfile | null);

    /**
     * Create a new profile.
     *
     * The profile temporary directory will be chosen based on where the
     * profile directory is located.
     *
     * If a profile with the given name already exists it will be returned
     * instead of creating a new profile.
     *
     * @param aRootDir
     *        The profile directory. May be null, in which case a suitable
     *        default will be chosen based on the profile name.
     * @param aName
     *        The profile name.
     */
    readonly createProfile: (aRootDir: (nsIFile | null), aName: IDLAUTF8String) => (nsIToolkitProfile | null);

    /**
     * Create a new profile with a unique name.
     *
     * As above however the name given will be altered to make it a unique
     * profile name.
     *
     * @param aRootDir
     *        The profile directory. May be null, in which case a suitable
     *        default will be chosen based on the profile name.
     * @param aNamePrefix
     *        The prefix to use for the profile name. If unused this will be
     *        used as the profile name otherwise additional characters will be
     *        added to make the name unique.
     */
    readonly createUniqueProfile: (aRootDir: (nsIFile | null), aNamePrefix: IDLAUTF8String) => (nsIToolkitProfile | null);

    /**
     * Returns the number of profiles.
     * @return the number of profiles.
     */
    readonly profileCount: number;

    /**
     * Flush the profiles list file. This will fail with
     * NS_ERROR_DATABASE_CHANGED if the files on disk have changed since the
     * profiles were loaded.
     */
    readonly flush: () => void;
  }

  export interface nsIWindowProviderRef {
    readonly name: "nsIWindowProvider";
    readonly number: "{e97a3830-15ef-499b-8372-c22d128091c1}";
  }

  /**
   * The nsIWindowProvider interface exists so that the window watcher's default
   * behavior of opening a new window can be easly modified.  When the window
   * watcher needs to open a new window, it will first check with the
   * nsIWindowProvider it gets from the parent window.  If there is no provider
   * or the provider does not provide a window, the window watcher will proceed
   * to actually open a new window.
   */
  export interface nsIWindowProvider extends nsISupports {
  }

  export interface nsIAuthInformationRef {
    readonly name: "nsIAuthInformation";
    readonly number: "{0d73639c-2a92-4518-9f92-28f71fea5f20}";

    /** @name Flags */
    /**
     * This dialog belongs to a network host.
     */
    AUTH_HOST: 1;

    /**
     * This dialog belongs to a proxy.
     */
    AUTH_PROXY: 2;

    /**
     * This dialog needs domain information. The user interface should show a
     * domain field, prefilled with the domain attribute's value.
     */
    NEED_DOMAIN: 4;

    /**
     * This dialog only asks for password information. Authentication prompts
     * SHOULD NOT show a username field. Attempts to change the username field
     * will have no effect. nsIAuthPrompt2 implementations should, however, show
     * its initial value to the user in some form. For example, a paragraph in
     * the dialog might say "Please enter your password for user jsmith at
     * server intranet".
     *
     * This flag is mutually exclusive with #NEED_DOMAIN.
     */
    ONLY_PASSWORD: 8;

    /**
     * We have already tried to log in for this channel
     * (with auth values from a previous promptAuth call),
     * but it failed, so we now ask the user to provide a new, correct login.
     *
     * @see also RFC 2616, Section 10.4.2
     */
    PREVIOUS_FAILED: 16;

    /**
     * A cross-origin sub-resource requests an authentication.
     * The message presented to users must reflect that.
     */
    CROSS_ORIGIN_SUB_RESOURCE: 32;
  }

  /**
   * A object that hold authentication information. The caller of
   * nsIAuthPrompt2::promptUsernameAndPassword or
   * nsIAuthPrompt2::promptPasswordAsync provides an object implementing this
   * interface; the prompt implementation can then read the values here to prefill
   * the dialog. After the user entered the authentication information, it should
   * set the attributes of this object to indicate to the caller what was entered
   * by the user.
   */
  export interface nsIAuthInformation extends nsISupports {

    /**
     * Flags describing this dialog. A bitwise OR of the flag values
     * above.
     *
     * It is possible that neither #AUTH_HOST nor #AUTH_PROXY are set.
     *
     * Auth prompts should ignore flags they don't understand; especially, they
     * should not throw an exception because of an unsupported flag.
     */
    readonly flags: number;

    /**
     * The server-supplied realm of the authentication as defined in RFC 2617.
     * Can be the empty string if the protocol does not support realms.
     * Otherwise, this is a human-readable string like "Secret files".
     */
    readonly realm: IDLAString;

    /**
     * The authentication scheme used for this request, if applicable. If the
     * protocol for this authentication does not support schemes, this will be
     * the empty string. Otherwise, this will be a string such as "basic" or
     * "digest". This string will always be in lowercase.
     */
    readonly authenticationScheme: IDLAUTF8String;

    /**
     * The initial value should be used to prefill the dialog or be shown
     * in some other way to the user.
     * On return, this parameter should contain the username entered by
     * the user.
     * This field can only be changed if the #ONLY_PASSWORD flag is not set.
     */
    username: IDLAString;

    /**
     * The initial value should be used to prefill the dialog or be shown
     * in some other way to the user.
     * The password should not be shown in clear.
     * On return, this parameter should contain the password entered by
     * the user.
     */
    password: IDLAString;

    /**
     * The initial value should be used to prefill the dialog or be shown
     * in some other way to the user.
     * On return, this parameter should contain the domain entered by
     * the user.
     * This attribute is only used if flags include #NEED_DOMAIN.
     */
    domain: IDLAString;
  }

  export interface nsIX509CertDBRef {
    readonly name: "nsIX509CertDB";
    readonly number: "{5c16cd9b-5a73-47f1-ab0f-11ede7495cce}";

    /**
     *  Constants that define which usages a certificate
     *  is trusted for.
     */
    UNTRUSTED: 0;

    TRUSTED_SSL: 1;

    TRUSTED_EMAIL: 2;

    Success: 0;

    ERROR_UNKNOWN: 1;

    ERROR_PKCS12_NOSMARTCARD_EXPORT: 2;

    ERROR_PKCS12_RESTORE_FAILED: 3;

    ERROR_PKCS12_BACKUP_FAILED: 4;

    ERROR_PKCS12_CERT_COLLISION: 5;

    ERROR_BAD_PASSWORD: 6;

    ERROR_DECODE_ERROR: 7;

    ERROR_PKCS12_DUPLICATE_DATA: 8;

    /**
     *  Verifies the signature on the given JAR file to verify that it has a
     *  valid signature.  To be considered valid, there must be exactly one
     *  signature on the JAR file and that signature must have signed every
     *  entry. Further, the signature must come from a certificate that
     *  is trusted for code signing.
     *
     *  On success, NS_OK, a nsIZipReader, and the trusted certificate that
     *  signed the JAR are returned.
     *
     *  On failure, an error code is returned.
     *
     *  This method returns a nsIZipReader, instead of taking an nsIZipReader
     *  as input, to encourage users of the API to verify the signature as the
     *  first step in opening the JAR.
     */
    AppXPCShellRoot: 6;

    AddonsPublicRoot: 7;

    AddonsStageRoot: 8;

    FLAG_LOCAL_ONLY: 1;

    FLAG_MUST_BE_EV: 2;
  }

  /**
   * This represents a service to access and manipulate
   * X.509 certificates stored in a database.
   */
  export interface nsIX509CertDB extends nsISupports {

    /**
     *  Will find a certificate based on its dbkey
     *  retrieved by getting the dbKey attribute of
     *  the certificate.
     *
     *  @param aDBkey Database internal key, as obtained using
     *                attribute dbkey in nsIX509Cert.
     */
    readonly findCertByDBKey: (aDBkey: IDLACString) => (nsIX509Cert | null);

    /**
     *  Use this to import a stream sent down as a mime type into
     *  the certificate database on the default token.
     *  The stream may consist of one or more certificates.
     *
     *  @param data The raw data to be imported
     *  @param length The length of the data to be imported
     *  @param type The type of the certificate, see constants in nsIX509Cert
     *  @param ctx A UI context.
     */
    readonly importCertificates: (data: number[], length: number, type: number, ctx: (nsIInterfaceRequestor | null)) => void;

    /**
     *  Import another person's email certificate into the database.
     *
     *  @param data The raw data to be imported
     *  @param length The length of the data to be imported
     *  @param ctx A UI context.
     */
    readonly importEmailCertificate: (data: number[], length: number, ctx: (nsIInterfaceRequestor | null)) => void;

    /**
     *  Import a personal certificate into the database, assuming
     *  the database already contains the private key for this certificate.
     *
     *  @param data The raw data to be imported
     *  @param length The length of the data to be imported
     *  @param ctx A UI context.
     */
    readonly importUserCertificate: (data: number[], length: number, ctx: (nsIInterfaceRequestor | null)) => void;

    /**
     *  Delete a certificate stored in the database.
     *
     *  @param aCert Delete this certificate.
     */
    readonly deleteCertificate: (aCert: (nsIX509Cert | null)) => void;

    /**
     *  Modify the trust that is stored and associated to a certificate within
     *  a database. Separate trust is stored for
     *  One call manipulates the trust for one trust type only.
     *  See the trust type constants defined within this interface.
     *
     *  @param cert Change the stored trust of this certificate.
     *  @param type The type of the certificate. See nsIX509Cert.
     *  @param trust A bitmask. The new trust for the possible usages.
     *               See the trust constants defined within this interface.
     */
    readonly setCertTrust: (cert: (nsIX509Cert | null), type: number, trust: number) => void;

    /**
     * @param cert        The certificate for which to modify trust.
     * @param trustString decoded by CERT_DecodeTrustString. 3 comma separated
     *                    characters, indicating SSL, Email, and Object signing
     *                    trust. The object signing trust flags are effectively
     *                    ignored by gecko, but they still must be specified (at
     *                    least by a final trailing comma) because this argument
     *                    is passed to CERT_DecodeTrustString.
     */
    readonly setCertTrustFromString: (cert: (nsIX509Cert | null), trustString: IDLACString) => void;

    /**
     *  Query whether a certificate is trusted for a particular use.
     *
     *  @param cert Obtain the stored trust of this certificate.
     *  @param certType The type of the certificate. See nsIX509Cert.
     *  @param trustType A single bit from the usages constants defined
     *                   within this interface.
     *
     *  @return Returns true if the certificate is trusted for the given use.
     */
    readonly isCertTrusted: (cert: (nsIX509Cert | null), certType: number, trustType: number) => boolean;

    /**
     *  Import certificate(s) from file
     *
     *  @param aFile Identifies a file that contains the certificate
     *               to be imported.
     *  @param aType Describes the type of certificate that is going to
     *               be imported. See type constants in nsIX509Cert.
     */
    readonly importCertsFromFile: (aFile: (nsIFile | null), aType: number) => void;

    /**
     *  Import a PKCS#12 file containing cert(s) and key(s) into the database.
     *
     *  @param aFile Identifies a file that contains the data to be imported.
     *  @param password The password used to protect the file.
     *  @return Success or the specific error code on failure.  The return
     *          values are defined in this file.
     */
    readonly importPKCS12File: (aFile: (nsIFile | null), aPassword: IDLAString) => number;

    /**
     *  Export a set of certs and keys from the database to a PKCS#12 file.
     *
     *  @param aFile Identifies a file that will be filled with the data to be
     *               exported.
     *  @param count The number of certificates to be exported.
     *  @param aCerts The array of all certificates to be exported.
     *  @param password The password used to protect the file.
     *  @return Success or the specific error code on failure
     */
    readonly exportPKCS12File: (aFile: (nsIFile | null), aCerts: (nsIX509Cert | null)[], aPassword: IDLAString) => number;

    readonly constructX509FromBase64: (base64: IDLACString) => (nsIX509Cert | null);

    readonly constructX509: (certDER: number[]) => (nsIX509Cert | null);

    readonly openSignedAppFileAsync: (trustedRoot: number, aJarFile: (nsIFile | null), callback: (nsIOpenSignedAppFileCallback | nsIOpenSignedAppFileCallbackFunction | null)) => void;

    readonly addCert: (certDER: IDLACString, trust: IDLACString) => (nsIX509Cert | null);

    readonly asyncVerifyCertAtTime: (aCert: (nsIX509Cert | null), aUsage: number, aFlags: number, aHostname: IDLACString, aTime: number, aCallback: (nsICertVerificationCallback | nsICertVerificationCallbackFunction | null)) => void;

    readonly clearOCSPCache: () => void;

    readonly addCertFromBase64: (base64: IDLACString, trust: IDLACString) => (nsIX509Cert | null);

    readonly getCerts: () => (nsIX509Cert | null)[];

    /**
     * Encode the list of certificates as a PKCS#7 SignedData structure. No data
     * is actually signed - this is merely a way of exporting a collection of
     * certificates.
     */
    readonly asPKCS7Blob: (certList: (nsIX509Cert | null)[]) => IDLACString;
  }

  export interface nsITypeAheadFindRef {
    readonly name: "nsITypeAheadFind";
    readonly number: "{ae501e28-c57f-4692-ac74-410e1bed98b7}";

    /******************************* Constants *******************************/
    FIND_INITIAL: 0;

    FIND_NEXT: 1;

    FIND_PREVIOUS: 2;

    FIND_FIRST: 3;

    FIND_LAST: 4;

    FIND_FOUND: 0;

    FIND_NOTFOUND: 1;

    FIND_WRAPPED: 2;

    FIND_PENDING: 3;
  }

  /****************************** nsTypeAheadFind ******************************/
  export interface nsITypeAheadFind extends nsISupports {

    /****************************** Initializer ******************************/
    readonly init: (aDocShell: (nsIDocShell | null)) => void;

    /***************************** Core functions ****************************/
    readonly find: (aSearchString: IDLAString, aLinksOnly: boolean, aMode: number, aDontIterateFrames: boolean) => number;

    readonly getFoundRange: () => WebIDL.Range;

    /**************************** Helper functions ***************************/
    readonly setDocShell: (aDocShell: (nsIDocShell | null)) => void;

    readonly setSelectionModeAndRepaint: (toggle: number) => void;

    readonly collapseSelection: () => void;

    readonly isRangeVisible: (aRange: WebIDL.Range, aMustBeInViewPort: boolean) => boolean;

    readonly isRangeRendered: (aRange: WebIDL.Range) => boolean;

    /******************************* Attributes ******************************/
    readonly searchString: IDLAString;

    caseSensitive: boolean;

    matchDiacritics: boolean;

    entireWord: boolean;

    readonly foundLink: WebIDL.Element;

    readonly foundEditable: WebIDL.Element;

    readonly currentWindow: (mozIDOMWindow | null);
  }

  export interface nsIRequestRef {
    readonly name: "nsIRequest";
    readonly number: "{ef6bfbd2-fd46-48d8-96b7-9f8f0fd387fe}";

    /**
     * Mask defining the bits reserved for nsIRequest LoadFlags
     */
    LOAD_REQUESTMASK: 65535;

    /**************************************************************************
     * Listed below are the various load flags which may be or'd together.
     */
    /**
     * No special load flags:
     */
    LOAD_NORMAL: 0;

    /**
     * Do not deliver status notifications to the nsIProgressEventSink and
     * do not block the loadgroup from completing (should this load belong to one).
     * Note: Progress notifications will still be delivered.
     */
    LOAD_BACKGROUND: 1;

    /**
     * This flag marks the request as being made to load the data for an html
     * <object> tag. This means that the LOAD_DOCUMENT_URI flag may be set after
     * the channel has been provided with the MIME type.
     */
    LOAD_HTML_OBJECT_DATA: 2;

    /**
     * This flag marks the request as belonging to a document that requires access
     * to the document.cookies API.
     */
    LOAD_DOCUMENT_NEEDS_COOKIE: 4;

    /**
     * Set this flag to disable TRR for this request.
     */
    LOAD_DISABLE_TRR: 8;

    /**************************************************************************
     * The following flags control the flow of data into the cache.
     */
    /**
     * This flag prevents caching of any kind.  It does not, however, prevent
     * cached content from being used to satisfy this request.
     */
    INHIBIT_CACHING: 128;

    /**
     * This flag prevents caching on disk (or other persistent media), which
     * may be needed to preserve privacy.
     */
    INHIBIT_PERSISTENT_CACHING: 256;

    /**************************************************************************
     * The following flags control what happens when the cache contains data
     * that could perhaps satisfy this request.  They are listed in descending
     * order of precidence.
     */
    /**
     * Force an end-to-end download of content data from the origin server.
     * This flag is used for a shift-reload.
     */
    LOAD_BYPASS_CACHE: 512;

    /**
     * Attempt to force a load from the cache, bypassing ALL validation logic
     * (note: this is stronger than VALIDATE_NEVER, which still validates for
     * certain conditions).
     *
     * If the resource is not present in cache, it will be loaded from the
     * network.  Combine this flag with LOAD_ONLY_FROM_CACHE if you wish to
     * perform cache-only loads without validation checks.
     *
     * This flag is used when browsing via history.  It is not recommended for
     * normal browsing as it may likely violate reasonable assumptions made by
     * the server and confuse users.
     */
    LOAD_FROM_CACHE: 1024;

    /**
     * The following flags control the frequency of cached content validation
     * when neither LOAD_BYPASS_CACHE or LOAD_FROM_CACHE are set.  By default,
     * cached content is automatically validated if necessary before reuse.
     *
     * VALIDATE_ALWAYS forces validation of any cached content independent of
     * its expiration time (unless it is https with Cache-Control: immutable)
     *
     * VALIDATE_NEVER disables validation of cached content, unless it arrived
     * with the "Cache: no-store" header, or arrived via HTTPS with the
     * "Cache: no-cache" header.
     *
     * VALIDATE_ONCE_PER_SESSION disables validation of expired content,
     * provided it has already been validated (at least once) since the start
     * of this session.
     *
     * NOTE TO IMPLEMENTORS:
     *   These flags are intended for normal browsing, and they should therefore
     *   not apply to content that must be validated before each use.  Consider,
     *   for example, a HTTP response with a "Cache-control: no-cache" header.
     *   According to RFC2616, this response must be validated before it can
     *   be taken from a cache.  Breaking this requirement could result in
     *   incorrect and potentially undesirable side-effects.
     */
    VALIDATE_ALWAYS: 2048;

    VALIDATE_NEVER: 4096;

    VALIDATE_ONCE_PER_SESSION: 8192;

    /**
     * When set, this flag indicates that no user-specific data should be added
     * to the request when opened. This means that things like authorization
     * tokens or cookie headers should not be added.
     */
    LOAD_ANONYMOUS: 16384;

    /**
     * When set, this flag indicates that caches of network connections,
     * particularly HTTP persistent connections, should not be used.
     * Use this together with LOAD_INITIAL_DOCUMENT_URI as otherwise it has no
     * effect.
     */
    LOAD_FRESH_CONNECTION: 32768;
  }

  /**
   * nsIRequest
   */
  export interface nsIRequest extends nsISupports {

    /**
     * The name of the request.  Often this is the URI of the request.
     */
    readonly name: IDLAUTF8String;

    /**
     * Indicates whether the request is pending. nsIRequest::isPending is
     * true when there is an outstanding asynchronous event that will make
     * the request no longer be pending.  Requests do not necessarily start
     * out pending; in some cases, requests have to be explicitly initiated
     * (e.g. nsIChannel implementations are only pending once asyncOpen
     * returns successfully).
     *
     * Requests can become pending multiple times during their lifetime.
     *
     * @return TRUE if the request has yet to reach completion.
     * @return FALSE if the request has reached completion (e.g., after
     *   OnStopRequest has fired).
     * @note Suspended requests are still considered pending.
     */
    readonly isPending: () => boolean;

    /**
     * The error status associated with the request.
     */
    readonly status: number;

    /**
     * Cancels the current request.  This will close any open input or
     * output streams and terminate any async requests.  Users should
     * normally pass NS_BINDING_ABORTED, although other errors may also
     * be passed.  The error passed in will become the value of the
     * status attribute.
     *
     * Implementations must not send any notifications (e.g. via
     * nsIRequestObserver) synchronously from this function. Similarly,
     * removal from the load group (if any) must also happen asynchronously.
     *
     * Requests that use nsIStreamListener must not call onDataAvailable
     * anymore after cancel has been called.
     *
     * @param aStatus the reason for canceling this request.
     *
     * NOTE: most nsIRequest implementations expect aStatus to be a
     * failure code; however, some implementations may allow aStatus to
     * be a success code such as NS_OK.  In general, aStatus should be
     * a failure code.
     */
    readonly cancel: (aStatus: number) => void;

    /**
     * Suspends the current request.  This may have the effect of closing
     * any underlying transport (in order to free up resources), although
     * any open streams remain logically opened and will continue delivering
     * data when the transport is resumed.
     *
     * Calling cancel() on a suspended request must not send any
     * notifications (such as onstopRequest) until the request is resumed.
     *
     * NOTE: some implementations are unable to immediately suspend, and
     * may continue to deliver events already posted to an event queue. In
     * general, callers should be capable of handling events even after
     * suspending a request.
     */
    readonly suspend: () => void;

    /**
     * Resumes the current request.  This may have the effect of re-opening
     * any underlying transport and will resume the delivery of data to
     * any open streams.
     */
    readonly resume: () => void;

    /**
     * The load group of this request.  While pending, the request is a
     * member of the load group.  It is the responsibility of the request
     * to implement this policy.
     */
    loadGroup: (nsILoadGroup | null);

    /**
     * The load flags of this request.  Bits 0-15 are reserved.
     *
     * When added to a load group, this request's load flags are merged with
     * the load flags of the load group.
     */
    loadFlags: number;
  }

  export interface mozILocalizationRef {
    readonly name: "mozILocalization";
    readonly number: "{7d468600-551f-4fe0-98c9-92a53b63ec8d}";
  }

  export interface mozILocalization extends nsISupports {

    readonly addResourceIds: (resourceIds: IDLAString[], aEager: boolean) => number;

    readonly removeResourceIds: (resourceIds: IDLAString[]) => number;

    readonly onChange: () => void;

    readonly formatMessages: (aKeys: IDLjsval[]) => IDLPromise;

    readonly formatValues: (aKeys: IDLjsval[]) => IDLPromise;

    readonly formatValue: (aId: IDLAString, aArgs?: IDLjsval) => IDLPromise;

    readonly formatMessagesSync: (aKeys: IDLjsval[]) => IDLjsval[];

    readonly setIsSync: (isSync: boolean) => void;
  }

  export interface nsIURIFixupRef {
    readonly name: "nsIURIFixup";
    readonly number: "{1da7e9d4-620b-4949-849a-1cd6077b1b2d}";

    /** No fixup flags. */
    FIXUP_FLAG_NONE: 0;

    /**
     * Allow the fixup to use a keyword lookup service to complete the URI.
     * The fixup object implementer should honour this flag and only perform
     * any lengthy keyword (or search) operation if it is set.
     */
    FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP: 1;

    /**
     * Tell the fixup to make an alternate URI from the input URI, for example
     * to turn foo into www.foo.com.
     */
    FIXUP_FLAGS_MAKE_ALTERNATE_URI: 2;

    FIXUP_FLAG_PRIVATE_CONTEXT: 4;

    FIXUP_FLAG_FIX_SCHEME_TYPOS: 8;
  }

  /**
   * Interface implemented by objects capable of fixing up strings into URIs
   */
  export interface nsIURIFixup extends nsISupports {

    /**
     * Converts an internal URI (e.g. one that has a username and password in
     * it) into one which we can expose to the user, for example on the URL bar.
     *
     * @param  aURI       The URI to be converted
     * @return nsIURI     The converted, exposable URI
     * @throws NS_ERROR_MALFORMED_URI when the exposable portion of aURI is malformed
     * @throws NS_ERROR_UNKNOWN_PROTOCOL when we can't get a protocol handler service
     *         for the URI scheme.
     */
    readonly createExposableURI: (aURI: (nsIURI | null)) => (nsIURI | null);

    /**
     * Converts the specified string into a URI, first attempting
     * to correct any errors in the syntax or other vagaries. Returns
     * a wellformed URI or nullptr if it can't.
     *
     * @param aURIText    Candidate URI.
     * @param aFixupFlags Flags that govern ways the URI may be fixed up.
     * @param aPostData   The POST data to submit with the returned
     *                    URI (see nsISearchSubmission).
     */
    readonly createFixupURI: (aURIText: IDLAUTF8String, aFixupFlags: number, aPostData?: Out<(nsIInputStream | null)>) => (nsIURI | null);

    /**
     * Same as createFixupURI, but returns information about what it corrected
     * (e.g. whether we could rescue the URI or "just" generated a keyword
     * search URI instead).
     *
     * @param aURIText    Candidate URI.
     * @param aFixupFlags Flags that govern ways the URI may be fixed up.
     * @param aPostData   The POST data to submit with the returned
     *                    URI (see nsISearchSubmission).
     */
    readonly getFixupURIInfo: (aURIText: IDLAUTF8String, aFixupFlags: number, aPostData?: Out<(nsIInputStream | null)>) => (nsIURIFixupInfo | null);

    /**
     * Convert load flags from nsIWebNavigation to URI fixup flags for use in
     * createFixupURI or getFixupURIInfo.
     *
     * @param aURIText       Candidate URI; used for determining whether to
     *                       allow keyword lookups.
     * @param aDocShellFlags Load flags from nsIDocShell to convert.
     */
    readonly webNavigationFlagsToFixupFlags: (aURIText: IDLAUTF8String, aDocShellFlags: number) => number;

    /**
     * Converts the specified keyword string into a URI.  Note that it's the
     * caller's responsibility to check whether keywords are enabled and
     * whether aKeyword is a sensible keyword.
     *
     * @param aKeyword  The keyword string to convert into a URI
     * @param aIsPrivateContext Whether this is invoked from a private context.
     * @param aPostData The POST data to submit to the returned URI
     *                  (see nsISearchSubmission).
     *
     * @throws NS_ERROR_FAILURE if the resulting URI requires submission of POST
     *         data and aPostData is null.
     */
    readonly keywordToURI: (aKeyword: IDLAUTF8String, aIsPrivateContext?: boolean, aPostData?: Out<(nsIInputStream | null)>) => (nsIURIFixupInfo | null);

    /**
     * Returns true if the specified domain is whitelisted and false otherwise.
     * A whitelisted domain is relevant when we have a single word and can't be
     * sure whether to treat the word as a host name or should instead be
     * treated as a search term.
     *
     * @param aDomain A domain name to query.
     * @param aDotPos The position of the first '.' character in aDomain, or
     *                -1 if no '.' character exists.
     */
    readonly isDomainWhitelisted: (aDomain: IDLAUTF8String, aDotPos: number) => boolean;
  }

  export interface nsIOutputStreamRef {
    readonly name: "nsIOutputStream";
    readonly number: "{0d0acd2a-61b4-11d4-9877-00c04fa0cf4a}";
  }

  export interface nsIOutputStream extends nsISupports {

    /**
     * nsIOutputStream
     *
     * An interface describing a writable stream of data.  An output stream may be
     * "blocking" or "non-blocking" (see the IsNonBlocking method).  A blocking
     * output stream may suspend the calling thread in order to satisfy a call to
     * Close, Flush, Write, WriteFrom, or WriteSegments.  A non-blocking output
     * stream, on the other hand, must not block the calling thread of execution.
     *
     * NOTE: blocking output streams are often written to on a background thread to
     * avoid locking up the main application thread.  For this reason, it is
     * generally the case that a blocking output stream should be implemented using
     * thread- safe AddRef and Release.
     */
    /**
     * Close the stream. Forces the output stream to flush any buffered data.
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if unable to flush without blocking
     *   the calling thread (non-blocking mode only)
     */
    readonly close: () => void;

    /**
     * Flush the stream.
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if unable to flush without blocking
     *   the calling thread (non-blocking mode only)
     */
    readonly flush: () => void;

    /**
     * Write data into the stream.
     *
     * @param aBuf the buffer containing the data to be written
     * @param aCount the maximum number of bytes to be written
     *
     * @return number of bytes written (may be less than aCount)
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if writing to the output stream would
     *   block the calling thread (non-blocking mode only)
     * @throws <other-error> on failure
     */
    readonly write: (aBuf: string, aCount: number) => number;

    /**
     * Writes data into the stream from an input stream.
     *
     * @param aFromStream the stream containing the data to be written
     * @param aCount the maximum number of bytes to be written
     *
     * @return number of bytes written (may be less than aCount)
     *
     * @throws NS_BASE_STREAM_WOULD_BLOCK if writing to the output stream would
     *    block the calling thread (non-blocking mode only). This failure
     *    means no bytes were transferred.
     * @throws <other-error> on failure
     *
     * NOTE: This method is defined by this interface in order to allow the
     * output stream to efficiently copy the data from the input stream into
     * its internal buffer (if any). If this method was provided as an external
     * facility, a separate char* buffer would need to be used in order to call
     * the output stream's other Write method.
     */
    readonly writeFrom: (aFromStream: (nsIInputStream | null), aCount: number) => number;

    /**
     * @return true if stream is non-blocking
     *
     * NOTE: writing to a blocking output stream will block the calling thread
     * until all given data can be consumed by the stream.
     *
     * NOTE: a non-blocking output stream may implement nsIAsyncOutputStream to
     * provide consumers with a way to wait for the stream to accept more data
     * once its write method is unable to accept any data without blocking.
     */
    readonly isNonBlocking: () => boolean;
  }

  export interface nsIWebVTTListenerRef {
    readonly name: "nsIWebVTTListener";
    readonly number: "{8a2d7780-2045-4a29-99f4-df15cae5fc49}";
  }

  /**
   * Listener for a JS WebVTT parser (vtt.js).
   */
  export interface nsIWebVTTListener extends nsISupports {

    /**
     * Is called when the WebVTTParser successfully parses a WebVTT cue.
     *
     * @param cue An object representing the data of a parsed WebVTT cue.
     */
    readonly onCue: (cue: IDLjsval) => void;

    /**
     * Is called when the WebVTT parser successfully parses a WebVTT region.
     *
     * @param region An object representing the data of a parsed
     *               WebVTT region.
     */
    readonly onRegion: (region: IDLjsval) => void;

    /**
     * Is called when the WebVTT parser encounters a parsing error.
     *
     * @param error The error code of the ParserError the occured.
     */
    readonly onParsingError: (errorCode: number) => void;
  }

  export interface nsIOpenSignedAppFileCallbackRef {
    readonly name: "nsIOpenSignedAppFileCallback";
    readonly number: "{fc2b60e5-9a07-47c2-a2cd-b83b68a660ac}";
  }

  type nsIOpenSignedAppFileCallbackFunction = (rv: number, aZipReader: (nsIZipReader | null), aSignerCert: (nsIX509Cert | null)) => void;

  export interface nsIOpenSignedAppFileCallback extends nsISupports {

    readonly openSignedAppFileFinished: (rv: number, aZipReader: (nsIZipReader | null), aSignerCert: (nsIX509Cert | null)) => void;
  }

  export interface nsIDashboardRef {
    readonly name: "nsIDashboard";
    readonly number: "{c79eb3c6-091a-45a6-8544-5a8d1ab79537}";
  }

  export interface nsIDashboard extends nsISupports {

    readonly requestSockets: (cb: (nsINetDashboardCallback | nsINetDashboardCallbackFunction | null)) => void;

    readonly requestHttpConnections: (cb: (nsINetDashboardCallback | nsINetDashboardCallbackFunction | null)) => void;

    readonly requestWebsocketConnections: (cb: (nsINetDashboardCallback | nsINetDashboardCallbackFunction | null)) => void;

    readonly requestDNSInfo: (cb: (nsINetDashboardCallback | nsINetDashboardCallbackFunction | null)) => void;

    readonly requestConnection: (aHost: IDLACString, aPort: number, aProtocol: string, aTimeout: number, cb: (nsINetDashboardCallback | nsINetDashboardCallbackFunction | null)) => void;

    enableLogging: boolean;

    readonly requestDNSLookup: (aHost: IDLACString, cb: (nsINetDashboardCallback | nsINetDashboardCallbackFunction | null)) => void;

    /**
     * Asyncly returns stats regarding the "Race Cache With Network" feature.
     */
    readonly requestRcwnStats: (cb: (nsINetDashboardCallback | nsINetDashboardCallbackFunction | null)) => void;

    readonly getLogPath: () => IDLAUTF8String;
  }

  export interface nsIDomainPolicyRef {
    readonly name: "nsIDomainPolicy";
    readonly number: "{82b24a20-6701-4d40-a0f9-f5dc7321b555}";
  }

  export interface nsIDomainPolicy extends nsISupports {

    readonly blocklist: (nsIDomainSet | null);

    readonly superBlocklist: (nsIDomainSet | null);

    readonly allowlist: (nsIDomainSet | null);

    readonly superAllowlist: (nsIDomainSet | null);

    readonly deactivate: () => void;
  }

  export interface nsIPresentationSessionListenerRef {
    readonly name: "nsIPresentationSessionListener";
    readonly number: "{7dd48df8-8f8c-48c7-ac37-7b9fd1acf2f8}";

    STATE_CONNECTING: 0;

    STATE_CONNECTED: 1;

    STATE_CLOSED: 2;

    STATE_TERMINATED: 3;
  }

  export interface nsIPresentationSessionListener extends nsISupports {

    readonly notifyStateChange: (sessionId: IDLAString, state: number, reason: number) => void;

    readonly notifyMessage: (sessionId: IDLAString, data: IDLACString, isBinary: boolean) => void;
  }

  export interface nsIHTMLEditorRef {
    readonly name: "nsIHTMLEditor";
    readonly number: "{87ee993e-985f-4a43-a974-0d9512da2fb0}";

    eLeft: 0;

    eCenter: 1;

    eRight: 2;

    eJustify: 3;
  }

  export interface nsIHTMLEditor extends nsISupports {

    /**
     * SetInlineProperty() sets the aggregate properties on the current selection
     *
     * @param aProperty   the property to set on the selection
     * @param aAttribute  the attribute of the property, if applicable.
     *                    May be null.
     *                    Example: aProperty="font", aAttribute="color"
     * @param aValue      if aAttribute is not null, the value of the attribute.
     *                    May be null.
     *                    Example: aProperty="font", aAttribute="color",
     *                             aValue="0x00FFFF"
     */
    readonly setInlineProperty: (aProperty: IDLAString, aAttribute: IDLAString, aValue: IDLAString) => void;

    /**
     * getInlineProperty() gets aggregate properties of the current selection.
     * All object in the current selection are scanned and their attributes are
     * represented in a list of Property object.
     *
     * @param aProperty   the property to get on the selection
     * @param aAttribute  the attribute of the property, if applicable.
     *                    May be null.
     *                    Example: aProperty="font", aAttribute="color"
     * @param aValue      if aAttribute is not null, the value of the attribute.
     *                    May be null.
     *                    Example: aProperty="font", aAttribute="color",
     *                             aValue="0x00FFFF"
     * @param aFirst      [OUT] PR_TRUE if the first text node in the
     *                          selection has the property
     * @param aAny        [OUT] PR_TRUE if any of the text nodes in the
     *                          selection have the property
     * @param aAll        [OUT] PR_TRUE if all of the text nodes in the
     *                          selection have the property
     */
    readonly getInlineProperty: (aProperty: IDLAString, aAttribute: IDLAString, aValue: IDLAString, aFirst: Out<boolean>, aAny: Out<boolean>, aAll: Out<boolean>) => void;

    readonly getInlinePropertyWithAttrValue: (aProperty: IDLAString, aAttribute: IDLAString, aValue: IDLAString, aFirst: Out<boolean>, aAny: Out<boolean>, aAll: Out<boolean>) => IDLAString;

    /**
     * removeAllInlineProperties() deletes all the inline properties from all
     * text in the current selection.
     */
    readonly removeAllInlineProperties: () => void;

    /**
     * removeInlineProperty() removes a property which changes inline style of
     * text.  E.g., bold, italic, super and sub.
     *
     * @param aProperty   Tag name whcih represents the inline style you want to
     *                    remove.  E.g., "strong", "b", etc.
     *                    If "href", <a> element which has href attribute will be
     *                    removed.
     *                    If "name", <a> element which has non-empty name
     *                    attribute will be removed.
     * @param aAttribute  If aProperty is "font", aAttribute should be "face",
     *                    "size", "color" or "bgcolor".
     */
    readonly removeInlineProperty: (aProperty: IDLAString, aAttribute: IDLAString) => void;

    /**
     *  Increase font size for text in selection by 1 HTML unit
     *  All existing text is scanned for existing <FONT SIZE> attributes
     *  so they will be incremented instead of inserting new <FONT> tag
     */
    readonly increaseFontSize: () => void;

    /**
     *  Decrease font size for text in selection by 1 HTML unit
     *  All existing text is scanned for existing <FONT SIZE> attributes
     *  so they will be decreased instead of inserting new <FONT> tag
     */
    readonly decreaseFontSize: () => void;

    /**
     * Tests if a node is a BLOCK element according the the HTML 4.0 DTD.
     *   This does NOT consider CSS effect on display type
     *
     * @param aNode      the node to test
     */
    readonly nodeIsBlock: (node: WebIDL.Node) => boolean;

    /**
     * Insert some HTML source at the current location
     *
     * @param aInputString   the string to be inserted
     */
    readonly insertHTML: (aInputString: IDLAString) => void;

    /**
     * Paste the text in the OS clipboard at the cursor position, replacing
     * the selected text (if any), but strip out any HTML styles and formatting
     */
    readonly pasteNoFormatting: (aSelectionType: number) => void;

    /**
     *  Rebuild the entire document from source HTML
     *  Needed to be able to edit HEAD and other outside-of-BODY content
     *
     *  @param aSourceString   HTML source string of the entire new document
     */
    readonly rebuildDocumentFromSource: (aSourceString: IDLAString) => void;

    /**
     * Insert an element, which may have child nodes, at the selection
     * Used primarily to insert a new element for various insert element dialogs,
     *   but it enforces the HTML 4.0 DTD "CanContain" rules, so it should
     *   be useful for other elements.
     *
     * @param aElement           The element to insert
     * @param aDeleteSelection   Delete the selection before inserting
     *     If aDeleteSelection is PR_FALSE, then the element is inserted
     *     after the end of the selection for all element except
     *     Named Anchors, which insert before the selection
     */
    readonly insertElementAtSelection: (aElement: WebIDL.Element, aDeleteSelection: boolean) => void;

    /**
     *   Set the BaseURL for the document to the current URL
     *     but only if the page doesn't have a <base> tag
     *   This should be done after the document URL has changed,
     *     such as after saving a file
     *   This is used as base for relativizing link and image urls
     */
    readonly updateBaseURL: () => void;

    /**
     * Set the selection at the suppled element
     *
     * @param aElement   An element in the document
     */
    readonly selectElement: (aElement: WebIDL.Element) => void;

    /**
     * Create a collapsed selection just after aElement
     *
     * XXX could we parameterize SelectElement(before/select/after>?
     *
     * The selection is set to parent-of-aElement with an
     *   offset 1 greater than aElement's offset
     *   but it enforces the HTML 4.0 DTD "CanContain" rules, so it should
     *   be useful for other elements.
     *
     * @param aElement  An element in the document
     */
    readonly setCaretAfterElement: (aElement: WebIDL.Element) => void;

    /**
     * SetParagraphFormat       Insert a block paragraph tag around selection
     * @param aParagraphFormat  "p", "h1" to "h6", "address", "pre", or "blockquote"
     */
    readonly setParagraphFormat: (aParagraphFormat: IDLAString) => void;

    /**
     * getParagraphState returns what block tag paragraph format is in
     * the selection.
     * @param aMixed     True if there is more than one format
     * @return           Name of block tag. "" is returned for none.
     */
    readonly getParagraphState: (aMixed: Out<boolean>) => IDLAString;

    /**
     * getFontFaceState returns what font face is in the selection.
     * @param aMixed    True if there is more than one font face
     * @return          Name of face.  Note: "tt" is returned for
     *                  tt tag.  "" is returned for none.
     */
    readonly getFontFaceState: (aMixed: Out<boolean>) => IDLAString;

    /**
     * getBackgroundColorState returns what the background color of the selection.
     * @param aMixed     True if there is more than one font color
     * @return           Color string. "" is returned for none.
     */
    readonly getBackgroundColorState: (aMixed: Out<boolean>) => IDLAString;

    /**
     * getHighlightColorState returns what the highlight color of the selection.
     * @param aMixed     True if there is more than one font color
     * @return           Color string. "" is returned for none.
     */
    readonly getHighlightColorState: (aMixed: Out<boolean>) => IDLAString;

    /**
     * getListState returns what list type is in the selection.
     * @param aMixed    True if there is more than one type of list, or
     *                  if there is some list and non-list
     * @param aOL       The company that employs me.  No, really, it's
     *                  true if an "ol" list is selected.
     * @param aUL       true if an "ul" list is selected.
     * @param aDL       true if a "dl" list is selected.
     */
    readonly getListState: (aMixed: Out<boolean>, aOL: Out<boolean>, aUL: Out<boolean>, aDL: Out<boolean>) => void;

    /**
     * getListItemState returns what list item type is in the selection.
     * @param aMixed    True if there is more than one type of list item, or
     *                  if there is some list and non-list
     *                  XXX This ignores `<li>` element selected state.
     *                      For example, even if `<li>` and `<dt>` are selected,
     *                      this is set to false.
     * @param aLI       true if "li" list items are selected.
     * @param aDT       true if "dt" list items are selected.
     * @param aDD       true if "dd" list items are selected.
     */
    readonly getListItemState: (aMixed: Out<boolean>, aLI: Out<boolean>, aDT: Out<boolean>, aDD: Out<boolean>) => void;

    /**
     * getAlignment     returns what alignment is in the selection.
     * @param aMixed    Always returns false.
     * @param aAlign    enum value for first encountered alignment
     *                  (left/center/right)
     */
    readonly getAlignment: (aMixed: Out<boolean>, aAlign: Out<number>) => void;

    /**
     * Document me!
     *
     */
    readonly makeOrChangeList: (aListType: IDLAString, entireList: boolean, aBulletType: IDLAString) => void;

    /**
     * removeList removes list items (<li>, <dd>, and <dt>) and list structures
     * (<ul>, <ol>, and <dl>).
     *
     * @param aListType  Unused.
     */
    readonly removeList: (aListType: IDLAString) => void;

    /**
     * Document me!
     *
     */
    readonly indent: (aIndent: IDLAString) => void;

    /**
     * Document me!
     *
     */
    readonly align: (aAlign: IDLAString) => void;

    /**
     * GetElementOrParentByTagName() looks for an element node whose name matches
     * aTagName from aNode or anchor node of Selection to <body> element.
     *
     * @param aTagName        The tag name which you want to look for.
     *                        Must not be empty string.
     *                        If "list", the result may be <ul>, <ol> or <dl>
     *                        element.
     *                        If "td", the result may be <td> or <th>.
     *                        If "href", the result may be <a> element
     *                        which has "href" attribute with non-empty value.
     *                        If "anchor", the result may be <a> which has
     *                        "name" attribute with non-empty value.
     * @param aNode           If non-null, this starts to look for the result
     *                        from it.  Otherwise, i.e., null, starts from
     *                        anchor node of Selection.
     * @return                If an element which matches aTagName, returns
     *                        an Element.  Otherwise, nullptr.
     */
    readonly getElementOrParentByTagName: (aTagName: IDLAString, aNode: WebIDL.Node) => WebIDL.Element;

    /**
     * getSelectedElement() returns a "selected" element node.  "selected" means:
     * - there is only one selection range
     * - the range starts from an element node or in an element
     * - the range ends at immediately after same element
     * - and the range does not include any other element nodes.
     * Additionally, only when aTagName is "href", this thinks that an <a>
     * element which has non-empty "href" attribute includes the range, the
     * <a> element is selected.
     *
     * @param aTagName    Case-insensitive element name.
     *                    If empty string, this returns any element node or null.
     *                    If "href", this returns an <a> element which has
     *                    non-empty "href" attribute or null.
     *                    If "anchor", this returns an <a> element which has
     *                    non-empty "name" attribute or null.
     *                    Otherwise, returns an element node whose name is
     *                    same as aTagName or null.
     * @return            A "selected" element.
     */
    readonly getSelectedElement: (aTagName: IDLAString) => (nsISupports | null);

    /**
     * Return a new element with default attribute values
     *
     * This does not rely on the selection, and is not sensitive to context.
     *
     * Used primarily to supply new element for various insert element dialogs
     *  (Image, Link, NamedAnchor, Table, and HorizontalRule
     *   are the only returned elements as of 7/25/99)
     *
     * @param aTagName  The HTML tagname
     *    Special input values for Links and Named anchors:
     *    Use "href" to get a link node
     *      (an "A" tag with the "href" attribute set)
     *    Use "anchor" or "namedanchor" to get a named anchor node
     *      (an "A" tag with the "name" attribute set)
     * @return          The new element created.
     */
    readonly createElementWithDefaults: (aTagName: IDLAString) => WebIDL.Element;

    /**
     * Insert an link element as the parent of the current selection
     *
     * @param aElement   An "A" element with a non-empty "href" attribute
     */
    readonly insertLinkAroundSelection: (aAnchorElement: WebIDL.Element) => void;

    /**
     * Set the value of the "bgcolor" attribute on the document's <body> element
     *
     * @param aColor  The HTML color string, such as "#ffccff" or "yellow"
     */
    readonly setBackgroundColor: (aColor: IDLAString) => void;

    /**
     * A boolean which is true is the HTMLEditor has been instantiated
     * with CSS knowledge and if the CSS pref is currently checked
     *
     * @return    true if CSS handled and enabled
     */
    isCSSEnabled: boolean;

    /**
     * checkSelectionStateForAnonymousButtons() may refresh editing UI such as
     * resizers, inline-table-editing UI, absolute positioning UI for current
     * Selection and focus state.  When this method shows or hides UI, the
     * editor (and/or its document/window) could be broken by mutation observers.
     * FYI: Current user in script is only BlueGriffon.
     */
    readonly checkSelectionStateForAnonymousButtons: () => void;

    readonly isAnonymousElement: (aElement: WebIDL.Element) => boolean;

    /**
     * A boolean indicating if a return key pressed in a paragraph creates
     * another paragraph or just inserts a <br> at the caret
     *
     * @return    true if CR in a paragraph creates a new paragraph
     */
    returnInParagraphCreatesNewParagraph: boolean;
  }

  export interface nsIUrlClassifierCallbackRef {
    readonly name: "nsIUrlClassifierCallback";
    readonly number: "{4ca27b6b-a674-4b3d-ab30-d21e2da2dffb}";
  }

  type nsIUrlClassifierCallbackFunction = (value: IDLACString) => void;

  export interface nsIUrlClassifierCallback extends nsISupports {

    readonly handleEvent: (value: IDLACString) => void;
  }

  export interface nsISupportsFloatRef {
    readonly name: "nsISupportsFloat";
    readonly number: "{abeaa390-4ac0-11d3-baea-00805f8a5dd7}";
  }

  /**
   * Scriptable storage for floating point numbers
   */
  export interface nsISupportsFloat extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsIClipboardHelperRef {
    readonly name: "nsIClipboardHelper";
    readonly number: "{438307fd-0c68-4d79-922a-f6cc9550cd02}";
  }

  /**
   * helper service for common uses of nsIClipboard.
   */
  export interface nsIClipboardHelper extends nsISupports {

    /**
     * copy string to given clipboard
     *
     * @param aString, the string to copy to the clipboard
     * @param aClipboardID, the ID of the clipboard to copy to
     *        (eg. kSelectionClipboard -- see nsIClipboard.idl)
     */
    readonly copyStringToClipboard: (aString: IDLAString, aClipboardID: number) => void;

    /**
     * copy string to (default) clipboard
     *
     * @param aString, the string to copy to the clipboard
     */
    readonly copyString: (aString: IDLAString) => void;
  }

  export interface nsIWebBrowserPersistDocumentReceiverRef {
    readonly name: "nsIWebBrowserPersistDocumentReceiver";
    readonly number: "{321e3174-594f-4036-b7be-791b821bd376}";
  }

  /**
   * Asynchronous callback for creating a persistable document from some
   * other object.
   *
   * XXXbz This should really be changed to just return a promise that
   * then gets resolved or rejected...
   *
   * @see WebBrowserPersistable in FrameLoader.webidl.
   */
  export interface nsIWebBrowserPersistDocumentReceiver extends nsISupports {

    readonly onDocumentReady: (aDocument: (nsIWebBrowserPersistDocument | null)) => void;

    readonly onError: (aFailure: number) => void;
  }

  export interface nsIDOMXULContainerItemElementRef {
    readonly name: "nsIDOMXULContainerItemElement";
    readonly number: "{800a68c7-b854-4597-a436-3055ce5c5c96}";
  }

  export interface nsIDOMXULContainerItemElement extends nsISupports {

    /**
     * Returns the parent container if any.
     */
    readonly parentContainer: WebIDL.Element;
  }

  export interface nsIWebProgressRef {
    readonly name: "nsIWebProgress";
    readonly number: "{c4d64640-b332-4db6-a2a5-e08566000dc9}";

    /**
     * The following flags may be combined to form the aNotifyMask parameter for
     * the addProgressListener method.  They limit the set of events that are
     * delivered to an nsIWebProgressListener instance.
     */
    /**
     * These flags indicate the state transistions to observe, corresponding to
     * nsIWebProgressListener::onStateChange.
     *
     * NOTIFY_STATE_REQUEST
     *   Only receive the onStateChange event if the aStateFlags parameter
     *   includes nsIWebProgressListener::STATE_IS_REQUEST.
     *
     * NOTIFY_STATE_DOCUMENT
     *   Only receive the onStateChange event if the aStateFlags parameter
     *   includes nsIWebProgressListener::STATE_IS_DOCUMENT.
     *
     * NOTIFY_STATE_NETWORK
     *   Only receive the onStateChange event if the aStateFlags parameter
     *   includes nsIWebProgressListener::STATE_IS_NETWORK.
     *
     * NOTIFY_STATE_WINDOW
     *   Only receive the onStateChange event if the aStateFlags parameter
     *   includes nsIWebProgressListener::STATE_IS_WINDOW.
     *
     * NOTIFY_STATE_ALL
     *   Receive all onStateChange events.
     */
    NOTIFY_STATE_REQUEST: 1;

    NOTIFY_STATE_DOCUMENT: 2;

    NOTIFY_STATE_NETWORK: 4;

    NOTIFY_STATE_WINDOW: 8;

    NOTIFY_STATE_ALL: 15;

    /**
     * These flags indicate the other events to observe, corresponding to the
     * other four methods defined on nsIWebProgressListener.
     *
     * NOTIFY_PROGRESS
     *   Receive onProgressChange events.
     *
     * NOTIFY_STATUS
     *   Receive onStatusChange events.
     *
     * NOTIFY_SECURITY
     *   Receive onSecurityChange events.
     *
     * NOTIFY_LOCATION
     *   Receive onLocationChange events.
     *
     * NOTIFY_CONTENT_BLOCKING
     *   Receive onContentBlockingEvent events.
     *
     * NOTIFY_REFRESH
     *   Receive onRefreshAttempted events.
     *   This is defined on nsIWebProgressListener2.
     */
    NOTIFY_PROGRESS: 16;

    NOTIFY_STATUS: 32;

    NOTIFY_SECURITY: 64;

    NOTIFY_LOCATION: 128;

    NOTIFY_REFRESH: 256;

    NOTIFY_CONTENT_BLOCKING: 512;

    /**
     * This flag enables all notifications.
     */
    NOTIFY_ALL: 1023;
  }

  /**
   * The nsIWebProgress interface is used to add or remove nsIWebProgressListener
   * instances to observe the loading of asynchronous requests (usually in the
   * context of a DOM window).
   *
   * nsIWebProgress instances may be arranged in a parent-child configuration,
   * corresponding to the parent-child configuration of their respective DOM
   * windows.  However, in some cases a nsIWebProgress instance may not have an
   * associated DOM window.  The parent-child relationship of nsIWebProgress
   * instances is not made explicit by this interface, but the relationship may
   * exist in some implementations.
   *
   * A nsIWebProgressListener instance receives notifications for the
   * nsIWebProgress instance to which it added itself, and it may also receive
   * notifications from any nsIWebProgress instances that are children of that
   * nsIWebProgress instance.
   */
  export interface nsIWebProgress extends nsISupports {

    /**
     * Registers a listener to receive web progress events.
     *
     * @param aListener
     *        The listener interface to be called when a progress event occurs.
     *        This object must also implement nsISupportsWeakReference.
     * @param aNotifyMask
     *        The types of notifications to receive.
     *
     * @throw NS_ERROR_INVALID_ARG
     *        Indicates that aListener was either null or that it does not
     *        support weak references.
     * @throw NS_ERROR_FAILURE
     *        Indicates that aListener was already registered.
     */
    readonly addProgressListener: (aListener: (nsIWebProgressListener | null), aNotifyMask: number) => void;

    /**
     * Removes a previously registered listener of progress events.
     *
     * @param aListener
     *        The listener interface previously registered with a call to
     *        addProgressListener.
     *
     * @throw NS_ERROR_FAILURE
     *        Indicates that aListener was not registered.
     */
    readonly removeProgressListener: (aListener: (nsIWebProgressListener | null)) => void;

    /**
     * The DOM window associated with this nsIWebProgress instance.
     *
     * @throw NS_ERROR_FAILURE
     *        Indicates that there is no associated DOM window.
     */
    readonly DOMWindow: (mozIDOMWindowProxy | null);

    readonly DOMWindowID: number;

    readonly innerDOMWindowID: number;

    /**
     * Indicates whether DOMWindow.top == DOMWindow.
     */
    readonly isTopLevel: boolean;

    /**
     * Indicates whether or not a document is currently being loaded
     * in the context of this nsIWebProgress instance.
     */
    readonly isLoadingDocument: boolean;

    /**
     * Contains a load type as specified by the load* constants in
     * nsIDocShellLoadInfo.idl.
     */
    readonly loadType: number;

    /**
     * Main thread event target to which progress updates should be
     * dispatched. This typically will be a SchedulerEventTarget
     * corresponding to the tab requesting updates.
     */
    target: (nsIEventTarget | null);
  }

  export interface nsIBrowserDOMWindowRef {
    readonly name: "nsIBrowserDOMWindow";
    readonly number: "{2a9bb880-5d73-40f3-8152-c60c8d137a14}";

    /**
     * Values for createContentWindow's and openURI's aWhere parameter.
     */
    /**
     * Do whatever the default is based on application state, user preferences,
     * and the value of the aContext parameter to openURI.
     */
    OPEN_DEFAULTWINDOW: 0;

    /**
     * Open in the "current window".  If aOpener is provided, this should be the
     * top window in aOpener's window hierarchy, but exact behavior is
     * application-dependent.  If aOpener is not provided, it's up to the
     * application to decide what constitutes a "current window".
     */
    OPEN_CURRENTWINDOW: 1;

    /**
     * Open in a new window.
     */
    OPEN_NEWWINDOW: 2;

    /**
     * Open in a new content tab in the toplevel browser window corresponding to
     * this nsIBrowserDOMWindow.
     */
    OPEN_NEWTAB: 3;

    /**
     * Open in an existing content tab based on the URI. If a match can't be
     * found, revert to OPEN_NEWTAB behavior.
     */
    OPEN_SWITCHTAB: 4;

    /**
     * Values for createContentWindow's and openURI's aFlags parameter.
     * This is a bitflags field.
     *
     * The 0x1 bit decides the behavior of OPEN_DEFAULTWINDOW, and the 0x4 bit
     * controls whether or not to set the window.opener property on the newly
     * opened window.
     *
     * NOTE: The 0x2 bit is ignored for backwards compatibility with addons, as
     * OPEN_NEW used to have the value 2. The values 0 and 2 are treated
     * the same way internally.
     */
    /**
     * Internal open new window.
     */
    OPEN_NEW: 0;

    /**
     * External link (load request from another application, xremote, etc).
     */
    OPEN_EXTERNAL: 1;

    /**
     * Don't set the window.opener property on the window which is being opened.
     */
    OPEN_NO_OPENER: 4;

    /**
     * Don't set the referrer on the navigation inside the window which is
     * being opened.
     */
    OPEN_NO_REFERRER: 8;
  }

  /**
   * The C++ source has access to the browser script source through
   * nsIBrowserDOMWindow. It is intended to be attached to the chrome DOMWindow
   * of a toplevel browser window (a XUL window). A DOMWindow that does not
   * happen to be a browser chrome window will simply have no access to any such
   * interface.
   */
  export interface nsIBrowserDOMWindow extends nsISupports {

    /**
     * Create the content window for the given URI.
     
     * @param aURI the URI to be opened in the window (can be null).
     * @param aWhere see possible values described above.
     * @param aOpener window requesting the creation (can be null).
     * @param aFlags flags which control the behavior of the load. The
     *               OPEN_EXTERNAL/OPEN_NEW flag is only used when
     *               aWhere == OPEN_DEFAULTWINDOW.
     * @param aTriggeringPrincipal the principal that would trigger the potential
     *        load of aURI.
     * @param aCsp the CSP to use (if any) for the new window.
     * @return the window into which the URI would have been opened.
     */
    readonly createContentWindow: (aURI: (nsIURI | null), aOpener: (mozIDOMWindowProxy | null), aWhere: number, aFlags: number, aTriggeringPrincipal: (nsIPrincipal | null), aCsp?: (nsIContentSecurityPolicy | null)) => WebIDL.BrowsingContext;

    /**
     * As above, but return the nsFrameLoaderOwner for the new window. Value is
     * returned as Element, QI'd back to nsFrameLoaderOwner as needed.
     *
     * Additional Parameters:
     * @param aNextRemoteTabId The RemoteTab to associate the window with.
     * @param aName The name to give the window opened in the new tab.
     * @return The frame element for the newly opened window.
     */
    readonly createContentWindowInFrame: (aURI: (nsIURI | null), params: (nsIOpenURIInFrameParams | null), aWhere: number, aFlags: number, aNextRemoteTabId: number, aName: IDLAString) => WebIDL.Element;

    /**
     * Load a URI.
     
     * @param aURI the URI to open. null is not allowed. To create the window
     *        without loading the URI, use createContentWindow instead.
     * @param aWhere see possible values described above.
     * @param aOpener window requesting the open (can be null).
     * @param aFlags flags which control the behavior of the load. The
     *               OPEN_EXTERNAL/OPEN_NEW flag is only used when
     *               aWhere == OPEN_DEFAULTWINDOW.
     * @param aTriggeringPrincipal the principal that triggered the load of aURI.
     * @param aCsp the CSP to be applied to the new load.
     * @return the window into which the URI was opened.
     */
    readonly openURI: (aURI: (nsIURI | null), aOpener: (mozIDOMWindowProxy | null), aWhere: number, aFlags: number, aTriggeringPrincipal: (nsIPrincipal | null), aCsp?: (nsIContentSecurityPolicy | null)) => WebIDL.BrowsingContext;

    /**
       * As above, but return the nsFrameLoaderOwner for the new window. Value is
       * returned as Element, QI'd back to nsFrameLoaderOwner as needed.
       *
       * Additional Parameters:
       * @param aNextRemoteTabId The RemoteTab to associate the window with.
       * @param aName The name to give the window opened in the new tab.
       * @return The frame element for the newly opened window.
       // XXXbz is this the right API?
       // See bug 537428
       */
    readonly openURIInFrame: (aURI: (nsIURI | null), params: (nsIOpenURIInFrameParams | null), aWhere: number, aFlags: number, aNextRemoteTabId: number, aName: IDLAString) => WebIDL.Element;

    /**
     * @param  aWindow the window to test.
     * @return whether the window is the main content window for any
     *         currently open tab in this toplevel browser window.
     */
    readonly isTabContentWindow: (aWindow: (nsIDOMWindow | null)) => boolean;

    /**
     * This function is responsible for calling
     * nsIContentViewer::PermitUnload on each frame in the window. It
     * returns true if closing the window is allowed. See canClose() in
     * BrowserUtils.jsm for a simple implementation of this method.
     */
    readonly canClose: () => boolean;

    /**
     * The number browser tabs in the window. This number currently includes
     * lazy tabs, though for most uses it probably should not.
     */
    readonly tabCount: number;
  }

  export interface nsIPrinterEnumeratorRef {
    readonly name: "nsIPrinterEnumerator";
    readonly number: "{5e738fff-404c-4c94-9189-e8f2cce93e94}";
  }

  export interface nsIPrinterEnumerator extends nsISupports {

    /**
     * The name of the system default printer. This name should also be
     * present in printerNameList below. This is not necessarily gecko's
     * default printer; see nsIPrintSettingsService.defaultPrinterName
     * for that.
     */
    readonly defaultPrinterName: IDLAString;

    /**
     * Initializes certain settings from the native printer into the PrintSettings
     * These settings include, but are not limited to:
     *   Page Orientation
     *   Page Size
     *   Number of Copies
     */
    readonly initPrintSettingsFromPrinter: (aPrinterName: IDLAString, aPrintSettings: (nsIPrintSettings | null)) => void;

    /**
     * The list of printer names
     */
    readonly printerNameList: (nsIStringEnumerator | null);
  }

  export enum nsIUrlClassifierFeature_listType {
    blacklist = 0,
    whitelist = 1,
  }

  export enum nsIUrlClassifierFeature_URIType {
    blacklistURI = 0,
    whitelistURI = 1,
    pairwiseWhitelistURI = 2,
  }

  export interface nsIUrlClassifierFeatureRef {
    readonly name: "nsIUrlClassifierFeature";
    readonly number: "{a6c9b24e-b4f1-426e-af58-2c976c3943a8}";

    blacklist: 0;
    whitelist: 1;

    blacklistURI: 0;
    whitelistURI: 1;
    pairwiseWhitelistURI: 2;
  }

  /**
   * A single URLClassifier feature.
   */
  export interface nsIUrlClassifierFeature extends nsISupports {

    /**
     * The feature name
     */
    readonly name: IDLACString;

    /**
     * Returns a comma-separated list of hosts to be ignored.
     */
    readonly skipHostList: IDLACString;
  }

  export interface nsIUrlClassifierStreamUpdaterRef {
    readonly name: "nsIUrlClassifierStreamUpdater";
    readonly number: "{e1797597-f4d6-4dd3-a1e1-745ad352cd80}";
  }

  /**
   * This is a class to manage large table updates from the server.  Rather than
   * downloading the whole update and then updating the sqlite database, we
   * update tables as the data is streaming in.
   */
  export interface nsIUrlClassifierStreamUpdater extends nsISupports {

    /**
     * Try to download updates from updateUrl. If an update is already in
     * progress, queues the requested update. This is used in nsIUrlListManager
     * as well as in testing.
     * @param aRequestTables Comma-separated list of tables included in this
     *        update.
     * @param aRequestPayload The payload for the request.
     * @param aIsPostRequest Whether the request should be sent by POST method.
     *                       Should be 'true' for v2 usage.
     * @param aUpdateUrl The plaintext url from which to request updates.
     * @param aSuccessCallback Called after a successful update.
     * @param aUpdateErrorCallback Called for problems applying the update
     * @param aDownloadErrorCallback Called if we get an http error or a
     *        connection refused error.
     */
    readonly downloadUpdates: (aRequestTables: IDLACString, aRequestPayload: IDLACString, aIsPostRequest: boolean, aUpdateUrl: IDLACString, aSuccessCallback: (nsIUrlClassifierCallback | nsIUrlClassifierCallbackFunction | null), aUpdateErrorCallback: (nsIUrlClassifierCallback | nsIUrlClassifierCallbackFunction | null), aDownloadErrorCallback: (nsIUrlClassifierCallback | nsIUrlClassifierCallbackFunction | null)) => boolean;
  }

  export interface nsIArrayExtensionsRef {
    readonly name: "nsIArrayExtensions";
    readonly number: "{261d442e-050c-453d-8aaa-b3f23bcc528b}";
  }

  /**
   * Helper interface for allowing scripts to treat nsIArray instances as if
   * they were nsISupportsArray instances while iterating.
   *
   * nsISupportsArray is convenient to iterate over in JavaScript:
   *
   * for (let i = 0; i < array.Count(); ++i) {
   *   let elem = array.GetElementAt(i);
   *   ...
   * }
   *
   * but doing the same with nsIArray is somewhat less convenient, since
   * queryElementAt is not nearly so nice to use from JavaScript.  So we provide
   * this extension interface so interfaces that currently return
   * nsISupportsArray can start returning nsIArrayExtensions and all JavaScript
   * should Just Work. Eventually we'll roll this interface into nsIArray
   * itself, possibly getting rid of the Count() method, as it duplicates
   * nsIArray functionality.
   */
  export interface nsIArrayExtensions extends nsIArray {

    /**
     * Count()
     *
     * Retrieves the length of the array. This is an alias for the
     * |nsIArray.length| attribute.
     */
    readonly Count: () => number;

    /**
     * GetElementAt()
     *
     * Retrieve a specific element of the array. null is a valid result for
     * this method.
     *
     * Note: If the index is out of bounds null will be returned.
     *       This differs from the behavior of nsIArray.queryElementAt() which
     *       will throw if an invalid index is specified.
     *
     * @param index position of element
     */
    readonly GetElementAt: (index: number) => (nsISupports | null);
  }

  export interface nsIBitsRequestRef {
    readonly name: "nsIBitsRequest";
    readonly number: "{ab9da0e9-06bf-4e73-bb1b-c0f2ea9ecc3e}";
  }

  export interface nsIBitsRequest extends nsIRequest {

    /**
     * The BITS id of the download. This will be a string representing a UUID.
     */
    readonly bitsId: IDLAUTF8String;

    /**
     * The transfer result of the download, meant to be accessed after the
     * transfer has stopped (i.e. after the observer's onStopRequest method has
     * been called). Will be nsIBits::ERROR_TYPE_SUCCESS if the transfer is
     * successful (and before transfer completion). If the transfer failed, this
     * will be a different nsBitsErrorType value indicating the cause of the
     * failure.
     */
    readonly transferError: number;

    /**
     * Requests a change to the frequency that Firefox is receiving download
     * status notifications.
     *
     * @param monitorIntervalMs
     *        The new number of milliseconds between download status
     *        notifications.
     * @param callback
     *        The callback function used to relay success or failure.
     */
    readonly changeMonitorInterval: (monitorIntervalMs: number, callback: (nsIBitsCallback | null)) => void;

    /**
     * Cancels the download. This function is named this way to avoid conflict
     * with nsIRequest::cancel.
     *
     * @param status
     *        The reason for cancelling the request. This must be a failure code
     *        rather than a success code like NS_OK.
     * @param callback
     *        The callback function used to relay success or failure.
     */
    readonly cancelAsync: (status: number, callback: (nsIBitsCallback | null)) => void;

    /**
     * Sets the priority of the BITS job to high (i.e. foreground download).
     *
     * @param callback
     *        The callback function used to relay success or failure.
     */
    readonly setPriorityHigh: (callback: (nsIBitsCallback | null)) => void;

    /**
     * Sets the priority of the BITS job to low (i.e. background download).
     *
     * @param callback
     *        The callback function used to relay success or failure.
     */
    readonly setPriorityLow: (callback: (nsIBitsCallback | null)) => void;

    /**
     * Sets the BITS "no progress" timeout for the job.
     *
     * @param timeoutSecs
     *        The new number of seconds for the timeout. After there has been
     *        no progress for this long, BITS will not retry the job following
     *        a transient error, producing instead a permanent error.
     * @param callback
     *        The callback function used to relay success or failure.
     */
    readonly setNoProgressTimeout: (timeoutSecs: number, callback: (nsIBitsCallback | null)) => void;

    readonly complete: (callback: (nsIBitsCallback | null)) => void;

    readonly suspendAsync: (callback: (nsIBitsCallback | null)) => void;

    readonly resumeAsync: (callback: (nsIBitsCallback | null)) => void;
  }

  export interface nsINavHistoryResultObserverRef {
    readonly name: "nsINavHistoryResultObserver";
    readonly number: "{f62d8b6b-3c4e-4a9f-a897-db605d0b7a0f}";
  }

  /**
   * Allows clients to observe what is happening to a result as it updates itself
   * according to history and bookmark system events. Register this observer on a
   * result using nsINavHistoryResult::addObserver.
   */
  export interface nsINavHistoryResultObserver extends nsISupports {

    /**
     * Called when 'aItem' is inserted into 'aParent' at index 'aNewIndex'.
     * The item previously at index (if any) and everything below it will have
     * been shifted down by one. The item may be a container or a leaf.
     */
    readonly nodeInserted: (aParent: (nsINavHistoryContainerResultNode | null), aNode: (nsINavHistoryResultNode | null), aNewIndex: number) => void;

    /**
     * Called whan 'aItem' is removed from 'aParent' at 'aOldIndex'. The item
     * may be a container or a leaf. This function will be called after the item
     * has been removed from its parent list, but before anything else (including
     * NULLing out the item's parent) has happened.
     */
    readonly nodeRemoved: (aParent: (nsINavHistoryContainerResultNode | null), aItem: (nsINavHistoryResultNode | null), aOldIndex: number) => void;

    /**
     * Called whan 'aItem' is moved from 'aOldParent' at 'aOldIndex' to
     * aNewParent at aNewIndex. The item may be a container or a leaf.
     *
     * XXX: at the moment, this method is called only when an item is moved
     * within the same container. When an item is moved between containers,
     * a new node is created for the item, and the itemRemoved/itemAdded methods
     * are used.
     */
    readonly nodeMoved: (aNode: (nsINavHistoryResultNode | null), aOldParent: (nsINavHistoryContainerResultNode | null), aOldIndex: number, aNewParent: (nsINavHistoryContainerResultNode | null), aNewIndex: number) => void;

    /**
     * Called right after aNode's title has changed.
     *
     * @param aNode
     *        a result node
     * @param aNewTitle
     *        the new title
     */
    readonly nodeTitleChanged: (aNode: (nsINavHistoryResultNode | null), aNewTitle: IDLAUTF8String) => void;

    /**
     * Called right after aNode's uri property has changed.
     *
     * @param aNode
     *        a result node
     * @param aNewURI
     *        the old uri
     */
    readonly nodeURIChanged: (aNode: (nsINavHistoryResultNode | null), aOldURI: IDLAUTF8String) => void;

    /**
     * Called right after aNode's icon property has changed.
     *
     * @param aNode
     *        a result node
     *
     * @note: The new icon is accessible through aNode.icon.
     */
    readonly nodeIconChanged: (aNode: (nsINavHistoryResultNode | null)) => void;

    /**
     * Called right after aNode's time property or accessCount property, or both,
     * have changed.
     *
     * @param aNode
     *        a uri result node
     * @param aOldVisitDate
     *        the old visit date
     * @param aOldAccessCount
     *        the old access-count
     */
    readonly nodeHistoryDetailsChanged: (aNode: (nsINavHistoryResultNode | null), aOldVisitDate: number, aOldAccessCount: number) => void;

    /**
     * Called when the tags set on the uri represented by aNode have changed.
     *
     * @param aNode
     *        a uri result node
     *
     * @note: The new tags list is accessible through aNode.tags.
     */
    readonly nodeTagsChanged: (aNode: (nsINavHistoryResultNode | null)) => void;

    /**
     * Called right after the aNode's keyword property has changed.
     *
     * @param aNode
     *        a uri result node
     * @param aNewKeyword
     *        the new keyword
     */
    readonly nodeKeywordChanged: (aNode: (nsINavHistoryResultNode | null), aNewKeyword: IDLAUTF8String) => void;

    /**
     * Called right after aNode's dateAdded property has changed.
     *
     * @param aNode
     *        a result node
     * @param aNewValue
     *        the new value of the dateAdded property
     */
    readonly nodeDateAddedChanged: (aNode: (nsINavHistoryResultNode | null), aNewValue: number) => void;

    /**
     * Called right after aNode's dateModified property has changed.
     *
     * @param aNode
     *        a result node
     * @param aNewValue
     *        the new value of the dateModified property
     */
    readonly nodeLastModifiedChanged: (aNode: (nsINavHistoryResultNode | null), aNewValue: number) => void;

    /**
     * Called after a container changes state.
     *
     * @param aContainerNode
     *        The container that has changed state.
     * @param aOldState
     *        The state that aContainerNode has transitioned out of.
     * @param aNewState
     *        The state that aContainerNode has transitioned into.
     */
    readonly containerStateChanged: (aContainerNode: (nsINavHistoryContainerResultNode | null), aOldState: number, aNewState: number) => void;

    /**
     * Called when something significant has happened within the container. The
     * contents of the container should be re-built.
     *
     * @param aContainerNode
     *        the container node to invalidate
     */
    readonly invalidateContainer: (aContainerNode: (nsINavHistoryContainerResultNode | null)) => void;

    /**
     * This is called to indicate to the UI that the sort has changed to the
     * given mode. For trees, for example, this would update the column headers
     * to reflect the sorting. For many other types of views, this won't be
     * applicable.
     *
     * @param sortingMode  One of nsINavHistoryQueryOptions.SORT_BY_* that
     *                     indicates the new sorting mode.
     *
     * This only is expected to update the sorting UI. invalidateAll() will also
     * get called if the sorting changes to update everything.
     */
    readonly sortingChanged: (sortingMode: number) => void;

    /**
     * This is called to indicate that a batch operation is about to start or end.
     * The observer could want to disable some events or updates during batches,
     * since multiple operations are packed in a short time.
     * For example treeviews could temporarily suppress select notifications.
     *
     * @param aToggleMode
     *        true if a batch is starting, false if it's ending.
     */
    readonly batching: (aToggleMode: boolean) => void;

    /**
     * Called by the result when this observer is added.
     */
    result: (nsINavHistoryResult | null);
  }

  export interface nsIPipeRef {
    readonly name: "nsIPipe";
    readonly number: "{25d0de93-685e-4ea4-95d3-d884e31df63c}";
  }

  /**
   * nsIPipe represents an in-process buffer that can be read using nsIInputStream
   * and written using nsIOutputStream.  The reader and writer of a pipe do not
   * have to be on the same thread.  As a result, the pipe is an ideal mechanism
   * to bridge data exchange between two threads.  For example, a worker thread
   * might write data to a pipe from which the main thread will read.
   *
   * Each end of the pipe can be either blocking or non-blocking.  Recall that a
   * non-blocking stream will return NS_BASE_STREAM_WOULD_BLOCK if it cannot be
   * read or written to without blocking the calling thread.  For example, if you
   * try to read from an empty pipe that has not yet been closed, then if that
   * pipe's input end is non-blocking, then the read call will fail immediately
   * with NS_BASE_STREAM_WOULD_BLOCK as the error condition.  However, if that
   * pipe's input end is blocking, then the read call will not return until the
   * pipe has data or until the pipe is closed.  This example presumes that the
   * pipe is being filled asynchronously on some background thread.
   *
   * The pipe supports nsIAsyncInputStream and nsIAsyncOutputStream, which give
   * the user of a non-blocking pipe the ability to wait for the pipe to become
   * ready again.  For example, in the case of an empty non-blocking pipe, the
   * user can call AsyncWait on the input end of the pipe to be notified when
   * the pipe has data to read (or when the pipe becomes closed).
   *
   * NS_NewPipe2 and NS_NewPipe provide convenient pipe constructors.  In most
   * cases nsIPipe is not actually used.  It is usually enough to just get
   * references to the pipe's input and output end.  In which case, the pipe is
   * automatically closed when the respective pipe ends are released.
   */
  export interface nsIPipe extends nsISupports {

    /**
     * initialize this pipe
     *
     * @param nonBlockingInput
     *        true specifies non-blocking input stream behavior
     * @param nonBlockingOutput
     *        true specifies non-blocking output stream behavior
     * @param segmentSize
     *        specifies the segment size in bytes (pass 0 to use default value)
     * @param segmentCount
     *        specifies the max number of segments (pass 0 to use default
     *        value).   Passing UINT32_MAX here causes the pipe to have
     *        "infinite" space.  This mode can be useful in some cases, but
     *        should always be used with caution.  The default value for this
     *        parameter is a finite value.
     */
    readonly init: (nonBlockingInput: boolean, nonBlockingOutput: boolean, segmentSize: number, segmentCount: number) => void;

    /**
     * The pipe's input end, which also implements nsISearchableInputStream.
     * Getting fails if the pipe hasn't been initialized.
     */
    readonly inputStream: (nsIAsyncInputStream | null);

    /**
     * The pipe's output end. Getting fails if the pipe hasn't been
     * initialized.
     */
    readonly outputStream: (nsIAsyncOutputStream | null);
  }

  export interface nsIThreadManagerRef {
    readonly name: "nsIThreadManager";
    readonly number: "{1be89eca-e2f7-453b-8d38-c11ba247f6f3}";
  }

  /**
   * An interface for creating and locating nsIThread instances.
   */
  export interface nsIThreadManager extends nsISupports {

    /**
     * Default number of bytes reserved for a thread's stack, if no stack size
     * is specified in newThread().
     *
     * Defaults can be a little overzealous for many platforms.
     *
     * On Linux and OS X, for instance, the default thread stack size is whatever
     * getrlimit(RLIMIT_STACK) returns, which is often set at 8MB. Or, on Linux,
     * if the stack size is unlimited, we fall back to 2MB. This causes particular
     * problems on Linux, which allocates 2MB huge VM pages, and will often
     * immediately allocate them for any stacks which are 2MB or larger.
     *
     * The default on Windows is 1MB, which is a little more reasonable. But the
     * vast majority of our threads don't need anywhere near that much space.
     *
     * ASan and TSan builds, however, often need a bit more, so give them a the
     * platform default.
     */
    /**
     * Create a new thread (a global, user PRThread).
     *
     * @param creationFlags
     *   Reserved for future use.  Pass 0.
     * @param stackSize
     *   Number of bytes to reserve for the thread's stack. 0 means use platform
     *   default.
     *
     * @returns
     *   The newly created nsIThread object.
     */
    readonly newThread: (creationFlags: number, stackSize?: number) => (nsIThread | null);

    /**
     * Get the main thread.
     */
    readonly mainThread: (nsIThread | null);

    /**
     * Get the current thread.  If the calling thread does not already have a
     * nsIThread associated with it, then a new nsIThread will be created and
     * associated with the current PRThread.
     */
    readonly currentThread: (nsIThread | null);

    /**
     * This queues a runnable to the main thread. It's a shortcut for JS callers
     * to be used instead of
     *   .mainThread.dispatch(runnable, Ci.nsIEventTarget.DISPATCH_NORMAL);
     * or
     *   .currentThread.dispatch(runnable, Ci.nsIEventTarget.DISPATCH_NORMAL);
     * C++ callers should instead use NS_DispatchToMainThread.
     */
    readonly dispatchToMainThread: (event: (nsIRunnable | nsIRunnableFunction | null), priority?: number) => void;

    /**
     * This queues a runnable to the main thread's idle queue.
     *
     * @param event
     *   The event to dispatch.
     * @param timeout
     *   The time in milliseconds until this event should be moved from the idle
     *   queue to the regular queue if it hasn't been executed by then.  If not
     *   passed or a zero value is specified, the event will never be moved to
     *   the regular queue.
     */
    readonly idleDispatchToMainThread: (event: (nsIRunnable | nsIRunnableFunction | null), timeout?: number) => void;

    /**
     * Enter a nested event loop on the current thread, waiting on, and
     * processing events until condition.isDone() returns true.
     *
     * If condition.isDone() throws, this function will throw as well.
     *
     * C++ code should not use this function, instead preferring
     * mozilla::SpinEventLoopUntil.
     */
    readonly spinEventLoopUntil: (condition: (nsINestedEventLoopCondition | nsINestedEventLoopConditionFunction | null)) => void;

    /**
     * Similar to the previous method, but the spinning of the event loop
     * terminates when the shutting down starts.
     *
     * C++ code should not use this function, instead preferring
     * mozilla::SpinEventLoopUntil.
     */
    readonly spinEventLoopUntilOrShutdown: (condition: (nsINestedEventLoopCondition | nsINestedEventLoopConditionFunction | null)) => void;

    /**
     * Spin the current thread's event loop until there are no more pending
     * events.  This could be done with spinEventLoopUntil, but that would
     * require access to the current thread from JavaScript, which we are
     * moving away from.
     */
    readonly spinEventLoopUntilEmpty: () => void;

    /**
     * Return the SchedulerEventTarget for the SystemGroup.
     */
    readonly systemGroupEventTarget: (nsIEventTarget | null);
  }

  export interface nsIWebBrowserPrintRef {
    readonly name: "nsIWebBrowserPrint";
    readonly number: "{c9a934ed-fff1-4971-bfba-6c25ad70e1e6}";

    /**
     * PrintPreview Navigation Constants
     */
    PRINTPREVIEW_GOTO_PAGENUM: 0;

    PRINTPREVIEW_PREV_PAGE: 1;

    PRINTPREVIEW_NEXT_PAGE: 2;

    PRINTPREVIEW_HOME: 3;

    PRINTPREVIEW_END: 4;
  }

  /**
   * nsIWebBrowserPrint corresponds to the main interface
   * for printing an embedded Gecko web browser window/document
   */
  export interface nsIWebBrowserPrint extends nsISupports {

    /**
     * Returns a "global" PrintSettings object
     * Creates a new the first time, if one doesn't exist.
     *
     * Then returns the same object each time after that.
     *
     * Initializes the globalPrintSettings from the default printer
     */
    readonly globalPrintSettings: (nsIPrintSettings | null);

    /**
     * Returns a pointer to the PrintSettings object that
     * that was passed into either "print" or "print preview"
     *
     * This enables any consumers of the interface to have access
     * to the "current" PrintSetting at later points in the execution
     */
    readonly currentPrintSettings: (nsIPrintSettings | null);

    /**
     * The "name" of the document that is to be printed.  This is the document's
     * title, unless that's empty, in which case it is a sanitized version of the
     * document's URL.
     */
    readonly documentName: IDLAString;

    /**
     * Returns whether it is in Print mode
     */
    readonly doingPrint: boolean;

    /**
     * Returns whether it is in Print Preview mode
     */
    readonly doingPrintPreview: boolean;

    /**
     * This returns whether there is an IFrame selected
     */
    readonly isIFrameSelected: boolean;

    /**
     * This returns whether there is a "range" selection
     */
    readonly isRangeSelection: boolean;

    /**
     * This returns the total number of pages for the Print Preview
     */
    readonly printPreviewNumPages: number;

    /**
     * Print the specified DOM window
     *
     * @param aThePrintSettings - Printer Settings for the print job, if aThePrintSettings is null
     *                            then the global PS will be used.
     * @param aWPListener - is updated during the print
     * @return void
     */
    readonly print: (aThePrintSettings: (nsIPrintSettings | null), aWPListener: (nsIWebProgressListener | null)) => void;

    /**
     * Print Preview the specified DOM window
     *
     * @param aThePrintSettings - Printer Settings for the print preview, if aThePrintSettings is null
     *                            then the global PS will be used.
     * @param aChildDOMWin - DOM Window to be print previewed.
     * @param aWPListener - is updated during the printpreview
     * @return void
     */
    readonly printPreview: (aThePrintSettings: (nsIPrintSettings | null), aChildDOMWin: (mozIDOMWindowProxy | null), aWPListener: (nsIWebProgressListener | null)) => void;

    /**
     * @param aNavType - navigation enum
     * @param aPageNum - page num to navigate to when aNavType = ePrintPreviewGoToPageNum
     * @return void
     */
    readonly printPreviewScrollToPage: (aNavType: number, aPageNum: number) => void;

    /**
     * Cancels the current print
     * @return void
     */
    readonly cancel: () => void;

    /**
     * This exists PrintPreview mode and returns browser window to galley mode
     * @return void
     */
    readonly exitPrintPreview: () => void;
  }

  export interface nsIListenerChangeListenerRef {
    readonly name: "nsIListenerChangeListener";
    readonly number: "{aa7c95f6-d3b5-44b3-9597-1d9f19b9c5f2}";
  }

  type nsIListenerChangeListenerFunction = (aEventListenerChanges: (nsIArray | null)) => void;

  export interface nsIListenerChangeListener extends nsISupports {

    readonly listenersChanged: (aEventListenerChanges: (nsIArray | null)) => void;
  }

  export interface nsISSLSocketControlRef {
    readonly name: "nsISSLSocketControl";
    readonly number: "{418265c8-654e-4fbb-ba62-4eed27de1f03}";

    KEY_EXCHANGE_UNKNOWN: -1;

    SSL_VERSION_3: 768;

    TLS_VERSION_1: 769;

    TLS_VERSION_1_1: 770;

    TLS_VERSION_1_2: 771;

    TLS_VERSION_1_3: 772;

    SSL_VERSION_UNKNOWN: -1;

    SSL_MAC_UNKNOWN: -1;

    SSL_MAC_NULL: 0;

    SSL_MAC_MD5: 1;

    SSL_MAC_SHA: 2;

    SSL_HMAC_MD5: 3;

    SSL_HMAC_SHA: 4;

    SSL_HMAC_SHA256: 5;

    SSL_MAC_AEAD: 6;
  }

  export interface nsISSLSocketControl extends nsISupports {

    notificationCallbacks: (nsIInterfaceRequestor | null);

    readonly proxyStartSSL: () => void;

    readonly StartTLS: () => void;

    readonly negotiatedNPN: IDLACString;

    readonly getAlpnEarlySelection: () => IDLACString;

    readonly earlyDataAccepted: boolean;

    readonly driveHandshake: () => void;

    readonly joinConnection: (npnProtocol: IDLACString, hostname: IDLACString, port: number) => boolean;

    readonly testJoinConnection: (npnProtocol: IDLACString, hostname: IDLACString, port: number) => boolean;

    readonly isAcceptableForHost: (hostname: IDLACString) => boolean;

    readonly KEAUsed: number;

    readonly KEAKeyBits: number;

    readonly providerFlags: number;

    readonly providerTlsFlags: number;

    readonly SSLVersionUsed: number;

    readonly SSLVersionOffered: number;

    readonly MACAlgorithmUsed: number;

    /**
     * If set before the server requests a client cert (assuming it does so at
     * all), then this cert will be presented to the server, instead of asking
     * the user or searching the set of rememebered user cert decisions.
     */
    clientCert: (nsIX509Cert | null);

    /**
     * True iff a client cert has been sent to the server - i.e. this
     * socket has been client-cert authenticated.
     */
    readonly clientCertSent: boolean;

    readonly failedVerification: boolean;

    esniTxt: IDLACString;

    /**
     * True iff the connection was resumed using the resumption token.
     */
    readonly resumed: boolean;

    /**
     * The id used to uniquely identify the connection to the peer.
     */
    readonly peerId: IDLACString;
  }

  export interface nsILineInputStreamRef {
    readonly name: "nsILineInputStream";
    readonly number: "{c97b466c-1e6e-4773-a4ab-2b2b3190a7a6}";
  }

  export interface nsILineInputStream extends nsISupports {

    /**
     * Read a single line from the stream, where a line is a
     * possibly zero length sequence of 8bit chars terminated by a
     * CR, LF, CRLF, LFCR, or eof.
     * The line terminator is not returned.
     * @retval false
     *         End of file. This line is the last line of the file
     *         (aLine is valid).
     * @retval true
     *         The file contains further lines.
     * @note Do not mix readLine with other read functions.
     *       Doing so can cause various problems and is not supported.
     */
    readonly readLine: (aLine: Out<IDLACString>) => boolean;
  }

  export interface nsICertVerificationCallbackRef {
    readonly name: "nsICertVerificationCallback";
    readonly number: "{49e16fc8-efac-4f57-8361-956ef6b960a4}";
  }

  type nsICertVerificationCallbackFunction = (aPRErrorCode: number, aVerifiedChain: (nsIX509Cert | null)[], aHasEVPolicy: boolean) => void;

  /**
   * Callback type for use with asyncVerifyCertAtTime.
   * If aPRErrorCode is PRErrorCodeSuccess (i.e. 0), aVerifiedChain represents the
   * verified certificate chain determined by asyncVerifyCertAtTime. aHasEVPolicy
   * represents whether or not the end-entity certificate verified as EV.
   * If aPRErrorCode is non-zero, it represents the error encountered during
   * verification. aVerifiedChain is null in that case and aHasEVPolicy has no
   * meaning.
   */
  export interface nsICertVerificationCallback extends nsISupports {

    readonly verifyCertFinished: (aPRErrorCode: number, aVerifiedChain: (nsIX509Cert | null)[], aHasEVPolicy: boolean) => void;
  }

  export interface nsIInterfaceRequestorRef {
    readonly name: "nsIInterfaceRequestor";
    readonly number: "{033a1470-8b2a-11d3-af88-00a024ffc08c}";
  }

  /**
   * The nsIInterfaceRequestor interface defines a generic interface for
   * requesting interfaces that a given object might provide access to.
   * This is very similar to QueryInterface found in nsISupports.
   * The main difference is that interfaces returned from GetInterface()
   * are not required to provide a way back to the object implementing this
   * interface.  The semantics of QI() dictate that given an interface A that
   * you QI() on to get to interface B, you must be able to QI on B to get back
   * to A.  This interface however allows you to obtain an interface C from A
   * that may or most likely will not have the ability to get back to A.
   */
  export interface nsIInterfaceRequestor extends nsISupports {
  }

  export interface nsINetDashboardCallbackRef {
    readonly name: "nsINetDashboardCallback";
    readonly number: "{19d7f24f-a95a-4fd9-87e2-d96e9e4b1f6d}";
  }

  type nsINetDashboardCallbackFunction = (data: IDLjsval) => void;

  export interface nsINetDashboardCallback extends nsISupports {

    readonly onDashboardDataAvailable: (data: IDLjsval) => void;
  }

  export interface nsIPKCS11ModuleDBRef {
    readonly name: "nsIPKCS11ModuleDB";
    readonly number: "{ff9fbcd7-9517-4334-b97a-ceed78909974}";
  }

  export interface nsIPKCS11ModuleDB extends nsISupports {

    readonly deleteModule: (moduleName: IDLAString) => void;

    readonly addModule: (moduleName: IDLAString, libraryFullPath: IDLAString, cryptoMechanismFlags: number, cipherFlags: number) => void;

    readonly listModules: () => (nsISimpleEnumerator | null);

    readonly canToggleFIPS: boolean;

    readonly toggleFIPSMode: () => void;

    readonly isFIPSEnabled: boolean;
  }

  export interface nsIPresentationTerminateRequestRef {
    readonly name: "nsIPresentationTerminateRequest";
    readonly number: "{3ddbf3a4-53ee-4b70-9bbc-58ac90dce6b5}";
  }

  export interface nsIPresentationTerminateRequest extends nsISupports {

    readonly device: (nsIPresentationDevice | null);

    readonly presentationId: IDLAString;

    readonly controlChannel: (nsIPresentationControlChannel | null);

    readonly isFromReceiver: boolean;
  }

  export interface nsISimpleStreamListenerRef {
    readonly name: "nsISimpleStreamListener";
    readonly number: "{a9b84f6a-0824-4278-bae6-bfca0570a26e}";
  }

  /**
   * A simple stream listener can be used with AsyncRead to supply data to
   * a output stream.
   */
  export interface nsISimpleStreamListener extends nsIStreamListener {

    /**
     * Initialize the simple stream listener.
     *
     * @param aSink data will be read from the channel to this output stream.
     *              Must implement writeFrom.
     * @param aObserver optional stream observer (can be NULL)
     */
    readonly init: (aSink: (nsIOutputStream | null), aObserver: (nsIRequestObserver | null)) => void;
  }

  export interface nsIWorkerDebuggerListenerRef {
    readonly name: "nsIWorkerDebuggerListener";
    readonly number: "{9cf3b48e-361d-486a-8917-55cf8d00bb41}";
  }

  export interface nsIWorkerDebuggerListener extends nsISupports {

    readonly onClose: () => void;

    readonly onError: (filename: IDLAString, lineno: number, message: IDLAString) => void;

    readonly onMessage: (message: IDLAString) => void;
  }

  export interface nsIStandardURLRef {
    readonly name: "nsIStandardURL";
    readonly number: "{babd6cca-ebe7-4329-967c-d6b9e33caa81}";

    /**
     * blah:foo/bar    => blah://foo/bar
     * blah:/foo/bar   => blah:///foo/bar
     * blah://foo/bar  => blah://foo/bar
     * blah:///foo/bar => blah:///foo/bar
     */
    URLTYPE_STANDARD: 1;

    /**
     * blah:foo/bar    => blah://foo/bar
     * blah:/foo/bar   => blah://foo/bar
     * blah://foo/bar  => blah://foo/bar
     * blah:///foo/bar => blah://foo/bar
     */
    URLTYPE_AUTHORITY: 2;

    /**
     * blah:foo/bar    => blah:///foo/bar
     * blah:/foo/bar   => blah:///foo/bar
     * blah://foo/bar  => blah://foo/bar
     * blah:///foo/bar => blah:///foo/bar
     */
    URLTYPE_NO_AUTHORITY: 3;
  }

  /**
   * nsIStandardURL defines the interface to an URL with the standard
   * file path format common to protocols like http, ftp, and file.
   * It supports initialization from a relative path and provides
   * some customization on how URLs are normalized.
   */
  export interface nsIStandardURL extends nsISupports {
  }

  export interface nsIPushSubscriptionCallbackRef {
    readonly name: "nsIPushSubscriptionCallback";
    readonly number: "{1799c074-9d52-46b0-ab3c-c09790732f6f}";
  }

  type nsIPushSubscriptionCallbackFunction = (status: number, subscription: (nsIPushSubscription | null)) => void;

  /**
   * Called by methods that return a push subscription. A non-success
   * |status| indicates that there was a problem returning the
   * subscription, and the |subscription| argument should be ignored. Otherwise,
   * |subscription| will point to a valid push subscription, or |null| if the
   * subscription does not exist.
   */
  export interface nsIPushSubscriptionCallback extends nsISupports {

    readonly onPushSubscription: (status: number, subscription: (nsIPushSubscription | null)) => void;
  }

  export interface nsITimerCallbackRef {
    readonly name: "nsITimerCallback";
    readonly number: "{a796816d-7d47-4348-9ab8-c7aeb3216a7d}";
  }

  type nsITimerCallbackFunction = (timer: (nsITimer | null)) => void;

  export interface nsITimerCallback extends nsISupports {

    /**
     * @param aTimer the timer which has expired
     */
    readonly notify: (timer: (nsITimer | null)) => void;
  }

  export interface nsIPresentationChannelDescriptionRef {
    readonly name: "nsIPresentationChannelDescription";
    readonly number: "{ae318e05-2a4e-4f85-95c0-e8b191ad812c}";

    TYPE_TCP: 1;

    TYPE_DATACHANNEL: 2;
  }

  export interface nsIPresentationChannelDescription extends nsISupports {

    readonly type: number;

    readonly tcpAddress: (nsIArray | null);

    readonly tcpPort: number;

    readonly dataChannelSDP: IDLAString;
  }

  export interface nsIUnicharLineInputStreamRef {
    readonly name: "nsIUnicharLineInputStream";
    readonly number: "{67f42475-ba80-40f8-ac0b-649c89230184}";
  }

  export interface nsIUnicharLineInputStream extends nsISupports {

    /**
     * Read a single line from the stream, where a line is a
     * possibly zero length sequence of characters terminated by a
     * CR, LF, CRLF, LFCR, or eof.
     * The line terminator is not returned.
     * @retval false
     *         End of file. This line is the last line of the file
     *         (aLine is valid).
     * @retval true
     *         The file contains further lines.
     * @note Do not mix readLine with other read functions.
     *       Doing so can cause various problems and is not supported.
     */
    readonly readLine: (aLine: Out<IDLAString>) => boolean;
  }

  export interface nsIRequestObserverProxyRef {
    readonly name: "nsIRequestObserverProxy";
    readonly number: "{c2b06151-1bf8-4eef-aea9-1532f12f5a10}";
  }

  /**
   * A request observer proxy is used to ship data over to another thread
   * specified by the thread's dispatch target. The "true" request observer's
   * methods are invoked on the other thread.
   *
   * This interface only provides the initialization needed after construction.
   * Otherwise, these objects are used simply as nsIRequestObserver's.
   */
  export interface nsIRequestObserverProxy extends nsIRequestObserver {

    /**
     * Initializes an nsIRequestObserverProxy.
     *
     * @param observer - receives observer notifications on the main thread
     * @param context  - the context argument that will be passed to OnStopRequest
     *                   and OnStartRequest. This has to be stored permanently on
     *                   initialization because it sometimes can't be
     *                   AddRef/Release'd off-main-thread.
     */
    readonly init: (observer: (nsIRequestObserver | null), context: (nsISupports | null)) => void;
  }

  export interface nsIHTMLAbsPosEditorRef {
    readonly name: "nsIHTMLAbsPosEditor";
    readonly number: "{91375f52-20e6-4757-9835-eb04fabe5498}";
  }

  export interface nsIHTMLAbsPosEditor extends nsISupports {

    /**
     * true if Absolute Positioning handling is enabled in the editor
     */
    absolutePositioningEnabled: boolean;

    /**
     * true if Snap To Grid is enabled in the editor.
     */
    snapToGridEnabled: boolean;

    /**
     * sets the grid size in pixels.
     * @param aSizeInPixels [IN] the size of the grid in pixels
     */
    gridSize: number;

    /**
     * refreshes the grabber if it shown, possibly updating its position or
     * even hiding it.
     * FYI: Current user in script is only BlueGriffon.
     */
    readonly refreshGrabber: () => void;
  }

  export interface nsIMIMEServiceRef {
    readonly name: "nsIMIMEService";
    readonly number: "{5b3675a1-02db-4f8f-a560-b34736635f47}";
  }

  /**
   * The MIME service is responsible for mapping file extensions to MIME-types
   * (see RFC 2045). It also provides access to nsIMIMEInfo interfaces and
   * acts as a general convenience wrapper of nsIMIMEInfo interfaces.
   *
   * The MIME service maintains a database with a <b>one</b> MIME type <b>to many</b>
   * file extensions rule. Adding the same file extension to multiple MIME types
   * is illegal and behavior is undefined.
   *
   * @see nsIMIMEInfo
   */
  export interface nsIMIMEService extends nsISupports {

    /**
     * Retrieves an nsIMIMEInfo using both the extension
     * and the type of a file. The type is given preference
     * during the lookup. One of aMIMEType and aFileExt
     * can be an empty string. At least one of aMIMEType and aFileExt
     * must be nonempty.
     */
    readonly getFromTypeAndExtension: (aMIMEType: IDLACString, aFileExt: IDLAUTF8String) => (nsIMIMEInfo | null);

    /**
     * Retrieves a ACString representation of the MIME type
     * associated with this file extension.
     *
     * @param  A file extension (excluding the dot ('.')).
     * @return The MIME type, if any.
     */
    readonly getTypeFromExtension: (aFileExt: IDLAUTF8String) => IDLACString;

    /**
     * Retrieves a ACString representation of the MIME type
     * associated with this URI. The association is purely
     * file extension to MIME type based. No attempt to determine
     * the type via server headers or byte scanning is made.
     *
     * @param  The URI the user wants MIME info on.
     * @return The MIME type, if any.
     */
    readonly getTypeFromURI: (aURI: (nsIURI | null)) => IDLACString;

    readonly getTypeFromFile: (aFile: (nsIFile | null)) => IDLACString;

    /**
     * Given a Type/Extension combination, returns the default extension
     * for this type. This may be identical to the passed-in extension.
     *
     * @param aMIMEType The Type to get information on. Must not be empty.
     * @param aFileExt  File Extension. Can be empty.
     */
    readonly getPrimaryExtension: (aMIMEType: IDLACString, aFileExt: IDLAUTF8String) => IDLAUTF8String;

    readonly getMIMEInfoFromOS: (aType: IDLACString, aFileExtension: IDLACString, aFound: Out<boolean>) => (nsIMIMEInfo | null);
  }

  export interface nsIWebSocketEventServiceRef {
    readonly name: "nsIWebSocketEventService";
    readonly number: "{b89d1b90-2cf3-4d8f-ac21-5aedfb25c760}";
  }

  export interface nsIWebSocketEventService extends nsISupports {

    readonly addListener: (aInnerWindowID: number, aListener: (nsIWebSocketEventListener | null)) => void;

    readonly removeListener: (aInnerWindowID: number, aListener: (nsIWebSocketEventListener | null)) => void;

    readonly hasListenerFor: (aInnerWindowID: number) => boolean;
  }

  export interface nsIMethodChangeDetailsRef {
    readonly name: "nsIMethodChangeDetails";
    readonly number: "{2035e0a9-c9ab-4c9f-b8e9-28b2ed61548c}";

    /**
     *  The consts for representing the method change details data type.
     *  GENERAL_DETAILS is the general purpose details data type. Except basic
     *  card details, all details should belong to this type.
     *  BASICCARD_DETAILS is a special details data type for basic card change
     *  details.
     */
    GENERAL_DETAILS: 0;

    BASICCARD_DETAILS: 1;
  }

  export interface nsIMethodChangeDetails extends nsISupports {

    /**
     *  The method change details data type.
     *  Using the above defined consts(GENERAL_DETAILS or BASICCARD_DETAILS).
     */
    readonly type: number;

    /**
     *  The initial method.
     *  @param aType - the method change details data type.
     */
    readonly init: (aType: number) => void;
  }

  export interface nsIMemoryReporterRef {
    readonly name: "nsIMemoryReporter";
    readonly number: "{92a36db1-46bd-4fe6-988e-47db47236d8b}";

    KIND_NONHEAP: 0;

    KIND_HEAP: 1;

    KIND_OTHER: 2;

    UNITS_BYTES: 0;

    UNITS_COUNT: 1;

    UNITS_COUNT_CUMULATIVE: 2;

    UNITS_PERCENTAGE: 3;
  }

  export interface nsIMemoryReporter extends nsISupports {

    readonly collectReports: (callback: (nsIHandleReportCallback | nsIHandleReportCallbackFunction | null), data: (nsISupports | null), anonymize: boolean) => void;
  }

  export interface nsIStandardURLMutatorRef {
    readonly name: "nsIStandardURLMutator";
    readonly number: "{fc894e98-23a1-43cd-a7fe-72876f8ea2ee}";
  }

  export interface nsIStandardURLMutator extends nsISupports {

    /**
     * Initialize a standard URL.
     *
     * @param aUrlType       - one of the URLTYPE_ flags listed above.
     * @param aDefaultPort   - if the port parsed from the URL string matches
     *                         this port, then the port will be removed from the
     *                         canonical form of the URL.
     * @param aSpec          - URL string.
     * @param aOriginCharset - the charset from which this URI string
     *                         originated.  this corresponds to the charset
     *                         that should be used when communicating this
     *                         URI to an origin server, for example.  if
     *                         null, then provide aBaseURI implements this
     *                         interface, the origin charset of aBaseURI will
     *                         be assumed, otherwise defaulting to UTF-8 (i.e.,
     *                         no charset transformation from aSpec).
     * @param aBaseURI       - if null, aSpec must specify an absolute URI.
     *                         otherwise, aSpec will be resolved relative
     *                         to aBaseURI.
     */
    readonly init: (aUrlType: number, aDefaultPort: number, aSpec: IDLAUTF8String, aOriginCharset: string, aBaseURI: (nsIURI | null)) => (nsIURIMutator | null);

    /**
     * Set the default port.
     *
     * Note: If this object is already using its default port (i.e. if it has
     * mPort == -1), then it will now implicitly be using the new default port.
     *
     * @param aNewDefaultPort - if the URI has (or is later given) a port that
     *                          matches this default, then we won't include a
     *                          port number in the canonical form of the URL.
     */
    readonly setDefaultPort: (aNewDefaultPort: number) => (nsIURIMutator | null);
  }

  export interface nsIXPCComponents_ConstructorRef {
    readonly name: "nsIXPCComponents_Constructor";
    readonly number: "{88655640-e028-11d3-8f5d-0010a4e73d9a}";
  }

  /**
   * interface of Components.Constructor
   * (interesting stuff only reflected into JavaScript)
   */
  export interface nsIXPCComponents_Constructor extends nsISupports {
  }

  export interface nsIHttpActivityDistributorRef {
    readonly name: "nsIHttpActivityDistributor";
    readonly number: "{7c512cb8-582a-4625-b5b6-8639755271b5}";
  }

  /**
   * nsIHttpActivityDistributor
   *
   * This interface provides a way to register and unregister observers to the
   * http activities.
   */
  export interface nsIHttpActivityDistributor extends nsIHttpActivityObserver {

    readonly addObserver: (aObserver: (nsIHttpActivityObserver | null)) => void;

    readonly removeObserver: (aObserver: (nsIHttpActivityObserver | null)) => void;
  }

  export interface nsIHelperAppLauncherRef {
    readonly name: "nsIHelperAppLauncher";
    readonly number: "{acf2a516-7d7f-4771-8b22-6c4a559c088e}";
  }

  /**
   * A helper app launcher is a small object created to handle the launching
   * of an external application.
   *
   * Note that cancelling the load via the nsICancelable interface will release
   * the reference to the launcher dialog.
   */
  export interface nsIHelperAppLauncher extends nsICancelable {

    /**
     * The mime info object associated with the content type this helper app
     * launcher is currently attempting to load
     */
    readonly MIMEInfo: (nsIMIMEInfo | null);

    /**
     * The source uri
     */
    readonly source: (nsIURI | null);

    /**
     * The suggested name for this file
     */
    readonly suggestedFileName: IDLAString;

    /**
     * Saves the final destination of the file. Does not actually perform the
     * save.
     * NOTE: This will release the reference to the
     * nsIHelperAppLauncherDialog.
     */
    readonly saveToDisk: (aNewFileLocation: (nsIFile | null), aRememberThisPreference: boolean) => void;

    /**
     * Remembers that aApplication should be used to launch this content. Does
     * not actually launch the application.
     * NOTE: This will release the reference to the nsIHelperAppLauncherDialog.
     * @param aApplication nsIFile corresponding to the location of the application to use.
     * @param aRememberThisPreference TRUE if we should remember this choice.
     */
    readonly launchWithApplication: (aApplication: (nsIFile | null), aRememberThisPreference: boolean) => void;

    /**
     * Callback invoked by nsIHelperAppLauncherDialog::promptForSaveToFileAsync
     * after the user has chosen a file through the File Picker (or dismissed it).
     * @param aFile The file that was chosen by the user (or null if dialog was dismissed).
     */
    readonly saveDestinationAvailable: (aFile: (nsIFile | null)) => void;

    /**
     * The following methods are used by the progress dialog to get or set
     * information on the current helper app launcher download.
     * This reference will be released when the download is finished (after the
     * listener receives the STATE_STOP notification).
     */
    readonly setWebProgressListener: (aWebProgressListener: (nsIWebProgressListener2 | null)) => void;

    /**
     * The file we are saving to
     */
    readonly targetFile: (nsIFile | null);

    /**
     * The executable-ness of the target file
     */
    readonly targetFileIsExecutable: boolean;

    /**
     * Time when the download started
     */
    readonly timeDownloadStarted: number;

    /**
     * The download content length, or -1 if the length is not available.
     */
    readonly contentLength: number;
  }

  export interface nsIPropertiesRef {
    readonly name: "nsIProperties";
    readonly number: "{78650582-4e93-4b60-8e85-26ebd3eb14ca}";
  }

  export interface nsIProperties extends nsISupports {

    /**
     * Sets a property with a given name to a given value.
     */
    readonly set: (prop: string, value: (nsISupports | null)) => void;

    /**
     * Returns true if the property with the given name exists.
     */
    readonly has: (prop: string) => boolean;

    /**
     * Undefines a property.
     * @throws NS_ERROR_FAILURE if a property with that name doesn't
     * already exist.
     */
    readonly undefine: (prop: string) => void;

    /**
     *  Returns an array of the keys.
     */
    readonly getKeys: () => IDLACString[];
  }

  export interface amIAddonManagerStartupRef {
    readonly name: "amIAddonManagerStartup";
    readonly number: "{01dfa47b-87e4-4135-877b-586d033e1b5d}";
  }

  export interface amIAddonManagerStartup extends nsISupports {

    /**
     * Reads and parses startup data from the addonState.json.lz4 file, checks
     * for modifications, and returns the result.
     *
     * Returns null for an empty or nonexistent state file, but throws for an
     * invalid one.
     */
    readonly readStartupData: () => IDLjsval;

    /**
     * Registers a set of dynamic chrome registry entries, and returns an object
     * with a `destruct()` method which must be called in order to unregister
     * the entries.
     *
     * @param manifestURI The base manifest URI for the entries. URL values are
     *        resolved relative to this URI.
     * @param entries An array of arrays, each containing a registry entry as it
     *        would appar in a chrome.manifest file. Only the following entry
     *        types are currently accepted:
     *
     *         - "locale" A locale package entry. Must be a 4-element array.
     *         - "override" A URL override entry. Must be a 3-element array.
     */
    readonly registerChrome: (manifestURI: (nsIURI | null), entries: IDLjsval) => (nsIJSRAIIHelper | null);

    readonly encodeBlob: (value: IDLjsval) => IDLjsval;

    readonly decodeBlob: (value: IDLjsval) => IDLjsval;

    /**
     * Enumerates over all entries in the JAR file at the given URI, and returns
     * an array of entry paths which match the given pattern. The URI may be
     * either a file: URL pointing directly to a zip file, or a jar: URI
     * pointing to a zip file nested within another zip file. Only one level of
     * nesting is supported.
     *
     * This should be used in preference to manually opening or retrieving a
     * ZipReader from the zip cache, since the former causes main thread IO and
     * the latter can lead to file locking issues due to unpredictable GC behavior
     * keeping the cached ZipReader alive after the cache is flushed.
     *
     * @param uri The URI of the zip file to enumerate.
     * @param pattern The pattern to match, as passed to nsIZipReader.findEntries.
     */
    readonly enumerateJAR: (uri: (nsIURI | null), pattern: IDLAUTF8String) => IDLAString[];

    /**
     * Similar to |enumerateJAR| above, but accepts the URI of a directory
     * within a JAR file, and returns a list of all entries below it.
     *
     * The given URI must be a jar: URI, and its JAR file must point either to a
     * file: URI, or to a singly-nested JAR within another JAR file (i.e.,
     * "jar:file:///thing.jar!/" or "jar:jar:file:///thing.jar!/stuff.jar!/").
     * Multiple levels of nesting are not supported.
     */
    readonly enumerateJARSubtree: (uri: (nsIURI | null)) => IDLAString[];

    /**
     * Initializes the URL Preloader.
     *
     * NOT FOR USE OUTSIDE OF UNIT TESTS.
     */
    readonly initializeURLPreloader: () => void;
  }

  export interface nsITooltipListenerRef {
    readonly name: "nsITooltipListener";
    readonly number: "{44b78386-1dd2-11b2-9ad2-e4eee2ca1916}";
  }

  /**
   * An optional interface for embedding clients wishing to receive
   * notifications for when a tooltip should be displayed or removed.
   * The embedder implements this interface on the web browser chrome
   * object associated with the window that notifications are required
   * for.
   *
   * @see nsITooltipTextProvider
   */
  export interface nsITooltipListener extends nsISupports {

    /**
     * Called when a tooltip should be displayed.
     *
     * @param aXCoords The tooltip left edge X coordinate.
     * @param aYCoords The tooltip top edge Y coordinate.
     * @param aTipText The text to display in the tooltip, typically obtained
     *        from the TITLE attribute of the node (or containing parent)
     *        over which the pointer has been positioned.
     * @param aTipDir  The direction (ltr or rtl) in which to display the text
     *
     * @note
     * Coordinates are specified in pixels, relative to the top-left
     * corner of the browser area.
     *
     * @return <code>NS_OK</code> if the tooltip was displayed.
     */
    readonly onShowTooltip: (aXCoords: number, aYCoords: number, aTipText: IDLAString, aTipDir: IDLAString) => void;

    /**
     * Called when the tooltip should be hidden, either because the pointer
     * has moved or the tooltip has timed out.
     */
    readonly onHideTooltip: () => void;
  }

  export interface nsISelectionControllerRef {
    readonly name: "nsISelectionController";
    readonly number: "{3801c9d4-8e69-4bfc-9edb-b58278621f8f}";

    SELECTION_NONE: 0;

    SELECTION_NORMAL: 1;

    SELECTION_SPELLCHECK: 2;

    SELECTION_IME_RAWINPUT: 3;

    SELECTION_IME_SELECTEDRAWTEXT: 4;

    SELECTION_IME_CONVERTEDTEXT: 5;

    SELECTION_IME_SELECTEDCONVERTEDTEXT: 6;

    SELECTION_ACCESSIBILITY: 7;

    SELECTION_FIND: 8;

    SELECTION_URLSECONDARY: 9;

    SELECTION_URLSTRIKEOUT: 10;

    NUM_SELECTIONTYPES: 11;

    SELECTION_ANCHOR_REGION: 0;

    SELECTION_FOCUS_REGION: 1;

    SELECTION_WHOLE_SELECTION: 2;

    NUM_SELECTION_REGIONS: 3;

    SELECTION_OFF: 0;

    SELECTION_HIDDEN: 1;

    SELECTION_ON: 2;

    SELECTION_DISABLED: 3;

    SELECTION_ATTENTION: 4;

    SCROLL_SYNCHRONOUS: 2;

    SCROLL_FIRST_ANCESTOR_ONLY: 4;

    SCROLL_CENTER_VERTICALLY: 16;

    SCROLL_OVERFLOW_HIDDEN: 32;

    SCROLL_FOR_CARET_MOVE: 64;

    /**
     * nsFrameSelection::PhysicalMove depends on the ordering of these values;
     * do not change without checking there!
     */
    MOVE_LEFT: 0;

    MOVE_RIGHT: 1;

    MOVE_UP: 2;

    MOVE_DOWN: 3;
  }

  export interface nsISelectionController extends nsISelectionDisplay {

    /**
     * SetDisplaySelection will set the display mode for the selection. OFF,ON,DISABLED
     */
    readonly setDisplaySelection: (toggle: number) => void;

    /**
     * GetDisplaySelection will get the display mode for the selection. OFF,ON,DISABLED
     */
    readonly getDisplaySelection: () => number;

    /**
     * GetSelection will return the selection that the presentation
     *  shell may implement.
     *
     * @param aType This will hold the type of selection.  This value must be one
     *              of RawSelectionType values.
     * @param _return will hold the return value
     */
    readonly getSelection: (type: number) => WebIDL.Selection;

    /**
     * ScrollSelectionIntoView scrolls a region of the selection,
     * so that it is visible in the scrolled view.
     *
     * @param aType the selection to scroll into view.  This value must be one
     *              of RawSelectionType values.
     * @param aRegion the region inside the selection to scroll into view. //SelectionRegion
     * @param aFlags the scroll flags.  Valid bits include:
     * SCROLL_SYNCHRONOUS: when set, scrolls the selection into view
     * before returning. If not set, posts a request which is processed
     * at some point after the method returns.
     * SCROLL_FIRST_ANCESTOR_ONLY: if set, only the first ancestor will be scrolled
     * into view.
     * SCROLL_OVERFLOW_HIDDEN: if set, scrolls even if the overflow is specified
     * as hidden.
     * SCROLL_FOR_CARET_MOVE: set to indicate whether scrolling is in response
     * to the caret being moved. Does not affect behavior (used for telemetry
     * purposes only).
     *
     * Note that if isSynchronous is true, then this might flush the pending
     * reflow. It's dangerous for some objects. See bug 418470 comment 12.
     */
    readonly scrollSelectionIntoView: (type: number, region: number, flags: number) => void;

    /**
     * RepaintSelection repaints the selection specified by aType.
     *
     * @param aType specifies the selection to repaint.
     */
    readonly repaintSelection: (type: number) => void;

    /**
     * Set the caret as enabled or disabled. An enabled caret will
     * draw or blink when made visible. A disabled caret will never show up.
     * Can be called any time.
     * @param aEnable PR_TRUE to enable caret.  PR_FALSE to disable.
     * @return always NS_OK
     */
    readonly setCaretEnabled: (enabled: boolean) => void;

    /**
     * Set the caret readonly or not. An readonly caret will
     * draw but not blink when made visible.
     * @param aReadOnly PR_TRUE to enable caret.  PR_FALSE to disable.
     * @return always NS_OK
     */
    readonly setCaretReadOnly: (readOnly: boolean) => void;

    /**
     * Gets the current state of the caret.
     * @param aEnabled  [OUT] set to the current caret state, as set by SetCaretEnabled
     * @return   if aOutEnabled==null, returns NS_ERROR_INVALID_ARG
     *           else NS_OK
     */
    readonly getCaretEnabled: () => boolean;

    /**
     * This is true if the caret is enabled, visible, and currently blinking.
     * This is still true when the caret is enabled, visible, but in its "off"
     * blink cycle.
     */
    readonly caretVisible: boolean;

    /**
     * Show the caret even in selections. By default the caret is hidden unless the
     * selection is collapsed. Use this function to show the caret even in selections.
     * @param aVisibility PR_TRUE to show the caret in selections.  PR_FALSE to hide.
     * @return always NS_OK
     */
    readonly setCaretVisibilityDuringSelection: (visibility: boolean) => void;

    /** CharacterMove will move the selection one character forward/backward in the document.
     *  this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     *  the "point" of selection that is extended is considered the "focus" point.
     *  or the last point adjusted by the selection.
     *  @param aForward forward or backward if PR_FALSE
     *  @param aExtend  should it collapse the selection of extend it?
     */
    readonly characterMove: (forward: boolean, extend: boolean) => void;

    /** PhysicalMove will move the selection one "unit" in a given direction
     *  within the document.
     *  this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     *  the "point" of selection that is extended is considered the "focus" point.
     *  or the last point adjusted by the selection.
     *  @param aDirection
     *  @param aAmount    character/line; word/lineBoundary
     *  @param aExtend    should it collapse the selection of extend it?
     */
    readonly physicalMove: (direction: number, amount: number, extend: boolean) => void;

    /** WordMove will move the selection one word forward/backward in the document.
     *  this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     *  the "point" of selection that is extended is considered the "focus" point.
     *  or the last point adjusted by the selection.
     *  @param aForward forward or backward if PR_FALSE
     *  @param aExtend  should it collapse the selection of extend it?
     */
    readonly wordMove: (forward: boolean, extend: boolean) => void;

    /** LineMove will move the selection one line forward/backward in the document.
     *  this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     *  the "point" of selection that is extended is considered the "focus" point.
     *  or the last point adjusted by the selection.
     *  @param aForward forward or backward if PR_FALSE
     *  @param aExtend  should it collapse the selection of extend it?
     */
    readonly lineMove: (forward: boolean, extend: boolean) => void;

    /** IntraLineMove will move the selection to the front of the line or end of the line
     *  in the document.
     *  this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     *  the "point" of selection that is extended is considered the "focus" point.
     *  or the last point adjusted by the selection.
     *  @param aForward forward or backward if PR_FALSE
     *  @param aExtend  should it collapse the selection of extend it?
     */
    readonly intraLineMove: (forward: boolean, extend: boolean) => void;

    /** PageMove will move the selection one page forward/backward in the document.
     *  this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     *  the "point" of selection that is extended is considered the "focus" point.
     *  or the last point adjusted by the selection.
     *  @param aForward forward or backward if PR_FALSE
     *  @param aExtend  should it collapse the selection of extend it?
     */
    readonly pageMove: (forward: boolean, extend: boolean) => void;

    /** CompleteScroll will move page view to the top or bottom of the document
     *  @param aForward forward or backward if PR_FALSE
     */
    readonly completeScroll: (forward: boolean) => void;

    /** CompleteMove will move page view to the top or bottom of the document
     *  this will also have the effect of collapsing the selection if the aExtend = PR_FALSE
     *  the "point" of selection that is extended is considered the "focus" point.
     *  or the last point adjusted by the selection.
     *  @param aForward forward or backward if PR_FALSE
     *  @param aExtend  should it collapse the selection of extend it?
     */
    readonly completeMove: (forward: boolean, extend: boolean) => void;

    /** ScrollPage will scroll the page without affecting the selection.
     *  @param aForward scroll forward or backwards in selection
     */
    readonly scrollPage: (forward: boolean) => void;

    /** ScrollLine will scroll line up or down dependent on the boolean
     *  @param aForward scroll forward or backwards in selection
     */
    readonly scrollLine: (forward: boolean) => void;

    /** ScrollCharacter will scroll right or left dependent on the boolean
     *  @param aRight if true will scroll right. if not will scroll left.
     */
    readonly scrollCharacter: (right: boolean) => void;

    /** SelectAll will select the whole page
     */
    readonly selectAll: () => void;

    /** CheckVisibility will return true if textnode and offsets are actually rendered
     *  in the current precontext.
     *  @param aNode textNode to test
     *  @param aStartOffset  offset in dom to first char of textnode to test
     *  @param aEndOffset    offset in dom to last char of textnode to test
     *  @param aReturnBool   boolean returned TRUE if visible FALSE if not
     */
    readonly checkVisibility: (node: WebIDL.Node, startOffset: number, endOffset: number) => boolean;
  }

  export interface nsIIDBPermissionsRequestRef {
    readonly name: "nsIIDBPermissionsRequest";
    readonly number: "{c3493c65-0530-496e-995c-bcd38dbfce21}";
  }

  export interface nsIIDBPermissionsRequest extends nsISupports {

    readonly browserElement: WebIDL.Element;

    readonly responseObserver: (nsIObserver | null);
  }

  export interface nsIMessageLoopRef {
    readonly name: "nsIMessageLoop";
    readonly number: "{3e8c58e8-e52c-43e0-8e66-669ca788ff5f}";
  }

  /**
   * This service allows access to the current thread's Chromium MessageLoop
   * instance, with some extra sugar added.  If you're calling from C++, it may
   * or may not make sense for you to use this interface.  If you're calling from
   * JS, you don't have a choice!
   *
   * Right now, you can only call PostIdleTask(), and the wrath of khuey is
   * stopping you from adding other methods.
   *
   * nsIMessageLoop's contractid is "@mozilla.org/message-loop;1".
   */
  export interface nsIMessageLoop extends nsISupports {

    /**
     * Posts a task to be run when this thread's message loop is idle, or after
     * ensureRunsAfterMS milliseconds have elapsed.  (That is, the task is
     * guaranteed to run /eventually/.)
     *
     * Note that if the event loop is busy, we will hold a reference to the task
     * until ensureRunsAfterMS milliseconds have elapsed.  Be careful when
     * specifying long timeouts and tasks which hold references to windows or
     * other large objects, because you can leak memory in a difficult-to-detect
     * way!
     */
    readonly postIdleTask: (task: (nsIRunnable | nsIRunnableFunction | null), ensureRunsAfterMS: number) => void;
  }

  export interface imgINotificationObserverRef {
    readonly name: "imgINotificationObserver";
    readonly number: "{03da5641-a333-454a-a859-036d0bb683b7}";

    SIZE_AVAILABLE: 1;

    FRAME_UPDATE: 2;

    FRAME_COMPLETE: 3;

    LOAD_COMPLETE: 4;

    DECODE_COMPLETE: 5;

    DISCARD: 6;

    UNLOCKED_DRAW: 7;

    IS_ANIMATED: 8;

    HAS_TRANSPARENCY: 9;
  }

  export interface imgINotificationObserver extends nsISupports {
  }

  export interface nsINestedAboutURIMutatorRef {
    readonly name: "nsINestedAboutURIMutator";
    readonly number: "{c6357a3b-c2bb-4b4b-9278-513377398a38}";
  }

  export interface nsINestedAboutURIMutator extends nsISupports {
  }

  export interface nsIFxAccountsUIGlueRef {
    readonly name: "nsIFxAccountsUIGlue";
    readonly number: "{ab8d0700-9577-11e3-a5e2-0800200c9a66}";
  }

  export interface nsIFxAccountsUIGlue extends nsISupports {

    readonly signInFlow: () => IDLjsval;

    readonly refreshAuthentication: (email: IDLAString) => IDLjsval;
  }

  export interface nsILoginReputationQueryRef {
    readonly name: "nsILoginReputationQuery";
    readonly number: "{c21ffe59-595f-46c8-9052-fefb639e196e}";
  }

  export interface nsILoginReputationQuery extends nsISupports {

    readonly formURI: (nsIURI | null);
  }

  export interface nsIParserUtilsRef {
    readonly name: "nsIParserUtils";
    readonly number: "{a1101145-0025-411e-8873-fdf57bf28128}";

    /**
     * Flag for sanitizer: Allow comment nodes.
     */
    SanitizerAllowComments: 1;

    /**
     * Flag for sanitizer: Allow <style> and style="" (with contents sanitized
     * in case of -moz-binding). Note! If -moz-binding is absent, properties
     * that might be XSS risks in other Web engines are preserved!
     */
    SanitizerAllowStyle: 2;

    /**
     * Flag for sanitizer: Only allow cid: URLs for embedded content.
     *
     * At present, sanitizing CSS backgrounds, etc., is not supported, so setting
     * this together with SanitizerAllowStyle doesn't make sense.
     *
     * At present, sanitizing CSS syntax in SVG presentational attributes is not
     * supported, so this option flattens out SVG.
     */
    SanitizerCidEmbedsOnly: 4;

    /**
     * Flag for sanitizer: Drop non-CSS presentational HTML elements and
     * attributes, such as <font>, <center> and bgcolor="".
     */
    SanitizerDropNonCSSPresentation: 8;

    /**
     * Flag for sanitizer: Drop forms and form controls (excluding
     * fieldset/legend).
     */
    SanitizerDropForms: 16;

    /**
     * Flag for sanitizer: Drop <img>, <video>, <audio> and <source> and flatten
     * out SVG.
     */
    SanitizerDropMedia: 32;

    /**
     * Flag for sanitizer: Log messages to the console for everything that gets
     * sanitized
     */
    SanitizerLogRemovals: 64;

    /**
     * Flag for sanitizer: Only CSS conditional rules will be moved,
     * nothing else will be changed.
     * Can be combined with flag SanitizerLogRemovals, only.
     */
    SanitizerRemoveOnlyConditionalCSS: 128;
  }

  /**
   * Non-Web HTML parser functionality to Firefox extensions and XULRunner apps.
   * Don't use this from within Gecko--use nsContentUtils, nsTreeSanitizer, etc.
   * directly instead.
   */
  export interface nsIParserUtils extends nsISupports {

    /**
     * Parses a string into an HTML document, sanitizes the document and
     * returns the result serialized to a string.
     *
     * The sanitizer is designed to protect against XSS when sanitized content
     * is inserted into a different-origin context without an iframe-equivalent
     * sandboxing mechanism.
     *
     * By default, the sanitizer doesn't try to avoid leaking information that
     * the content was viewed to third parties. That is, by default, e.g.
     * <img src> pointing to an HTTP server potentially controlled by a third
     * party is not removed. To avoid ambient information leakage upon loading
     * the sanitized content, use the SanitizerInternalEmbedsOnly flag. In that
     * case, <a href> links (and similar) to other content are preserved, so an
     * explicit user action (following a link) after the content has been loaded
     * can still leak information.
     *
     * By default, non-dangerous non-CSS presentational HTML elements and
     * attributes or forms are not removed. To remove these, use
     * SanitizerDropNonCSSPresentation and/or SanitizerDropForms.
     *
     * By default, comments and CSS is removed. To preserve comments, use
     * SanitizerAllowComments. To preserve <style> and style="", use
     * SanitizerAllowStyle. -moz-binding is removed from <style> and style="" if
     * present. In this case, properties that Gecko doesn't recognize can get
     * removed as a side effect. Note! If -moz-binding is not present, <style>
     * and style="" and SanitizerAllowStyle is specified, the sanitized content
     * may still be XSS dangerous if loaded into a non-Gecko Web engine!
     *
     * @param src the HTML source to parse (C++ callers are allowed but not
     *            required to use the same string for the return value.)
     * @param flags sanitization option flags defined above
     */
    readonly sanitize: (src: IDLAString, flags: number) => IDLAString;

    /**
     * Convert HTML to plain text.
     *
     * @param src the HTML source to parse (C++ callers are allowed but not
     *            required to use the same string for the return value.)
     * @param flags conversion option flags defined in nsIDocumentEncoder
     * @param wrapCol number of characters per line; 0 for no auto-wrapping
     */
    readonly convertToPlainText: (src: IDLAString, flags: number, wrapCol: number) => IDLAString;

    /**
     * Parses markup into a sanitized document fragment.
     *
     * @param fragment the input markup
     * @param flags sanitization option flags defined above
     * @param isXML true if |fragment| is XML and false if HTML
     * @param baseURI the base URL for this fragment
     * @param element the context node for the fragment parsing algorithm
     */
    readonly parseFragment: (fragment: IDLAString, flags: number, isXML: boolean, baseURI: (nsIURI | null), element: WebIDL.Element) => WebIDL.DocumentFragment;
  }

  export interface nsIUrlListManagerRef {
    readonly name: "nsIUrlListManager";
    readonly number: "{d60a08ee-5c83-4eb6-bdfb-79fd0716501e}";
  }

  /**
   * Interface for a class that manages updates of the url classifier database.
   */
  export interface nsIUrlListManager extends nsISupports {

    /**
     * Get the gethash url for this table
     */
    readonly getGethashUrl: (tableName: IDLACString) => IDLACString;

    /**
     * Get the update url for this table
     */
    readonly getUpdateUrl: (tableName: IDLACString) => IDLACString;

    /**
     * Add a table to the list of tables we are managing. The name is a
     * string of the format provider_name-semantic_type-table_type.  For
     * @param tableName A string of the format
     *        provider_name-semantic_type-table_type.  For example,
     *        goog-white-enchash or goog-black-url.
     * @param providerName The name of the entity providing the list.
     * @param updateUrl The URL from which to fetch updates.
     * @param gethashUrl The URL from which to fetch hash completions.
     */
    readonly registerTable: (tableName: IDLACString, providerName: IDLACString, updateUrl: IDLACString, gethashUrl: IDLACString) => boolean;

    /**
     * Unregister table from the list
     */
    readonly unregisterTable: (tableName: IDLACString) => void;

    /**
     * Turn on update checking for a table. I.e., during the next server
     * check, download updates for this table.
     */
    readonly enableUpdate: (tableName: IDLACString) => void;

    /**
     * Turn off update checking for all tables.
     */
    readonly disableAllUpdates: () => void;

    /**
     * Turn off update checking for a single table. Only used in tests.
     */
    readonly disableUpdate: (tableName: IDLACString) => void;

    /**
     * Toggle update checking, if necessary.
     */
    readonly maybeToggleUpdateChecking: () => void;

    /**
     * This is currently used by about:url-classifier to force an update
     * for the update url. Update may still fail because of backoff algorithm.
     */
    readonly checkForUpdates: (updateUrl: IDLACString) => boolean;

    /**
     * Force updates for the given tables, updates are still restricted to
     * backoff algorithm.
     * @param tables  A string lists all the tables that we want to trigger updates.
     *                table names are separated with ','.
     */
    readonly forceUpdates: (tableNames: IDLACString) => boolean;

    /**
     * This is currently used by about:url-classifier to get back-off time
     * (in millisecond since epoch) for the given provider. Return 0 if we
     * are not in back-off mode.
     */
    readonly getBackOffTime: (provider: IDLACString) => number;

    /**
     * Return true if someone registers a table, this is used by testcase
     * to figure out it SafeBrowsing.jsm is initialized.
     */
    readonly isRegistered: () => boolean;
  }

  export interface nsIPKCS11SlotRef {
    readonly name: "nsIPKCS11Slot";
    readonly number: "{c2d4f296-ee60-11d4-998b-00b0d02354a0}";

    SLOT_DISABLED: 0;

    SLOT_NOT_PRESENT: 1;

    SLOT_UNINITIALIZED: 2;

    SLOT_NOT_LOGGED_IN: 3;

    SLOT_LOGGED_IN: 4;

    SLOT_READY: 5;
  }

  export interface nsIPKCS11Slot extends nsISupports {

    readonly name: IDLAUTF8String;

    readonly desc: IDLAUTF8String;

    /**
     * Manufacturer ID of the slot.
     */
    readonly manID: IDLAUTF8String;

    /**
     * Hardware version of the slot.
     */
    readonly HWVersion: IDLAUTF8String;

    /**
     * Firmware version of the slot.
     */
    readonly FWVersion: IDLAUTF8String;

    readonly status: number;

    readonly getToken: () => (nsIPK11Token | null);

    readonly tokenName: IDLAUTF8String;
  }

  export interface nsIIdentityCryptoServiceRef {
    readonly name: "nsIIdentityCryptoService";
    readonly number: "{f087e6bc-dd33-4f6c-a106-dd786e052ee9}";
  }

  export interface nsIIdentityCryptoService extends nsISupports {

    readonly generateKeyPair: (algorithm: IDLAUTF8String, callback: (nsIIdentityKeyGenCallback | nsIIdentityKeyGenCallbackFunction | null)) => void;

    readonly base64UrlEncode: (toEncode: IDLAUTF8String) => IDLACString;
  }

  export interface nsIContentPrefObserverRef {
    readonly name: "nsIContentPrefObserver";
    readonly number: "{43635c53-b445-4c4e-8cc5-562697299b55}";
  }

  export interface nsIContentPrefObserver extends nsISupports {

    /**
     * Called when a content pref is set to a different value.
     *
     * @param    aGroup      the group to which the pref belongs, or null
     *                       if it's a global pref (applies to all sites)
     * @param    aName       the name of the pref that was set
     * @param    aValue      the new value of the pref
     * @param    aIsPrivate  an optional flag determining whether the
     *                       original context is private or not
     */
    readonly onContentPrefSet: (aGroup: IDLAString, aName: IDLAString, aValue: (nsIVariant | null), aIsPrivate?: boolean) => void;

    /**
     * Called when a content pref is removed.
     *
     * @param    aGroup      the group to which the pref belongs, or null
     *                       if it's a global pref (applies to all sites)
     * @param    aName       the name of the pref that was removed
     * @param    aIsPrivate  an optional flag determining whether the
     *                       original context is private or not
     */
    readonly onContentPrefRemoved: (aGroup: IDLAString, aName: IDLAString, aIsPrivate?: boolean) => void;
  }

  export interface nsIKeyObjectFactoryRef {
    readonly name: "nsIKeyObjectFactory";
    readonly number: "{838bdbf1-8244-448f-8bcd-cede70227d75}";
  }

  export interface nsIKeyObjectFactory extends nsISupports {

    readonly keyFromString: (aAlgorithm: number, aKey: IDLACString) => (nsIKeyObject | null);
  }

  export interface nsIPaymentRequestServiceRef {
    readonly name: "nsIPaymentRequestService";
    readonly number: "{cccd665f-edf3-41fc-ab9b-fc55b37340aa}";
  }

  /**
   *  nsPaymentRequestService is used to manage the created PaymentRequest in the
   *  chrome process. It is also the IPC agent for payment UI to communicate with
   *  merchant side.
   */
  export interface nsIPaymentRequestService extends nsISupports {

    /**
     *  Get the nsIPaymentRequest through the given payment request identifier.
     *  @param aRequestId - the payment request identifier.
     *                      This is an internal id generated by Gecko.
     *  @return           - the requested payment request. null if there is no
     *                      coressponding nsIPaymentRequest for aRequestId.
     */
    readonly getPaymentRequestById: (aRequestId: IDLAString) => (nsIPaymentRequest | null);

    /**
     *  Get the enumerator for all managed nsIPaymentRequests.
     *  @return - an enumerator for all managed nsIPaymentRequests.
     */
    readonly enumerate: () => (nsISimpleEnumerator | null);

    /**
     *  Send the user's response to the merchant.
     *  @param aResponse - the user's response.
     */
    readonly respondPayment: (aResponse: (nsIPaymentActionResponse | null)) => void;

    /**
     *  Inform the merchant the shipping address has changed.
     *  @param requestId - the request identifier of the payment request.
     *  @param aAddress - the new payment address.
     */
    readonly changeShippingAddress: (requestId: IDLAString, aAddress: (nsIPaymentAddress | null)) => void;

    /**
     *  Inform the merchant the shipping option has changed.
     *  @param requestId - the request identifier of the payment request.
     *  @param option - the shipping option ID string.
     */
    readonly changeShippingOption: (requestId: IDLAString, option: IDLAString) => void;

    /**
     *  Inform the merchant the payer's details changed in the PaymentResponse.
     *  @param requestId - the request identifier of the payment request.
     *  @param aPayerName - the changed payer's name.
     *  @param aPayerEmail - the changed payer's email.
     *  @param aPayerPhone - the changed payer's phone.
     */
    readonly changePayerDetail: (requestId: IDLAString, aPayerName: IDLAString, aPayerEmail: IDLAString, aPayerPhone: IDLAString) => void;

    /**
     *  Inform the merchant the payment method has changed.
     *  @param requestId - the request identifier of the payment request.
     *  @param aMethodName - the changed payment method's name.
     *  @param aMethodDetails - the changed payment method's details.
     */
    readonly changePaymentMethod: (requestId: IDLAString, aMethodName: IDLAString, aMethodDetails: (nsIMethodChangeDetails | null)) => void;

    /**
     *  Following APIs are for testing or platform code only. UI implementation
     *  should not use them.
     */
    /**
     *  Clean up the all managed payment requests.
     *  This API is for testing only.
     */
    readonly cleanup: () => void;

    /**
     *  Setup the customized nsIPaymentUIService.
     *  This API is for testing only.
     */
    readonly setTestingUIService: (aUIService: (nsIPaymentUIService | null)) => void;
  }

  export interface nsIContentProcessInfoRef {
    readonly name: "nsIContentProcessInfo";
    readonly number: "{456f58be-29dd-4973-885b-95aece1c9a8a}";
  }

  export interface nsIContentProcessInfo extends nsISupports {

    /**
     * Is this content process alive?
     */
    readonly isAlive: boolean;

    /**
     * The content process's PID.
     * Throws if the process is not alive.
     */
    readonly processId: number;

    /**
     * This content process's opener.
     */
    readonly opener: (nsIContentProcessInfo | null);

    /**
     * Number of opened tabs living in this content process.
     */
    readonly tabCount: number;

    /**
     * The process manager for this ContentParent (so a process message manager
     * as opposed to a frame message manager.
     */
    readonly messageManager: (nsISupports | null);
  }

  export interface nsIComponentRegistrarRef {
    readonly name: "nsIComponentRegistrar";
    readonly number: "{2417cbfe-65ad-48a6-b4b6-eb84db174392}";
  }

  export interface nsIComponentRegistrar extends nsISupports {

    /**
     * autoRegister
     *
     * Register a .manifest file, or an entire directory containing
     * these files. Registration lasts for this run only, and is not cached.
     *
     * @note Formerly this method would register component files directly. This
     *       is no longer supported.
     */
    readonly autoRegister: (aSpec: (nsIFile | null)) => void;

    /**
     * autoUnregister
     * @status OBSOLETE: This method is no longer implemented, but preserved
     *                   in this interface for binary compatibility with
     *                   Mozilla 1.9.2.
     */
    readonly autoUnregister: (aSpec: (nsIFile | null)) => void;

    /**
     * isContractIDRegistered
     *
     * Returns true if a factory is registered for the contract id.
     *
     * @param aClass : contract id queried for registeration
     * @return       : true if a factory is registered for contract id
     *                 false otherwise.
     */
    readonly isContractIDRegistered: (aContractID: string) => boolean;

    /**
     * getContractIDs
     *
     * Return the list of all registered ContractIDs.
     *
     * @return : Array of ContractIDs. Elements of the array are the string
     *           encoding of Contract IDs.
     */
    readonly getContractIDs: () => IDLACString[];
  }

  export interface nsISlowScriptDebugCallbackRef {
    readonly name: "nsISlowScriptDebugCallback";
    readonly number: "{f7dbb80c-5d1e-4fd9-b55c-a9ffda4a75b1}";
  }

  type nsISlowScriptDebugCallbackFunction = (aWindow: (nsIDOMWindow | null)) => void;

  export interface nsISlowScriptDebugCallback extends nsISupports {

    readonly handleSlowScriptDebug: (aWindow: (nsIDOMWindow | null)) => void;
  }

  export interface nsIVariantRef {
    readonly name: "nsIVariant";
    readonly number: "{81e4c2de-acac-4ad6-901a-b5fb1b851a0d}";
  }

  /**
   * XPConnect has magic to transparently convert between nsIVariant and JS types.
   * We mark the interface [scriptable] so that JS can use methods
   * that refer to this interface. But we mark all the methods and attributes
   * [noscript] since any nsIVariant object will be automatically converted to a
   * JS type anyway.
   */
  export interface nsIVariant extends nsISupports {
  }

  export interface nsISecretDecoderRingRef {
    readonly name: "nsISecretDecoderRing";
    readonly number: "{0ec80360-075c-11d4-9fd4-00c04f1b83d8}";
  }

  export interface nsISecretDecoderRing extends nsISupports {

    /**
     * Encrypt to Base64 output.
     * Note that the input must basically be a byte array (i.e. the code points
     * must be within the range [0, 255]). Hence, using this method directly to
     * encrypt passwords (or any text, really) won't work as expected.
     * Instead, use something like nsIScriptableUnicodeConverter to first convert
     * the desired password or text to UTF-8, then encrypt that. Remember to
     * convert back when calling decryptString().
     *
     * @param text The text to encrypt.
     * @return The encrypted text, encoded as Base64.
     */
    readonly encryptString: (text: IDLACString) => IDLACString;

    /**
     * Run encryptString on multiple strings, asynchronously. This will allow you
     * to not jank the browser if you need to encrypt a large number of strings
     * all at once. This method accepts an array of wstrings which it will convert
     * to UTF-8 internally before encrypting.
     *
     * @param plaintexts the strings to encrypt.
     * @return A promise for the list of encrypted strings, encoded as Base64.
     */
    readonly asyncEncryptStrings: (plaintexts: IDLAUTF8String[]) => IDLPromise;

    /**
     * Decrypt Base64 input.
     * See the encryptString() documentation - this method has basically the same
     * limitations.
     *
     * @param encryptedBase64Text Encrypted input text, encoded as Base64.
     * @return The decoded text.
     */
    readonly decryptString: (encryptedBase64Text: IDLACString) => IDLACString;

    /**
     * Run decryptString on multiple strings, asynchronously. This will allow you
     * to not jank the browser if you need to decrypt a large number of strings
     * all at once.
     *
     * @param encryptedStrings the strings to decrypt, encoded as Base64.
     * @return A promise that resolves with the list of decrypted strings in Unicode.
     */
    readonly asyncDecryptStrings: (encryptedStrings: IDLACString[]) => IDLPromise;

    /**
     * Prompt the user to change the password on the SDR key.
     */
    readonly changePassword: () => void;

    /**
     * Logout of the security device that protects the SDR key.
     */
    readonly logout: () => void;

    /**
     * Logout of the security device that protects the SDR key and tear
     * down authenticated objects.
     */
    readonly logoutAndTeardown: () => void;
  }

  export interface nsINestedURIRef {
    readonly name: "nsINestedURI";
    readonly number: "{6de2c874-796c-46bf-b57f-0d7bd7d6cab0}";
  }

  /**
   * nsINestedURI is an interface that must be implemented by any nsIURI
   * implementation which has an "inner" URI that it actually gets data
   * from.
   *
   * For example, if URIs for the scheme "sanitize" have the structure:
   *
   *   sanitize:http://example.com
   *
   * and opening a channel on such a sanitize: URI gets the data from
   * http://example.com, sanitizes it, and returns it, then the sanitize: URI
   * should implement nsINestedURI and return the http://example.com URI as its
   * inner URI.
   */
  export interface nsINestedURI extends nsISupports {

    /**
     * The inner URI for this nested URI.  This must not return null if the
     * getter succeeds; URIs that have no inner must not QI to this interface.
     * Dynamically changing whether there is an inner URI is not allowed.
     *
     * Modifying the returned URI must not in any way modify the nested URI; this
     * means the returned URI must be either immutable or a clone.
     */
    readonly innerURI: (nsIURI | null);

    /**
     * The innermost URI for this nested URI.  This must not return null if the
     * getter succeeds.  This is equivalent to repeatedly calling innerURI while
     * the returned URI QIs to nsINestedURI.
     *
     * Modifying the returned URI must not in any way modify the nested URI; this
     * means the returned URI must be either immutable or a clone.
     */
    readonly innermostURI: (nsIURI | null);
  }

  export interface mozIStorageStatementCallbackRef {
    readonly name: "mozIStorageStatementCallback";
    readonly number: "{29383d00-d8c4-4ddd-9f8b-c2feb0f2fcfa}";

    /**
     * Called when the statement has finished executing.  This function will only
     * be called once for any given asynchronous statement.
     *
     * @param aReason
     *        Indicates if the statement is no longer executing because it either
     *        finished (REASON_FINISHED), was canceled (REASON_CANCELED), or
     *        a fatal error occurred (REASON_ERROR).
     */
    REASON_FINISHED: 0;

    REASON_CANCELED: 1;

    REASON_ERROR: 2;
  }

  export interface mozIStorageStatementCallback extends nsISupports {

    /**
     * Called when some result is obtained from the database.  This function can
     * be called more than once with a different storageIResultSet each time for
     * any given asynchronous statement.
     *
     * @param aResultSet
     *        The result set containing the data from the database.
     */
    readonly handleResult: (aResultSet: (mozIStorageResultSet | null)) => void;

    /**
     * Called when some error occurs while executing the statement.  This function
     * may be called more than once with a different storageIError each time for
     * any given asynchronous statement.
     *
     * @param aError
     *        An object containing information about the error.
     */
    readonly handleError: (aError: (mozIStorageError | null)) => void;

    readonly handleCompletion: (aReason: number) => void;
  }

  export interface nsINativeFileWatcherSuccessCallbackRef {
    readonly name: "nsINativeFileWatcherSuccessCallback";
    readonly number: "{c3d7f542-681b-4abd-9d65-9d799b29a42b}";
  }

  type nsINativeFileWatcherSuccessCallbackFunction = (resourcePath: IDLAString) => void;

  /**
   * The interface for the callback invoked when a file watcher operation
   * successfully completes.
   */
  export interface nsINativeFileWatcherSuccessCallback extends nsISupports {

    /**
     * @param resourcePath
     *        The path of the resource for which the operation completes.
     */
    readonly complete: (resourcePath: IDLAString) => void;
  }

  export interface nsITransportSecurityInfoRef {
    readonly name: "nsITransportSecurityInfo";
    readonly number: "{216112d3-28bc-4671-b057-f98cc09ba1ea}";

    SSL_VERSION_3: 0;

    TLS_VERSION_1: 1;

    TLS_VERSION_1_1: 2;

    TLS_VERSION_1_2: 3;

    TLS_VERSION_1_3: 4;

    CERTIFICATE_TRANSPARENCY_NOT_APPLICABLE: 0;

    CERTIFICATE_TRANSPARENCY_POLICY_COMPLIANT: 5;

    CERTIFICATE_TRANSPARENCY_POLICY_NOT_ENOUGH_SCTS: 6;

    CERTIFICATE_TRANSPARENCY_POLICY_NOT_DIVERSE_SCTS: 7;
  }

  export interface nsITransportSecurityInfo extends nsISupports {

    readonly securityState: number;

    readonly errorCode: number;

    readonly errorCodeString: IDLAString;

    /**
     * The following parameters are only valid after the TLS handshake
     * has completed.  Check securityState first.
     */
    /**
     * If certificate verification failed, this will be the peer certificate
     * chain provided in the handshake, so it can be used for error reporting.
     * If verification succeeded, this will be empty.
     */
    readonly failedCertChain: (nsIX509Cert | null)[];

    readonly serverCert: (nsIX509Cert | null);

    readonly succeededCertChain: (nsIX509Cert | null)[];

    readonly cipherName: IDLACString;

    readonly keyLength: number;

    readonly secretKeyLength: number;

    readonly keaGroupName: IDLACString;

    readonly signatureSchemeName: IDLACString;

    readonly protocolVersion: number;

    readonly certificateTransparencyStatus: number;

    readonly isDelegatedCredential: boolean;

    readonly isDomainMismatch: boolean;

    readonly isNotValidAtThisTime: boolean;

    readonly isUntrusted: boolean;

    /**
     * True only if (and after) serverCert was successfully validated as
     * Extended Validation (EV).
     */
    readonly isExtendedValidation: boolean;
  }

  export interface nsIIdentitySignCallbackRef {
    readonly name: "nsIIdentitySignCallback";
    readonly number: "{2d3e5036-374b-4b47-a430-1196b67b890f}";
  }

  type nsIIdentitySignCallbackFunction = (rv: number, base64urlSignature: IDLACString) => void;

  export interface nsIIdentitySignCallback extends nsISupports {

    /**
     * This interface provides a JavaScript callback object used to collect the
     * AUTF8String signature
     */
    /** On success, base64urlSignature is the base-64-URL-encoded signature
     *
     * For RS256 signatures, XXX bug 769858
     *
     * For DSA128 signatures, the signature is the r value concatenated with the
     * s value, each component padded with leading zeroes as necessary.
     */
    readonly signFinished: (rv: number, base64urlSignature: IDLACString) => void;
  }

  export interface nsIPushMessageRef {
    readonly name: "nsIPushMessage";
    readonly number: "{b9d063ca-0e3f-4fee-be4b-ea9103263433}";
  }

  /**
   * The subject of a `push-message` observer notification. |data| may be |null|
   * for messages without data.
   */
  export interface nsIPushMessage extends nsISupports {

    readonly principal: (nsIPrincipal | null);

    readonly data: (nsIPushData | null);
  }

  export interface nsINSSVersionRef {
    readonly name: "nsINSSVersion";
    readonly number: "{a8a53a2b-75cc-4c68-a9bb-9791dbddaa00}";
  }

  export interface nsINSSVersion extends nsISupports {

    readonly NSPR_MinVersion: IDLAString;

    readonly NSS_MinVersion: IDLAString;

    readonly NSSUTIL_MinVersion: IDLAString;

    readonly NSSSSL_MinVersion: IDLAString;

    readonly NSSSMIME_MinVersion: IDLAString;

    readonly NSPR_Version: IDLAString;

    readonly NSS_Version: IDLAString;

    readonly NSSUTIL_Version: IDLAString;

    readonly NSSSSL_Version: IDLAString;

    readonly NSSSMIME_Version: IDLAString;
  }

  export interface nsIStreamLoaderObserverRef {
    readonly name: "nsIStreamLoaderObserver";
    readonly number: "{359f7990-d4e9-11d3-a1a5-0050041caf44}";
  }

  export interface nsIStreamLoaderObserver extends nsISupports {

    /**
     * Called when the entire stream has been loaded.
     *
     * @param loader the stream loader that loaded the stream.
     * @param ctxt the context parameter of the underlying channel
     * @param status the status of the underlying channel
     * @param resultLength the length of the data loaded
     * @param result the data
     *
     * This method will always be called asynchronously by the
     * nsIStreamLoader involved, on the thread that called the
     * loader's init() method.
     *
     * If the observer wants to take over responsibility for the
     * data buffer (result), it returns NS_SUCCESS_ADOPTED_DATA
     * in place of NS_OK as its success code. The loader will then
     * "forget" about the data and not free() it after
     * onStreamComplete() returns; observer must call free()
     * when the data is no longer required.
     */
    readonly onStreamComplete: (loader: (nsIStreamLoader | null), ctxt: (nsISupports | null), status: number, resultLength: number) => void;
  }

  export interface nsICaptivePortalCallbackRef {
    readonly name: "nsICaptivePortalCallback";
    readonly number: "{593fdeec-6284-4de8-b416-8e63cbdc695e}";
  }

  export interface nsICaptivePortalCallback extends nsISupports {

    /**
     * Preparation for network interface before captive portal detection started.
     */
    readonly prepare: () => void;

    /**
     * Invoke callbacks after captive portal detection finished.
     */
    readonly complete: (success: boolean) => void;
  }

  export interface nsIAutoplayRef {
    readonly name: "nsIAutoplay";
    readonly number: "{048a24f6-c4d6-47bc-bea2-f6038d1db80a}";

    ALLOWED: 0;

    BLOCKED: 1;

    BLOCKED_ALL: 5;
  }

  export interface nsIAutoplay extends nsISupports {
  }

  export interface nsISuspendedTypesRef {
    readonly name: "nsISuspendedTypes";
    readonly number: "{2822a840-f009-11e5-a837-0800200c9a66}";

    /**
     * The suspended enum is used in three different situations,
     * - platform audio focus (Fennec/B2G)
     * - remote media control (Fennec)
     * - block auto-play video in non-active page
     *
     * Note: the "remote side" must control the AudioChannelAgent using
     * nsIAudioChannelAgentCallback.windowSuspendChanged() callback instead using
     * play/pause methods or any button in the webpage.
     *
     * - SUSPENDED_PAUSE :
     * It's used when transiently losing audio focus, the media can't be resumed
     * until we gain the audio focus again. It would change the internal state of
     * MediaElement when it's being suspended/resumed, and it would trigger the
     * related JS event. eg. "play" and "pause" event.
     *
     * - SUSPENDED_BLOCK
     * It's used to prevent auto-playing media in inactive page in order to
     * reduce the power consumption, and the media can't be resumed until the
     * page becomes active again. It would change the internal state of
     * MediaElement when it's being blocked/resumed, so it won't trigger the
     * related JS event. eg. "play" and "pause" event.
     *
     * - SUSPENDED_PAUSE_DISPOSABLE
     * It's used for remote media-control to pause the playing media and when we
     * lose audio focus permanently. It's disposable suspended, so the media can
     * be resumed arbitrary after that. Same as SUSPENDED_PAUSE, it would change
     * the internal state of MediaElement when it's being suspended.
     *
     * - SUSPENDED_STOP_DISPOSABLE
     * It's used for remote media-control to stop the playing media. The remote
     * control would disappear after stopping the media, so we would disconnect
     * the audio channel agent. It's disposable suspended, so the media can be
     * resumed arbitrary after that. Same as SUSPENDED_PAUSE, it would change
     * the internal state of MediaElement when it's being suspended.
     */
    NONE_SUSPENDED: 0;

    SUSPENDED_PAUSE: 1;

    SUSPENDED_BLOCK: 2;

    SUSPENDED_PAUSE_DISPOSABLE: 3;

    SUSPENDED_STOP_DISPOSABLE: 4;
  }

  export interface nsISuspendedTypes extends nsISupports {
  }

  export interface nsIDroppedLinkHandlerRef {
    readonly name: "nsIDroppedLinkHandler";
    readonly number: "{21b5c25a-28a9-47bd-8431-fa9116305ded}";
  }

  export interface nsIDroppedLinkHandler extends nsISupports {

    /**
     * Determines if a link being dragged can be dropped and returns true if so.
     * aEvent should be a dragenter or dragover event.
     *
     * If aAllowSameDocument is false, drops are only allowed if the document
     * of the source of the drag is different from the destination. This check
     * includes any parent, sibling and child frames in the same content tree.
     * If true, the source is not checked.
     */
    readonly canDropLink: (aEvent: WebIDL.DragEvent, aAllowSameDocument: boolean) => boolean;

    /**
     * Given a drop event aEvent, determines the link being dragged and returns
     * it. If a uri is returned the caller can, for instance, load it. If null
     * is returned, there is no valid link to be dropped.
     *
     * A NS_ERROR_DOM_SECURITY_ERR error will be thrown and the event cancelled if
     * the receiving target should not load the uri for security reasons. This
     * will occur if any of the following conditions are true:
     *  - the source of the drag initiated a link for dragging that
     *    it itself cannot access. This prevents a source document from tricking
     *    the user into a dragging a chrome url, for example.
     *  - aDisallowInherit is true, and the URI being dropped would inherit the
     *    current document's security context (URI_INHERITS_SECURITY_CONTEXT).
     *
     * aName is filled in with the link title if it exists, or an empty string
     * otherwise.
     */
    readonly dropLink: (aEvent: WebIDL.DragEvent, aName: Out<IDLAString>, aDisallowInherit?: boolean) => IDLAString;

    /**
     * Given a drop event aEvent, determines links being dragged and returns
     * them. If links are returned the caller can, for instance, load them. If
     * the returned array is empty, there is no valid link to be dropped.
     *
     * A NS_ERROR_DOM_SECURITY_ERR error will be thrown and the event cancelled if
     * the receiving target should not load the uri for security reasons. This
     * will occur if any of the following conditions are true:
     *  - the source of the drag initiated a link for dragging that
     *    it itself cannot access. This prevents a source document from tricking
     *    the user into a dragging a chrome url, for example.
     *  - aDisallowInherit is true, and the URI being dropped would inherit the
     *    current document's security context (URI_INHERITS_SECURITY_CONTEXT).
     */
    readonly dropLinks: (aEvent: WebIDL.DragEvent, aDisallowInherit?: boolean) => (nsIDroppedLinkItem | null)[];

    /**
     * Given a drop event aEvent, validate the extra URIs for the event,
     * this is used when the caller extracts yet another URIs from the dropped
     * text, like home button that splits the text with "|".
     */
    readonly validateURIsForDrop: (aEvent: WebIDL.DragEvent, aURIs: IDLAString[], aDisallowInherit?: boolean) => void;

    /**
     * Given a dataTransfer, allows caller to determine and verify links being
     * dragged. Since drag/drop performs a roundtrip of parent, child, parent,
     * it allows the parent to verify that the child did not modify links
     * being dropped.
     */
    readonly queryLinks: (aDataTransfer: WebIDL.DataTransfer) => (nsIDroppedLinkItem | null)[];

    /**
     * Given a drop event aEvent, determines the triggering principal for the
     * event and returns it.
     */
    readonly getTriggeringPrincipal: (aEvent: WebIDL.DragEvent) => (nsIPrincipal | null);

    /**
     * Given a drop event aEvent, determines the CSP for the event and returns it.
     */
    readonly getCSP: (aEvent: WebIDL.DragEvent) => (nsIContentSecurityPolicy | null);
  }

  export interface mozIStorageFunctionRef {
    readonly name: "mozIStorageFunction";
    readonly number: "{9ff02465-21cb-49f3-b975-7d5b38ceec73}";
  }

  type mozIStorageFunctionFunction = (aFunctionArguments: (mozIStorageValueArray | null)) => (nsIVariant | null);

  /**
   * mozIStorageFunction is to be implemented by storage consumers that
   * wish to receive callbacks during the request execution.
   *
   * SQL can apply functions to values from tables. Examples of
   * such functions are MIN(a1,a2) or SQRT(num). Many functions are
   * implemented in SQL engine.
   *
   * This interface allows consumers to implement their own,
   * problem-specific functions.
   * These functions can be called from triggers, too.
   *
   */
  export interface mozIStorageFunction extends nsISupports {

    /**
     * onFunctionCall is called when execution of a custom
     * function should occur.
     *
     * @param aNumArguments         The number of arguments
     * @param aFunctionArguments    The arguments passed in to the function
     *
     * @returns any value as Variant type.
     */
    readonly onFunctionCall: (aFunctionArguments: (mozIStorageValueArray | null)) => (nsIVariant | null);
  }

  export interface nsIDOMXULRadioGroupElementRef {
    readonly name: "nsIDOMXULRadioGroupElement";
    readonly number: "{2cc1d24b-ec9f-4e18-aa34-a298a9007f23}";
  }

  export interface nsIDOMXULRadioGroupElement extends nsISupports {

    focusedItem: WebIDL.Element;
  }

  export interface nsIXULRuntimeRef {
    readonly name: "nsIXULRuntime";
    readonly number: "{03602fac-fa3f-4a50-9baa-b88456fb4a0f}";

    /**
     * The legal values of processType.
     */
    PROCESS_TYPE_DEFAULT: 0;

    PROCESS_TYPE_PLUGIN: 1;

    PROCESS_TYPE_CONTENT: 2;

    PROCESS_TYPE_IPDLUNITTEST: 3;

    PROCESS_TYPE_GMPLUGIN: 4;

    PROCESS_TYPE_GPU: 5;

    PROCESS_TYPE_VR: 6;

    PROCESS_TYPE_RDD: 7;

    PROCESS_TYPE_SOCKET: 8;

    PROCESS_TYPE_SANDBOX_BROKER: 9;

    PROCESS_TYPE_FORKSERVER: 10;

    /**
     * The current e10s-multi experiment number. Set dom.ipc.multiOptOut to (at
     * least) this to disable it until the next experiment.
     */
    E10S_MULTI_EXPERIMENT: 1;
  }

  /**
   * Provides information about the XUL runtime.
   * @status UNSTABLE - This interface is not frozen and will probably change in
   *                    future releases. If you need this functionality to be
   *                    stable/frozen, please contact Benjamin Smedberg.
   */
  export interface nsIXULRuntime extends nsISupports {

    /**
     * Whether the application was launched in safe mode.
     */
    readonly inSafeMode: boolean;

    /**
     * Whether to write console errors to a log file. If a component
     * encounters startup errors that might prevent the app from showing
     * proper UI, it should set this flag to "true".
     */
    logConsoleErrors: boolean;

    /**
     * A string tag identifying the current operating system. This is taken
     * from the OS_TARGET configure variable. It will always be available.
     */
    readonly OS: IDLAUTF8String;

    /**
     * A string tag identifying the binary ABI of the current processor and
     * compiler vtable. This is taken from the TARGET_XPCOM_ABI configure
     * variable. It may not be available on all platforms, especially
     * unusual processor or compiler combinations.
     *
     * The result takes the form <processor>-<compilerABI>, for example:
     *   x86-msvc
     *   ppc-gcc3
     *
     * This value should almost always be used in combination with "OS".
     *
     * @throw NS_ERROR_NOT_AVAILABLE if not available.
     */
    readonly XPCOMABI: IDLAUTF8String;

    /**
     * A string tag identifying the target widget toolkit in use.
     * This is taken from the MOZ_WIDGET_TOOLKIT configure variable.
     */
    readonly widgetToolkit: IDLAUTF8String;

    /**
     * The type of the caller's process.  Returns one of the values above.
     */
    readonly processType: number;

    /**
     * The system process ID of the caller's process.
     */
    readonly processID: number;

    /**
     * A globally unique and non-recycled ID of the caller's process.
     */
    readonly uniqueProcessID: number;

    /**
     * The type of remote content process we're running in.
     * null if we're in the parent/chrome process. This can contain
     * a URI if Fission is enabled, so don't use it for any kind of
     * telemetry.
     */
    readonly remoteType: IDLAString;

    /**
     * If true, browser tabs may be opened by default in a different process
     * from the main browser UI.
     */
    readonly browserTabsRemoteAutostart: boolean;

    /**
     * Returns the number of content processes to use for normal web pages. If
     * this value is > 1, then e10s-multi should be considered to be "on".
     *
     * NB: If browserTabsRemoteAutostart is false, then this value has no
     * meaning and e10s should be considered to be "off"!
     */
    readonly maxWebProcessCount: number;

    /**
     * If true, the accessibility service is running.
     */
    readonly accessibilityEnabled: boolean;

    /**
     * If true, the AccessibleHandler dll is used.
     */
    readonly accessibleHandlerUsed: boolean;

    /**
     * Executable of Windows service that activated accessibility.
     */
    readonly accessibilityInstantiator: IDLAString;

    /**
     * Temporary, do not use. Indicates if an incompat version of JAWS
     * screen reader software is loaded in our process space.
     */
    readonly shouldBlockIncompatJaws: boolean;

    /**
     * Indicates whether the current Firefox build is 64-bit.
     */
    readonly is64Bit: boolean;

    /**
     * Signal the apprunner to invalidate caches on the next restart.
     * This will cause components to be autoregistered and all
     * fastload data to be re-created.
     */
    readonly invalidateCachesOnRestart: () => void;

    /**
     * Starts a child process. This method is intented to pre-start a
     * content child process so that when it is actually needed, it is
     * ready to go.
     *
     * @throw NS_ERROR_NOT_AVAILABLE if not available.
     */
    readonly ensureContentProcess: () => void;

    /**
     * Modification time of the profile lock before the profile was locked on
     * this startup. Used to know the last time the profile was used and not
     * closed cleanly. This is set to 0 if there was no existing profile lock.
     */
    readonly replacedLockTime: number;

    /**
     * True if this is RELEASE_OR_BETA.
     */
    readonly isReleaseOrBeta: boolean;

    /**
     * True if this build uses official branding (MOZ_OFFICIAL_BRANDING).
     */
    readonly isOfficialBranding: boolean;

    /**
     * The default update channel (MOZ_UPDATE_CHANNEL).
     */
    readonly defaultUpdateChannel: IDLAUTF8String;

    /**
     * The distribution ID for this build (MOZ_DISTRIBUTION_ID).
     */
    readonly distributionID: IDLAUTF8String;

    /**
     * True if Windows DLL blocklist initialized correctly. This is
     * primarily for automated testing purposes.
     */
    readonly windowsDLLBlocklistStatus: boolean;

    /**
     * True if this application was started by the OS as part of an automatic
     * restart mechanism (such as RegisterApplicationRestart on Windows).
     */
    readonly restartedByOS: boolean;

    /**
     * Returns a value corresponding to one of the
     * |mozilla::LauncherRegistryInfo::EnabledState| values.
     */
    readonly launcherProcessState: number;
  }

  export interface imgIScriptedNotificationObserverRef {
    readonly name: "imgIScriptedNotificationObserver";
    readonly number: "{10be55b3-2029-41a7-a975-538efed250ed}";
  }

  export interface imgIScriptedNotificationObserver extends nsISupports {

    readonly sizeAvailable: (aRequest: (imgIRequest | null)) => void;

    readonly frameUpdate: (aRequest: (imgIRequest | null)) => void;

    readonly frameComplete: (aRequest: (imgIRequest | null)) => void;

    readonly loadComplete: (aRequest: (imgIRequest | null)) => void;

    readonly decodeComplete: (aRequest: (imgIRequest | null)) => void;

    readonly discard: (aRequest: (imgIRequest | null)) => void;

    readonly isAnimated: (aRequest: (imgIRequest | null)) => void;

    readonly hasTransparency: (aRequest: (imgIRequest | null)) => void;
  }

  export interface nsINestedEventLoopConditionRef {
    readonly name: "nsINestedEventLoopCondition";
    readonly number: "{039a227d-0cb7-44a5-a8f9-dbb7071979f2}";
  }

  type nsINestedEventLoopConditionFunction = () => boolean;

  export interface nsINestedEventLoopCondition extends nsISupports {

    /**
     * Returns true if the current nested event loop should stop spinning.
     */
    readonly isDone: () => boolean;
  }

  export interface nsIUDPSocketListenerRef {
    readonly name: "nsIUDPSocketListener";
    readonly number: "{2e4b5dd3-7358-4281-b81f-10c62ef39cb5}";
  }

  export interface nsIUDPSocketListener extends nsISupports {

    /**
     * nsIUDPSocketListener
     *
     * This interface is notified whenever a UDP socket accepts a new connection.
     * The transport is in the connected state, and read/write streams can be opened
     * using the normal nsITransport API.  The address of the client can be found by
     * calling the nsISocketTransport::GetAddress method or by inspecting
     * nsISocketTransport::GetHost, which returns a string representation of the
     * client's IP address (NOTE: this may be an IPv4 or IPv6 string literal).
     */
    /**
     * onPacketReceived
     *
     * This method is called when a client sends an UDP packet.
     *
     * @param aSocket
     *        The UDP socket.
     * @param aMessage
     *        The message.
     */
    readonly onPacketReceived: (aSocket: (nsIUDPSocket | null), aMessage: (nsIUDPMessage | null)) => void;

    /**
     * onStopListening
     *
     * This method is called when the listening socket stops for some reason.
     * The UDP socket is effectively dead after this notification.
     *
     * @param aSocket
     *        The UDP socket.
     * @param aStatus
     *        The reason why the UDP socket stopped listening.  If the
     *        UDP socket was manually closed, then this value will be
     *        NS_BINDING_ABORTED.
     */
    readonly onStopListening: (aSocket: (nsIUDPSocket | null), aStatus: number) => void;
  }

  export interface nsISystemProxySettingsRef {
    readonly name: "nsISystemProxySettings";
    readonly number: "{971591cd-277e-409a-bbf6-0a79879cd307}";
  }

  /**
   * This interface allows the proxy code to use platform-specific proxy
   * settings when the proxy preference is set to "automatic discovery". This service
   * acts like a PAC parser to netwerk, but it will actually read the system settings and
   * either return the proper proxy data from the autoconfig URL specified in the system proxy,
   * or generate proxy data based on the system's manual proxy settings.
   */
  export interface nsISystemProxySettings extends nsISupports {

    /**
     * Whether or not it is appropriate to execute getProxyForURI off the main thread.
     * If that method can block (e.g. for WPAD as windows does) then it must be
     * not mainThreadOnly to avoid creating main thread jank. The main thread only option is
     * provided for implementations that do not block but use other main thread only
     * functions such as dbus.
     */
    readonly mainThreadOnly: boolean;

    /**
     * If non-empty, use this PAC file. If empty, call getProxyForURI instead.
     */
    readonly PACURI: IDLAUTF8String;

    /**
     * See ProxyAutoConfig::getProxyForURI; this function behaves similarly except
     * a more relaxed return string is allowed that includes full urls instead of just
     * host:port syntax. e.g. "PROXY http://www.foo.com:8080" instead of
     * "PROXY www.foo.com:8080"
     */
    readonly getProxyForURI: (testSpec: IDLAUTF8String, testScheme: IDLAUTF8String, testHost: IDLAUTF8String, testPort: number) => IDLAUTF8String;
  }

  export interface nsIAsyncOutputStreamRef {
    readonly name: "nsIAsyncOutputStream";
    readonly number: "{beb632d3-d77a-4e90-9134-f9ece69e8200}";

    /**
     * If passed to asyncWait, this flag overrides the default behavior,
     * causing the OnOutputStreamReady notification to be suppressed until the
     * stream becomes closed (either as a result of closeWithStatus/close being
     * called on the stream or possibly due to some error in the underlying
     * stream).
     */
    WAIT_CLOSURE_ONLY: 1;
  }

  /**
   * If an output stream is non-blocking, it may return NS_BASE_STREAM_WOULD_BLOCK
   * when written to.  The caller must then wait for the stream to become
   * writable.  If the stream implements nsIAsyncOutputStream, then the caller can
   * use this interface to request an asynchronous notification when the stream
   * becomes writable or closed (via the AsyncWait method).
   *
   * While this interface is almost exclusively used with non-blocking streams, it
   * is not necessary that nsIOutputStream::isNonBlocking return true.  Nor is it
   * necessary that a non-blocking nsIOutputStream implementation also implement
   * nsIAsyncOutputStream.
   */
  export interface nsIAsyncOutputStream extends nsIOutputStream {

    /**
     * This method closes the stream and sets its internal status.  If the
     * stream is already closed, then this method is ignored.  Once the stream
     * is closed, the stream's status cannot be changed.  Any successful status
     * code passed to this method is treated as NS_BASE_STREAM_CLOSED, which
     * is equivalent to nsIInputStream::close.
     *
     * NOTE: this method exists in part to support pipes, which have both an
     * input end and an output end.  If the output end of a pipe is closed, then
     * reads from the input end of the pipe will fail.  The error code returned
     * when an attempt is made to read from a "closed" pipe corresponds to the
     * status code passed in when the output end of the pipe is closed, which
     * greatly simplifies working with pipes in some cases.
     *
     * @param aStatus
     *        The error that will be reported if this stream is accessed after
     *        it has been closed.
     */
    readonly closeWithStatus: (reason: number) => void;

    /**
     * Asynchronously wait for the stream to be writable or closed.  The
     * notification is one-shot, meaning that each asyncWait call will result
     * in exactly one notification callback.  After the OnOutputStreamReady event
     * is dispatched, the stream releases its reference to the
     * nsIOutputStreamCallback object.  It is safe to call asyncWait again from the
     * notification handler.
     *
     * This method may be called at any time (even if write has not been called).
     * In other words, this method may be called when the stream already has
     * room for more data.  It may also be called when the stream is closed.  If
     * the stream is already writable or closed when AsyncWait is called, then the
     * OnOutputStreamReady event will be dispatched immediately.  Otherwise, the
     * event will be dispatched when the stream becomes writable or closed.
     *
     * @param aCallback
     *        This object is notified when the stream becomes ready.  This
     *        parameter may be null to clear an existing callback.
     * @param aFlags
     *        This parameter specifies optional flags passed in to configure
     *        the behavior of this method.  Pass zero to specify no flags.
     * @param aRequestedCount
     *        Wait until at least this many bytes can be written.  This is only
     *        a suggestion to the underlying stream; it may be ignored.  The
     *        caller may pass zero to indicate no preference.
     * @param aEventTarget
     *        Specify NULL to receive notification on ANY thread (possibly even
     *        recursively on the calling thread -- i.e., synchronously), or
     *        specify that the notification be delivered to a specific event
     *        target.
     */
    readonly asyncWait: (aCallback: (nsIOutputStreamCallback | nsIOutputStreamCallbackFunction | null), aFlags: number, aRequestedCount: number, aEventTarget: (nsIEventTarget | null)) => void;
  }

  export interface nsICertOverrideServiceRef {
    readonly name: "nsICertOverrideService";
    readonly number: "{be019e47-22fc-4355-9f16-9ab047d6742d}";

    /**
     *  Override Untrusted
     */
    ERROR_UNTRUSTED: 1;

    /**
     *  Override hostname Mismatch
     */
    ERROR_MISMATCH: 2;

    /**
     *  Override Time error
     */
    ERROR_TIME: 4;
  }

  /**
   * This represents the global list of triples
   *   {host:port, cert-fingerprint, allowed-overrides}
   * that the user wants to accept without further warnings.
   */
  export interface nsICertOverrideService extends nsISupports {

    /**
     *  The given cert should always be accepted for the given hostname:port,
     *  regardless of errors verifying the cert.
     *  Host:Port is a primary key, only one entry per host:port can exist.
     *  The implementation will store a fingerprint of the cert.
     *  The implementation will decide which fingerprint alg is used.
     *
     *  Each override is specific to exactly the errors overridden, so
     *  overriding everything won't match certs at the given host:port
     *  which only exhibit some subset of errors.
     *
     *  @param aHostName The host (punycode) this mapping belongs to
     *  @param aPort The port this mapping belongs to, if it is -1 then it
     *          is internaly treated as 443
     *  @param aCert The cert that should always be accepted
     *  @param aOverrideBits The precise set of errors we want to be overriden
     */
    readonly rememberValidityOverride: (aHostName: IDLAUTF8String, aPort: number, aCert: (nsIX509Cert | null), aOverrideBits: number, aTemporary: boolean) => void;

    /**
     *  Certs with the given fingerprint should always be accepted for the
     *  given hostname:port, regardless of errors verifying the cert.
     *  Host:Port is a primary key, only one entry per host:port can exist.
     *  The fingerprint should be an SHA-256 hash of the certificate.
     *
     *  @param aHostName The host (punycode) this mapping belongs to
     *  @param aPort The port this mapping belongs to, if it is -1 then it
     *          is internaly treated as 443
     *  @param aCertFingerprint The cert fingerprint that should be accepted, in
     *          the format 'AA:BB:...' (colon-separated upper-case hex bytes).
     *  @param aOverrideBits The errors we want to be overriden
     */
    readonly rememberTemporaryValidityOverrideUsingFingerprint: (aHostName: IDLAUTF8String, aPort: number, aCertFingerprint: IDLAUTF8String, aOverrideBits: number) => void;

    /**
     *  Return whether this host, port, cert triple has a stored override.
     *  If so, the outparams will contain the specific errors that were
     *  overridden, and whether the override is permanent, or only for the current
     *  session.
     *
     *  @param aHostName The host (punycode) this mapping belongs to
     *  @param aPort The port this mapping belongs to, if it is -1 then it
     *         is internally treated as 443
     *  @param aCert The certificate this mapping belongs to
     *  @param aOverrideBits The errors that are currently overridden
     *  @param aIsTemporary Whether the stored override is session-only,
     *         or permanent
     *  @return Whether an override has been stored for this host+port+cert
     */
    readonly hasMatchingOverride: (aHostName: IDLAUTF8String, aPort: number, aCert: (nsIX509Cert | null), aOverrideBits: Out<number>, aIsTemporary: Out<boolean>) => boolean;

    /**
     *  Remove a override for the given hostname:port.
     *
     *  @param aHostName The host (punycode) whose entry should be cleared.
     *  @param aPort The port whose entry should be cleared.
     *               If it is -1, then it is internaly treated as 443.
     *               If it is 0 and aHostName is "all:temporary-certificates",
     *               then all temporary certificates should be cleared.
     */
    readonly clearValidityOverride: (aHostName: IDLAUTF8String, aPort: number) => void;

    /**
     *  Remove all overrides.
     */
    readonly clearAllOverrides: () => void;

    /**
     *  Is the given cert used in rules?
     *
     *  @param aCert The cert we're looking for
     *  @return how many override entries are currently on file
     *          for the given certificate
     */
    readonly isCertUsedForOverrides: (aCert: (nsIX509Cert | null), aCheckTemporaries: boolean, aCheckPermanents: boolean) => number;

    /**
     *  NOTE: This function is used only for testing!
     *
     *  @param aDisable If true, disable all security check and make
     *                  hasMatchingOverride always return true.
     */
    readonly setDisableAllSecurityChecksAndLetAttackersInterceptMyData: (aDisable: boolean) => void;
  }

  export interface nsIDNSServiceResolveListenerRef {
    readonly name: "nsIDNSServiceResolveListener";
    readonly number: "{24ee6408-648e-421d-accf-c6e5adeccf97}";
  }

  /**
   * The callback interface for service resolve
   */
  export interface nsIDNSServiceResolveListener extends nsISupports {

    /**
     * Callback when the service is resolved successfully.
     * @param   aServiceInfo
     *          the info about the resolved service, where |host| and |port| are set.
     */
    readonly onServiceResolved: (aServiceInfo: (nsIDNSServiceInfo | null)) => void;

    /**
     * Callback when the service cannot be resolved.
     * @param   aServiceInfo
     *          the info about the service to be resolved.
     * @param   aErrorCode
     *          the error code.
     */
    readonly onResolveFailed: (aServiceInfo: (nsIDNSServiceInfo | null), aErrorCode: number) => void;
  }

  export interface nsIPresentationTCPSessionTransportBuilderRef {
    readonly name: "nsIPresentationTCPSessionTransportBuilder";
    readonly number: "{cde36d6e-f471-4262-a70d-f932a26b21d9}";
  }

  /**
   * Builder for TCP session transport
   */
  export interface nsIPresentationTCPSessionTransportBuilder extends nsIPresentationSessionTransportBuilder {

    /**
     * The following creation functions will trigger |listener.onSessionTransport|
     * if the session transport is successfully built, |listener.onError| if some
     * error occurs during building session transport.
     */
    readonly buildTCPSenderTransport: (aTransport: (nsISocketTransport | null), aListener: (nsIPresentationSessionTransportBuilderListener | null)) => void;

    readonly buildTCPReceiverTransport: (aDescription: (nsIPresentationChannelDescription | null), aListener: (nsIPresentationSessionTransportBuilderListener | null)) => void;
  }

  export interface nsIQueryContentEventResultRef {
    readonly name: "nsIQueryContentEventResult";
    readonly number: "{e2c39e0e-345f-451a-a7b2-e0230d555847}";
  }

  /**
   * The result of query content events.  succeeded propery can be used always.
   * Whether other properties can be used or not depends on the event.
   * See nsIDOMWindowUtils.idl, which properites can be used was documented.
   */
  export interface nsIQueryContentEventResult extends nsISupports {

    readonly offset: number;

    readonly tentativeCaretOffset: number;

    readonly reversed: boolean;

    readonly left: number;

    readonly top: number;

    readonly width: number;

    readonly height: number;

    readonly text: IDLAString;

    readonly getCharacterRect: (offset: number, left: Out<number>, top: Out<number>, width: Out<number>, height: Out<number>) => void;

    readonly succeeded: boolean;

    readonly notFound: boolean;

    readonly tentativeCaretOffsetNotFound: boolean;
  }

  export interface nsIDialogParamBlockRef {
    readonly name: "nsIDialogParamBlock";
    readonly number: "{f76c0901-437a-11d3-b7a0-e35db351b4bc}";
  }

  /**
   * An interface to pass strings, integers and nsISupports to a dialog
   */
  export interface nsIDialogParamBlock extends nsISupports {

    /** Get or set an integer to pass.
     * Index must be in the range 0..7
     */
    readonly GetInt: (inIndex: number) => number;

    readonly SetInt: (inIndex: number, inInt: number) => void;

    /** Set the maximum number of strings to pass. Default is 16.
     * Use before setting any string (If you want to change it from the default).
     */
    readonly SetNumberStrings: (inNumStrings: number) => void;

    /** Get or set an string to pass.
     * Index starts at 0
     */
    readonly GetString: (inIndex: number) => string;

    readonly SetString: (inIndex: number, inString: string) => void;

    /**
     * A place where you can store an nsIMutableArray to pass nsISupports
     */
    objects: (nsIMutableArray | null);
  }

  export interface nsIAsyncShutdownServiceRef {
    readonly name: "nsIAsyncShutdownService";
    readonly number: "{db365c78-c860-4e64-9a63-25b73f89a016}";
  }

  /**
   * A service that allows registering shutdown-time dependencies.
   */
  export interface nsIAsyncShutdownService extends nsISupports {

    /**
     * Create a new barrier.
     *
     * By convention, the name should respect the following format:
     * "MyModuleName: Doing something while it's time"
     * e.g.
     * "OS.File: Waiting for clients to flush before shutting down"
     *
     * This attribute is uploaded as part of crash reports.
     */
    readonly makeBarrier: (aName: IDLAString) => (nsIAsyncShutdownBarrier | null);

    /**
     * Barrier for notification profile-before-change.
     */
    readonly profileBeforeChange: (nsIAsyncShutdownClient | null);

    /**
     * Barrier for notification profile-change-teardown.
     */
    readonly profileChangeTeardown: (nsIAsyncShutdownClient | null);

    /**
     * Barrier for notification quit-application-granted.
     */
    readonly quitApplicationGranted: (nsIAsyncShutdownClient | null);

    /**
     * Barrier for notification profile-before-change-telemetry.
     */
    readonly sendTelemetry: (nsIAsyncShutdownClient | null);

    /**
     * Barrier for notification web-workers-shutdown.
     */
    readonly webWorkersShutdown: (nsIAsyncShutdownClient | null);

    /**
     * Barrier for notification xpcom-will-shutdown.
     */
    readonly xpcomWillShutdown: (nsIAsyncShutdownClient | null);
  }

  export interface nsISearchSubmissionRef {
    readonly name: "nsISearchSubmission";
    readonly number: "{5799251f-5b55-4df7-a9e7-0c27812c469a}";
  }

  export interface nsISearchSubmission extends nsISupports {

    /**
     * The POST data associated with a search submission, wrapped in a MIME
     * input stream. May be null.
     */
    readonly postData: (nsIInputStream | null);

    /**
     * The URI to submit a search to.
     */
    readonly uri: (nsIURI | null);
  }

  export interface nsIIdleServiceInternalRef {
    readonly name: "nsIIdleServiceInternal";
    readonly number: "{7b89a2e7-ed12-42e0-b86d-4984239abd7b}";
  }

  export interface nsIIdleServiceInternal extends nsIIdleService {

    /**
     * "Resets the idle time to the value specified."
     *
     * @param idleDelta the time (in milliseconds) since the last user inter
     *                  action
     **/
    readonly resetIdleTimeOut: (idleDeltaInMS: number) => void;
  }

  export interface nsIPluginTagRef {
    readonly name: "nsIPluginTag";
    readonly number: "{5daa99d5-265a-4397-b429-c943803e2619}";

    STATE_DISABLED: 0;

    STATE_CLICKTOPLAY: 1;

    STATE_ENABLED: 2;
  }

  export interface nsIPluginTag extends nsISupports {

    readonly description: IDLAUTF8String;

    readonly filename: IDLAUTF8String;

    readonly fullpath: IDLAUTF8String;

    readonly version: IDLAUTF8String;

    readonly name: IDLAUTF8String;

    readonly niceName: IDLAUTF8String;

    /**
     * true only if this plugin is "hardblocked" and cannot be enabled.
     */
    readonly blocklisted: boolean;

    /**
     * true if the state is non-default and locked, false otherwise.
     */
    readonly isEnabledStateLocked: boolean;

    readonly active: boolean;

    readonly blocklistState: number;

    readonly disabled: boolean;

    readonly clicktoplay: boolean;

    readonly loaded: boolean;

    enabledState: number;

    readonly lastModifiedTime: number;

    readonly isFlashPlugin: boolean;

    readonly getMimeTypes: () => IDLAUTF8String[];

    readonly getMimeDescriptions: () => IDLAUTF8String[];

    readonly getExtensions: () => IDLAUTF8String[];

    /**
     * An id for this plugin. 0 is a valid id.
     */
    readonly id: number;
  }

  export interface nsIBackgroundFileSaverObserverRef {
    readonly name: "nsIBackgroundFileSaverObserver";
    readonly number: "{ee7058c3-6e54-4411-b76b-3ce87b76fcb6}";
  }

  export interface nsIBackgroundFileSaverObserver extends nsISupports {

    /**
     * Called when the name of the output file has been determined.  This function
     * may be called more than once if the target file is renamed while saving.
     *
     * @param aSaver
     *        Reference to the object that raised the notification.
     * @param aTarget
     *        Name of the file that is being written.
     */
    readonly onTargetChange: (aSaver: (nsIBackgroundFileSaver | null), aTarget: (nsIFile | null)) => void;

    /**
     * Called when the operation completed, and the target file has been closed.
     * If the operation succeeded, the target file is ready to be used, otherwise
     * it might have been already deleted.
     *
     * @param aSaver
     *        Reference to the object that raised the notification.
     * @param aStatus
     *        Result code that determines whether the operation succeeded or
     *        failed, as well as the failure reason.
     */
    readonly onSaveComplete: (aSaver: (nsIBackgroundFileSaver | null), aStatus: number) => void;
  }

  export interface nsISubstitutionObserverRef {
    readonly name: "nsISubstitutionObserver";
    readonly number: "{492c9192-3803-4e2b-8373-d25fe55f5588}";
  }

  /**
   * An observer of substitutions being set or unset on a
   * SubstitutingProtocolHandler. Useful for receiving asynchronous notification
   * in a child process after a substitution has been set in the parent process
   * and is propagated to the child.
   */
  export interface nsISubstitutionObserver extends nsISupports {

    /**
     * To be called when a substition has been set or unset on a protocol
     * handler. Unset operations are identified by a null URI argument.
     *
     * @param aRoot the root key of the mapping
     * @param aBaseURI the base URI to be substituted for the root key by the
     *        protocol handler. For notifications triggered by unset
     *        operations (i.e., when is a substitution is removed from the
     *        protocol handler) this argument is null.
     */
    readonly onSetSubstitution: (aRoot: IDLACString, aBaseURI: (nsIURI | null)) => void;
  }

  export interface nsIMediaManagerServiceRef {
    readonly name: "nsIMediaManagerService";
    readonly number: "{24b23e01-33fd-401f-ba25-6e52658750b0}";

    STATE_NOCAPTURE: 0;

    STATE_CAPTURE_ENABLED: 1;

    STATE_CAPTURE_DISABLED: 2;
  }

  export interface nsIMediaManagerService extends nsISupports {

    readonly activeMediaCaptureWindows: (nsIArray | null);

    readonly mediaCaptureWindowState: (aWindow: (nsIDOMWindow | null), aCamera: Out<number>, aMicrophone: Out<number>, aScreenShare?: Out<number>, aWindowShare?: Out<number>, aBrowserShare?: Out<number>) => void;

    readonly sanitizeDeviceIds: (sinceWhen: number) => void;
  }

  export interface nsIPresentationDevicePromptRef {
    readonly name: "nsIPresentationDevicePrompt";
    readonly number: "{ac1a7e44-de86-454f-a9f1-276de2539831}";
  }

  export interface nsIPresentationDevicePrompt extends nsISupports {

    readonly promptDeviceSelection: (request: (nsIPresentationDeviceRequest | null)) => void;
  }

  export interface nsICertBlocklistRef {
    readonly name: "nsICertBlocklist";
    readonly number: "{e0654480-f433-11e4-b939-0800200c9a66}";
  }

  /**
   * Represents a service to add certificates as explicitly blocked/distrusted.
   */
  export interface nsICertBlocklist extends nsISupports {

    /**
     * Add details of a revoked certificate :
     * issuer name (base-64 encoded DER) and serial number (base-64 encoded DER).
     */
    readonly revokeCertByIssuerAndSerial: (issuer: IDLACString, serialNumber: IDLACString) => void;

    /**
     * Add details of a revoked certificate :
     * subject name (base-64 encoded DER) and hash of public key (base-64 encoded
     * sha-256 hash of the public key).
     */
    readonly revokeCertBySubjectAndPubKey: (subject: IDLACString, pubKeyHash: IDLACString) => void;

    /**
     * Persist (fresh) blocklist entries to the profile (if a profile directory is
     * available). Note: calling this will result in synchronous I/O.
     */
    readonly saveEntries: () => void;

    /**
     * Check if a certificate is blocked.
     * issuer - issuer name, DER, Base64 encoded
     * serial - serial number, DER, BAse64 encoded
     * subject - subject name, DER, Base64 encoded
     * pubkey - public key, DER, Base64 encoded
     */
    readonly isCertRevoked: (issuer: IDLACString, serial: IDLACString, subject: IDLACString, pubkey: IDLACString) => boolean;

    /**
     * Check that the blocklist data is current. Specifically, that the current
     * time is no more than security.onecrl.maximum_staleness_in_seconds seconds
     * after the last blocklist update (as stored in the
     * app.update.lastUpdateTime.blocklist-background-update-timer pref)
     */
    readonly isBlocklistFresh: () => boolean;
  }

  export interface nsIByteRangeRequestRef {
    readonly name: "nsIByteRangeRequest";
    readonly number: "{c1b1f426-7e83-4759-9f88-0e1b17f49366}";
  }

  export interface nsIByteRangeRequest extends nsISupports {

    /**
     * Returns true IFF this request is a byte range request, otherwise it
     * returns false (This is effectively the same as checking to see if
     * |startRequest| is zero and |endRange| is the content length.)
     */
    readonly isByteRangeRequest: boolean;

    /**
     * Absolute start position in remote file for this request.
     */
    readonly startRange: number;

    /**
     * Absolute end postion in remote file for this request
     */
    readonly endRange: number;
  }

  export interface nsIPresentationServiceRef {
    readonly name: "nsIPresentationService";
    readonly number: "{de42b741-5619-4650-b961-c2cebb572c95}";

    ROLE_CONTROLLER: 1;

    ROLE_RECEIVER: 2;

    CLOSED_REASON_ERROR: 1;

    CLOSED_REASON_CLOSED: 2;

    CLOSED_REASON_WENTAWAY: 3;
  }

  export interface nsIPresentationService extends nsISupports {

    readonly sendSessionMessage: (sessionId: IDLAString, role: number, data: IDLAString) => void;

    readonly sendSessionBinaryMsg: (sessionId: IDLAString, role: number, data: IDLACString) => void;

    readonly sendSessionBlob: (sessionId: IDLAString, role: number, blob: WebIDL.Blob) => void;

    readonly closeSession: (sessionId: IDLAString, role: number, closedReason: number) => void;

    readonly terminateSession: (sessionId: IDLAString, role: number) => void;

    readonly registerSessionListener: (sessionId: IDLAString, role: number, listener: (nsIPresentationSessionListener | null)) => void;

    readonly unregisterSessionListener: (sessionId: IDLAString, role: number) => void;

    readonly registerRespondingListener: (windowId: number, listener: (nsIPresentationRespondingListener | null)) => void;

    readonly unregisterRespondingListener: (windowId: number) => void;

    readonly notifyReceiverReady: (sessionId: IDLAString, windowId: number, isLoading: boolean, constructor: (nsIPresentationTransportBuilderConstructor | null)) => void;

    readonly NotifyTransportClosed: (sessionId: IDLAString, role: number, reason: number) => void;

    readonly untrackSessionInfo: (sessionId: IDLAString, role: number) => void;

    readonly getWindowIdBySessionId: (sessionId: IDLAString, role: number) => number;

    readonly updateWindowIdBySessionId: (sessionId: IDLAString, role: number, windowId: number) => void;

    readonly buildTransport: (sessionId: IDLAString, role: number) => void;
  }

  export interface nsIKeyValueEnumeratorRef {
    readonly name: "nsIKeyValueEnumerator";
    readonly number: "{b9ba7116-b7ff-4717-9a28-a08e6879b199}";
  }

  /**
   * An enumerator of key/value pairs.  Although its methods are similar
   * to those of nsISimpleEnumerator, this interface's getNext() method returns
   * an nsIKeyValuePair rather than an nsISupports, so consumers don't need
   * to QI it to that interface; but this interface doesn't implement the JS
   * iteration protocol (because the Rust-XPCOM bindings don't yet support it),
   * which is another reason why you should use the kvstore.jsm module from JS
   * instead of accessing this API directly.
   */
  export interface nsIKeyValueEnumerator extends nsISupports {

    readonly hasMoreElements: () => boolean;

    readonly getNext: () => (nsIKeyValuePair | null);
  }

  export interface nsIRefreshURIRef {
    readonly name: "nsIRefreshURI";
    readonly number: "{a5e61a3c-51bd-45be-ac0c-e87b71860656}";
  }

  export interface nsIRefreshURI extends nsISupports {

    /**
     * Load a uri after waiting for aMillis milliseconds. If the docshell
     * is busy loading a page currently, the refresh request will be
     * queued and executed when the current load finishes.
     *
     * @param aUri The uri to refresh.
     * @param aPrincipal The triggeringPrincipal for the refresh load
     *   May be null, in which case the principal of current document will be
     *   applied.
     * @param aMillis The number of milliseconds to wait.
     * @param aRepeat Flag to indicate if the uri is to be
     *                repeatedly refreshed every aMillis milliseconds.
     * @param aMetaRefresh Flag to indicate if this is a Meta refresh.
     */
    readonly refreshURI: (aURI: (nsIURI | null), aPrincipal: (nsIPrincipal | null), aMillis: number, aRepeat: boolean, aMetaRefresh: boolean) => void;

    /**
     * Loads a URI immediately as if it were a refresh.
     *
     * @param aURI The URI to refresh.
     * @param aPrincipal The triggeringPrincipal for the refresh load
     *   May be null, in which case the principal of current document will be
     *   applied.
     * @param aMillis The number of milliseconds by which this refresh would
     *                be delayed if it were not being forced.
     * @param aMetaRefresh Flag to indicate if this is a meta refresh.
     */
    readonly forceRefreshURI: (aURI: (nsIURI | null), aPrincipal: (nsIPrincipal | null), aMillis: number, aMetaRefresh: boolean) => void;

    /**
     * Checks the passed in channel to see if there is a refresh header,
     * if there is, will setup a timer to refresh the uri found
     * in the header. If docshell is busy loading a page currently, the
     * request will be queued and executed when the current page
     * finishes loading.
     *
     * Returns the NS_REFRESHURI_HEADER_FOUND success code if a refresh
     * header was found and successfully setup.
     *
     * @param aChannel The channel to be parsed.
     */
    readonly setupRefreshURI: (aChannel: (nsIChannel | null)) => void;

    /**
     * Parses the passed in header string and sets up a refreshURI if
     * a "refresh" header is found. If docshell is busy loading a page
     * currently, the request will be queued and executed when
     * the current page finishes loading.
     *
     * @param aBaseURI base URI to resolve refresh uri with.
     * @param aPrincipal The triggeringPrincipal for the refresh load
     *   May be null, in which case the principal of current document will be
     *   applied.
     * @param aInnerWindowID The window id to use for error reporting.
     * @param aHeader  The meta refresh header string.
     */
    readonly setupRefreshURIFromHeader: (aBaseURI: (nsIURI | null), principal: (nsIPrincipal | null), aInnerWindowID: number, aHeader: IDLACString) => void;

    /**
     * Cancels all timer loads.
     */
    readonly cancelRefreshURITimers: () => void;

    /**
     * True when there are pending refreshes, false otherwise.
     */
    readonly refreshPending: boolean;
  }

  export interface nsIScriptLoaderObserverRef {
    readonly name: "nsIScriptLoaderObserver";
    readonly number: "{7b787204-76fb-4764-96f1-fb7a666db4f4}";
  }

  export interface nsIScriptLoaderObserver extends nsISupports {
  }

  export interface nsIRedirectResultListenerRef {
    readonly name: "nsIRedirectResultListener";
    readonly number: "{85cd2640-e91e-41ac-bdca-1dbf10dc131e}";
  }

  export interface nsIRedirectResultListener extends nsISupports {

    /**
     *  When an HTTP redirect has been processed (either successfully or not)
     *  nsIHttpChannel will call this function if its callbacks implement this
     *  interface.
     *
     *  @param proceeding
     *         Indicated whether the redirect will be proceeding, or not (i.e.
     *         has been canceled, or failed).
     */
    readonly onRedirectResult: (proceeding: boolean) => void;
  }

  export interface nsIZipReaderRef {
    readonly name: "nsIZipReader";
    readonly number: "{9ba4ef54-e0a0-4f65-9d23-128482448885}";
  }

  export interface nsIZipReader extends nsISupports {

    /**
     * Opens a zip file for reading.
     * It is allowed to open with another file,
     * but it needs to be closed first with close().
     */
    readonly open: (zipFile: (nsIFile | null)) => void;

    /**
     * Opens a zip file inside a zip file for reading.
     */
    readonly openInner: (zipReader: (nsIZipReader | null), zipEntry: IDLAUTF8String) => void;

    /**
     * The file that represents the zip with which this zip reader was
     * initialized.  This will be null if there is no underlying file.
     */
    readonly file: (nsIFile | null);

    /**
     * Closes a zip reader. Subsequent attempts to extract files or read from
     * its input stream will result in an error.
     *
     * Subsequent attempts to access a nsIZipEntry obtained from this zip
     * reader will cause unspecified behavior.
     */
    readonly close: () => void;

    /**
     * Tests the integrity of the archive by performing a CRC check
     * on each item expanded into memory.  If an entry is specified
     * the integrity of only that item is tested.  If null (javascript)
     * or EmptyCString() (c++) is passed in the integrity of all items
     * in the archive are tested.
     */
    readonly test: (aEntryName: IDLAUTF8String) => void;

    /**
     * Extracts a zip entry into a local file specified by outFile.
     * The entry must be stored in the zip in either uncompressed or
     * DEFLATE-compressed format for the extraction to be successful.
     * If the entry is a directory, the directory will be extracted
     * non-recursively.
     */
    readonly extract: (zipEntry: IDLAUTF8String, outFile: (nsIFile | null)) => void;

    /**
     * Returns a nsIZipEntry describing a specified zip entry.
     */
    readonly getEntry: (zipEntry: IDLAUTF8String) => (nsIZipEntry | null);

    /**
     * Checks whether the zipfile contains an entry specified by entryName.
     */
    readonly hasEntry: (zipEntry: IDLAUTF8String) => boolean;

    /**
     * Returns a string enumerator containing the matching entry names.
     *
     * @param aPattern
     *   A regular expression used to find matching entries in the zip file.
     *   Set this parameter to null (javascript) or EmptyCString() (c++) or "*"
     *   to get all entries; otherwise, use the
     *   following syntax:
     *
     *   o * matches anything
     *   o ? matches one character
     *   o $ matches the end of the string
     *   o [abc] matches one occurrence of a, b, or c. The only character that
     *           must be escaped inside the brackets is ].  ^ and - must never
     *           appear in the first and second positions within the brackets,
     *           respectively.  (In the former case, the behavior specified for
     *           '[^az]' will happen.)
     *   o [a-z] matches any character between a and z.  The characters a and z
     *           must either both be letters or both be numbers, with the
     *           character represented by 'a' having a lower ASCII value than
     *           the character represented by 'z'.
     *   o [^az] matches any character except a or z.  If ] is to appear inside
     *           the brackets as a character to not match, it must be escaped.
     *   o pat~pat2 returns matches to the pattern 'pat' which do not also match
     *              the pattern 'pat2'.  This may be used to perform filtering
     *              upon the results of one pattern to remove all matches which
     *              also match another pattern.  For example, because '*'
     *              matches any string and '*z*' matches any string containing a
     *              'z', '*~*z*' will match all strings except those containing
     *              a 'z'.  Note that a pattern may not use '~' multiple times,
     *              so a string such as '*~*z*~*y*' is not a valid pattern.
     *   o (foo|bar) will match either the pattern foo or the pattern bar.
     *               Neither of the patterns foo or bar may use the 'pat~pat2'
     *               syntax described immediately above.
     *   o \ will escape a special character.  Escaping is required for all
     *       special characters unless otherwise specified.
     *   o All other characters match case-sensitively.
     *
     *   An aPattern not conforming to this syntax has undefined behavior.
     *
     * @throws NS_ERROR_ILLEGAL_VALUE on many but not all invalid aPattern
     *                                values.
     */
    readonly findEntries: (aPattern: IDLAUTF8String) => (nsIUTF8StringEnumerator | null);

    /**
     * Returns an input stream containing the contents of the specified zip
     * entry.
     * @param zipEntry the name of the entry to open the stream from
     */
    readonly getInputStream: (zipEntry: IDLAUTF8String) => (nsIInputStream | null);

    /**
     * Returns an input stream containing the contents of the specified zip
     * entry. If the entry refers to a directory (ends with '/'), a directory stream
     * is opened, otherwise the contents of the file entry is returned.
     * @param aJarSpec the Spec of the URI for the JAR (only used for directory streams)
     * @param zipEntry the name of the entry to open the stream from
     */
    readonly getInputStreamWithSpec: (aJarSpec: IDLAUTF8String, zipEntry: IDLAUTF8String) => (nsIInputStream | null);
  }

  export interface nsIParentRedirectingChannelRef {
    readonly name: "nsIParentRedirectingChannel";
    readonly number: "{3ed1d288-5324-46ee-8a98-33ac37d1080b}";
  }

  /**
   * Implemented by chrome side of IPC protocols that support redirect responses.
   */
  export interface nsIParentRedirectingChannel extends nsIParentChannel {

    /**
     * Called when the channel got a response that redirects it to a different
     * URI.  The implementation is responsible for calling the redirect observers
     * on the child process and provide the decision result to the callback.
     *
     * @param newURI
     *    the URI we redirect to
     * @param callback
     *    redirect result callback, usage is compatible with how
     *    nsIChannelEventSink defines it
     */
    readonly startRedirect: (newChannel: (nsIChannel | null), redirectFlags: number, callback: (nsIAsyncVerifyRedirectCallback | null)) => void;

    /**
     * Called after we are done with redirecting process and we know if to
     * redirect or not.  Forward the redirect result to the child process.  From
     * that moment the nsIParentChannel implementation expects it will be
     * forwarded all notifications from the 'real' channel.
     *
     * Primarilly used by ParentChannelListener::OnRedirectResult and kept as
     * mActiveChannel and mRedirectChannel in that class.
     */
    readonly completeRedirect: (succeeded: boolean) => void;
  }

  export interface nsIMemoryReporterManagerRef {
    readonly name: "nsIMemoryReporterManager";
    readonly number: "{2998574d-8993-407a-b1a5-8ad7417653e1}";
  }

  export interface nsIMemoryReporterManager extends nsISupports {

    readonly init: () => void;

    readonly registerStrongReporter: (reporter: (nsIMemoryReporter | null)) => void;

    readonly registerStrongAsyncReporter: (reporter: (nsIMemoryReporter | null)) => void;

    readonly registerWeakReporter: (reporter: (nsIMemoryReporter | null)) => void;

    readonly registerWeakAsyncReporter: (reporter: (nsIMemoryReporter | null)) => void;

    readonly unregisterStrongReporter: (reporter: (nsIMemoryReporter | null)) => void;

    readonly unregisterWeakReporter: (reporter: (nsIMemoryReporter | null)) => void;

    readonly blockRegistrationAndHideExistingReporters: () => void;

    readonly unblockRegistrationAndRestoreOriginalReporters: () => void;

    readonly registerStrongReporterEvenIfBlocked: (aReporter: (nsIMemoryReporter | null)) => void;

    readonly getReports: (handleReport: (nsIHandleReportCallback | nsIHandleReportCallbackFunction | null), handleReportData: (nsISupports | null), finishReporting: (nsIFinishReportingCallback | nsIFinishReportingCallbackFunction | null), finishReportingData: (nsISupports | null), anonymize: boolean) => void;

    readonly vsize: number;

    readonly vsizeMaxContiguous: number;

    readonly resident: number;

    readonly residentFast: number;

    readonly residentPeak: number;

    readonly residentUnique: number;

    readonly heapAllocated: number;

    readonly heapOverheadFraction: number;

    readonly JSMainRuntimeGCHeap: number;

    readonly JSMainRuntimeTemporaryPeak: number;

    readonly JSMainRuntimeCompartmentsSystem: number;

    readonly JSMainRuntimeCompartmentsUser: number;

    readonly JSMainRuntimeRealmsSystem: number;

    readonly JSMainRuntimeRealmsUser: number;

    readonly imagesContentUsedUncompressed: number;

    readonly storageSQLite: number;

    readonly lowMemoryEventsVirtual: number;

    readonly lowMemoryEventsCommitSpace: number;

    readonly lowMemoryEventsPhysical: number;

    readonly ghostWindows: number;

    readonly pageFaultsHard: number;

    readonly hasMozMallocUsableSize: boolean;

    readonly isDMDEnabled: boolean;

    readonly isDMDRunning: boolean;

    readonly minimizeMemoryUsage: (callback: (nsIRunnable | nsIRunnableFunction | null)) => void;

    readonly sizeOfTab: (window: (mozIDOMWindowProxy | null), jsObjectsSize: Out<number>, jsStringsSize: Out<number>, jsOtherSize: Out<number>, domSize: Out<number>, styleSize: Out<number>, otherSize: Out<number>, totalSize: Out<number>, jsMilliseconds: Out<number>, nonJSMilliseconds: Out<number>) => void;
  }

  export interface nsICertificateDialogsRef {
    readonly name: "nsICertificateDialogs";
    readonly number: "{da871dab-f69e-4173-ab26-99fcd47b0e85}";
  }

  /**
   * Functions that implement user interface dialogs to manage certificates.
   */
  export interface nsICertificateDialogs extends nsISupports {

    /**
     *  UI shown when a user is asked to download a new CA cert.
     *  Provides user with ability to choose trust settings for the cert.
     *  Asks the user to grant permission to import the certificate.
     *
     *  @param ctx A user interface context.
     *  @param cert The certificate that is about to get installed.
     *  @param trust A bit mask of trust flags.
     *               See nsIX509CertDB for possible values.
     *
     *  @return true if the user allows to import the certificate.
     */
    readonly confirmDownloadCACert: (ctx: (nsIInterfaceRequestor | null), cert: (nsIX509Cert | null), trust: Out<number>) => boolean;

    /**
     *  UI shown when a user's personal certificate is going to be
     *  exported to a backup file.
     *  The implementation of this dialog should make sure to prompt the user to
     *  type the password twice in order to confirm correct input.
     *  The wording in the dialog should also motivate the user to enter a strong
     *  password.
     *
     *  @param ctx A user interface context.
     *  @param password The password provided by the user.
     *
     *  @return false if the user requests to cancel.
     */
    readonly setPKCS12FilePassword: (ctx: (nsIInterfaceRequestor | null), password: Out<IDLAString>) => boolean;

    /**
     *  UI shown when a user is about to restore a personal
     *  certificate from a backup file.
     *  The user is requested to enter the password
     *  that was used in the past to protect that backup file.
     *
     *  @param ctx A user interface context.
     *  @param password The password provided by the user.
     *
     *  @return false if the user requests to cancel.
     */
    readonly getPKCS12FilePassword: (ctx: (nsIInterfaceRequestor | null), password: Out<IDLAString>) => boolean;
  }

  export interface nsIURLFormatterRef {
    readonly name: "nsIURLFormatter";
    readonly number: "{4ab31d30-372d-11db-a98b-0800200c9a66}";
  }

  export interface nsIURLFormatter extends nsISupports {

    /**
     * formatURL - Formats a string URL
     *
     * The set of known variables is predefined.
     * If a variable is unknown, it is left unchanged and a non-fatal error is reported.
     *
     * @param aFormat string Unformatted URL.
     *
     * @return The formatted URL.
     */
    readonly formatURL: (aFormat: IDLAString) => IDLAString;

    /**
     * formatURLPref - Formats a string URL stored in a preference
     *
     * If the preference value cannot be retrieved, a fatal error is reported
     * and the "about:blank" URL is returned.
     *
     * @param aPref string Preference name.
     *
     * @return The formatted URL returned by formatURL(), or "about:blank".
     */
    readonly formatURLPref: (aPref: IDLAString) => IDLAString;

    /**
     * Remove all of the sensitive query parameter strings from URLs in |aMsg|.
     */
    readonly trimSensitiveURLs: (aMsg: IDLAString) => IDLAString;
  }

  export interface nsIUpdateTimerManagerRef {
    readonly name: "nsIUpdateTimerManager";
    readonly number: "{0765c92c-6145-4253-9db4-594d8023087e}";
  }

  /**
   * An interface describing a global application service that allows long
   * duration (e.g. 1-7 or more days, weeks or months) timers to be registered
   * and then fired.
   */
  export interface nsIUpdateTimerManager extends nsISupports {

    /**
     * Register an interval with the timer manager. The timer manager
     * periodically checks to see if the interval has expired and if it has
     * calls the specified callback. This is persistent across application
     * restarts and can handle intervals of long durations. The callback will be
     * called soon after the first registration unless you ask to skip it.
     * @param   id
     *          An id that identifies the interval, used for persistence
     * @param   callback
     *          A nsITimerCallback object that is notified when the interval
     *          expires
     * @param   interval
     *          The length of time, in seconds, of the interval
     * @param   skipFirst
     *          Whether to skip the initial callback on first registration.
     *
     * Note: to avoid having to instantiate a component to call registerTimer
     * the component can intead register an update-timer category with comma
     * separated values as a single string:
     *
     * contractID,method,id,preference,interval
     *
     * via a manifest entry. The values are as follows:
     *   contractID : the contract ID for the component.
     *   method     : the method used to instantiate the interface. This should be
     *                either getService or createInstance depending on your
     *                component.
     *   id         : the id that identifies the interval, used for persistence.
     *   preference : the preference to for timer interval. This value can be
     *                optional by specifying an empty string for the value.
     *   interval   : the default interval in seconds for the timer.
     */
    readonly registerTimer: (id: IDLAString, callback: (nsITimerCallback | nsITimerCallbackFunction | null), interval: number, skipFirst?: boolean) => void;

    /**
     * Unregister an existing interval from the timer manager.
     *
     * @param   id
     *          An id that identifies the interval.
     */
    readonly unregisterTimer: (id: IDLAString) => void;
  }

  export interface nsIDirIndexListenerRef {
    readonly name: "nsIDirIndexListener";
    readonly number: "{fae4e9a8-1dd1-11b2-b53c-8f3aa1bbf8f5}";
  }

  /**
   * This interface is used to receive contents of directory index listings
   * from a protocol. They can then be transformed into an output format
   * (such as rdf, html, etc)
   */
  export interface nsIDirIndexListener extends nsISupports {

    /**
     * Called for each directory entry
     *
     * @param request - the request
     * @param ctxt - opaque parameter
     * @param index - new index to add
     */
    readonly onIndexAvailable: (aRequest: (nsIRequest | null), aCtxt: (nsISupports | null), aIndex: (nsIDirIndex | null)) => void;

    /**
     * Called for each information line
     *
     * @param request - the request
     * @param ctxt - opaque parameter
     * @param info - new info to add
     */
    readonly onInformationAvailable: (aRequest: (nsIRequest | null), aCtxt: (nsISupports | null), aInfo: IDLAString) => void;
  }

  export interface nsIURLRef {
    readonly name: "nsIURL";
    readonly number: "{86adcd89-0b70-47a2-b0fe-5bb2c5f37e31}";
  }

  /**
   * The nsIURL interface provides convenience methods that further
   * break down the path portion of nsIURI:
   *
   * http://host/directory/fileBaseName.fileExtension?query
   * http://host/directory/fileBaseName.fileExtension#ref
   *            \          \                       /
   *             \          -----------------------
   *              \                   |          /
   *               \               fileName     /
   *                ----------------------------
   *                            |
   *                        filePath
   */
  export interface nsIURL extends nsIURI {

    /*************************************************************************
     * The URL path is broken down into the following principal components:
     *
     * attribute AUTF8String filePath;
     * attribute AUTF8String query;
     *
     * These are inherited from nsIURI.
     */
    /*************************************************************************
     * The URL filepath is broken down into the following sub-components:
     */
    /**
     * Returns the directory portion of a URL.  If the URL denotes a path to a
     * directory and not a file, e.g. http://host/foo/bar/, then the Directory
     * attribute accesses the complete /foo/bar/ portion, and the FileName is
     * the empty string. If the trailing slash is omitted, then the Directory
     * is /foo/ and the file is bar (i.e. this is a syntactic, not a semantic
     * breakdown of the Path).  And hence don't rely on this for something to
     * be a definitely be a file. But you can get just the leading directory
     * portion for sure.
     *
     * Some characters may be escaped.
     */
    readonly directory: IDLAUTF8String;

    /**
     * Returns the file name portion of a URL.  If the URL denotes a path to a
     * directory and not a file, e.g. http://host/foo/bar/, then the Directory
     * attribute accesses the complete /foo/bar/ portion, and the FileName is
     * the empty string. Note that this is purely based on searching for the
     * last trailing slash. And hence don't rely on this to be a definite file.
     *
     * Some characters may be escaped.
     */
    readonly fileName: IDLAUTF8String;

    /*************************************************************************
     * The URL filename is broken down even further:
     */
    /**
     * Returns the file basename portion of a filename in a url.
     *
     * Some characters may be escaped.
     */
    readonly fileBaseName: IDLAUTF8String;

    /**
     * Returns the file extension portion of a filename in a url.  If a file
     * extension does not exist, the empty string is returned.
     *
     * Some characters may be escaped.
     */
    readonly fileExtension: IDLAUTF8String;

    /**
     * This method takes a uri and compares the two.  The common uri portion
     * is returned as a string.  The minimum common uri portion is the
     * protocol, and any of these if present:  login, password, host and port
     * If no commonality is found, "" is returned.  If they are identical, the
     * whole path with file/ref/etc. is returned.  For file uris, it is
     * expected that the common spec would be at least "file:///" since '/' is
     * a shared common root.
     *
     * Examples:
     *    this.spec               aURIToCompare.spec        result
     * 1) http://mozilla.org/     http://www.mozilla.org/   ""
     * 2) http://foo.com/bar/     ftp://foo.com/bar/        ""
     * 3) http://foo.com:8080/    http://foo.com/bar/       ""
     * 4) ftp://user@foo.com/     ftp://user:pw@foo.com/    ""
     * 5) ftp://foo.com/bar/      ftp://foo.com/bar         ftp://foo.com/
     * 6) ftp://foo.com/bar/      ftp://foo.com/bar/b.html  ftp://foo.com/bar/
     * 7) http://foo.com/a.htm#i  http://foo.com/b.htm      http://foo.com/
     * 8) ftp://foo.com/c.htm#i   ftp://foo.com/c.htm       ftp://foo.com/c.htm
     * 9) file:///a/b/c.html      file:///d/e/c.html        file:///
     */
    readonly getCommonBaseSpec: (aURIToCompare: (nsIURI | null)) => IDLAUTF8String;

    /**
     * This method tries to create a string which specifies the location of the
     * argument relative to |this|.  If the argument and |this| are equal, the
     * method returns "".  If any of the URIs' scheme, host, userpass, or port
     * don't match, the method returns the full spec of the argument.
     *
     * Examples:
     *    this.spec               aURIToCompare.spec        result
     * 1) http://mozilla.org/     http://www.mozilla.org/   http://www.mozilla.org/
     * 2) http://mozilla.org/     http://www.mozilla.org    http://www.mozilla.org/
     * 3) http://foo.com/bar/     http://foo.com:80/bar/    ""
     * 4) http://foo.com/         http://foo.com/a.htm#b    a.html#b
     * 5) http://foo.com/a/b/     http://foo.com/c          ../../c
     */
    readonly getRelativeSpec: (aURIToCompare: (nsIURI | null)) => IDLAUTF8String;
  }

  export interface nsIURIRef {
    readonly name: "nsIURI";
    readonly number: "{92073a54-6d78-4f30-913a-b871813208c6}";
  }

  /**
   * nsIURI - interface for an uniform resource identifier w/ i18n support.
   *
   * AUTF8String attributes may contain unescaped UTF-8 characters.
   * Consumers should be careful to escape the UTF-8 strings as necessary, but
   * should always try to "display" the UTF-8 version as provided by this
   * interface.
   *
   * AUTF8String attributes may also contain escaped characters.
   *
   * Unescaping URI segments is unadvised unless there is intimate
   * knowledge of the underlying charset or there is no plan to display (or
   * otherwise enforce a charset on) the resulting URI substring.
   *
   * The correct way to create an nsIURI from a string is via
   * nsIIOService.newURI.
   *
   * NOTE: nsBinaryInputStream::ReadObject contains a hackaround to intercept the
   * old (pre-gecko6) nsIURI IID and swap in the current IID instead, in order
   * for sessionstore to work after an upgrade.  If this IID is revved further,
   * we will need to add additional checks there for all intermediate IIDs, until
   * ContentPrincipal is fixed to serialize its URIs as nsISupports (bug 662693).
   */
  export interface nsIURI extends nsISupports {

    /************************************************************************
     * The URI is broken down into the following principal components:
     */
    /**
     * Returns a string representation of the URI.
     *
     * Some characters may be escaped.
     */
    readonly spec: IDLAUTF8String;

    /**
     * The prePath (eg. scheme://user:password@host:port) returns the string
     * before the path.  This is useful for authentication or managing sessions.
     *
     * Some characters may be escaped.
     */
    readonly prePath: IDLAUTF8String;

    /**
     * The Scheme is the protocol to which this URI refers.  The scheme is
     * restricted to the US-ASCII charset per RFC3986.
     */
    readonly scheme: IDLACString;

    /**
     * The username:password (or username only if value doesn't contain a ':')
     *
     * Some characters may be escaped.
     */
    readonly userPass: IDLAUTF8String;

    /**
     * The optional username and password, assuming the preHost consists of
     * username:password.
     *
     * Some characters may be escaped.
     */
    readonly username: IDLAUTF8String;

    readonly password: IDLAUTF8String;

    /**
     * The host:port (or simply the host, if port == -1).
     */
    readonly hostPort: IDLAUTF8String;

    /**
     * The host is the internet domain name to which this URI refers.  It could
     * be an IPv4 (or IPv6) address literal. Otherwise it is an ASCII or punycode
     * encoded string.
     */
    readonly host: IDLAUTF8String;

    /**
     * A port value of -1 corresponds to the protocol's default port (eg. -1
     * implies port 80 for http URIs).
     */
    readonly port: number;

    /**
     * The path, typically including at least a leading '/' (but may also be
     * empty, depending on the protocol).
     *
     * Some characters may be escaped.
     *
     * This attribute contains query and ref parts for historical reasons.
     * Use the 'filePath' attribute if you do not want those parts included.
     */
    readonly pathQueryRef: IDLAUTF8String;

    /************************************************************************
     * An URI supports the following methods:
     */
    /**
     * URI equivalence test (not a strict string comparison).
     *
     * eg. http://foo.com:80/ == http://foo.com/
     */
    readonly equals: (other: (nsIURI | null)) => boolean;

    /**
     * An optimization to do scheme checks without requiring the users of nsIURI
     * to GetScheme, thereby saving extra allocating and freeing. Returns true if
     * the schemes match (case ignored).
     */
    readonly schemeIs: (scheme: string) => boolean;

    /**
     * This method resolves a relative string into an absolute URI string,
     * using this URI as the base.
     *
     * NOTE: some implementations may have no concept of a relative URI.
     */
    readonly resolve: (relativePath: IDLAUTF8String) => IDLAUTF8String;

    /************************************************************************
     * Additional attributes:
     */
    /**
     * The URI spec with an ASCII compatible encoding.  Host portion follows
     * the IDNA draft spec.  Other parts are URL-escaped per the rules of
     * RFC2396.  The result is strictly ASCII.
     */
    readonly asciiSpec: IDLACString;

    /**
     * The host:port (or simply the host, if port == -1), with an ASCII compatible
     * encoding.  Host portion follows the IDNA draft spec.  The result is strictly
     * ASCII.
     */
    readonly asciiHostPort: IDLACString;

    /**
     * The URI host with an ASCII compatible encoding.  Follows the IDNA
     * draft spec for converting internationalized domain names (UTF-8) to
     * ASCII for compatibility with existing internet infrasture.
     */
    readonly asciiHost: IDLACString;

    /************************************************************************
     * Additional attribute & methods added for .ref support:
     */
    /**
     * Returns the reference portion (the part after the "#") of the URI.
     * If there isn't one, an empty string is returned.
     *
     * Some characters may be escaped.
     */
    readonly ref: IDLAUTF8String;

    /**
     * URI equivalence test (not a strict string comparison), ignoring
     * the value of the .ref member.
     *
     * eg. http://foo.com/# == http://foo.com/
     *     http://foo.com/#aaa == http://foo.com/#bbb
     */
    readonly equalsExceptRef: (other: (nsIURI | null)) => boolean;

    /**
     * returns a string for the current URI with the ref element cleared.
     */
    readonly specIgnoringRef: IDLAUTF8String;

    /**
     * Returns if there is a reference portion (the part after the "#") of the URI.
     */
    readonly hasRef: boolean;

    /************************************************************************
     * Additional attributes added for .query support:
     */
    /**
     * Returns a path including the directory and file portions of a
     * URL.  For example, the filePath of "http://host/foo/bar.html#baz"
     * is "/foo/bar.html".
     *
     * Some characters may be escaped.
     */
    readonly filePath: IDLAUTF8String;

    /**
     * Returns the query portion (the part after the "?") of the URL.
     * If there isn't one, an empty string is returned.
     *
     * Some characters may be escaped.
     */
    readonly query: IDLAUTF8String;

    /**
     * If the URI has a punycode encoded hostname, this will hold the UTF8
     * representation of that hostname (if that representation doesn't contain
     * blacklisted characters, and the network.IDN_show_punycode pref is false)
     * Otherwise, if the hostname is ASCII, it will return the same as .asciiHost
     */
    readonly displayHost: IDLAUTF8String;

    /**
     * The displayHost:port (or simply the displayHost, if port == -1).
     */
    readonly displayHostPort: IDLAUTF8String;

    /**
     * Returns the same as calling .spec, only with a UTF8 encoded hostname
     * (if that hostname doesn't contain blacklisted characters, and
     * the network.IDN_show_punycode pref is false)
     */
    readonly displaySpec: IDLAUTF8String;

    /**
     * Returns the same as calling .prePath, only with a UTF8 encoded hostname
     * (if that hostname doesn't contain blacklisted characters, and
     * the network.IDN_show_punycode pref is false)
     */
    readonly displayPrePath: IDLAUTF8String;

    /**
     * Returns an nsIURIMutator that can be used to make changes to the URI.
     * After performing the setter operations on the mutator, one may call
     * mutator.finalize() to get a new immutable URI with the desired
     * properties.
     */
    readonly mutate: () => (nsIURIMutator | null);
  }

  export interface nsIWebBrowserRef {
    readonly name: "nsIWebBrowser";
    readonly number: "{4052b6da-4faa-4646-b3a1-7e16a01c2dc2}";
  }

  /**
   * The nsIWebBrowser interface is implemented by web browser objects.
   * Embedders use this interface during initialisation to associate
   * the new web browser instance with the embedders chrome and
   * to register any listeners. The interface may also be used at runtime
   * to obtain the content DOM window and from that the rest of the DOM.
   */
  export interface nsIWebBrowser extends nsISupports {

    /**
     * The chrome object associated with the browser instance. The embedder
     * must create one chrome object for <I>each</I> browser object
     * that is instantiated. The embedder must associate the two by setting
     * this property to point to the chrome object before creating the browser
     * window via the browser's <CODE>nsIBaseWindow</CODE> interface.
     *
     * The chrome object must also implement <CODE>nsIEmbeddingSiteWindow</CODE>.
     *
     * The chrome may optionally implement <CODE>nsIInterfaceRequestor</CODE>,
     * <CODE>nsIWebBrowserChromeFocus</CODE>,
     * <CODE>nsIContextMenuListener</CODE> and
     * <CODE>nsITooltipListener</CODE> to receive additional notifications
     * from the browser object.
     *
     * The chrome object may optionally implement
     * <CODE>nsIWebProgressListener</CODE> to register a progress listener
     * object. If the implementation does this, it must also implement
     * <CODE>nsIWeakReference</CODE>.
     *
     * @note The implementation should not refcount the supplied chrome
     *       object; it should assume that a non <CODE>nullptr</CODE> value is
     *       always valid. The embedder must explicitly set this value back
     *       to nullptr if the chrome object is destroyed before the browser
     *       object.
     *
     * @see nsIBaseWindow
     * @see nsIWebBrowserChrome
     * @see nsIEmbeddingSiteWindow
     * @see nsIInterfaceRequestor
     * @see nsIWebBrowserChromeFocus
     * @see nsIContextMenuListener
     * @see nsITooltipListener
     * @see nsIWeakReference
     * @see nsIWebProgressListener
     */
    containerWindow: (nsIWebBrowserChrome | null);

    /**
     * The top-level DOM window. The embedder may walk the entire
     * DOM starting from this value.
     */
    readonly contentDOMWindow: (mozIDOMWindowProxy | null);
  }

  export interface nsIApplicationCacheRef {
    readonly name: "nsIApplicationCache";
    readonly number: "{06568dae-c374-4383-a122-0cc96c7177f2}";

    /**
     * Entries in an application cache can be marked as one or more of
     * the following types.
     */
    ITEM_MANIFEST: 1;

    ITEM_EXPLICIT: 2;

    ITEM_IMPLICIT: 4;

    ITEM_DYNAMIC: 8;

    ITEM_FOREIGN: 16;

    ITEM_FALLBACK: 32;

    ITEM_OPPORTUNISTIC: 64;
  }

  /**
   * Application caches store resources for offline use.  Each
   * application cache has a unique client ID for use with
   * nsICacheService::openSession() to access the cache's entries.
   *
   * Each entry in the application cache can be marked with a set of
   * types, as discussed in the WHAT-WG offline applications
   * specification.
   *
   * All application caches with the same group ID belong to a cache
   * group.  Each group has one "active" cache that will service future
   * loads.  Inactive caches will be removed from the cache when they are
   * no longer referenced.
   */
  export interface nsIApplicationCache extends nsISupports {

    /**
     * Init this application cache instance to just hold the group ID and
     * the client ID to work just as a handle to the real cache. Used on
     * content process to simplify the application cache code.
     */
    readonly initAsHandle: (groupId: IDLACString, clientId: IDLACString) => void;

    /**
     * URI of the manfiest specifying this application cache.
     **/
    readonly manifestURI: (nsIURI | null);

    /**
     * The group ID for this cache group.  It is an internally generated string
     * and cannot be used as manifest URL spec.
     **/
    readonly groupID: IDLACString;

    /**
     * The client ID for this application cache.  Clients can open a
     * session with nsICacheService::createSession() using this client
     * ID and a storage policy of STORE_OFFLINE to access this cache.
     */
    readonly clientID: IDLACString;

    /**
     * TRUE if the cache is the active cache for this group.
     */
    readonly active: boolean;

    /**
     * The disk usage of the application cache, in bytes.
     */
    readonly usage: number;

    /**
     * Makes this cache the active application cache for this group.
     * Future loads associated with this group will come from this
     * cache.  Other caches from this cache group will be deactivated.
     */
    readonly activate: () => void;

    /**
     * Discard this application cache.  Removes all cached resources
     * for this cache.  If this is the active application cache for the
     * group, the group will be removed.
     */
    readonly discard: () => void;

    /**
     * Adds item types to a given entry.
     */
    readonly markEntry: (key: IDLACString, typeBits: number) => void;

    /**
     * Removes types from a given entry.  If the resulting entry has
     * no types left, the entry is removed.
     */
    readonly unmarkEntry: (key: IDLACString, typeBits: number) => void;

    /**
     * Gets the types for a given entry.
     */
    readonly getTypes: (key: IDLACString) => number;

    /**
     * Returns any entries in the application cache whose type matches
     * one or more of the bits in typeBits.
     */
    readonly gatherEntries: (typeBits: number) => IDLACString[];

    /**
     * Add a set of namespace entries to the application cache.
     * @param namespaces
     *        An nsIArray of nsIApplicationCacheNamespace entries.
     */
    readonly addNamespaces: (namespaces: (nsIArray | null)) => void;

    /**
     * Get the most specific namespace matching a given key.
     */
    readonly getMatchingNamespace: (key: IDLACString) => (nsIApplicationCacheNamespace | null);

    /**
     * If set, this offline cache is placed in a different directory
     * than the current application profile.
     */
    readonly profileDirectory: (nsIFile | null);
  }

  export interface nsIApplicationReputationQueryRef {
    readonly name: "nsIApplicationReputationQuery";
    readonly number: "{812d7509-a9a3-446e-a66f-3ed8cc91ebd0}";
  }

  export interface nsIApplicationReputationQuery extends nsISupports {

    /**
     * A single-use, write-once interface for recording the metadata of the
     * downloaded file. nsIApplicationReputationService.Start() may only be called
     * once with a single query.
     */
    readonly sourceURI: (nsIURI | null);

    readonly referrerInfo: (nsIReferrerInfo | null);

    readonly suggestedFileName: IDLAUTF8String;

    readonly fileSize: number;

    readonly sha256Hash: IDLACString;

    readonly signatureInfo: number[][][];

    readonly redirects: (nsIArray | null);
  }

  export interface nsIDOMStorageManagerRef {
    readonly name: "nsIDOMStorageManager";
    readonly number: "{a20c742e-3ed1-44fb-b897-4080a75b1662}";
  }

  /**
   * General purpose interface that has two implementations, for localStorage
   * with "@mozilla.org/dom/localStorage-manager;1".
   */
  export interface nsIDOMStorageManager extends nsISupports {

    /**
     * This starts async preloading of a storage cache for scope
     * defined by the principal and storage principal.
     *
     * Because of how multi-e10s support was implemented in bug 1285898, the
     * StorageCache instance can no longer use a timer to keep itself alive.  So a
     * Storage instance is returned if precaching believes the storage principal may
     * have localStorage data.  (Previously the StorageCache would be brought into
     * existence and kept alive by the timer so that it could be returned if a
     * call to createStorage was made due to a request by the page.)
     */
    readonly precacheStorage: (aPrincipal: (nsIPrincipal | null), aStoragePrincipal: (nsIPrincipal | null)) => WebIDL.Storage;

    /**
     * Returns instance of DOM storage object for given principal.
     * A new object is always returned and it is ensured there is
     * a storage for the scope created.
     *
     * @param aWindow
     *    The parent window.
     * @param aPrincipal
     *    Principal to bound storage to.
     * @param aStoragePrincipal
     *    StoragePrincipal to bound storage to.
     * @param aDocumentURI
     *    URL of the demanding document, used for DOM storage event only.
     * @param aPrivate
     *    Whether the demanding document is running in Private Browsing mode or not.
     */
    readonly createStorage: (aWindow: (mozIDOMWindow | null), aPrincipal: (nsIPrincipal | null), aStoragePrincipal: (nsIPrincipal | null), aDocumentURI: IDLAString, aPrivate?: boolean) => WebIDL.Storage;

    /**
     * DEPRECATED.  The only good reason to use this was if you were writing a
     * test and wanted to hackily determine if a preload happened.  That's now
     * covered by `nsILocalStorageManager.isPreloaded` and you should use that if
     * that's what you want.  If LSNG is in use, this will throw.
     *
     * Returns instance of DOM storage object for given principal.
     * If there is no storage managed for the scope, then null is returned and
     * no object is created.  Otherwise, an object (new) for the existing storage
     * scope is returned.
     *
     * @param aWindow
     *    The parent window.
     * @param aPrincipal
     *    Principal to bound storage to.
     * @param aStoragePrincipal
     *    StoragePrincipal to bound storage to.
     * @param aPrivate
     *    Whether the demanding document is running in Private Browsing mode or not.
     */
    readonly getStorage: (aWindow: (mozIDOMWindow | null), aPrincipal: (nsIPrincipal | null), aStoragePrincipal: (nsIPrincipal | null), aPrivate?: boolean) => WebIDL.Storage;

    /**
     * Clones given storage into this storage manager.
     *
     * @param aStorageToCloneFrom
     *    The storage to copy all items from into this manager.  Manager will then
     *    return a new and independent object that contains snapshot of data from
     *    the moment this method was called.  Modification to this new object will
     *    not affect the original storage content we cloned from and vice versa.
     */
    readonly cloneStorage: (aStorageToCloneFrom: WebIDL.Storage) => void;

    /**
     * Returns true if the storage belongs to the given principal and is managed
     * (i.e. has been created and is cached) by this storage manager.
     *
     * @param aPrincipal
     *    Principal to check the storage against.
     * @param aStorage
     *    The storage object to examine.
     *
     * @result
     *    true when the storage object is bound with the principal and is managed
     *         by this storage manager.
     *    false otherwise
     */
    readonly checkStorage: (aPrincipal: (nsIPrincipal | null), aStorage: WebIDL.Storage) => boolean;
  }

  export interface nsITransportEventSinkRef {
    readonly name: "nsITransportEventSink";
    readonly number: "{eda4f520-67f7-484b-a691-8c3226a5b0a6}";
  }

  export interface nsITransportEventSink extends nsISupports {

    /**
     * Transport status notification.
     *
     * @param aTransport
     *        the transport sending this status notification.
     * @param aStatus
     *        the transport status (resolvable to a string using
     *        nsIErrorService). See nsISocketTransport for socket specific
     *        status codes and more comments.
     * @param aProgress
     *        the amount of data either read or written depending on the value
     *        of the status code.  this value is relative to aProgressMax.
     * @param aProgressMax
     *        the maximum amount of data that will be read or written.  if
     *        unknown, -1 will be passed.
     */
    readonly onTransportStatus: (aTransport: (nsITransport | null), aStatus: number, aProgress: number, aProgressMax: number) => void;
  }

  export interface nsITranslationNodeListRef {
    readonly name: "nsITranslationNodeList";
    readonly number: "{c694e359-7227-4392-a138-33c0cc1f15a6}";
  }

  export interface nsITranslationNodeList extends nsISupports {

    readonly length: number;

    readonly item: (index: number) => WebIDL.Node;

    readonly isTranslationRootAtIndex: (index: number) => boolean;
  }

  export interface nsITextInputProcessorNotificationRef {
    readonly name: "nsITextInputProcessorNotification";
    readonly number: "{c0ce1add-82bb-45ab-b99a-42cfba7fd5d7}";
  }

  /**
   * nsITextInputProcessorNotification stores the type of notification to IME and
   * its detail.  See each explanation of attribute for the detail.
   */
  export interface nsITextInputProcessorNotification extends nsISupports {

    /**
     * type attribute represents what's notified or requested.  Value must be
     * one of following values:
     *
     * "request-to-commit"  (required to be handled)
     *   This is requested when Gecko believes that active composition should be
     *   committed.  nsITextInputProcessorCallback::onNotify() has to handle this
     *   notification.
     *
     * "request-to-cancel" (required to be handled)
     *   This is requested when Gecko believes that active composition should be
     *   canceled.  I.e., composition should be committed with empty string.
     *   nsITextInputProcessorCallback::onNotify() has to handle this
     *   notification.
     *
     * "notify-end-input-transaction" (optional)
     *   This is notified when the callback is detached from
     *   nsITextInputProcessor.  I.e., the TextInputProcessor lost the rights
     *   to input text and needs to call .beginInputTransaction() before next
     *   input.
     *
     * "notify-focus" (optional)
     *   This is notified when an editable editor gets focus and Gecko starts
     *   to observe changes in the content. E.g., selection changes.
     *   IME shouldn't change DOM tree, focus nor something when this is notified.
     *
     * "notify-blur" (optional)
     *   This is notified when an editable editor loses focus and Gecko stops
     *   observing the changes in the content.
     *
     * "notify-text-change" (optional)
     *   This is notified when text in the focused editor is modified.
     *   Some attributes below are available to retrieve the detail.
     *   IME shouldn't change DOM tree, focus nor something when this is notified.
     *   Note that when there is no chance to notify you of some text changes
     *   safely, this represents all changes as a change.
     *
     * "notify-selection-change" (optional)
     *   This is notified when selection in the focused editor is changed.
     *   Some attributes below are available to retrieve the detail.
     *   IME shouldn't change DOM tree, focus nor something when this is notified.
     *   Note that when there was no chance to notify you of this safely, this
     *   represents the latest selection change.
     *
     * "notify-position-change" (optional)
     *   This is notified when layout is changed in the editor or the window
     *   is moved.
     *   IME shouldn't change DOM tree, focus nor something when this is notified.
     *   Note that when there was no chance to notify you of this safely, this
     *   represents the latest layout change.
     */
    readonly type: IDLACString;

    /**
     * Be careful, line breakers in the editor are treated as native line
     * breakers.  I.e., on Windows, a line breaker is "\r\n" (CRLF).  On the
     * others, it is "\n" (LF).  If you want TextInputProcessor to treat line
     * breakers on Windows as XP line breakers (LF), please file a bug with
     * the reason why you need the behavior.
     */
    /**
     * This attribute has a valid value when type is "notify-text-change" or
     * "notify-selection-change".
     * This is offset of the start of modified text range if type is
     * "notify-text-change".  Or offset of start of selection if type is
     * "notify-selection-change".
     */
    readonly offset: number;

    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * This is selected text.  I.e., the length is selected length and
     * it's empty if the selection is collapsed.
     */
    readonly text: IDLAString;

    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * This is set to true when the selection is collapsed.  Otherwise, false.
     */
    readonly collapsed: boolean;

    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * This is selected length.  I.e., if this is 0, collapsed is set to true.
     */
    readonly length: number;

    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * When selection is created from latter point to former point, this is
     * set to true.  Otherwise, false.
     * I.e., if this is true, offset + length is the anchor of selection.
     */
    readonly reversed: boolean;

    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * This indicates the start of the selection's writing mode.
     * The value can be "horizontal-tb", "vertical-rl" or "vertical-lr".
     */
    readonly writingMode: IDLACString;

    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * If the selection change was caused by composition, this is set to true.
     * Otherwise, false.
     */
    readonly causedByComposition: boolean;

    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * If the selection change was caused by selection event, this is set to true.
     * Otherwise, false.
     */
    readonly causedBySelectionEvent: boolean;

    /**
     * This attribute has a valid value when type is "notify-selection-change".
     * If the selection change occurred during composition, this is set to true.
     * Otherwise, false.
     */
    readonly occurredDuringComposition: boolean;

    /**
     * This attribute has a valid value when type is "notify-text-change".
     * This is removed text length by the change(s).  If this is empty, new text
     * was just inserted.  Otherwise, the text is replaced with new text.
     */
    readonly removedLength: number;

    /**
     * This attribute has a valid value when type is "notify-text-change".
     * This is added text length by the change(s).  If this is empty, old text
     * was just deleted.  Otherwise, the text replaces the old text.
     */
    readonly addedLength: number;

    /**
     * This attribute has a valid value when type is "notify-text-change".
     * If the text change(s) was caused only by composition, this is set to true.
     * Otherwise, false.  I.e., if one of text changes are caused by JS or
     * modifying without composition, this is set to false.
     */
    readonly causedOnlyByComposition: boolean;

    /**
     * This attribute has a valid value when type is "notify-text-change".
     * If at least one text change not caused by composition occurred during
     * composition, this is set to true.  Otherwise, false.
     * Note that this is set to false when new change is caused by neither
     * composition nor occurred during composition because it's outdated for
     * new composition.
     * In other words, when text changes not caused by composition occurred
     * during composition and it may cause committing composition, this is
     * set to true.
     */
    readonly includingChangesDuringComposition: boolean;

    /**
     * This attribute has a valid value when type is "notify-text-change".
     * If at least one text change occurred when there was no composition, this
     * is set to true.  Otherwise, false.
     */
    readonly includingChangesWithoutComposition: boolean;
  }

  export interface nsICollationFactoryRef {
    readonly name: "nsICollationFactory";
    readonly number: "{04971e14-d6b3-4ada-8cbb-c3a13842b349}";
  }

  export interface nsICollationFactory extends nsISupports {

    /**
     * Create a new collation for the current application locale.
     *
     * @return A new collation.
     */
    readonly CreateCollation: () => (nsICollation | null);

    /**
     * Create a new collation for a given locale.
     *
     * @return A new collation.
     */
    readonly CreateCollationForLocale: (locale: IDLACString) => (nsICollation | null);
  }

  export interface nsIContentHandlerRef {
    readonly name: "nsIContentHandler";
    readonly number: "{49439df2-b3d2-441c-bf62-866bdaf56fd2}";
  }

  export interface nsIContentHandler extends nsISupports {

    /**
     * Tells the content handler to take over handling the content. If this
     * function succeeds, the URI Loader will leave this request alone, ignoring
     * progress notifications. Failure of this method will cause the request to be
     * cancelled, unless the error code is NS_ERROR_WONT_HANDLE_CONTENT (see
     * below).
     *
     * @param aWindowContext
     *        Window context, used to get things like the current nsIDOMWindow
     *        for this request. May be null.
     * @param aContentType
     *        The content type of aRequest
     * @param aRequest
     *        A request whose content type is already known.
     *
     * @throw NS_ERROR_WONT_HANDLE_CONTENT Indicates that this handler does not
     *        want to handle this content. A different way for handling this
     *        content should be tried.
     */
    readonly handleContent: (aContentType: string, aWindowContext: (nsIInterfaceRequestor | null), aRequest: (nsIRequest | null)) => void;
  }

  export interface nsIEditingSessionRef {
    readonly name: "nsIEditingSession";
    readonly number: "{24f963d1-e6fc-43ea-a206-99ac5fcc5265}";

    /**
     *  Error codes when we fail to create an editor
     *  is placed in attribute editorStatus
     */
    eEditorOK: 0;

    eEditorCreationInProgress: 1;

    eEditorErrorCantEditMimeType: 2;

    eEditorErrorFileNotFound: 3;

    eEditorErrorCantEditFramesets: 8;

    eEditorErrorUnknown: 9;
  }

  export interface nsIEditingSession extends nsISupports {

    /**
     *  Status after editor creation and document loading
     *  Value is one of the above error codes
     */
    readonly editorStatus: number;

    /**
     *  Make this window editable
     *  @param aWindow nsIDOMWindow, the window the embedder needs to make editable
     *  @param aEditorType string, "html" "htmlsimple" "text" "textsimple"
     *  @param aMakeWholeDocumentEditable if PR_TRUE make the whole document in
     *                                    aWindow editable, otherwise it's the
     *                                    embedder who should make the document
     *                                    (or part of it) editable.
     *  @param aInteractive if PR_FALSE turn off scripting and plugins
     */
    readonly makeWindowEditable: (window: (mozIDOMWindowProxy | null), aEditorType: string, doAfterUriLoad: boolean, aMakeWholeDocumentEditable: boolean, aInteractive: boolean) => void;

    /**
     *  Test whether a specific window has had its editable flag set; it may have an editor
     *  now, or will get one after the uri load.
     *
     *  Use this, passing the content root window, to test if we've set up editing
     *  for this content.
     */
    readonly windowIsEditable: (window: (mozIDOMWindowProxy | null)) => boolean;

    /**
     *  Get the editor for this window. May return null
     */
    readonly getEditorForWindow: (window: (mozIDOMWindowProxy | null)) => (nsIEditor | null);
  }

  export interface nsIAuthPromptAdapterFactoryRef {
    readonly name: "nsIAuthPromptAdapterFactory";
    readonly number: "{60e46383-bb9a-4860-8962-80d9c5c05ddc}";
  }

  /**
   * An interface for wrapping nsIAuthPrompt interfaces to make
   * them usable via an nsIAuthPrompt2 interface.
   */
  export interface nsIAuthPromptAdapterFactory extends nsISupports {

    /**
     * Wrap an object implementing nsIAuthPrompt so that it's usable via
     * nsIAuthPrompt2.
     */
    readonly createAdapter: (aPrompt: (nsIAuthPrompt | null)) => (nsIAuthPrompt2 | null);
  }

  export interface nsIHeapAllocatedCallbackRef {
    readonly name: "nsIHeapAllocatedCallback";
    readonly number: "{1a80cd0f-0d9e-4397-be69-68ad28fe5175}";
  }

  type nsIHeapAllocatedCallbackFunction = (bytesAllocated: number) => void;

  export interface nsIHeapAllocatedCallback extends nsISupports {

    readonly callback: (bytesAllocated: number) => void;
  }

  export interface nsINavHistoryResultNodeRef {
    readonly name: "nsINavHistoryResultNode";
    readonly number: "{91d104bb-17ef-404b-9f9a-d9ed8de6824c}";

    /**
     * Identifies the type of this node. This node can then be QI-ed to the
     * corresponding specialized result node interface.
     */
    RESULT_TYPE_URI: 0;

    RESULT_TYPE_QUERY: 5;

    RESULT_TYPE_FOLDER: 6;

    RESULT_TYPE_SEPARATOR: 7;

    RESULT_TYPE_FOLDER_SHORTCUT: 9;
  }

  export interface nsINavHistoryResultNode extends nsISupports {

    /**
     * Indentifies the parent result node in the result set. This is null for
     * top level nodes.
     */
    readonly parent: (nsINavHistoryContainerResultNode | null);

    /**
     * The history-result to which this node belongs.
     */
    readonly parentResult: (nsINavHistoryResult | null);

    /**
     * URI of the resource in question. For visits and URLs, this is the URL of
     * the page. For folders and queries, this is the place: URI of the
     * corresponding folder or query. This may be empty for other types of
     * objects like host containers.
     */
    readonly uri: IDLAUTF8String;

    readonly type: number;

    /**
     * Title of the web page, or of the node's query (day, host, folder, etc)
     */
    readonly title: IDLAUTF8String;

    /**
     * Total number of times the URI has ever been accessed. For hosts, this
     * is the total of the children under it, NOT the total times the host has
     * been accessed (this would require an additional query, so is not given
     * by default when most of the time it is never needed).
     */
    readonly accessCount: number;

    /**
     * This is the time the user accessed the page.
     *
     * If this is a visit, it is the exact time that the page visit occurred.
     *
     * If this is a URI, it is the most recent time that the URI was visited.
     * Even if you ask for all URIs for a given date range long ago, this might
     * contain today's date if the URI was visited today.
     *
     * For hosts, or other node types with children, this is the most recent
     * access time for any of the children.
     *
     * For days queries this is the respective endTime - a maximum possible
     * visit time to fit in the day range.
     */
    readonly time: number;

    /**
     * This URI can be used as an image source URI and will give you the favicon
     * for the page. It is *not* the URI of the favicon, but rather something
     * that will resolve to the actual image.
     *
     * In most cases, this is an annotation URI that will query the favicon
     * service. If the entry has no favicon, this is the chrome URI of the
     * default favicon. If the favicon originally lived in chrome, this will
     * be the original chrome URI of the icon.
     */
    readonly icon: IDLAUTF8String;

    /**
     * This is the number of levels between this node and the top of the
     * hierarchy. The members of result.children have indentLevel = 0, their
     * children have indentLevel = 1, etc. The indent level of the root node is
     * set to -1.
     */
    readonly indentLevel: number;

    /**
     * When this item is in a bookmark folder (parent is of type folder), this is
     * the index into that folder of this node. These indices start at 0 and
     * increase in the order that they appear in the bookmark folder. For items
     * that are not in a bookmark folder, this value is -1.
     */
    readonly bookmarkIndex: number;

    /**
     * If the node is an item (bookmark, folder or a separator) this value is the
     * row ID of that bookmark in the database. For other nodes, this value is
     * set to -1.
     */
    readonly itemId: number;

    /**
     * If the node is an item (bookmark, folder or a separator) this value is the
     * time that the item was created. For other nodes, this value is 0.
     */
    readonly dateAdded: number;

    /**
     * If the node is an item (bookmark, folder or a separator) this value is the
     * time that the item was last modified. For other nodes, this value is 0.
     *
     *  @note When an item is added lastModified is set to the same value as
     *        dateAdded.
     */
    readonly lastModified: number;

    /**
     * For uri nodes, this is a sorted list of the tags, delimited with commans,
     * for the uri represented by this node. Otherwise this is an empty string.
     */
    readonly tags: IDLAString;

    /**
     * The unique ID associated with the page. It my return an empty string
     * if the result node is a non-URI node.
     */
    readonly pageGuid: IDLACString;

    /**
     * The unique ID associated with the bookmark. It returns an empty string
     * if the result node is not associated with a bookmark, a folder or a
     * separator.
     */
    readonly bookmarkGuid: IDLACString;

    /**
     * The unique ID associated with the history visit. For node types other than
     * history visit nodes, this value is -1.
     */
    readonly visitId: number;

    /**
     * The unique ID associated with visit node which was the referrer of this
     * history visit. For node types other than history visit nodes, or visits
     * without any known referrer, this value is -1.
     */
    readonly fromVisitId: number;

    /**
     * The transition type associated with this visit. For node types other than
     * history visit nodes, this value is 0.
     */
    readonly visitType: number;
  }

  export interface nsIPromptServiceRef {
    readonly name: "nsIPromptService";
    readonly number: "{404ebfa2-d8f4-4c94-8416-e65a55f9df5a}";

    /**
     * Button Flags
     *
     * The following flags are combined to form the aButtonFlags parameter passed
     * to confirmEx.  See confirmEx for more information on how the flags may be
     * combined.
     */
    /**
     * Button Position Flags
     */
    BUTTON_POS_0: 1;

    BUTTON_POS_1: 256;

    BUTTON_POS_2: 65536;

    /**
     * Button Title Flags (used to set the labels of buttons in the prompt)
     */
    BUTTON_TITLE_OK: 1;

    BUTTON_TITLE_CANCEL: 2;

    BUTTON_TITLE_YES: 3;

    BUTTON_TITLE_NO: 4;

    BUTTON_TITLE_SAVE: 5;

    BUTTON_TITLE_DONT_SAVE: 6;

    BUTTON_TITLE_REVERT: 7;

    BUTTON_TITLE_IS_STRING: 127;

    /**
     * Button Default Flags (used to select which button is the default one)
     */
    BUTTON_POS_0_DEFAULT: 0;

    BUTTON_POS_1_DEFAULT: 16777216;

    BUTTON_POS_2_DEFAULT: 33554432;

    /**
     * Causes the buttons to be initially disabled.  They are enabled after a
     * timeout expires.  The implementation may interpret this loosely as the
     * intent is to ensure that the user does not click through a security dialog
     * too quickly.  Strictly speaking, the implementation could choose to ignore
     * this flag.
     */
    BUTTON_DELAY_ENABLE: 67108864;

    /**
     * Selects the standard set of OK/Cancel buttons.
     */
    STD_OK_CANCEL_BUTTONS: 513;

    /**
     * Selects the standard set of Yes/No buttons.
     */
    STD_YES_NO_BUTTONS: 1027;
  }

  /**
   * This is the interface to the embeddable prompt service; the service that
   * implements nsIPrompt.  Its interface is designed to be just nsIPrompt, each
   * method modified to take a parent window parameter.
   *
   * Accesskeys can be attached to buttons and checkboxes by inserting an &
   * before the accesskey character in the checkbox message or button title.  For
   * a real &, use && instead.  (A "button title" generally refers to the text
   * label of a button.)
   *
   * One note: in all cases, the parent window parameter can be null.  However,
   * these windows are all intended to have parents.  So when no parent is
   * specified, the implementation should try hard to find a suitable foster
   * parent.
   *
   * Implementations are free to choose how they present the various button
   * types.  For example, while prompts that give the user a choice between OK
   * and Cancel are required to return a boolean value indicating whether or not
   * the user accepted the prompt (pressed OK) or rejected the prompt (pressed
   * Cancel), the implementation of this interface could very well speak the
   * prompt to the user instead of rendering any visual user-interface.  The
   * standard button types are merely idioms used to convey the nature of the
   * choice the user is to make.
   *
   * Because implementations of this interface may loosely interpret the various
   * button types, it is advised that text messages passed to these prompts do
   * not refer to the button types by name.  For example, it is inadvisable to
   * tell the user to "Press OK to proceed."  Instead, such a prompt might be
   * rewritten to ask the user: "Would you like to proceed?"
   */
  export interface nsIPromptService extends nsISupports {

    /**
     * Puts up an alert dialog with an OK button.
     *
     * @param aParent
     *        The parent window or null.
     * @param aDialogTitle
     *        Text to appear in the title of the dialog.
     * @param aText
     *        Text to appear in the body of the dialog.
     */
    readonly alert: (aParent: (mozIDOMWindowProxy | null), aDialogTitle: string, aText: string) => void;

    /**
     * Puts up an alert dialog with an OK button and a labeled checkbox.
     *
     * @param aParent
     *        The parent window or null.
     * @param aDialogTitle
     *        Text to appear in the title of the dialog.
     * @param aText
     *        Text to appear in the body of the dialog.
     * @param aCheckMsg
     *        Text to appear with the checkbox.
     * @param aCheckState
     *        Contains the initial checked state of the checkbox when this method
     *        is called and the final checked state after this method returns.
     */
    readonly alertCheck: (aParent: (mozIDOMWindowProxy | null), aDialogTitle: string, aText: string, aCheckMsg: string, aCheckState: InOut<boolean>) => void;

    /**
     * Puts up a dialog with OK and Cancel buttons.
     *
     * @param aParent
     *        The parent window or null.
     * @param aDialogTitle
     *        Text to appear in the title of the dialog.
     * @param aText
     *        Text to appear in the body of the dialog.
     *
     * @return true for OK, false for Cancel
     */
    readonly confirm: (aParent: (mozIDOMWindowProxy | null), aDialogTitle: string, aText: string) => boolean;

    /**
     * Puts up a dialog with OK and Cancel buttons and a labeled checkbox.
     *
     * @param aParent
     *        The parent window or null.
     * @param aDialogTitle
     *        Text to appear in the title of the dialog.
     * @param aText
     *        Text to appear in the body of the dialog.
     * @param aCheckMsg
     *        Text to appear with the checkbox.
     * @param aCheckState
     *        Contains the initial checked state of the checkbox when this method
     *        is called and the final checked state after this method returns.
     *
     * @return true for OK, false for Cancel
     */
    readonly confirmCheck: (aParent: (mozIDOMWindowProxy | null), aDialogTitle: string, aText: string, aCheckMsg: string, aCheckState: InOut<boolean>) => boolean;

    /**
     * Puts up a dialog with up to 3 buttons and an optional, labeled checkbox.
     *
     * @param aParent
     *        The parent window or null.
     * @param aDialogTitle
     *        Text to appear in the title of the dialog.
     * @param aText
     *        Text to appear in the body of the dialog.
     * @param aButtonFlags
     *        A combination of Button Flags.
     * @param aButton0Title
     *        Used when button 0 uses TITLE_IS_STRING
     * @param aButton1Title
     *        Used when button 1 uses TITLE_IS_STRING
     * @param aButton2Title
     *        Used when button 2 uses TITLE_IS_STRING
     * @param aCheckMsg
     *        Text to appear with the checkbox.  Null if no checkbox.
     * @param aCheckState
     *        Contains the initial checked state of the checkbox when this method
     *        is called and the final checked state after this method returns.
     *
     * @return index of the button pressed.
     *
     * Buttons are numbered 0 - 2. The implementation can decide whether the
     * sequence goes from right to left or left to right.  Button 0 is the
     * default button unless one of the Button Default Flags is specified.
     *
     * A button may use a predefined title, specified by one of the Button Title
     * Flags values.  Each title value can be multiplied by a position value to
     * assign the title to a particular button.  If BUTTON_TITLE_IS_STRING is
     * used for a button, the string parameter for that button will be used.  If
     * the value for a button position is zero, the button will not be shown.
     *
     * In general, aButtonFlags is constructed per the following example:
     *
     *   aButtonFlags = (BUTTON_POS_0) * (BUTTON_TITLE_AAA) +
     *                  (BUTTON_POS_1) * (BUTTON_TITLE_BBB) +
     *                   BUTTON_POS_1_DEFAULT;
     *
     * where "AAA" and "BBB" correspond to one of the button titles.
     */
    readonly confirmEx: (aParent: (mozIDOMWindowProxy | null), aDialogTitle: string, aText: string, aButtonFlags: number, aButton0Title: string, aButton1Title: string, aButton2Title: string, aCheckMsg: string, aCheckState: InOut<boolean>) => number;

    /**
     * Puts up a dialog with an edit field and an optional, labeled checkbox.
     *
     * @param aParent
     *        The parent window or null.
     * @param aDialogTitle
     *        Text to appear in the title of the dialog.
     * @param aText
     *        Text to appear in the body of the dialog.
     * @param aValue
     *        Contains the default value for the dialog field when this method
     *        is called (null value is ok).  Upon return, if the user pressed
     *        OK, then this parameter contains a newly allocated string value.
     *        Otherwise, the parameter's value is unmodified.
     * @param aCheckMsg
     *        Text to appear with the checkbox.  If null, check box will not be shown.
     * @param aCheckState
     *        Contains the initial checked state of the checkbox when this method
     *        is called and the final checked state after this method returns.
     *
     * @return true for OK, false for Cancel.
     */
    readonly prompt: (aParent: (mozIDOMWindowProxy | null), aDialogTitle: string, aText: string, aValue: InOut<string>, aCheckMsg: string, aCheckState: InOut<boolean>) => boolean;

    /**
     * Puts up a dialog with an edit field, a password field, and an optional,
     * labeled checkbox.
     *
     * @param aParent
     *        The parent window or null.
     * @param aDialogTitle
     *        Text to appear in the title of the dialog.
     * @param aText
     *        Text to appear in the body of the dialog.
     * @param aUsername
     *        Contains the default value for the username field when this method
     *        is called (null value is ok).  Upon return, if the user pressed OK,
     *        then this parameter contains a newly allocated string value.
     *        Otherwise, the parameter's value is unmodified.
     * @param aPassword
     *        Contains the default value for the password field when this method
     *        is called (null value is ok).  Upon return, if the user pressed OK,
     *        then this parameter contains a newly allocated string value.
     *        Otherwise, the parameter's value is unmodified.
     * @param aCheckMsg
     *        Text to appear with the checkbox.  If null, check box will not be shown.
     * @param aCheckState
     *        Contains the initial checked state of the checkbox when this method
     *        is called and the final checked state after this method returns.
     *
     * @return true for OK, false for Cancel.
     */
    readonly promptUsernameAndPassword: (aParent: (mozIDOMWindowProxy | null), aDialogTitle: string, aText: string, aUsername: InOut<string>, aPassword: InOut<string>, aCheckMsg: string, aCheckState: InOut<boolean>) => boolean;

    /**
     * Puts up a dialog with a password field and an optional, labeled checkbox.
     *
     * @param aParent
     *        The parent window or null.
     * @param aDialogTitle
     *        Text to appear in the title of the dialog.
     * @param aText
     *        Text to appear in the body of the dialog.
     * @param aPassword
     *        Contains the default value for the password field when this method
     *        is called (null value is ok).  Upon return, if the user pressed OK,
     *        then this parameter contains a newly allocated string value.
     *        Otherwise, the parameter's value is unmodified.
     * @param aCheckMsg
     *        Text to appear with the checkbox.  If null, check box will not be shown.
     * @param aCheckState
     *        Contains the initial checked state of the checkbox when this method
     *        is called and the final checked state after this method returns.
     *
     * @return true for OK, false for Cancel.
     */
    readonly promptPassword: (aParent: (mozIDOMWindowProxy | null), aDialogTitle: string, aText: string, aPassword: InOut<string>, aCheckMsg: string, aCheckState: InOut<boolean>) => boolean;

    /**
     * Puts up a dialog box which has a list box of strings from which the user
     * may make a single selection.
     *
     * @param aParent
     *        The parent window or null.
     * @param aDialogTitle
     *        Text to appear in the title of the dialog.
     * @param aText
     *        Text to appear in the body of the dialog.
     * @param aSelectList
     *        The list of strings to display.
     * @param aOutSelection
     *        Contains the index of the selected item in the list when this
     *        method returns true.
     *
     * @return true for OK, false for Cancel.
     */
    readonly select: (aParent: (mozIDOMWindowProxy | null), aDialogTitle: string, aText: string, aSelectList: IDLAString[], aOutSelection: Out<number>) => boolean;

    readonly promptAuth: (aParent: (mozIDOMWindowProxy | null), aChannel: (nsIChannel | null), level: number, authInfo: (nsIAuthInformation | null), checkboxLabel: string, checkValue: InOut<boolean>) => boolean;

    readonly asyncPromptAuth: (aParent: (mozIDOMWindowProxy | null), aChannel: (nsIChannel | null), aCallback: (nsIAuthPromptCallback | null), aContext: (nsISupports | null), level: number, authInfo: (nsIAuthInformation | null), checkboxLabel: string, checkValue: InOut<boolean>) => (nsICancelable | null);
  }

  export interface nsIAuthPromptProviderRef {
    readonly name: "nsIAuthPromptProvider";
    readonly number: "{bd9dc0fa-68ce-47d0-8859-6418c2ae8576}";

    /**
     * Normal (non-proxy) prompt request.
     */
    PROMPT_NORMAL: 0;

    /**
     * Proxy auth request.
     */
    PROMPT_PROXY: 1;
  }

  export interface nsIAuthPromptProvider extends nsISupports {
  }

  export interface nsIAsyncVerifyRedirectCallbackRef {
    readonly name: "nsIAsyncVerifyRedirectCallback";
    readonly number: "{8d171460-a716-41f1-92be-8c659db39b45}";
  }

  export interface nsIAsyncVerifyRedirectCallback extends nsISupports {

    /**
     * Complement to nsIChannelEventSink asynchronous callback. The result of
     * the redirect decision is passed through this callback.
     *
     * @param result
     *    Result of the redirect veto decision. If FAILED the redirect has been
     *    vetoed. If SUCCEEDED the redirect has been allowed by all consumers.
     */
    readonly onRedirectVerifyCallback: (result: number) => void;
  }

  export interface nsIOfflineCacheUpdateRef {
    readonly name: "nsIOfflineCacheUpdate";
    readonly number: "{6e3e26ea-45b2-4db7-9e4a-93b965679298}";
  }

  export interface nsIOfflineCacheUpdate extends nsISupports {

    /**
     * An nsIOfflineCacheUpdate is used to update an application's offline
     * resources.
     *
     * It can be used to perform partial or complete updates.
     *
     * One update object will be updating at a time.  The active object will
     * load its items one by one, sending itemCompleted() to any registered
     * observers.
     */
    /**
     * Fetch the status of the running update.  This will return a value
     * defined in OfflineResourceList.webidl.
     */
    readonly status: number;

    /**
     * TRUE if the update is being used to add specific resources.
     * FALSE if the complete cache update process is happening.
     */
    readonly partial: boolean;

    /**
     * TRUE if this is an upgrade attempt, FALSE if it is a new cache
     * attempt.
     */
    readonly isUpgrade: boolean;

    /**
     * The domain being updated, and the domain that will own any URIs added
     * with this update.
     */
    readonly updateDomain: IDLACString;

    /**
     * The manifest for the offline application being updated.
     */
    readonly manifestURI: (nsIURI | null);

    /**
     * The principal of the page that is requesting the update.
     */
    readonly loadingPrincipal: (nsIPrincipal | null);

    /**
     * TRUE if the cache update completed successfully.
     */
    readonly succeeded: boolean;

    /**
     * Initialize the update.
     *
     * @param aManifestURI
     *        The manifest URI to be checked.
     * @param aDocumentURI
     *        The page that is requesting the update.
     * @param aLoadingPrincipal
     *        The principal of the page that is requesting the update.
     */
    readonly init: (aManifestURI: (nsIURI | null), aDocumentURI: (nsIURI | null), aLoadingPrincipal: (nsIPrincipal | null), aDocument: WebIDL.Document, aCustomProfileDir?: (nsIFile | null)) => void;

    /**
     * Initialize the update to only check whether there is an update
     * to the manifest available (if it has actually changed on the server).
     *
     * @param aManifestURI
     *        The manifest URI of the related cache.
     * @param aObserver
     *        nsIObserver implementation that receives the result.
     *        When aTopic == "offline-cache-update-available" there is an update to
     *        to download. Update of the app cache will lead to a new version
     *        download.
     *        When aTopic == "offline-cache-update-unavailable" then there is no
     *        update available (the manifest has not changed on the server).
     */
    readonly initForUpdateCheck: (aManifestURI: (nsIURI | null), aLoadingPrincipal: (nsIPrincipal | null), aObserver: (nsIObserver | nsIObserverFunction | null)) => void;

    /**
     * Add a dynamic URI to the offline cache as part of the update.
     *
     * @param aURI
     *        The URI to add.
     */
    readonly addDynamicURI: (aURI: (nsIURI | null)) => void;

    /**
     * Add the update to the offline update queue.  An offline-cache-update-added
     * event will be sent to the observer service.
     */
    readonly schedule: () => void;

    /**
     * Observe loads that are added to the update.
     *
     * @param aObserver
     *        object that notifications will be sent to.
     * @param aHoldWeak
     *        TRUE if you want the update to hold a weak reference to the
     *        observer, FALSE for a strong reference.
     */
    readonly addObserver: (aObserver: (nsIOfflineCacheUpdateObserver | null), aHoldWeak?: boolean) => void;

    /**
     * Remove an observer from the update.
     *
     * @param aObserver
     *        the observer to remove.
     */
    readonly removeObserver: (aObserver: (nsIOfflineCacheUpdateObserver | null)) => void;

    /**
     * Cancel the update when still in progress. This stops all running resource
     * downloads and discards the downloaded cache version. Throws when update
     * has already finished and made the new cache version active.
     */
    readonly cancel: () => void;

    /**
     * Return the number of bytes downloaded so far
     */
    readonly byteProgress: number;
  }

  export interface nsIPaymentOptionsRef {
    readonly name: "nsIPaymentOptions";
    readonly number: "{d53f9f20-138e-47cc-9fd5-db16a3f6d301}";
  }

  export interface nsIPaymentOptions extends nsISupports {

    readonly requestPayerName: boolean;

    readonly requestPayerEmail: boolean;

    readonly requestPayerPhone: boolean;

    readonly requestShipping: boolean;

    readonly requestBillingAddress: boolean;

    readonly shippingType: IDLAString;
  }

  export interface nsIMutableArrayRef {
    readonly name: "nsIMutableArray";
    readonly number: "{af059da0-c85b-40ec-af07-ae4bfdc192cc}";
  }

  /**
   * nsIMutableArray
   * A separate set of methods that will act on the array. Consumers of
   * nsIArray should not QueryInterface to nsIMutableArray unless they
   * own the array.
   *
   * As above, it is legal to add null elements to the array. Note also
   * that null elements can be created as a side effect of
   * insertElementAt(). Conversely, if insertElementAt() is never used,
   * and null elements are never explicitly added to the array, then it
   * is guaranteed that queryElementAt() will never return a null value.
   *
   * Any of these methods may throw NS_ERROR_OUT_OF_MEMORY when the
   * array must grow to complete the call, but the allocation fails.
   */
  export interface nsIMutableArray extends nsIArrayExtensions {

    /**
     * appendElement()
     *
     * Append an element at the end of the array.
     *
     * @param element The element to append.
     */
    readonly appendElement: (element: (nsISupports | null)) => void;

    /**
     * removeElementAt()
     *
     * Remove an element at a specific position, moving all elements
     * stored at a higher position down one.
     * To remove a specific element, use indexOf() to find the index
     * first, then call removeElementAt().
     *
     * @param index the position of the item
     *
     */
    readonly removeElementAt: (index: number) => void;

    /**
     * insertElementAt()
     *
     * Insert an element at the given position, moving the element
     * currently located in that position, and all elements in higher
     * position, up by one.
     *
     * @param element The element to insert
     * @param index   The position in the array:
     *                If the position is lower than the current length
     *                of the array, the elements at that position and
     *                onwards are bumped one position up.
     *                If the position is equal to the current length
     *                of the array, the new element is appended.
     *                An index lower than 0 or higher than the current
     *                length of the array is invalid and will be ignored.
     */
    readonly insertElementAt: (element: (nsISupports | null), index: number) => void;

    /**
     * replaceElementAt()
     *
     * Replace the element at the given position.
     *
     * @param element The new element to insert
     * @param index   The position in the array
     *                If the position is lower than the current length
     *                of the array, an existing element will be replaced.
     *                If the position is equal to the current length
     *                of the array, the new element is appended.
     *                If the position is higher than the current length
     *                of the array, empty elements are appended followed
     *                by the new element at the specified position.
     *                An index lower than 0 is invalid and will be ignored.
     */
    readonly replaceElementAt: (element: (nsISupports | null), index: number) => void;

    /**
     * clear()
     *
     * clear the entire array, releasing all stored objects
     */
    readonly clear: () => void;
  }

  export interface nsIDOMXULSelectControlItemElementRef {
    readonly name: "nsIDOMXULSelectControlItemElement";
    readonly number: "{5c6be58f-17df-4750-88a5-4a59ac28adc9}";
  }

  export interface nsIDOMXULSelectControlItemElement extends nsISupports {

    disabled: boolean;

    crop: IDLAString;

    image: IDLAString;

    label: IDLAString;

    accessKey: IDLAString;

    command: IDLAString;

    value: IDLAString;

    readonly selected: boolean;

    readonly control: WebIDL.Element;
  }

  export interface nsIPresentationSessionTransportBuilderListenerRef {
    readonly name: "nsIPresentationSessionTransportBuilderListener";
    readonly number: "{673f6de1-e253-41b8-9be8-b7ff161fa8dc}";
  }

  export interface nsIPresentationSessionTransportBuilderListener extends nsISupports {

    readonly onSessionTransport: (transport: (nsIPresentationSessionTransport | null)) => void;

    readonly onError: (reason: number) => void;

    readonly sendOffer: (offer: (nsIPresentationChannelDescription | null)) => void;

    readonly sendAnswer: (answer: (nsIPresentationChannelDescription | null)) => void;

    readonly sendIceCandidate: (candidate: IDLAString) => void;

    readonly close: (reason: number) => void;
  }

  export interface nsIContentViewerEditRef {
    readonly name: "nsIContentViewerEdit";
    readonly number: "{35be2d7e-f29b-48ec-bf7e-80a30a724de3}";

    COPY_IMAGE_TEXT: 1;

    COPY_IMAGE_HTML: 2;

    COPY_IMAGE_DATA: 4;

    COPY_IMAGE_ALL: -1;
  }

  export interface nsIContentViewerEdit extends nsISupports {

    readonly clearSelection: () => void;

    readonly selectAll: () => void;

    readonly copySelection: () => void;

    readonly copyable: boolean;

    readonly copyLinkLocation: () => void;

    readonly inLink: boolean;

    readonly copyImage: (aCopyFlags: number) => void;

    readonly inImage: boolean;

    readonly getContents: (aMimeType: string, aSelectionOnly: boolean) => IDLAString;

    readonly canGetContents: boolean;

    readonly setCommandNode: (aNode: WebIDL.Node) => void;
  }

  export interface nsIASN1ObjectRef {
    readonly name: "nsIASN1Object";
    readonly number: "{ba8bf582-1dd1-11b2-898c-f40246bc9a63}";

    /**
     *  Identifiers for the possible types of object.
     */
    ASN1_END_CONTENTS: 0;

    ASN1_BOOLEAN: 1;

    ASN1_INTEGER: 2;

    ASN1_BIT_STRING: 3;

    ASN1_OCTET_STRING: 4;

    ASN1_NULL: 5;

    ASN1_OBJECT_ID: 6;

    ASN1_ENUMERATED: 10;

    ASN1_UTF8_STRING: 12;

    ASN1_SEQUENCE: 16;

    ASN1_SET: 17;

    ASN1_PRINTABLE_STRING: 19;

    ASN1_T61_STRING: 20;

    ASN1_IA5_STRING: 22;

    ASN1_UTC_TIME: 23;

    ASN1_GEN_TIME: 24;

    ASN1_VISIBLE_STRING: 26;

    ASN1_UNIVERSAL_STRING: 28;

    ASN1_BMP_STRING: 30;

    ASN1_HIGH_TAG_NUMBER: 31;

    ASN1_CONTEXT_SPECIFIC: 32;

    ASN1_APPLICATION: 33;

    ASN1_PRIVATE: 34;
  }

  /**
   * This represents an ASN.1 object,
   * where ASN.1 is "Abstract Syntax Notation number One".
   *
   * The additional state information carried in this interface
   * makes it fit for being used as the data structure
   * when working with visual reprenstation of ASN.1 objects
   * in a human user interface, like in a tree widget
   * where open/close state of nodes must be remembered.
   */
  export interface nsIASN1Object extends nsISupports {

    /**
     *  "type" will be equal to one of the defined object identifiers.
     */
    type: number;

    /**
     *  This contains a tag as explained in ASN.1 standards documents.
     */
    tag: number;

    /**
     *  "displayName" contains a human readable explanatory label.
     */
    displayName: IDLAString;

    /**
     *  "displayValue" contains the human readable value.
     */
    displayValue: IDLAString;
  }

  export interface nsIEmbeddingSiteWindowRef {
    readonly name: "nsIEmbeddingSiteWindow";
    readonly number: "{0b976267-4aaa-4f36-a2d4-27b5ca8d73bb}";

    /**
     * Flag indicates that position of the top left corner of the outer area
     * is required/specified.
     *
     * @see setDimensions
     * @see getDimensions
     */
    DIM_FLAGS_POSITION: 1;

    /**
     * Flag indicates that the size of the inner area is required/specified.
     *
     * @note The inner and outer flags are mutually exclusive and it is
     *       invalid to combine them.
     *
     * @see setDimensions
     * @see getDimensions
     * @see DIM_FLAGS_SIZE_OUTER
     */
    DIM_FLAGS_SIZE_INNER: 2;

    /**
     * Flag indicates that the size of the outer area is required/specified.
     *
     * @see setDimensions
     * @see getDimensions
     * @see DIM_FLAGS_SIZE_INNER
     */
    DIM_FLAGS_SIZE_OUTER: 4;

    /**
     * Flag indicates that the x parameter should be ignored.
     *
     * @see setDimensions
     */
    DIM_FLAGS_IGNORE_X: 8;

    /**
     * Flag indicates that the y parameter should be ignored.
     *
     * @see setDimensions
     */
    DIM_FLAGS_IGNORE_Y: 16;

    /**
     * Flag indicates that the cx parameter should be ignored.
     *
     * @see setDimensions
     */
    DIM_FLAGS_IGNORE_CX: 32;

    /**
     * Flag indicates that the cy parameter should be ignored.
     *
     * @see setDimensions
     */
    DIM_FLAGS_IGNORE_CY: 64;
  }

  /**
   * The nsIEmbeddingSiteWindow is implemented by the embedder to provide
   * Gecko with the means to call up to the host to resize the window,
   * hide or show it and set/get its title.
   */
  export interface nsIEmbeddingSiteWindow extends nsISupports {

    /**
     * Sets the dimensions for the window; the position & size. The
     * flags to indicate what the caller wants to set and whether the size
     * refers to the inner or outer area. The inner area refers to just
     * the embedded area, wheras the outer area can also include any
     * surrounding chrome, window frame, title bar, and so on.
     *
     * @param flags  Combination of position, inner and outer size flags.
     *               The ignore flags are telling the parent to use the
     *               current values for those dimensions and ignore the
     *               corresponding parameters the child sends.
     * @param x      Left hand corner of the outer area.
     * @param y      Top corner of the outer area.
     * @param cx     Width of the inner or outer area.
     * @param cy     Height of the inner or outer area.
     *
     * @return <code>NS_OK</code> if operation was performed correctly;
     *         <code>NS_ERROR_UNEXPECTED</code> if window could not be
     *           destroyed;
     *         <code>NS_ERROR_INVALID_ARG</code> for bad flag combination
     *           or illegal dimensions.
     *
     * @see getDimensions
     * @see DIM_FLAGS_POSITION
     * @see DIM_FLAGS_SIZE_OUTER
     * @see DIM_FLAGS_SIZE_INNER
     */
    readonly setDimensions: (flags: number, x: number, y: number, cx: number, cy: number) => void;

    /**
     * Gets the dimensions of the window. The caller may pass
     * <CODE>nullptr</CODE> for any value it is uninterested in receiving.
     *
     * @param flags  Combination of position, inner and outer size flag .
     * @param x      Left hand corner of the outer area; or <CODE>nullptr</CODE>.
     * @param y      Top corner of the outer area; or <CODE>nullptr</CODE>.
     * @param cx     Width of the inner or outer area; or <CODE>nullptr</CODE>.
     * @param cy     Height of the inner or outer area; or <CODE>nullptr</CODE>.
     *
     * @see setDimensions
     * @see DIM_FLAGS_POSITION
     * @see DIM_FLAGS_SIZE_OUTER
     * @see DIM_FLAGS_SIZE_INNER
     */
    readonly getDimensions: (flags: number, x: Out<number>, y: Out<number>, cx: Out<number>, cy: Out<number>) => void;

    /**
     * Give the window focus.
     */
    readonly setFocus: () => void;

    /**
     * Visibility of the window.
     */
    visibility: boolean;

    /**
     * Title of the window.
     */
    title: IDLAString;

    /**
     * Blur the window. This should unfocus the window and send an onblur event.
     */
    readonly blur: () => void;
  }

  export interface nsIBaseWindowRef {
    readonly name: "nsIBaseWindow";
    readonly number: "{ca635529-a977-4552-9b8a-66187e54d882}";

    /**
     * The 'flags' argument to setPositionAndSize is a set of these bits.
     */
    eRepaint: 1;

    eDelayResize: 2;
  }

  /**
   * The nsIBaseWindow describes a generic window and basic operations that
   * can be performed on it.  This is not to be a complete windowing interface
   * but rather a common set that nearly all windowed objects support.
   */
  export interface nsIBaseWindow extends nsISupports {

    readonly create: () => void;

    readonly destroy: () => void;

    readonly setPosition: (x: number, y: number) => void;

    readonly setPositionDesktopPix: (x: number, y: number) => void;

    readonly getPosition: (x: Out<number>, y: Out<number>) => void;

    readonly setSize: (cx: number, cy: number, fRepaint: boolean) => void;

    readonly getSize: (cx: Out<number>, cy: Out<number>) => void;

    readonly setPositionAndSize: (x: number, y: number, cx: number, cy: number, flags: number) => void;

    readonly getPositionAndSize: (x: Out<number>, y: Out<number>, cx: Out<number>, cy: Out<number>) => void;

    /**
     * Tell the window to repaint itself
     * @param aForce - if true, repaint immediately
     *                 if false, the window may defer repainting as it sees fit.
     */
    readonly repaint: (force: boolean) => void;

    readonly nativeHandle: IDLAString;

    visibility: boolean;

    enabled: boolean;

    readonly unscaledDevicePixelsPerCSSPixel: number;

    readonly devicePixelsPerDesktopPixel: number;

    /**
     * Give the window focus.
     */
    readonly setFocus: () => void;

    title: IDLAString;
  }

  export interface nsIServerSocketListenerRef {
    readonly name: "nsIServerSocketListener";
    readonly number: "{836d98ec-fee2-4bde-b609-abd5e966eabd}";
  }

  export interface nsIServerSocketListener extends nsISupports {

    /**
     * nsIServerSocketListener
     *
     * This interface is notified whenever a server socket accepts a new connection.
     * The transport is in the connected state, and read/write streams can be opened
     * using the normal nsITransport API.  The address of the client can be found by
     * calling the nsISocketTransport::GetAddress method or by inspecting
     * nsISocketTransport::GetHost, which returns a string representation of the
     * client's IP address (NOTE: this may be an IPv4 or IPv6 string literal).
     */
    /**
     * onSocketAccepted
     *
     * This method is called when a client connection is accepted.
     *
     * @param aServ
     *        The server socket.
     * @param aTransport
     *        The connected socket transport.
     */
    readonly onSocketAccepted: (aServ: (nsIServerSocket | null), aTransport: (nsISocketTransport | null)) => void;

    /**
     * onStopListening
     *
     * This method is called when the listening socket stops for some reason.
     * The server socket is effectively dead after this notification.
     *
     * @param aServ
     *        The server socket.
     * @param aStatus
     *        The reason why the server socket stopped listening.  If the
     *        server socket was manually closed, then this value will be
     *        NS_BINDING_ABORTED.
     */
    readonly onStopListening: (aServ: (nsIServerSocket | null), aStatus: number) => void;
  }

  export interface nsIEventListenerServiceRef {
    readonly name: "nsIEventListenerService";
    readonly number: "{77aab5f7-213d-4db4-9f22-e46dfb774f15}";
  }

  export interface nsIEventListenerService extends nsISupports {

    /**
     * Returns an array of nsIEventListenerInfo objects.
     * If aEventTarget doesn't have any listeners, this returns null.
     */
    readonly getListenerInfoFor: (aEventTarget: WebIDL.EventTarget) => (nsIEventListenerInfo | null)[];

    /**
     * Returns an array of event targets.
     * aEventTarget will be at index 0.
     * The objects are the ones that would be used as DOMEvent.currentTarget while
     * dispatching an event to aEventTarget
     * @note Some events, especially 'load', may actually have a shorter
     *       event target chain than what this methods returns.
     */
    readonly getEventTargetChainFor: (aEventTarget: WebIDL.EventTarget, composed: boolean) => WebIDL.EventTarget[];

    /**
     * Returns true if a event target has any listener for the given type.
     */
    readonly hasListenersFor: (aEventTarget: WebIDL.EventTarget, aType: IDLAString) => boolean;

    /**
     * Add a system-group eventlistener to a event target.
     */
    readonly addSystemEventListener: (target: WebIDL.EventTarget, type: IDLAString, listener: IDLjsval, useCapture: boolean) => void;

    /**
     * Remove a system-group eventlistener from a event target.
     */
    readonly removeSystemEventListener: (target: WebIDL.EventTarget, type: IDLAString, listener: IDLjsval, useCapture: boolean) => void;

    readonly addListenerForAllEvents: (target: WebIDL.EventTarget, listener: IDLjsval, aUseCapture?: boolean, aWantsUntrusted?: boolean, aSystemEventGroup?: boolean) => void;

    readonly removeListenerForAllEvents: (target: WebIDL.EventTarget, listener: IDLjsval, aUseCapture?: boolean, aSystemEventGroup?: boolean) => void;

    readonly addListenerChangeListener: (aListener: (nsIListenerChangeListener | nsIListenerChangeListenerFunction | null)) => void;

    readonly removeListenerChangeListener: (aListener: (nsIListenerChangeListener | nsIListenerChangeListenerFunction | null)) => void;
  }

  export interface nsIUrlClassifierPrefixSetRef {
    readonly name: "nsIUrlClassifierPrefixSet";
    readonly number: "{3d8579f0-75fa-4e00-ba41-38661d5b5d17}";
  }

  export interface nsIUrlClassifierPrefixSet extends nsISupports {

    readonly init: (aName: IDLACString) => void;

    readonly setPrefixes: (aPrefixes: number[], aLength: number) => void;

    readonly getPrefixes: (aCount: Out<number>) => number[];

    readonly contains: (aPrefix: number) => boolean;

    readonly isEmpty: () => boolean;
  }

  export interface nsIJARURIRef {
    readonly name: "nsIJARURI";
    readonly number: "{646a508c-f786-4e14-be6d-8dda2a633c60}";
  }

  /**
   * JAR URLs have the following syntax
   *
   * jar:<jar-file-uri>!/<jar-entry>
   *
   * EXAMPLE: jar:http://www.big.com/blue.jar!/ocean.html
   *
   * The nsIURL methods operate on the <jar-entry> part of the spec.
   */
  export interface nsIJARURI extends nsIURL {

    /**
     * Returns the root URI (the one for the actual JAR file) for this JAR
     * (e.g., http://www.big.com/blue.jar).
     */
    readonly JARFile: (nsIURI | null);

    /**
     * Returns the entry specified for this JAR URI (e.g., "ocean.html").  This
     * value may contain %-escaped byte sequences.
     */
    readonly JAREntry: IDLAUTF8String;
  }

  export interface nsIJSEnumeratorRef {
    readonly name: "nsIJSEnumerator";
    readonly number: "{4432e8ae-d4d3-42a6-a4d1-829f1c29512b}";
  }

  /**
   * Used to enumerate over elements defined by its implementor.
   * Although hasMoreElements() can be called independently of getNext(),
   * getNext() must be pre-ceeded by a call to hasMoreElements(). There is
   * no way to "reset" an enumerator, once you obtain one.
   *
   * @version 1.0
   */
  /**
   * A wrapper for an nsISimpleEnumerator instance which implements the
   * JavaScript iteration protocol.
   */
  export interface nsIJSEnumerator extends nsISupports {

    readonly iterator: () => (nsIJSEnumerator | null);

    readonly next: () => IDLjsval;
  }

  export interface nsIWebProtocolHandlerRegistrarRef {
    readonly name: "nsIWebProtocolHandlerRegistrar";
    readonly number: "{1ce9ef8d-f462-49ca-b8e9-c946c4f37d6e}";
  }

  /**
   * nsIWebProtocolHandlerRegistrar
   *
   * Applications wishing to use web protocol handlers need to implement this
   * interface. Typically they will prompt the user to confirm adding an entry
   * to the local list.
   *
   * The component must have the contract id defined below so that the Navigator
   * implementation can invoke it.
   */
  export interface nsIWebProtocolHandlerRegistrar extends nsISupports {

    /**
     * See documentation in Navigator.webidl
     * The additional contentWindow param for this method represents the dom
     * content window from which the method has been called, or its browser window.
     */
    readonly registerProtocolHandler: (protocol: IDLAString, uri: (nsIURI | null), title: IDLAString, documentURI: (nsIURI | null), windowOrBrowser: (nsISupports | null)) => void;

    /**
     * Removes a registered protocol handler
     *
     * While registerProtocolHandler is exposed on Navigator, unregistering
     * is exposed through the UI code.
     * @param   protocol
     *          The protocol scheme to remove a service handler for
     * @param   uri
     *          The uri of the service handler to remove
     */
    readonly removeProtocolHandler: (protocol: IDLAString, uri: IDLAString) => void;
  }

  export interface nsIStreamListenerRef {
    readonly name: "nsIStreamListener";
    readonly number: "{3b4c8a77-76ba-4610-b316-678c73a3b88c}";
  }

  /**
   * nsIStreamListener
   */
  export interface nsIStreamListener extends nsIRequestObserver {

    /**
     * Called when the next chunk of data (corresponding to the request) may
     * be read without blocking the calling thread.  The onDataAvailable impl
     * must read exactly |aCount| bytes of data before returning.
     *
     * @param aRequest request corresponding to the source of the data
     * @param aInputStream input stream containing the data chunk
     * @param aOffset
     *        Number of bytes that were sent in previous onDataAvailable calls
     *        for this request. In other words, the sum of all previous count
     *        parameters.
     * @param aCount number of bytes available in the stream
     *
     * NOTE: The aInputStream parameter must implement readSegments.
     *
     * An exception thrown from onDataAvailable has the side-effect of
     * causing the request to be canceled.
     */
    readonly onDataAvailable: (aRequest: (nsIRequest | null), aInputStream: (nsIInputStream | null), aOffset: number, aCount: number) => void;
  }

  export interface nsITCPSocketCallbackRef {
    readonly name: "nsITCPSocketCallback";
    readonly number: "{ac2c4b69-cb79-4767-b1ce-bcf62945cd39}";

    BUFFER_SIZE: 65536;
  }

  export interface nsITCPSocketCallback extends nsISupports {

    readonly fireErrorEvent: (name: IDLAString, type: IDLAString) => void;

    readonly fireDataStringEvent: (type: IDLAString, data: IDLACString) => void;

    readonly fireEvent: (type: IDLAString) => void;

    readonly updateReadyState: (readystate: number) => void;

    readonly updateBufferedAmount: (bufferedAmount: number, trackingNumber: number) => void;
  }

  export interface nsIChildChannelRef {
    readonly name: "nsIChildChannel";
    readonly number: "{c45b92ae-4f07-41dd-b0ef-aa044eeabb1e}";
  }

  /**
   * Implemented by content side of IPC protocols.
   */
  export interface nsIChildChannel extends nsISupports {

    /**
     * Create the chrome side of the IPC protocol and join an existing 'real'
     * channel on the parent process.  The id is provided by
     * nsIRedirectChannelRegistrar on the chrome process and pushed to the child
     * protocol as an argument to event starting a redirect.
     *
     * Primarilly used in HttpChannelChild::Redirect1Begin on a newly created
     * child channel, where the new channel is intended to be created on the
     * child process.
     */
    readonly connectParent: (registrarId: number) => void;

    /**
     * As AsyncOpen is called on the chrome process for redirect target channels,
     * we have to inform the child side of the protocol of that fact by a special
     * method.
     */
    readonly completeRedirectSetup: (aListener: (nsIStreamListener | null), aContext: (nsISupports | null)) => void;
  }

  export interface nsIPageThumbsStorageServiceRef {
    readonly name: "nsIPageThumbsStorageService";
    readonly number: "{97943eec-0e48-49ef-b7b7-cf4aa0109bb6}";
  }

  /**
   * A service which returns information about file paths where the
   * screenshots for URLs are stored. These screenshots are used by the
   * moz-page-thumb protocol
   */
  export interface nsIPageThumbsStorageService extends nsISupports {

    /**
     * Returns the leaf name of the file containing the screenshot for a given URL
     */
    readonly getLeafNameForURL: (aURL: IDLAString) => IDLAString;

    /**
     * Returns the path where the thumbnails are stored
     */
    readonly path: IDLAString;

    /**
     * Returns the full file path containing the screenshot for a given URL
     */
    readonly getFilePathForURL: (aURL: IDLAString) => IDLAString;
  }

  export interface nsIPermissionManagerRef {
    readonly name: "nsIPermissionManager";
    readonly number: "{4dcb3851-eba2-4e42-b236-82d2596fca22}";

    /**
     * Predefined return values for the testPermission method and for
     * the permission param of the add method
     * NOTE: UNKNOWN_ACTION (0) is reserved to represent the
     * default permission when no entry is found for a host, and
     * should not be used by consumers to indicate otherwise.
     */
    UNKNOWN_ACTION: 0;

    ALLOW_ACTION: 1;

    DENY_ACTION: 2;

    PROMPT_ACTION: 3;

    /**
     * Predefined expiration types for permissions.  Permissions can be permanent
     * (never expire), expire at the end of the session, or expire at a specified
     * time. Permissions that expire at the end of a session may also have a
     * specified expiration time.
     *
     * EXPIRE_POLICY is a special expiration status. It is set when the permission
     * is set by reading an enterprise policy. These permissions cannot be overridden.
     */
    EXPIRE_NEVER: 0;

    EXPIRE_SESSION: 1;

    EXPIRE_TIME: 2;

    EXPIRE_POLICY: 3;
  }

  export interface nsIPermissionManager extends nsISupports {

    /**
     * Get all custom permissions for a given nsIPrincipal. This will return an
     * enumerator of all permissions which are not set to default and which
     * belong to the matching principal of the given nsIPrincipal.
     *
     * @param principal  the URI to get all permissions for
     */
    readonly getAllForPrincipal: (principal: (nsIPrincipal | null)) => (nsIPermission | null)[];

    /**
     * Get all custom permissions of a specific type, specified with a prefix
     * string.  This will return an array of all permissions which are not set to
     * default.  Also the passed type argument is either equal to or a prefix of
     * the type of the returned permissions.
     *
     * @param prefix  the type prefix string
     */
    readonly getAllWithTypePrefix: (prefix: IDLACString) => (nsIPermission | null)[];

    /**
     * Add permission information for a given principal.
     * It is internally calling the other add() method using the nsIURI from the
     * principal.
     * Passing a system principal will be a no-op because they will always be
     * granted permissions.
     */
    readonly addFromPrincipal: (principal: (nsIPrincipal | null), type: IDLACString, permission: number, expireType?: number, expireTime?: number) => void;

    /**
     * Remove permission information for a given principal.
     * This is internally calling remove() with the host from the principal's URI.
     * Passing system principal will be a no-op because we never add them to the
     * database.
     */
    readonly removeFromPrincipal: (principal: (nsIPrincipal | null), type: IDLACString) => void;

    /**
     * Remove the given permission from the permission manager.
     *
     * @param perm   a permission obtained from the permission manager.
     */
    readonly removePermission: (perm: (nsIPermission | null)) => void;

    /**
     * Clear permission information for all websites.
     */
    readonly removeAll: () => void;

    /**
     * Clear all permission information added since the specified time.
     */
    readonly removeAllSince: (since: number) => void;

    /**
     * Clear all permissions of the passed type.
     */
    readonly removeByType: (type: IDLACString) => void;

    /**
     * Clear all permissions of the passed type added since the specified time.
     * @param type    a case-sensitive ASCII string, identifying the permission.
     * @param since   a unix timestamp representing the number of milliseconds from
     *                Jan 1, 1970 00:00:00 UTC.
     */
    readonly removeByTypeSince: (type: IDLACString, since: number) => void;

    /**
     * Test whether the principal has the permission to perform a given action.
     * System principals will always have permissions granted.
     * This function will perform a pref lookup to permissions.default.<type>
     * if the specific permission type is part of the whitelist for that functionality.
     */
    readonly testPermissionFromPrincipal: (principal: (nsIPrincipal | null), type: IDLACString) => number;

    /**
     * See testExactPermission() above.
     * System principals will always have permissions granted.
     * This function will perform a pref lookup to permissions.default.<type>
     * if the specific permission type is part of the whitelist for that functionality.
     */
    readonly testExactPermissionFromPrincipal: (principal: (nsIPrincipal | null), type: IDLACString) => number;

    /**
     * Test whether a website has permission to perform the given action
     * ignoring active sessions.
     * System principals will always have permissions granted.
     * This function will perform a pref lookup to permissions.default.<type>
     * if the specific permission type is part of the whitelist for that functionality.
     *
     * @param principal the principal
     * @param type      a case-sensitive ASCII string, identifying the consumer
     * @param return    see add(), param permission. returns UNKNOWN_ACTION when
     *                  there is no stored permission for this uri and / or type.
     */
    readonly testExactPermanentPermission: (principal: (nsIPrincipal | null), type: IDLACString) => number;

    /**
     * Get the permission object associated with the given principal and action.
     * @param principal The principal
     * @param type      A case-sensitive ASCII string identifying the consumer
     * @param exactHost If true, only the specific host will be matched,
     *                  @see testExactPermission. If false, subdomains will
     *                  also be searched, @see testPermission.
     * @returns The matching permission object, or null if no matching object
     *          was found. No matching object is equivalent to UNKNOWN_ACTION.
     * @note Clients in general should prefer the test* methods unless they
     *       need to know the specific stored details.
     * @note This method will always return null for the system principal.
     */
    readonly getPermissionObject: (principal: (nsIPrincipal | null), type: IDLACString, exactHost: boolean) => (nsIPermission | null);

    /**
     * Returns all stored permissions.
     * @return an array of nsIPermission objects
     */
    readonly all: (nsIPermission | null)[];

    /**
     * Remove all permissions that will match the origin pattern.
     */
    readonly removePermissionsWithAttributes: (patternAsJSON: IDLAString) => void;

    /**
     * Broadcasts permissions for the given principal to all content processes.
     *
     * DO NOT USE THIS METHOD if you can avoid it. It was added in bug XXX to
     * handle the current temporary implementation of ServiceWorker debugging. It
     * will be removed when service worker debugging is fixed.
     *
     * @param aPrincipal The principal to broadcast permissions for.
     */
    readonly broadcastPermissionsForPrincipalToAllContentProcesses: (aPrincipal: (nsIPrincipal | null)) => void;
  }

  export interface nsIChannelEventSinkRef {
    readonly name: "nsIChannelEventSink";
    readonly number: "{0197720d-37ed-4e75-8956-d0d296e4d8a6}";

    /**
     * This is a temporary redirect. New requests for this resource should
     * continue to use the URI of the old channel.
     *
     * The new URI may be identical to the old one.
     */
    REDIRECT_TEMPORARY: 1;

    /**
     * This is a permanent redirect. New requests for this resource should use
     * the URI of the new channel (This might be an HTTP 301 reponse).
     * If this flag is not set, this is a temporary redirect.
     *
     * The new URI may be identical to the old one.
     */
    REDIRECT_PERMANENT: 2;

    /**
     * This is an internal redirect, i.e. it was not initiated by the remote
     * server, but is specific to the channel implementation.
     *
     * The new URI may be identical to the old one.
     */
    REDIRECT_INTERNAL: 4;

    /**
     * This is a special-cased redirect coming from hitting HSTS upgrade
     * redirect from http to https only.  In some cases this type of redirect
     * may be considered as safe despite not being the-same-origin redirect.
     */
    REDIRECT_STS_UPGRADE: 8;
  }

  /**
   * Implement this interface to receive control over various channel events.
   * Channels will try to get this interface from a channel's
   * notificationCallbacks or, if not available there, from the loadGroup's
   * notificationCallbacks.
   *
   * These methods are called before onStartRequest.
   */
  export interface nsIChannelEventSink extends nsISupports {

    /**
     * Called when a redirect occurs. This may happen due to an HTTP 3xx status
     * code. The purpose of this method is to notify the sink that a redirect
     * is about to happen, but also to give the sink the right to veto the
     * redirect by throwing or passing a failure-code in the callback.
     *
     * Note that vetoing the redirect simply means that |newChannel| will not
     * be opened. It is important to understand that |oldChannel| will continue
     * loading as if it received a HTTP 200, which includes notifying observers
     * and possibly display or process content attached to the HTTP response.
     * If the sink wants to prevent this loading it must explicitly deal with
     * it, e.g. by calling |oldChannel->Cancel()|
     *
     * There is a certain freedom in implementing this method:
     *
     * If the return-value indicates success, a callback on |callback| is
     * required. This callback can be done from within asyncOnChannelRedirect
     * (effectively making the call synchronous) or at some point later
     * (making the call asynchronous). Repeat: A callback must be done
     * if this method returns successfully.
     *
     * If the return value indicates error (method throws an exception)
     * the redirect is vetoed and no callback must be done. Repeat: No
     * callback must be done if this method throws!
     *
     * @see nsIAsyncVerifyRedirectCallback::onRedirectVerifyCallback()
     *
     * @param oldChannel
     *        The channel that's being redirected.
     * @param newChannel
     *        The new channel. This channel is not opened yet.
     * @param flags
     *        Flags indicating the type of redirect. A bitmask consisting
     *        of flags from above.
     *        One of REDIRECT_TEMPORARY and REDIRECT_PERMANENT will always be
     *        set.
     * @param callback
     *        Object to inform about the async result of this method
     *
     * @throw <any> Throwing an exception will cause the redirect to be
     *        cancelled
     */
    readonly asyncOnChannelRedirect: (oldChannel: (nsIChannel | null), newChannel: (nsIChannel | null), flags: number, callback: (nsIAsyncVerifyRedirectCallback | null)) => void;
  }

  export interface nsIHandlerAppRef {
    readonly name: "nsIHandlerApp";
    readonly number: "{8bdf20a4-9170-4548-af52-78311a44f920}";
  }

  export interface nsIHandlerApp extends nsISupports {

    /**
     * nsIHandlerApp represents an external application that can handle content
     * of some sort (either a MIME type or a protocol).
     *
     * FIXME: now that we've made nsIWebHandlerApp inherit from nsIHandlerApp,
     * we should also try to make nsIWebContentHandlerInfo inherit from or possibly
     * be replaced by nsIWebHandlerApp (bug 394710).
     */
    /**
     * Human readable name for the handler
     */
    name: IDLAString;

    /**
     * Detailed description for this handler. Suitable for
     * a tooltip or short informative sentence.
     */
    detailedDescription: IDLAString;

    /**
     * Whether or not the given handler app is logically equivalent to the
     * invokant (i.e. they represent the same app).
     *
     * Two apps are the same if they are both either local or web handlers
     * and their executables/URI templates and command line parameters are
     * the same.
     *
     * @param aHandlerApp the handler app to compare to the invokant
     *
     * @returns true if the two are logically equivalent, false otherwise
     */
    readonly equals: (aHandlerApp: (nsIHandlerApp | null)) => boolean;

    /**
     * Launches the application with the specified URI.
     *
     * @param aURI
     *        The URI to launch this application with
     *
     * @param aWindowContext
     *
     *        Currently only relevant to web-handler apps.  If given, this
     *        represents the docshell to load the handler in and is passed
     *        through to nsIURILoader.openURI.  If this parameter is null or
     *        not present, the web handler app implementation will attempt to
     *        find/create a place to load the handler and do so.  As of this
     *        writing, it tries to load the web handler in a new window using
     *        nsIBrowserDOMWindow.openURI.  In the future, it may attempt to
     *        have a more comprehensive strategy which could include handing
     *        off to the system default browser (bug 394479).
     */
    readonly launchWithURI: (aURI: (nsIURI | null), aWindowContext?: (nsIInterfaceRequestor | null)) => void;
  }

  export interface nsIPresentationDeviceRequestRef {
    readonly name: "nsIPresentationDeviceRequest";
    readonly number: "{b2aa7f6a-9448-446a-bba4-9c29638b0ed4}";
  }

  export interface nsIPresentationDeviceRequest extends nsISupports {

    readonly origin: IDLAString;

    readonly requestURLs: (nsIArray | null);

    readonly chromeEventHandler: WebIDL.EventTarget;

    readonly principal: (nsIPrincipal | null);

    readonly select: (device: (nsIPresentationDevice | null)) => void;

    readonly cancel: (reason: number) => void;
  }

  export interface nsIBitsRef {
    readonly name: "nsIBits";
    readonly number: "{495d6f3d-9748-4d30-8ce5-0290c0001edf}";

    /**
     * nsBitsErrorType values
     * The BITS interface returns many error codes. These are intended to help
     * determine appropriate fallback actions and to report to telemetry.
     */
    ERROR_TYPE_SUCCESS: 0;

    ERROR_TYPE_UNKNOWN: 1;

    ERROR_TYPE_METHOD_THREW: 2;

    ERROR_TYPE_METHOD_TIMEOUT: 3;

    ERROR_TYPE_NULL_ARGUMENT: 4;

    ERROR_TYPE_INVALID_ARGUMENT: 5;

    ERROR_TYPE_NOT_INITIALIZED: 6;

    ERROR_TYPE_NO_UTF8_CONVERSION: 7;

    ERROR_TYPE_INVALID_GUID: 8;

    ERROR_TYPE_PIPE_NOT_CONNECTED: 9;

    ERROR_TYPE_PIPE_TIMEOUT: 10;

    ERROR_TYPE_PIPE_BAD_WRITE_COUNT: 11;

    ERROR_TYPE_PIPE_API_ERROR: 12;

    ERROR_TYPE_FAILED_TO_CREATE_BITS_JOB: 13;

    ERROR_TYPE_FAILED_TO_ADD_FILE_TO_JOB: 14;

    ERROR_TYPE_FAILED_TO_APPLY_BITS_JOB_SETTINGS: 15;

    ERROR_TYPE_FAILED_TO_RESUME_BITS_JOB: 16;

    ERROR_TYPE_OTHER_BITS_ERROR: 17;

    ERROR_TYPE_OTHER_BITS_CLIENT_ERROR: 18;

    ERROR_TYPE_BITS_JOB_NOT_FOUND: 19;

    ERROR_TYPE_FAILED_TO_GET_BITS_JOB: 20;

    ERROR_TYPE_FAILED_TO_SUSPEND_BITS_JOB: 21;

    ERROR_TYPE_FAILED_TO_COMPLETE_BITS_JOB: 22;

    ERROR_TYPE_PARTIALLY_COMPLETED_BITS_JOB: 23;

    ERROR_TYPE_FAILED_TO_CANCEL_BITS_JOB: 24;

    ERROR_TYPE_MISSING_RESULT_DATA: 25;

    ERROR_TYPE_MISSING_CALLBACK: 26;

    ERROR_TYPE_CALLBACK_ON_WRONG_THREAD: 27;

    ERROR_TYPE_MISSING_BITS_SERVICE: 28;

    ERROR_TYPE_BITS_SERVICE_ON_WRONG_THREAD: 29;

    ERROR_TYPE_MISSING_BITS_REQUEST: 30;

    ERROR_TYPE_BITS_REQUEST_ON_WRONG_THREAD: 31;

    ERROR_TYPE_MISSING_OBSERVER: 32;

    ERROR_TYPE_OBSERVER_ON_WRONG_THREAD: 33;

    ERROR_TYPE_MISSING_CONTEXT: 34;

    ERROR_TYPE_CONTEXT_ON_WRONG_THREAD: 35;

    ERROR_TYPE_FAILED_TO_START_THREAD: 36;

    ERROR_TYPE_FAILED_TO_CONSTRUCT_TASK_RUNNABLE: 37;

    ERROR_TYPE_FAILED_TO_DISPATCH_RUNNABLE: 38;

    ERROR_TYPE_TRANSFER_ALREADY_COMPLETE: 39;

    ERROR_TYPE_OPERATION_ALREADY_IN_PROGRESS: 40;

    ERROR_TYPE_MISSING_BITS_CLIENT: 41;

    ERROR_TYPE_FAILED_TO_GET_JOB_STATUS: 42;

    ERROR_TYPE_BITS_STATE_ERROR: 43;

    ERROR_TYPE_BITS_STATE_TRANSIENT_ERROR: 44;

    ERROR_TYPE_BITS_STATE_CANCELLED: 45;

    ERROR_TYPE_BITS_STATE_UNEXPECTED: 46;

    ERROR_TYPE_VERIFICATION_FAILURE: 47;

    ERROR_TYPE_ACCESS_DENIED_EXPECTED: 48;

    ERROR_TYPE_FAILED_TO_CONNECT_TO_BCM: 49;

    ERROR_TYPE_USE_AFTER_REQUEST_SHUTDOWN: 50;

    /**
     * nsBitsErrorAction values
     * These values indicate where the error occurred.
     */
    ERROR_ACTION_UNKNOWN: 1;

    ERROR_ACTION_NONE: 2;

    ERROR_ACTION_START_DOWNLOAD: 3;

    ERROR_ACTION_MONITOR_DOWNLOAD: 4;

    ERROR_ACTION_CHANGE_MONITOR_INTERVAL: 5;

    ERROR_ACTION_CANCEL: 6;

    ERROR_ACTION_SET_PRIORITY: 7;

    ERROR_ACTION_COMPLETE: 8;

    ERROR_ACTION_SUSPEND: 9;

    ERROR_ACTION_RESUME: 10;

    ERROR_ACTION_SET_NO_PROGRESS_TIMEOUT: 11;

    /**
     * nsBitsErrorStage values
     * These values allow the caller to determine at what point in the download
     * mechanism a failure occurred.
     */
    ERROR_STAGE_UNKNOWN: 1;

    ERROR_STAGE_PRETASK: 2;

    ERROR_STAGE_COMMAND_THREAD: 3;

    ERROR_STAGE_AGENT_COMMUNICATION: 4;

    ERROR_STAGE_BITS_CLIENT: 5;

    ERROR_STAGE_MAIN_THREAD: 6;

    ERROR_STAGE_MONITOR: 7;

    ERROR_STAGE_VERIFICATION: 8;

    /**
     * These values indicate what type of error code was returned. These are used
     * to allow the different types taken by the different callback failure
     * functions to be made into one generic error type in Javascript.
     */
    ERROR_CODE_TYPE_NONE: 1;

    ERROR_CODE_TYPE_NSRESULT: 2;

    ERROR_CODE_TYPE_HRESULT: 3;

    ERROR_CODE_TYPE_STRING: 4;

    ERROR_CODE_TYPE_EXCEPTION: 5;

    PROXY_NONE: 1;

    PROXY_PRECONFIG: 2;

    PROXY_AUTODETECT: 3;
  }

  /**
   * An interface for interacting with Windows Background Intelligent Transfer
   * Service. This should only be used on Windows.
   *
   * It would be preferable for the functions in this interface to return
   * Promises, but this interface is implemented in Rust, which does not yet have
   * support for Promises. There is a JS wrapper around this class that should be
   * preferred over using this interface directly, located in Bits.jsm.
   *
   * Methods of this class that take a nsIBitsNewRequestCallback do not return or
   * throw errors. All errors will be reported through the callback. The only
   * things that should cause methods to directly throw errors are null arguments.
   */
  export interface nsIBits extends nsISupports {

    /**
     * Indicates whether init() has been called.
     */
    readonly initialized: boolean;

    /**
     * Initializes the BITS interface. Unlike other functions here, this happens
     * synchronously.
     * init() should only be called only once.
     *
     * @param jobName
     *        The name of the BITS job. This is used both to set the name during
     *        job creation and to verify that a job is ours.
     * @param savePathPrefix
     *        The directory that downloads will be saved to. Providing a safe
     *        directory here ensures that the download path cannot be manipulated
     *        to save files to a malicious location. Downloads are guaranteed to
     *        be saved to this directory or a subdirectory.
     * @param monitorTimeoutMs
     *        The amount of time to wait between download monitor notifications.
     *        This should be larger than the largest monitorIntervalMs that will
     *        be passed to startDownload(), monitorDownload(), or
     *        changeMonitorInterval(). This value may not be 0.
     */
    readonly init: (jobName: IDLAUTF8String, savePathPrefix: IDLAUTF8String, monitorTimeoutMs: number) => void;

    /**
     * Downloads the specified URL to the specified location within the
     * savePathPrefix passed to init().
     *
     * @param downloadURL
     *        The URL to be downloaded.
     * @param saveRelativePath
     *        The location to download to. The path given should be a path
     *        relative to the savePathPrefix passed to init(). If this attempts to
     *        escape the directory specified by savePathPrefix, this call will
     *        fail (ex: Don't pass "../filename").
     * @param proxy
     *        Specifies what proxy to use when downloading. Valid values are
     *        listed below.
     * @param noProgressTimeoutSecs
     *        The number of seconds for the "no progress" timeout. After there has
     *        been no download progress for this long, BITS will not retry the job
     *        following a transient error, producing instead a permanent error.
     * @param monitorIntervalMs
     *        The number of milliseconds between download status notifications.
     * @param observer
     *        An observer to be notified of various events. OnStartRequest is
     *        called once the BITS job has been created. OnStopRequest is called
     *        when the file transfer has completed or when an error occurs. If
     *        this object implements nsIProgressEventSink, then its OnProgress
     *        method will be called as data is transferred.
     *        IMPORTANT NOTE: When OnStopRequest is called, the download has
     *                        completed, but nsIBitsRequest::complete() still
     *                        needs to be called to save the file to the
     *                        filesystem.
     * @param context
     *        User defined object forwarded to the observer's onProgress method.
     *        This parameter, unlike others for this interface, can be passed a
     *        null pointer.
     * @param callback
     *        The callback used to relay the response from BITS.
     */
    readonly startDownload: (downloadURL: IDLAUTF8String, saveRelativePath: IDLAUTF8String, proxy: number, noProgressTimeoutSecs: number, monitorIntervalMs: number, observer: (nsIRequestObserver | null), context: (nsISupports | null), callback: (nsIBitsNewRequestCallback | null)) => void;

    /**
     * Similar to startDownload, but connects to a BITS transfer that has already
     * been started.
     *
     * @param id
     *        The GUID of the download to monitor.
     * @param monitorIntervalMs
     *        The number of milliseconds between download status notifications.
     * @param observer
     *        An observer to be notified of various events. OnStartRequest is
     *        called once the BITS job has been created. OnStopRequest is called
     *        when the file transfer has completed or when an error occurs. If
     *        this object implements nsIProgressEventSink, then its OnProgress
     *        method will be called as data is transferred.
     *        IMPORTANT NOTE: When OnStopRequest is called, the download has
     *                        completed, but nsIBitsRequest::complete() still
     *                        needs to be called to save the file to the
     *                        filesystem.
     * @param context
     *        User defined object forwarded to the observer's onProgress method.
     *        This parameter, unlike others for this interface, can be passed a
     *        null pointer.
     * @param callback
     *        The callback used to relay the response from BITS.
     */
    readonly monitorDownload: (id: IDLAUTF8String, monitorIntervalMs: number, observer: (nsIRequestObserver | null), context: (nsISupports | null), callback: (nsIBitsNewRequestCallback | null)) => void;
  }

  export interface nsITableEditorRef {
    readonly name: "nsITableEditor";
    readonly number: "{4805e684-49b9-11d3-9ce4-ed60bd6cb5bc}";

    eNoSearch: 0;

    ePreviousColumn: 1;

    ePreviousRow: 2;
  }

  export interface nsITableEditor extends nsISupports {

    /**
     * insertTableCell() inserts <td> elements before or after a cell element
     * containing first selection range.  I.e., if the cell spans columns and
     * aInsertPosition is true, new columns will be inserted after the
     * right-most column which contains the cell.  Note that this simply
     * inserts <td> elements, i.e., colspan and rowspan around the cell
     * containing selection are not modified.  So, for example, adding a cell
     * to rectangular table changes non-rectangular table.  And if a cell
     * containing selection is at left of row-spanning cell, it may be moved to
     * right side of the row-spanning cell after inserting some cell elements
     * before it.  Similarly, colspan won't be adjusted for keeping table
     * rectangle.
     * If first selection range is not in table cell element, this does nothing
     * without exception.
     *
     * @param aNumberOfCellssToInsert     Number of cells to insert.
     * @param aInsertAfterSelectedCell    true if new cells should be inserted
     *                                    before current cell.  Otherwise, will
     *                                    be inserted after the cell.
     */
    readonly insertTableCell: (aNumberOfColumnsToInsert: number, aInsertAfterSelectedCell: boolean) => void;

    /**
     * insertTableColumn() inserts columns before or after a cell element
     * containing first selection range.  I.e., if the cell spans columns and
     * aInsertAfterSelectedCell is tre, new columns will be inserted after the
     * right-most column which contains the cell.  If first selection range is
     * not in table cell element, this does nothing without exception.
     *
     * @param aNumberOfColumnsToInsert    Number of columns to insert.
     * @param aInsertAfterSelectedCell    true if new columns will be inserted
     *                                    before current cell.  Otherwise, will
     *                                    be inserted after the cell.
     */
    readonly insertTableColumn: (aNumberOfColumnsToInsert: number, aInsertAfterSelectedCell: boolean) => void;

    readonly insertTableRow: (aNumberOfRowsToInsert: number, aInsertAfterSelectedCell: boolean) => void;

    /** Delete table methods
     * Delete starting at the selected cell or the
     *  cell (or table) enclosing the selection anchor
     * The selection is collapsed and is left in the
     *  cell at the same row,col location as
     *  the previous selection anchor, if possible,
     *  else in the closest neighboring cell
     *
     * @param aNumber    Number of items to insert/delete
     */
    readonly deleteTable: () => void;

    /**
     * deleteTableCellContents() removes any contents in cell elements.  If two
     * or more cell elements are selected, this removes all selected cells'
     * contents.  Otherwise, this removes contents of a cell which contains
     * first selection range.  This does nothing without exception if selection
     * is not in cell element.
     */
    readonly deleteTableCellContents: () => void;

    /**
     * deleteTableCell() removes table cell elements.  If two or more cell
     * elements are selected, this removes all selected cell elements.
     * Otherwise, this removes some cell elements starting from selected cell
     * element or a cell containing first selection range.  When this removes
     * last cell element in <tr> or <table>, this removes the <tr> or the
     * <table> too.  Note that when removing a cell causes number of its row
     * becomes less than the others, this method does NOT fill the place with
     * rowspan nor colspan.  This does nothing without exception if selection is
     * not in cell element.
     *
     * @param aNumberOfCellsToDelete  Number of cells to remove.  This is ignored
     *                                if 2 or more cells are selected.
     */
    readonly deleteTableCell: (aNumberOfCellsToDelete: number) => void;

    /**
     * deleteTableColumn() removes cell elements which belong to same columns
     * of selected cell elements.
     * If only one cell element is selected or first selection range is
     * in a cell, removes cell elements which belong to same column.
     * If 2 or more cell elements are selected, removes cell elements which
     * belong to any of all selected columns.  In this case,
     * aNumberOfColumnsToDelete is ignored.
     * If there is no selection ranges, throws exception.
     * If selection is not in a cell element, just does nothing without
     * throwing exception.
     * WARNING: This does not remove <col> nor <colgroup> elements.
     *
     * @param aNumberOfColumnsToDelete    Number of columns to remove.  This is
     *                                    ignored if 2 ore more cells are
     *                                    selected.
     */
    readonly deleteTableColumn: (aNumberOfColumnsToDelete: number) => void;

    /**
     * deleteTableRow() removes <tr> elements.
     * If only one cell element is selected or first selection range is
     * in a cell, removes <tr> elements starting from a <tr> element
     * containing the selected cell or first selection range.
     * If 2 or more cell elements are selected, all <tr> elements
     * which contains selected cell(s).  In this case, aNumberOfRowsToDelete
     * is ignored.
     * If there is no selection ranges, throws exception.
     * If selection is not in a cell element, just does nothing without
     * throwing exception.
     *
     * @param aNumberOfRowsToDelete   Number of rows to remove.  This is ignored
     *                                if 2 or more cells are selected.
     */
    readonly deleteTableRow: (aNumberOfRowsToDelete: number) => void;

    /** Table Selection methods
     * Selecting a row or column actually
     * selects all cells (not TR in the case of rows)
     */
    readonly selectTableCell: () => void;

    /** Select a rectangular block of cells:
     *  all cells falling within the row/column index of aStartCell
     *  to through the row/column index of the aEndCell
     *  aStartCell can be any location relative to aEndCell,
     *   as long as they are in the same table
     *  @param aStartCell  starting cell in block
     *  @param aEndCell    ending cell in block
     */
    readonly selectBlockOfCells: (aStartCell: WebIDL.Element, aEndCell: WebIDL.Element) => void;

    readonly selectTableRow: () => void;

    readonly selectTableColumn: () => void;

    readonly selectTable: () => void;

    readonly selectAllTableCells: () => void;

    /** Create a new TD or TH element, the opposite type of the supplied aSourceCell
     *   1. Copy all attributes from aSourceCell to the new cell
     *   2. Move all contents of aSourceCell to the new cell
     *   3. Replace aSourceCell in the table with the new cell
     *
     *  @param aSourceCell   The cell to be replaced
     *  @return              The new cell that replaces aSourceCell
     */
    readonly switchTableCellHeaderType: (aSourceCell: WebIDL.Element) => WebIDL.Element;

    /** Merges contents of all selected cells
     * for selected cells that are adjacent,
     * this will result in a larger cell with appropriate
     * rowspan and colspan, and original cells are deleted
     * The resulting cell is in the location of the
     *   cell at the upper-left corner of the adjacent
     *   block of selected cells
     *
     * @param aMergeNonContiguousContents:
     *       If true:
     *         Non-contiguous cells are not deleted,
     *         but their contents are still moved
     *         to the upper-left cell
     *       If false: contiguous cells are ignored
     *
     * If there are no selected cells,
     *   and selection or caret is in a cell,
     *   that cell and the one to the right
     *   are merged
     */
    readonly joinTableCells: (aMergeNonContiguousContents: boolean) => void;

    /** Split a cell that has rowspan and/or colspan > 0
     *   into cells such that all new cells have
     *   rowspan = 1 and colspan = 1
     *  All of the contents are not touched --
     *   they will appear to be in the upper-left cell
     */
    readonly splitTableCell: () => void;

    /** Scan through all rows and add cells as needed so
     *   all locations in the cellmap are occupied.
     *   Used after inserting single cells or pasting
     *   a collection of cells that extend past the
     *   previous size of the table
     * If aTable is null, it uses table enclosing the selection anchor
     * This doesn't doesn't change the selection,
     *   thus it can be used to fixup all tables
     *   in a page independent of the selection
     */
    readonly normalizeTable: (aTable: WebIDL.Element) => void;

    /**
     * getCellIndexes() computes row index and column index of a table cell.
     * Note that this depends on layout information.  Therefore, all pending
     * layout should've been flushed before calling this.
     *
     * @param aCellElement        If not null, this computes indexes of the cell.
     *                            If null, this computes indexes of a cell which
     *                            contains anchor of Selection.
     * @param aRowIndex           Must be an object, whose .value will be set
     *                            to row index of the cell.  0 is the first row.
     *                            If rowspan is set to 2 or more, the start
     *                            row index is used.
     * @param aColumnIndex        Must be an object, whose .value will be set
     *                            to column index of the cell.  0 is the first
     *                            column.  If colspan is set to 2 or more, the
     *                            start column index is used.
     */
    readonly getCellIndexes: (aCellElement: WebIDL.Element, aRowIndex: Out<number>, aColumnIndex: Out<number>) => void;

    /**
     * getTableSize() computes number of rows and columns.
     * Note that this depends on layout information.  Therefore, all pending
     * layout should've been flushed before calling this.
     *
     * @param aTableOrElementInTable  If a <table> element, this computes number
     *                                of rows and columns of it.
     *                                If another element and in a <table>, this
     *                                computes number of rows and columns of
     *                                the nearest ancestor <table> element.
     *                                If element is not in <table> element,
     *                                throwing an exception.
     *                                If null, this looks for nearest ancestor
     *                                <table> element containing anchor of
     *                                Selection.  If found, computes the number
     *                                of rows and columns of the <table>.
     *                                Otherwise, throwing an exception.
     * @param aRowCount               Number of *actual* row count.
     *                                I.e., rowspan does NOT increase this value.
     * @param aColumnCount            Number of column count.
     *                                I.e., if colspan is specified with bigger
     *                                number than actual, the value is used
     *                                as this.
     */
    readonly getTableSize: (aTableOrElementInTable: WebIDL.Element, aRowCount: Out<number>, aColCount: Out<number>) => void;

    /**
     * getCellAt() returns a <td> or <th> element in a <table> if there is a
     * cell at the indexes.
     *
     * @param aTableElement       If not null, must be a <table> element.
     *                            If null, looks for the nearest ancestor <table>
     *                            to look for a cell.
     * @param aRowIndex           Row index of the cell.
     * @param aColumnIndex        Column index of the cell.
     * @return                    Returns a <td> or <th> element if there is.
     *                            Otherwise, returns null without throwing
     *                            exception.
     *                            If aTableElement is not null and not a <table>
     *                            element, throwing an exception.
     *                            If aTableElement is null and anchor of Selection
     *                            is not in any <table> element, throwing an
     *                            exception.
     */
    readonly getCellAt: (aTableElement: WebIDL.Element, aRowIndex: number, aColumnIndex: number) => WebIDL.Element;

    /**
     * Get cell element and its various information from <table> element and
     * indexes in it.  If aTableElement is null, this looks for an ancestor
     * <table> element of anchor of Selection.  If there is no <table> element
     * at that point, this throws exception.  Note that this requires layout
     * information.  So, you need to flush the layout after changing the DOM
     * tree.
     * If there is no cell element at the indexes, this throws exception.
     * XXX Perhaps, this is wrong behavior, this should return null without
     *     exception since the caller cannot distinguish whether the exception
     *     is caused by "not found" or other unexpected situation.
     *
     * @param aTableElement       A <table> element.  If this is null, this
     *                            uses ancestor of anchor of Selection.
     * @param aRowIndex           Row index in aTableElement.  Starting from 0.
     * @param aColumnIndex        Column index in aTableElement.  Starting from
     *                            0.
     * @param aCellElement        [OUT] The cell element at the indexes.
     * @param aStartRowIndex      [OUT] First row index which contains
     *                            aCellElement.  E.g., if the cell's rowspan is
     *                            not 1, this returns its first row index.
     *                            I.e., this can be smaller than aRowIndex.
     * @param aStartColumnIndex   [OUT] First column index which contains the
     *                            aCellElement.  E.g., if the cell's colspan is
     *                            larger than 1, this returns its first column
     *                            index.  I.e., this can be smaller than
     *                            aColumIndex.
     * @param aRowSpan            [OUT] rowspan attribute value in most cases.
     *                            If the specified value is invalid, this
     *                            returns 1.  Only when the document is written
     *                            in HTML5 or later, this can be 0.
     * @param aColSpan            [OUT] colspan attribute value in most cases.
     *                            If the specified value is invalid, this
     *                            returns 1.
     * @param aEffectiveRowSpan   [OUT] Effective rowspan value at aRowIndex.
     *                            This is same as:
     *                              aRowSpan - (aRowIndex - aStartRowIndex)
     * @param aEffectiveColSpan   [OUT] Effective colspan value at aColumnIndex.
     *                            This is same as:
     *                              aColSpan - (aColumnIndex - aStartColumnIndex)
     * @param aIsSelected         [OUT] Returns true if aCellElement or its
     *                            <tr> or <table> element is selected.
     *                            Otherwise, e.g., aCellElement just contains
     *                            selection range, returns false.
     */
    readonly getCellDataAt: (aTableElement: WebIDL.Element, aRowIndex: number, aColumnIndex: number, aCellElement: Out<WebIDL.Element>, aStartRowIndex: Out<number>, aStartColumnIndex: Out<number>, aRowSpan: Out<number>, aColSpan: Out<number>, aEffectiveRowSpan: Out<number>, aEffectiveColSpan: Out<number>, aIsSelected: Out<boolean>) => void;

    /**
     * getFirstRow() returns first <tr> element in a <table> element.
     *
     * @param aTableOrElementInTable  If a <table> element, returns its first
     *                                <tr> element.
     *                                If another element, looks for nearest
     *                                ancestor <table> element first.  Then,
     *                                return its first <tr> element.
     * @return                        <tr> element in the <table> element.
     *                                If <table> element is not found, this
     *                                throws an exception.
     *                                If there is a <table> element but it
     *                                does not have <tr> elements, returns
     *                                null without throwing exception.
     *                                Note that this may return anonymous <tr>
     *                                element if <table> has one or more cells
     *                                but <tr> element is not in the source.
     */
    readonly getFirstRow: (aTableElement: WebIDL.Element) => WebIDL.Element;

    /** Preferred direction to search for neighboring cell
     * when trying to locate a cell to place caret in after
     * a table editing action.
     * Used for aDirection param in SetSelectionAfterTableEdit
     */
    /**
     * getSelectedOrParentTableElement() returns a <td>, <th>, <tr> or <table>.
     * If first selection range selects a <td> or <th>, returns it.  aTagName
     * is set to "td" even if the result is a <th> and aCount is set to
     * Selection.rangeCount.
     * If first selection range does not select <td> nor <th>, but selection
     * anchor refers <table>, returns it.  aTagName is set to "table" and
     * aCount is set to 1.
     * If first selection range does not select <td> nor <th>, but selection
     * anchor refers <tr>, returns it.  aTagName is set to "tr" and aCount is
     * set to 1.
     * If first selection range does not select <td> nor <th>, but selection
     * anchor refers <td> (not include <th>!), returns it.  aTagName is set to
     * "td" and aCount is set to 0.
     * Otherwise, if container of selection anchor is in a <td> or <th>,
     * returns it.  aTagName is set to "td" but aCount is set to 0.
     * Otherwise, returns null, aTagName is set to empty string and aCount is
     * set to 0.  I.e., does not throw exception even if a cell is not found.
     * NOTE: Calling this resets internal counter of getFirstSelectedCell()
     *       and getNextSelectedCell().  I.e., getNextSelectedCell() will
     *       return second selected cell element.
     */
    readonly getSelectedOrParentTableElement: (aTagName: Out<IDLAString>, aCount: Out<number>) => WebIDL.Element;

    /** Generally used after GetSelectedOrParentTableElement
     *   to test if selected cells are complete rows or columns
     *
     * @param aElement           Any table or cell element or any element
     *                           inside a table
     *                           Used to get enclosing table.
     *                           If null, selection's anchorNode is used
     *
     * @return
     *     0                        aCellElement was not a cell
     *                              (returned result = NS_ERROR_FAILURE)
     *     TableSelection::Cell     There are 1 or more cells selected but
     *                              complete rows or columns are not selected
     *     TableSelection::Row      All cells are in 1 or more rows
     *                              and in each row, all cells selected
     *                              Note: This is the value if all rows
     *                              (thus all cells) are selected
     *     TableSelection::Column   All cells are in 1 or more columns
     *                              and in each column, all cells are selected
     */
    readonly getSelectedCellsType: (aElement: WebIDL.Element) => number;

    /**
     * getFirstSelectedCell() returns a <td> or <th> element if first range of
     * Selection selects only one table cell element (i.e., startContainer and
     * endContainer are same <tr> element and startOffset + 1 equals endOffset).
     * If first range of Selection does not select a table cell element, this
     * returns null.  However, if Selection has no range, this throws an
     * exception.
     *
     * @param aFirstRangeOfSelection [OUT] Returns the first range of Selection
     *                               only when this returns a <td> or <th>
     *                               element.  Otherwise, returns null.
     * @return                       A <td> or <th> element if first range of
     *                               Selection selects only one table cell
     *                               element.
     */
    readonly getFirstSelectedCell: (aFirstRangeOfSelection: Out<WebIDL.Range>) => WebIDL.Element;

    /**
     * getFirstSelectedCellInTable() returns a cell element, its row index and
     * its column index if first range of Selection selects a cell.  Note that
     * that "selects a cell" means that the range container is a <tr> element
     * and endOffset is startOffset + 1.  So, even if first range of Selection
     * is in a cell element, this treats the range does not select a cell.
     * NOTE: Calling this resets internal counter of getFirstSelectedCell()
     *       and getNextSelectedCell().  I.e., getNextSelectedCell() will
     *       return second selected cell element.
     *
     * @param aRowIndex    [OUT} Returns row index of the found cell.  If not
     *                     found, returns 0.
     * @param aColumnIndex [OUT] Returns column index of the found cell.  If
     *                     not found, returns 0.
     * @return             The cell element which is selected by the first
     *                     range of Selection.  Even if this is not found,
     *                     this returns null, not throwing exception.
     */
    readonly getFirstSelectedCellInTable: (aRowIndex: Out<number>, aColIndex: Out<number>) => WebIDL.Element;

    /**
     * getNextSelectedCell() is a stateful method to retrieve selected table
     * cell elements which are selected by 2nd or later ranges of Selection.
     * When you call getFirstSelectedCell(), it resets internal counter of
     * this method.  Then, following calls of getNextSelectedCell() scans the
     * remaining ranges of Selection.  If a range selects a <td> or <th>
     * element, returns the cell element.  If a range selects an element but
     * neither <td> nor <th> element, this ignores the range.  If a range is
     * in a text node, returns null without throwing exception, but stops
     * scanning the remaining ranges even you call this again.
     * Note that this may cross <table> boundaries since this method just
     * scans all ranges of Selection.  Therefore, returning cells which
     * belong to different <table> elements.
     *
     * @param aNextSelectedCellRange [OUT] Returns null if this method returns
     *                               null.  Otherwise, i.e., found a range which
     *                               selects a <td> or <th> element, returns the
     *                               range.
     * @return                       A <td> or <th> element if one of remaining
     *                               ranges selects a <td> or <th> element unless
     *                               this does not meet a range in a text node.
     */
    readonly getNextSelectedCell: (aNextSelectedCellRange: Out<WebIDL.Range>) => WebIDL.Element;
  }

  export interface nsINativeOSFileInternalsServiceRef {
    readonly name: "nsINativeOSFileInternalsService";
    readonly number: "{913362ad-1526-4623-9e6b-a2eb08afbbb9}";
  }

  /**
   * A service providing native implementations of some of the features
   * of OS.File.
   */
  export interface nsINativeOSFileInternalsService extends nsISupports {

    /**
     * Implementation of OS.File.read
     *
     * @param path The absolute path to the file to read.
     * @param options An object that may contain some of the following fields
     * - {number} bytes The maximal number of bytes to read.
     * - {string} encoding If provided, return the result as a string, decoded
     *   using this encoding. Otherwise, pass the result as an ArrayBuffer.
     *   Invalid encodings cause onError to be called with the platform-specific
     *   "invalid argument" constant.
     * - {string} compression Unimplemented at the moment.
     * @param onSuccess The success callback.
     * @param onError The error callback.
     */
    readonly read: (path: IDLAString, options: IDLjsval, onSuccess: (nsINativeOSFileSuccessCallback | nsINativeOSFileSuccessCallbackFunction | null), onError: (nsINativeOSFileErrorCallback | nsINativeOSFileErrorCallbackFunction | null)) => void;

    /**
     * Implementation of OS.File.writeAtomic
     *
     * @param path the absolute path of the file to write to.
     * @param buffer the data as an array buffer to be written to the file.
     * @param options An object that may contain the following fields
     * - {number} bytes If provided, the number of bytes written is equal to this.
     *   The default value is the size of the |buffer|.
     * - {string} tmpPath If provided and not null, first write to this path, and
     *   move to |path| after writing.
     * - {string} backupPath if provided, backup file at |path| to this path
     *   before overwriting it.
     * - {bool} flush if provided and true, flush the contents of the buffer after
     *   writing. This is slower, but safer.
     * - {bool} noOverwrite if provided and true, do not write if a file already
     *   exists at |path|.
     * @param onSuccess The success callback.
     * @param onError The error callback.
     */
    readonly writeAtomic: (path: IDLAString, buffer: IDLjsval, options: IDLjsval, onSuccess: (nsINativeOSFileSuccessCallback | nsINativeOSFileSuccessCallbackFunction | null), onError: (nsINativeOSFileErrorCallback | nsINativeOSFileErrorCallbackFunction | null)) => void;
  }

  export interface nsIExternalProtocolHandlerRef {
    readonly name: "nsIExternalProtocolHandler";
    readonly number: "{0e61f3b2-34d7-4c79-bfdc-4860bc7341b7}";
  }

  export interface nsIExternalProtocolHandler extends nsIProtocolHandler {

    /**
     * This method checks if the external handler exists for a given scheme.
     *
     * @param scheme external scheme.
     * @return TRUE if the external handler exists for the input scheme, FALSE otherwise.
     */
    readonly externalAppExistsForScheme: (scheme: IDLACString) => boolean;
  }

  export interface nsIFinalizationWitnessServiceRef {
    readonly name: "nsIFinalizationWitnessService";
    readonly number: "{15686f9d-483e-4361-98cd-37f1e8f1e61d}";
  }

  export interface nsIFinalizationWitnessService extends nsISupports {

    /**
     * Create a new Finalization Witness.
     *
     * A finalization witness is an object whose sole role is to
     * broadcast when it is garbage-collected. Once the witness is
     * created, call method its method |forget()| to prevent the
     * broadcast.
     *
     * @param aTopic The topic that the witness will broadcast using
     *               Services.obs.
     * @param aString The string that the witness will broadcast.
     * @return An object with a single method |forget()|.
     */
    readonly make: (aTopic: string, aString: string) => IDLjsval;
  }

  export interface nsIHTMLObjectResizerRef {
    readonly name: "nsIHTMLObjectResizer";
    readonly number: "{8b396020-69d3-451f-80c1-1a96a7da25a9}";

    eTopLeft: 0;

    eTop: 1;

    eTopRight: 2;

    eLeft: 3;

    eRight: 4;

    eBottomLeft: 5;

    eBottom: 6;

    eBottomRight: 7;
  }

  export interface nsIHTMLObjectResizer extends nsISupports {

    /**
     * a boolean indicating if object resizing is enabled in the editor
     */
    objectResizingEnabled: boolean;

    /**
     * Hide resizers if they are visible.  If this is called while there is no
     * visible resizers, this does not throw exception, just does nothing.
     */
    readonly hideResizers: () => void;

    /**
     * Refresh positions of resizers.  If you change size of target of resizers,
     * you need to refresh position of resizers with calling this.
     * FYI: Current user in script is only BlueGriffon.
     */
    readonly refreshResizers: () => void;
  }

  export interface nsICacheEntryInfoRef {
    readonly name: "nsICacheEntryInfo";
    readonly number: "{fab51c92-95c3-4468-b317-7de4d7588254}";
  }

  export interface nsICacheEntryInfo extends nsISupports {

    /**
     * Get the client id associated with this cache entry.
     */
    readonly clientID: IDLACString;

    /**
     * Get the id for the device that stores this cache entry.
     */
    readonly deviceID: IDLACString;

    /**
     * Get the key identifying the cache entry.
     */
    readonly key: IDLACString;

    /**
     * Get the number of times the cache entry has been opened.
     */
    readonly fetchCount: number;

    /**
     * Get the last time the cache entry was opened (in seconds since the Epoch).
     */
    readonly lastFetched: number;

    /**
     * Get the last time the cache entry was modified (in seconds since the Epoch).
     */
    readonly lastModified: number;

    /**
     * Get the expiration time of the cache entry (in seconds since the Epoch).
     */
    readonly expirationTime: number;

    /**
     * Get the cache entry data size.
     */
    readonly dataSize: number;

    /**
     * Find out whether or not the cache entry is stream based.
     */
    readonly isStreamBased: () => boolean;
  }

  export interface nsIContentPrefRef {
    readonly name: "nsIContentPref";
    readonly number: "{9f24948d-24b5-4b1b-b554-7dbd58c1d792}";
  }

  export interface nsIContentPref extends nsISupports {

    readonly domain: IDLAString;

    readonly name: IDLAString;

    readonly value: (nsIVariant | null);
  }

  export interface nsIMemoryRef {
    readonly name: "nsIMemory";
    readonly number: "{1e004834-6d8f-425a-bc9c-a2812ed43bb7}";
  }

  /**
   *
   * nsIMemory: interface to allocate and deallocate memory. Also provides
   * for notifications in low-memory situations.
   *
   * The frozen exported symbols moz_xmalloc, moz_xrealloc, and free
   * provide a more efficient way to access XPCOM memory allocation. Using
   * those symbols is preferred to using the methods on this interface.
   *
   * A client that wishes to be notified of low memory situations (for
   * example, because the client maintains a large memory cache that
   * could be released when memory is tight) should register with the
   * observer service (see nsIObserverService) using the topic
   * "memory-pressure".  There are specific types of notications
   * that can occur.  These types will be passed as the |aData|
   * parameter of the of the "memory-pressure" notification:
   *
   * "low-memory"
   * This will be passed as the extra data when the pressure
   * observer is being asked to flush for low-memory conditions.
   *
   * "low-memory-ongoing"
   * This will be passed when we continue to be in a low-memory
   * condition and we want to flush caches and do other cheap
   * forms of memory minimization, but heavy handed approaches like
   * a GC are unlikely to succeed.
   *
   * "heap-minimize"
   * This will be passed as the extra data when the pressure
   * observer is being asked to flush because of a heap minimize
   * call.
   */
  export interface nsIMemory extends nsISupports {

    /**
     * Attempts to shrink the heap.
     * @param immediate - if true, heap minimization will occur
     *   immediately if the call was made on the main thread. If
     *   false, the flush will be scheduled to happen when the app is
     *   idle.
     * @throws NS_ERROR_FAILURE if 'immediate' is set an the call
     *   was not on the application's main thread.
     */
    readonly heapMinimize: (immediate: boolean) => void;

    /**
     * This predicate can be used to determine if the platform is a "low-memory"
     * platform. Callers may use this to dynamically tune their behaviour
     * to favour reduced memory usage at the expense of performance. The value
     * returned by this function will not change over the lifetime of the process.
     */
    readonly isLowMemoryPlatform: () => boolean;
  }

  export interface nsISupportsPRUint32Ref {
    readonly name: "nsISupportsPRUint32";
    readonly number: "{e01dc470-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for unsigned 32-bit integers
   */
  export interface nsISupportsPRUint32 extends nsISupportsPrimitive {

    data: number;

    readonly toString: () => string;
  }

  export interface nsINativeOSFileErrorCallbackRef {
    readonly name: "nsINativeOSFileErrorCallback";
    readonly number: "{f612e0fc-6736-4d24-aa50-fd661b3b40b6}";
  }

  type nsINativeOSFileErrorCallbackFunction = (operation: IDLACString, OSstatus: number) => void;

  /**
   * A callback invoked in case of error.
   */
  export interface nsINativeOSFileErrorCallback extends nsISupports {

    /**
     * @param operation The name of the failed operation. Provided to aid
     * debugging only, may change without notice.
     * @param OSstatus The OS status of the operation (errno under Unix,
     * GetLastError under Windows).
     */
    readonly complete: (operation: IDLACString, OSstatus: number) => void;
  }

  export interface mozIStorageBindingParamsArrayRef {
    readonly name: "mozIStorageBindingParamsArray";
    readonly number: "{67eea5c3-4881-41ff-b0fe-09f2356aeadb}";
  }

  export interface mozIStorageBindingParamsArray extends nsISupports {

    /**
     * Creates a new mozIStorageBindingParams object that can be added to this
     * array.
     *
     * @return a mozIStorageBindingParams object that can be used to specify
     *         parameters that need to be bound.
     */
    readonly newBindingParams: () => (mozIStorageBindingParams | null);

    /**
     * Adds the parameters to the end of this array.
     *
     * @param aParameters
     *        The parameters to add to this array.
     */
    readonly addParams: (aParameters: (mozIStorageBindingParams | null)) => void;

    /**
     * The number of mozIStorageBindingParams this object contains.
     */
    readonly length: number;
  }

  export interface nsIDOMGeoPositionErrorCallbackRef {
    readonly name: "nsIDOMGeoPositionErrorCallback";
    readonly number: "{7d9b09d9-4843-43eb-a7a7-67f7dda6b3c4}";
  }

  type nsIDOMGeoPositionErrorCallbackFunction = (positionError: WebIDL.GeolocationPositionError) => void;

  export interface nsIDOMGeoPositionErrorCallback extends nsISupports {

    readonly handleEvent: (positionError: WebIDL.GeolocationPositionError) => void;
  }

  export interface nsIWebProgressListener2Ref {
    readonly name: "nsIWebProgressListener2";
    readonly number: "{dde39de0-e4e0-11da-8ad9-0800200c9a66}";
  }

  /**
   * An extended version of nsIWebProgressListener.
   */
  export interface nsIWebProgressListener2 extends nsIWebProgressListener {

    /**
     * Notification that the progress has changed for one of the requests
     * associated with aWebProgress.  Progress totals are reset to zero when all
     * requests in aWebProgress complete (corresponding to onStateChange being
     * called with aStateFlags including the STATE_STOP and STATE_IS_WINDOW
     * flags).
     *
     * This function is identical to nsIWebProgressListener::onProgressChange,
     * except that this function supports 64-bit values.
     *
     * @param aWebProgress
     *        The nsIWebProgress instance that fired the notification.
     * @param aRequest
     *        The nsIRequest that has new progress.
     * @param aCurSelfProgress
     *        The current progress for aRequest.
     * @param aMaxSelfProgress
     *        The maximum progress for aRequest.
     * @param aCurTotalProgress
     *        The current progress for all requests associated with aWebProgress.
     * @param aMaxTotalProgress
     *        The total progress for all requests associated with aWebProgress.
     *
     * NOTE: If any progress value is unknown, then its value is replaced with -1.
     *
     * @see nsIWebProgressListener2::onProgressChange64
     */
    readonly onProgressChange64: (aWebProgress: (nsIWebProgress | null), aRequest: (nsIRequest | null), aCurSelfProgress: number, aMaxSelfProgress: number, aCurTotalProgress: number, aMaxTotalProgress: number) => void;

    /**
     * Notification that a refresh or redirect has been requested in aWebProgress
     * For example, via a <meta http-equiv="refresh"> or an HTTP Refresh: header
     *
     * @param aWebProgress
     *        The nsIWebProgress instance that fired the notification.
     * @param aRefreshURI
     *        The new URI that aWebProgress has requested redirecting to.
     * @param aMillis
     *        The delay (in milliseconds) before refresh.
     * @param aSameURI
     *        True if aWebProgress is requesting a refresh of the
     *        current URI.
     *        False if aWebProgress is requesting a redirection to
     *        a different URI.
     *
     * @return True if the refresh may proceed.
     *         False if the refresh should be aborted.
     */
    readonly onRefreshAttempted: (aWebProgress: (nsIWebProgress | null), aRefreshURI: (nsIURI | null), aMillis: number, aSameURI: boolean) => boolean;
  }

  export interface mozIStorageAggregateFunctionRef {
    readonly name: "mozIStorageAggregateFunction";
    readonly number: "{763217b7-3123-11da-918d-000347412e16}";
  }

  /**
   * mozIStorageAggregateFunction represents aggregate SQL function.
   * Common examples of aggregate functions are SUM() and COUNT().
   *
   * An aggregate function calculates one result for a given set of data, where
   * a set of data is a group of tuples. There can be one group
   * per request or many of them, if GROUP BY clause is used or not.
   */
  export interface mozIStorageAggregateFunction extends nsISupports {

    /**
     * onStep is called when next value should be passed to
     * a custom function.
     *
     * @param aFunctionArguments    The arguments passed in to the function
     */
    readonly onStep: (aFunctionArguments: (mozIStorageValueArray | null)) => void;

    /**
     * Called when all tuples in a group have been processed and the engine
     * needs the aggregate function's value.
     *
     * @returns aggregate result as Variant.
     */
    readonly onFinal: () => (nsIVariant | null);
  }

  export interface nsIURIMutatorRef {
    readonly name: "nsIURIMutator";
    readonly number: "{4d1f3103-1c44-4dcd-b717-5d22a697a7d9}";
  }

  export interface nsIURIMutator extends nsIURISetters {

    /**
     * Finishes changing or constructing the URI and returns an immutable URI.
     */
    readonly finalize: () => (nsIURI | null);
  }

  export interface nsIEditorRef {
    readonly name: "nsIEditor";
    readonly number: "{094be624-f0bf-400f-89e2-6a84baab9474}";

    eNone: 0;

    eNext: 1;

    ePrevious: 2;

    eNextWord: 3;

    ePreviousWord: 4;

    eToBeginningOfLine: 5;

    eToEndOfLine: 6;

    eStrip: 0;

    eNoStrip: 1;
  }

  export interface nsIEditor extends nsISupports {

    readonly selection: WebIDL.Selection;

    readonly setAttributeOrEquivalent: (element: WebIDL.Element, sourceAttrName: IDLAString, sourceAttrValue: IDLAString, aSuppressTransaction: boolean) => void;

    readonly removeAttributeOrEquivalent: (element: WebIDL.Element, sourceAttrName: IDLAString, aSuppressTransaction: boolean) => void;

    /** edit flags for this editor.  May be set at any time. */
    flags: number;

    /**
     * the MimeType of the document
     */
    contentsMIMEType: string;

    /** Returns true if we have a document that is not marked read-only */
    readonly isDocumentEditable: boolean;

    /** Returns true if the current selection anchor is editable */
    readonly isSelectionEditable: boolean;

    /**
     * the DOM Document this editor is associated with, refcounted.
     */
    readonly document: WebIDL.Document;

    /** the body element, i.e. the root of the editable document.
     */
    readonly rootElement: WebIDL.Element;

    /**
     * the selection controller for the current presentation, refcounted.
     */
    readonly selectionController: (nsISelectionController | null);

    /**
     * DeleteSelection removes all nodes in the current selection.
     * @param aDir  if eNext, delete to the right (for example, the DEL key)
     *              if ePrevious, delete to the left (for example, the BACKSPACE key)
     * @param stripWrappers If eStrip, strip any empty inline elements left
     *                      behind after the deletion; if eNoStrip, don't.  If in
     *                      doubt, pass eStrip -- eNoStrip is only for if you're
     *                      about to insert text or similar right after.
     */
    readonly deleteSelection: (action: number, stripWrappers: number) => void;

    /** Returns true if the document has no *meaningful* content */
    readonly documentIsEmpty: boolean;

    /** Returns true if the document is modifed and needs saving */
    readonly documentModified: boolean;

    /** Sets the current 'Save' document character set */
    documentCharacterSet: IDLACString;

    /** to be used ONLY when we need to override the doc's modification
     * state (such as when it's saved).
     */
    readonly resetModificationCount: () => void;

    /** Gets the modification count of the document we are editing.
     * @return the modification count of the document being edited.
     *         Zero means unchanged.
     */
    readonly getModificationCount: () => number;

    /** called each time we modify the document.
     * Increments the modification count of the document.
     * @param  aModCount  the number of modifications by which
     *                    to increase or decrease the count
     */
    readonly incrementModificationCount: (aModCount: number) => void;

    /** transactionManager Get the transaction manager the editor is using.
     */
    readonly transactionManager: (nsITransactionManager | null);

    /** doTransaction() fires a transaction.
     * It is provided here so clients can create their own transactions.
     * If a transaction manager is present, it is used.
     * Otherwise, the transaction is just executed directly.
     *
     * @param aTxn the transaction to execute
     */
    readonly doTransaction: (txn: (nsITransaction | null)) => void;

    /** turn the undo system on or off
     * @param aEnable  if PR_TRUE, the undo system is turned on if available
     *                 if PR_FALSE the undo system is turned off if it
     *                 was previously on
     * @return         if aEnable is PR_TRUE, returns NS_OK if
     *                 the undo system could be initialized properly
     *                 if aEnable is PR_FALSE, returns NS_OK.
     */
    readonly enableUndo: (enable: boolean) => void;

    /** undo reverses the effects of the last Do operation,
     * if Undo is enabled in the editor.
     * It is provided here so clients need no knowledge of whether
     * the editor has a transaction manager or not.
     * If a transaction manager is present, it is told to undo,
     * and the result of that undo is returned.
     * Otherwise, the Undo request is ignored and an
     * error NS_ERROR_NOT_AVAILABLE is returned.
     *
     */
    readonly undo: (count: number) => void;

    /** returns state information about the undo system.
     * @param aIsEnabled [OUT] PR_TRUE if undo is enabled
     * @param aCanUndo   [OUT] PR_TRUE if at least one transaction is
     *                         currently ready to be undone.
     */
    readonly canUndo: (isEnabled: Out<boolean>, canUndo: Out<boolean>) => void;

    /** redo reverses the effects of the last Undo operation
     * It is provided here so clients need no knowledge of whether
     * the editor has a transaction manager or not.
     * If a transaction manager is present, it is told to redo and the
     * result of the previously undone transaction is reapplied to the document.
     * If no transaction is available for Redo, or if the document
     * has no transaction manager, the Redo request is ignored and an
     * error NS_ERROR_NOT_AVAILABLE is returned.
     *
     */
    readonly redo: (count: number) => void;

    /** returns state information about the redo system.
        * @param aIsEnabled [OUT] PR_TRUE if redo is enabled
        * @param aCanRedo   [OUT] PR_TRUE if at least one transaction is
                                  currently ready to be redone.
        */
    readonly canRedo: (isEnabled: Out<boolean>, canRedo: Out<boolean>) => void;

    /** beginTransaction is a signal from the caller to the editor that
     * the caller will execute multiple updates to the content tree
     * that should be treated as a single logical operation,
     * in the most efficient way possible.<br>
     * All transactions executed between a call to beginTransaction and
     * endTransaction will be undoable as an atomic action.<br>
     * endTransaction must be called after beginTransaction.<br>
     * Calls to beginTransaction can be nested, as long as endTransaction
     * is called once per beginUpdate.
     */
    readonly beginTransaction: () => void;

    /** endTransaction is a signal to the editor that the caller is
     * finished updating the content model.<br>
     * beginUpdate must be called before endTransaction is called.<br>
     * Calls to beginTransaction can be nested, as long as endTransaction
     * is called once per beginTransaction.
     */
    readonly endTransaction: () => void;

    /**
     * While setting the flag with this method to false, CreateElementTransaction,
     * DeleteRangeTransaction, DeleteTextTransaction, InsertNodeTransaction,
     * InsertTextTransaction and SplitNodeTransaction won't change Selection
     * after modifying the DOM tree.
     * Note that calling this with false does not guarantee that Selection won't
     * be changed because other transaction may ignore this flag, editor itself
     * may change selection, and current selection may become invalid after
     * changing the DOM tree, etc.
     * After calling this method with true, the caller should guarantee that
     * Selection should be positioned where user expects.
     *
     * @param should    false if you don't want above transactions to modify
     *                  Selection automatically after modifying the DOM tree.
     *                  Note that calling this with false does not guarantee
     *                  that Selection is never changed.
     */
    readonly setShouldTxnSetSelection: (should: boolean) => void;

    /** Returns the inline spell checker associated with this object. The spell
     * checker is lazily created, so this function may create the object for
     * you during this call.
     * @param  autoCreate  If true, this will create a spell checker object
     *                     if one does not exist yet for this editor. If false
     *                     and the object has not been created, this function
     *                     WILL RETURN NULL.
     */
    readonly getInlineSpellChecker: (autoCreate: boolean) => (nsIInlineSpellChecker | null);

    /** Called when the user manually overrides the spellchecking state for this
     * editor.
     * @param  enable  The new state of spellchecking in this editor, as
     *                 requested by the user.
     */
    readonly setSpellcheckUserOverride: (enable: boolean) => void;

    /** cut the currently selected text, putting it into the OS clipboard
     * What if no text is selected?
     * What about mixed selections?
     * What are the clipboard formats?
     */
    readonly cut: () => void;

    /**
     * canCut() returns true if selected content is allowed to be copied to the
     * clipboard and to be removed.
     * Note that this always returns true if the editor is in a non-chrome
     * HTML/XHTML document.
     * FYI: Current user in script is only BlueGriffon.
     */
    readonly canCut: () => boolean;

    /** copy the currently selected text, putting it into the OS clipboard
     * What if no text is selected?
     * What about mixed selections?
     * What are the clipboard formats?
     */
    readonly copy: () => void;

    /**
     * canCopy() returns true if selected content is allowed to be copied to
     * the clipboard.
     * Note that this always returns true if the editor is in a non-chrome
     * HTML/XHTML document.
     * FYI: Current user in script is only BlueGriffon.
     */
    readonly canCopy: () => boolean;

    /** paste the text in the OS clipboard at the cursor position, replacing
     * the selected text (if any)
     */
    readonly paste: (aClipboardType: number) => void;

    /** Paste the text in |aTransferable| at the cursor position, replacing the
     * selected text (if any).
     */
    readonly pasteTransferable: (aTransferable: (nsITransferable | null)) => void;

    /** Can we paste? True if the doc is modifiable, and we have
     * pasteable data in the clipboard.
     */
    readonly canPaste: (aClipboardType: number) => boolean;

    /** sets the document selection to the entire contents of the document */
    readonly selectAll: () => void;

    /**
     * Collapses selection at start of the document.  If it's an HTML editor,
     * collapses selection at start of current editing host (<body> element if
     * it's in designMode) instead.  If there is a non-editable node before any
     * editable text nodes or inline elements which can have text nodes as their
     * children, collapses selection at start of the editing host.  If there is
     * an editable text node which is not collapsed, collapses selection at
     * start of the text node.  If there is an editable inline element which
     * cannot have text nodes as its child, collapses selection at before the
     * element node.  Otherwise, collapses selection at start of the editing
     * host.
     */
    readonly beginningOfDocument: () => void;

    /** sets the document selection to the end of the document */
    readonly endOfDocument: () => void;

    /**
     * setAttribute() sets the attribute of aElement.
     * No checking is done to see if aAttribute is a legal attribute of the node,
     * or if aValue is a legal value of aAttribute.
     *
     * @param aElement    the content element to operate on
     * @param aAttribute  the string representation of the attribute to set
     * @param aValue      the value to set aAttribute to
     */
    readonly setAttribute: (aElement: WebIDL.Element, attributestr: IDLAString, attvalue: IDLAString) => void;

    /**
     * getAttributeValue() retrieves the attribute's value for aElement.
     *
     * @param aElement      the content element to operate on
     * @param aAttribute    the string representation of the attribute to get
     * @param aResultValue  [OUT] the value of aAttribute.
     *                      Only valid if aResultIsSet is PR_TRUE
     * @return              PR_TRUE if aAttribute is set on the current node,
     *                      PR_FALSE if it is not.
     */
    readonly getAttributeValue: (aElement: WebIDL.Element, attributestr: IDLAString, resultValue: Out<IDLAString>) => boolean;

    /**
     * removeAttribute() deletes aAttribute from the attribute list of aElement.
     * If aAttribute is not an attribute of aElement, nothing is done.
     *
     * @param aElement      the content element to operate on
     * @param aAttribute    the string representation of the attribute to get
     */
    readonly removeAttribute: (aElement: WebIDL.Element, aAttribute: IDLAString) => void;

    /**
     * cloneAttribute() copies the attribute from the source node to
     * the destination node and delete those not in the source.
     *
     * The supplied nodes MUST BE ELEMENTS (most callers are working with nodes)
     * @param aAttribute     the name of the attribute to copy
     * @param aDestElement   the destination element to operate on
     * @param aSourceElement the source element to copy attributes from
     * @exception NS_ERROR_NULL_POINTER at least one of the elements is null
     */
    readonly cloneAttribute: (aAttribute: IDLAString, aDestElement: WebIDL.Element, aSourceElement: WebIDL.Element) => void;

    /**
     * cloneAttributes() is similar to Node::cloneNode(),
     *   it assures the attribute nodes of the destination are identical
     *   with the source node by copying all existing attributes from the
     *   source and deleting those not in the source.
     *   This is used when the destination element already exists
     *
     * @param aDestNode     the destination element to operate on
     * @param aSourceNode   the source element to copy attributes from
     */
    readonly cloneAttributes: (aDestElement: WebIDL.Element, aSourceElement: WebIDL.Element) => void;

    /**
     * insertNode inserts aNode into aParent at aPosition.
     * No checking is done to verify the legality of the insertion.
     * That is the responsibility of the caller.
     * @param aNode     The DOM Node to insert.
     * @param aParent   The node to insert the new object into
     * @param aPosition The place in aParent to insert the new node
     *                  0=first child, 1=second child, etc.
     *                  any number > number of current children = last child
     */
    readonly insertNode: (node: WebIDL.Node, parent: WebIDL.Node, aPosition: number) => void;

    /**
     * splitNode() creates a new node identical to an existing node,
     * and split the contents between the two nodes
     * @param aExistingRightNode   the node to split.
     *                             It will become the new node's next sibling.
     * @param aOffset              the offset of aExistingRightNode's
     *                             content|children to do the split at
     * @param aNewLeftNode         [OUT] the new node resulting from the split,
     *                             becomes aExistingRightNode's previous sibling.
     */
    readonly splitNode: (existingRightNode: WebIDL.Node, offset: number, newLeftNode: Out<WebIDL.Node>) => void;

    /**
     * joinNodes() takes 2 nodes and merge their content|children.
     * @param aLeftNode     The left node.  It will be deleted.
     * @param aRightNode    The right node. It will remain after the join.
     * @param aParent       The parent of aExistingRightNode
     *
     *                      There is no requirement that the two nodes be
     *                      of the same type.  However, a text node can be
     *                      merged only with another text node.
     */
    readonly joinNodes: (leftNode: WebIDL.Node, rightNode: WebIDL.Node, parent: WebIDL.Node) => void;

    /**
     * deleteNode removes aChild from aParent.
     * @param aChild    The node to delete
     */
    readonly deleteNode: (child: WebIDL.Node) => void;

    /**
     * markNodeDirty() sets a special dirty attribute on the node.
     * Usually this will be called immediately after creating a new node.
     * @param aNode      The node for which to insert formatting.
     */
    readonly markNodeDirty: (node: WebIDL.Node) => void;

    /**
     * Output methods:
     * aFormatType is a mime type, like text/plain.
     */
    readonly outputToString: (formatType: IDLAString, flags: number) => IDLAString;

    /** add an EditorObserver to the editors list of observers. */
    readonly addEditorObserver: (observer: (nsIEditorObserver | null)) => void;

    /** Remove an EditorObserver from the editor's list of observers. */
    readonly removeEditorObserver: (observer: (nsIEditorObserver | null)) => void;

    /** add an EditActionListener to the editors list of listeners. */
    readonly addEditActionListener: (listener: (nsIEditActionListener | null)) => void;

    /** Remove an EditActionListener from the editor's list of listeners. */
    readonly removeEditActionListener: (listener: (nsIEditActionListener | null)) => void;

    /** Add a DocumentStateListener to the editors list of doc state listeners. */
    readonly addDocumentStateListener: (listener: (nsIDocumentStateListener | null)) => void;

    /** Remove a DocumentStateListener to the editors list of doc state listeners. */
    readonly removeDocumentStateListener: (listener: (nsIDocumentStateListener | null)) => void;

    /**
     * forceCompositionEnd() force the composition end
     */
    readonly forceCompositionEnd: () => void;

    /**
     * whether this editor has active IME transaction
     */
    readonly composing: boolean;

    /**
     * unmask() is available only when the editor is a passwrod field.  This
     * unmasks characters in specified by aStart and aEnd.  If there have
     * already unmasked characters, they are masked when this is called.
     * Note that if you calls this without non-zero `aTimeout`, you bear
     * responsibility for masking password with calling `mask()`.  I.e.,
     * user inputting password won't be masked automacitally.  If user types
     * a new character and echo is enabled, unmasked range is expanded to
     * including it.
     *
     * @param aStart      Optional, first index to show the character.  If you
     *                    specify middle of a surrogate pair, this expands the
     *                    range to include the prceding high surrogate
     *                    automatically.
     *                    If omitted, it means that all characters of the
     *                    password becomes unmasked.
     * @param aEnd        Optional, next index of last unmasked character.  If
     *                    you specify middle of a surrogate pair, the expands
     *                    the range to include the following low surrogate.
     *                    If omitted or negative value, it means unmasking all
     *                    characters after aStart.  Specifying same index
     *                    throws an exception.
     * @param aTimeout    Optional, specify milliseconds to hide the unmasked
     *                    characters if you want to show them temporarily.
     *                    If omitted or 0, it means this won't mask the characters
     *                    automatically.
     */
    readonly unmask: (aStart?: number, aEnd?: number, aTimeout?: number) => void;

    /**
     * mask() is available only when the editor is a password field.  This masks
     * all unmasked characters immediately.
     */
    readonly mask: () => void;

    /**
     * These attributes are available only when the editor is a password field.
     * unmaskedStart is first unmasked character index, or 0 if there is no
     * unmasked characters.
     * unmaskedEnd is next index of the last unmasked character.  0 means there
     * is no unmasked characters.
     */
    readonly unmaskedStart: number;

    readonly unmaskedEnd: number;

    /**
     * autoMaskingEnabled is true if unmasked range and newly inputted characters
     * are masked automatically.  That's the default state.  If false, until
     * `mask()` is called, unmasked range and newly inputted characters are
     * unmasked.
     */
    readonly autoMaskingEnabled: boolean;

    /**
     * passwordMask attribute is a mask character which is used to mask password.
     */
    readonly passwordMask: IDLAString;
  }

  export interface nsIUrlClassifierCacheInfoRef {
    readonly name: "nsIUrlClassifierCacheInfo";
    readonly number: "{69384f24-d9c5-4462-b24e-351c69e3b46a}";
  }

  /**
   * Cache information for a given table.
   */
  export interface nsIUrlClassifierCacheInfo extends nsISupports {

    /**
     * Table name.
     */
    readonly table: IDLACString;

    readonly entries: (nsIArray | null);
  }

  export interface nsIEncodedChannelRef {
    readonly name: "nsIEncodedChannel";
    readonly number: "{29c29ce6-8ce4-45e6-8d60-36c8fa3e255b}";
  }

  /**
   * A channel interface which allows special handling of encoded content
   */
  export interface nsIEncodedChannel extends nsISupports {

    /**
     * This attribute holds the MIME types corresponding to the content
     * encodings on the channel.  The enumerator returns nsISupportsCString
     * objects.  The first one corresponds to the outermost encoding on the
     * channel and then we work our way inward.  "identity" is skipped and not
     * represented on the list.  Unknown encodings make the enumeration stop.
     * If you want the actual Content-Encoding value, use
     * getResponseHeader("Content-Encoding").
     *
     * When there is no Content-Encoding header, this property is null.
     *
     * Modifying the Content-Encoding header on the channel will cause
     * this enumerator to have undefined behavior.  Don't do it.
     *
     * Also note that contentEncodings only exist during or after OnStartRequest.
     * Calling contentEncodings before OnStartRequest is an error.
     */
    readonly contentEncodings: (nsIUTF8StringEnumerator | null);

    /**
     * This attribute controls whether or not content conversion should be
     * done per the Content-Encoding response header.  applyConversion can only
     * be set before or during OnStartRequest.  Calling this during
     * OnDataAvailable is an error.
     *
     * TRUE by default.
     */
    applyConversion: boolean;

    /**
     * This function will start converters if they are available.
     * aNewNextListener will be nullptr if no converter is available.
     */
    readonly doApplyContentConversions: (aNextListener: (nsIStreamListener | null), aNewNextListener: Out<(nsIStreamListener | null)>, aCtxt: (nsISupports | null)) => void;
  }

  export interface nsIHangReportRef {
    readonly name: "nsIHangReport";
    readonly number: "{5fcffbb9-be62-49b1-b8a1-36e820787a74}";

    SLOW_SCRIPT: 1;

    PLUGIN_HANG: 2;
  }

  /**
   * When a content process hangs, Gecko notifies "process-hang-report" observers
   * and passes an nsIHangReport for the subject parameter. There is at most one
   * nsIHangReport associated with a given content process. As long as the content
   * process stays stuck, the "process-hang-report" observer will continue to be
   * notified at regular intervals (approximately once per second). The content
   * process will continue to run uninhibitedly during this time.
   */
  export interface nsIHangReport extends nsISupports {

    readonly hangType: number;

    readonly scriptBrowser: WebIDL.Element;

    readonly scriptFileName: IDLACString;

    readonly addonId: IDLAString;

    readonly pluginName: IDLACString;

    readonly userCanceled: () => void;

    readonly terminateScript: () => void;

    readonly terminateGlobal: () => void;

    readonly terminatePlugin: () => void;

    readonly beginStartingDebugger: () => void;

    readonly endStartingDebugger: () => void;

    readonly isReportForBrowser: (aFrameLoader: WebIDL.FrameLoader) => boolean;
  }

  export interface nsIStringEnumeratorBaseRef {
    readonly name: "nsIStringEnumeratorBase";
    readonly number: "{f5213d15-a4d1-4fb7-8a48-d69ccb7fb0eb}";
  }

  /**
   * Used to enumerate over an ordered list of strings.
   */
  /**
   * Base class for C++-implemented string iterators. JS implementors need not
   * be queryable to it.
   */
  export interface nsIStringEnumeratorBase extends nsISupports {

    readonly iterator: () => (nsIJSEnumerator | null);
  }

  export interface nsIWorkerDebuggerRef {
    readonly name: "nsIWorkerDebugger";
    readonly number: "{22f93aa3-8a05-46be-87e0-fa93bf8a8eff}";

    TYPE_DEDICATED: 0;

    TYPE_SHARED: 1;

    TYPE_SERVICE: 2;
  }

  export interface nsIWorkerDebugger extends nsISupports {

    readonly isClosed: boolean;

    readonly isChrome: boolean;

    readonly isInitialized: boolean;

    readonly parent: (nsIWorkerDebugger | null);

    readonly type: number;

    readonly url: IDLAString;

    readonly window: (mozIDOMWindow | null);

    readonly principal: (nsIPrincipal | null);

    readonly serviceWorkerID: number;

    readonly id: IDLAString;

    readonly initialize: (url: IDLAString) => void;

    readonly postMessage: (message: IDLAString) => void;

    readonly addListener: (listener: (nsIWorkerDebuggerListener | null)) => void;

    readonly removeListener: (listener: (nsIWorkerDebuggerListener | null)) => void;

    readonly setDebuggerReady: (ready: boolean) => void;
  }

  export interface nsIProfileLockRef {
    readonly name: "nsIProfileLock";
    readonly number: "{7c58c703-d245-4864-8d75-9648ca4a6139}";
  }

  /**
   * Hold on to a profile lock. Once you release the last reference to this
   * interface, the profile lock is released.
   */
  export interface nsIProfileLock extends nsISupports {

    /**
     * The main profile directory.
     */
    readonly directory: (nsIFile | null);

    /**
     * A directory corresponding to the main profile directory that exists for
     * the purpose of storing data on the local filesystem, including cache
     * files or other data files that may not represent critical user data.
     * (e.g., this directory may not be included as part of a backup scheme.)
     *
     * In some cases, this directory may just be the main profile directory.
     */
    readonly localDirectory: (nsIFile | null);

    /**
     * The timestamp of an existing profile lock at lock time.
     */
    readonly replacedLockTime: number;

    /**
     * Unlock the profile.
     */
    readonly unlock: () => void;
  }

  export interface nsIHandlerServiceRef {
    readonly name: "nsIHandlerService";
    readonly number: "{53f0ad17-ec62-46a1-adbc-efccc06babcd}";
  }

  export interface nsIHandlerService extends nsISupports {

    /**
     * Asynchronously performs any IO that the nsIHandlerService needs to do
     * before it can be of use.
     */
    readonly asyncInit: () => void;

    /**
     * Retrieve a list of all handlers in the datastore.  This list is not
     * guaranteed to be in any particular order, and callers should not assume
     * it will remain in the same order in the future.
     *
     * @returns a list of all handlers in the datastore
     */
    readonly enumerate: () => (nsISimpleEnumerator | null);

    /**
     * Fill a handler info object with information from the datastore.
     *
     * Note: because of the way the external helper app service currently mixes
     * OS and user handler info in the same handler info object, this method
     * takes an existing handler info object (probably retrieved from the OS)
     * and "fills it in" with information from the datastore, overriding any
     * existing properties on the object with properties from the datastore.
     *
     * Ultimately, however, we're going to separate OS and user handler info
     * into separate objects, at which point this method should be renamed to
     * something like "get" or "retrieve", take a class and type (or perhaps
     * a type whose class can be determined by querying the type, for example
     * an nsIContentType which is also an nsIMIMEType or an nsIProtocolScheme),
     * and return a handler info object representing only the user info.
     *
     * Note: if you specify an override type, then the service will fill in
     * the handler info object with information about that type instead of
     * the type specified by the object's nsIHandlerInfo::type attribute.
     *
     * This is useful when you are trying to retrieve information about a MIME
     * type that doesn't exist in the datastore, but you have a file extension
     * for that type, and nsIHandlerService::getTypeFromExtension returns another
     * MIME type that does exist in the datastore and can handle that extension.
     *
     * For example, the user clicks on a link, and the content has a MIME type
     * that isn't in the datastore, but the link has a file extension, and that
     * extension is associated with another MIME type in the datastore (perhaps
     * an unofficial MIME type preceded an official one, like with image/x-png
     * and image/png).
     *
     * In that situation, you can call this method to fill in the handler info
     * object with information about that other type by passing the other type
     * as the aOverrideType parameter.
     *
     * @param aHandlerInfo   the handler info object
     * @param aOverrideType  a type to use instead of aHandlerInfo::type
     *
     * Note: if there is no information in the datastore about this type,
     * this method throws NS_ERROR_NOT_AVAILABLE. Callers are encouraged to
     * check exists() before calling fillHandlerInfo(), to prevent spamming the
     * console with XPCOM exception errors.
     */
    readonly fillHandlerInfo: (aHandlerInfo: (nsIHandlerInfo | null), aOverrideType: IDLACString) => void;

    /**
     * Save the preferred action, preferred handler, possible handlers, and
     * always ask properties of the given handler info object to the datastore.
     * Updates an existing record or creates a new one if necessary.
     *
     * Note: if preferred action is undefined or invalid, then we assume
     * the default value nsIHandlerInfo::useHelperApp.
     *
     * @param aHandlerInfo  the handler info object
     */
    readonly store: (aHandlerInfo: (nsIHandlerInfo | null)) => void;

    /**
     * Whether or not a record for the given handler info object exists
     * in the datastore. If the datastore is corrupt (or some other error
     * is caught in the implementation), false will be returned.
     *
     * @param aHandlerInfo  a handler info object
     *
     * @returns whether or not a record exists
     */
    readonly exists: (aHandlerInfo: (nsIHandlerInfo | null)) => boolean;

    /**
     * Remove the given handler info object from the datastore.  Deletes all
     * records associated with the object, including the preferred handler, info,
     * and type records plus the entry in the list of types, if they exist.
     * Otherwise, it does nothing and does not return an error.
     *
     * @param aHandlerInfo  the handler info object
     */
    readonly remove: (aHandlerInfo: (nsIHandlerInfo | null)) => void;

    /**
     * Get the MIME type mapped to the given file extension in the datastore.
     *
     * XXX If we ever support extension -> protocol scheme mappings, then this
     * method should work for those as well.
     *
     * Note: in general, you should use nsIMIMEService::getTypeFromExtension
     * to get a MIME type from a file extension, as that method checks a variety
     * of other sources besides just the datastore.  Use this only when you want
     * to specifically get only the mapping available in the datastore.
     *
     * @param aFileExtension  the file extension
     *
     * @returns the MIME type, if any; otherwise returns an empty string ("").
     */
    readonly getTypeFromExtension: (aFileExtension: IDLACString) => IDLACString;

    /**
     * Whether or not there is a handler known to the OS for the
     * specified protocol type.
     *
     * @param aProtocolScheme scheme to check for support
     *
     * @returns whether or not a handler exists
     */
    readonly existsForProtocolOS: (aProtocolScheme: IDLACString) => boolean;

    /**
     * Whether or not there is a handler in the datastore or OS for
     * the specified protocol type. If there is no handler in the datastore,
     * falls back to a check for an OS handler.
     *
     * @param aProtocolScheme scheme to check for support
     *
     * @returns whether or not a handler exists
     */
    readonly existsForProtocol: (aProtocolScheme: IDLACString) => boolean;

    readonly getMIMEInfoFromOS: (aHandlerInfo: (nsIHandlerInfo | null), aMIMEType: IDLACString, aExtension: IDLACString, aFound: Out<boolean>) => void;

    readonly getApplicationDescription: (aProtocolScheme: IDLACString) => IDLAString;
  }

  export interface nsINestedURIMutatorRef {
    readonly name: "nsINestedURIMutator";
    readonly number: "{ca3d6c03-4eee-4271-a97a-d16c0a0b2c5c}";
  }

  export interface nsINestedURIMutator extends nsISupports {
  }

  export interface nsIBrowserElementAPIRef {
    readonly name: "nsIBrowserElementAPI";
    readonly number: "{57758c10-6036-11e5-a837-0800200c9a66}";
  }

  /**
   * Interface to the BrowserElementParent implementation. All methods
   * but setFrameLoader throw when the remote process is dead.
   */
  export interface nsIBrowserElementAPI extends nsISupports {

    /**
     * Notify frame scripts that support the API to destroy.
     */
    readonly destroyFrameScripts: () => void;

    readonly setFrameLoader: (frameLoader: WebIDL.FrameLoader) => void;

    readonly sendMouseEvent: (type: IDLAString, x: number, y: number, button: number, clickCount: number, mifiers: number) => void;

    readonly goBack: () => void;

    readonly goForward: () => void;

    readonly reload: (hardReload: boolean) => void;

    readonly stop: () => void;

    readonly getCanGoBack: () => IDLPromise;

    readonly getCanGoForward: () => IDLPromise;
  }

  export interface nsISupportsIDRef {
    readonly name: "nsISupportsID";
    readonly number: "{d18290a0-4a1c-11d3-9890-006008962422}";
  }

  /**
   * Scriptable storage for nsID structures
   */
  export interface nsISupportsID extends nsISupportsPrimitive {

    readonly toString: () => string;
  }

  export interface nsIGfxInfoRef {
    readonly name: "nsIGfxInfo";
    readonly number: "{1accd618-4c80-4703-9d29-ecf257d397c8}";

    FEATURE_DIRECT2D: 1;

    FEATURE_DIRECT3D_9_LAYERS: 2;

    FEATURE_DIRECT3D_10_LAYERS: 3;

    FEATURE_DIRECT3D_10_1_LAYERS: 4;

    FEATURE_OPENGL_LAYERS: 5;

    FEATURE_WEBGL_OPENGL: 6;

    FEATURE_WEBGL_ANGLE: 7;

    FEATURE_WEBGL_MSAA: 8;

    FEATURE_STAGEFRIGHT: 9;

    FEATURE_WEBRTC_HW_ACCELERATION_H264: 10;

    FEATURE_DIRECT3D_11_LAYERS: 11;

    FEATURE_HARDWARE_VIDEO_DECODING: 12;

    FEATURE_DIRECT3D_11_ANGLE: 13;

    FEATURE_WEBRTC_HW_ACCELERATION_ENCODE: 14;

    FEATURE_WEBRTC_HW_ACCELERATION_DECODE: 15;

    FEATURE_CANVAS2D_ACCELERATION: 16;

    FEATURE_VP8_HW_DECODE: 17;

    FEATURE_VP9_HW_DECODE: 18;

    FEATURE_DX_INTEROP2: 19;

    FEATURE_GPU_PROCESS: 20;

    FEATURE_WEBGL2: 21;

    FEATURE_ADVANCED_LAYERS: 22;

    FEATURE_D3D11_KEYED_MUTEX: 23;

    FEATURE_WEBRENDER: 24;

    FEATURE_DX_NV12: 25;

    FEATURE_DX_P010: 26;

    FEATURE_DX_P016: 27;

    FEATURE_GL_SWIZZLE: 28;

    FEATURE_WEBRENDER_COMPOSITOR: 29;

    FEATURE_MAX_VALUE: 29;

    FEATURE_STATUS_OK: 1;

    FEATURE_STATUS_UNKNOWN: 2;

    FEATURE_BLOCKED_DRIVER_VERSION: 3;

    FEATURE_BLOCKED_DEVICE: 4;

    FEATURE_DISCOURAGED: 5;

    FEATURE_BLOCKED_OS_VERSION: 6;

    FEATURE_BLOCKED_MISMATCHED_VERSION: 7;
  }

  export interface nsIGfxInfo extends nsISupports {

    readonly D2DEnabled: boolean;

    readonly DWriteEnabled: boolean;

    readonly usingGPUProcess: boolean;

    readonly DWriteVersion: IDLAString;

    readonly cleartypeParameters: IDLAString;

    readonly windowProtocol: IDLAString;

    readonly ContentBackend: IDLAString;

    readonly WebRenderEnabled: boolean;

    readonly isHeadless: boolean;

    readonly UsesTiling: boolean;

    readonly ContentUsesTiling: boolean;

    readonly OffMainThreadPaintEnabled: boolean;

    readonly OffMainThreadPaintWorkerCount: number;

    readonly TargetFrameRate: number;

    /**
     * The name of the display adapter.
     */
    readonly adapterDescription: IDLAString;

    readonly adapterDescription2: IDLAString;

    readonly adapterDriver: IDLAString;

    readonly adapterDriver2: IDLAString;

    readonly adapterVendorID: IDLAString;

    readonly adapterVendorID2: IDLAString;

    readonly adapterDeviceID: IDLAString;

    readonly adapterDeviceID2: IDLAString;

    readonly adapterSubsysID: IDLAString;

    readonly adapterSubsysID2: IDLAString;

    /**
     * The amount of RAM in MB in the display adapter.
     */
    readonly adapterRAM: number;

    readonly adapterRAM2: number;

    readonly adapterDriverVendor: IDLAString;

    readonly adapterDriverVendor2: IDLAString;

    readonly adapterDriverVersion: IDLAString;

    readonly adapterDriverVersion2: IDLAString;

    readonly adapterDriverDate: IDLAString;

    readonly adapterDriverDate2: IDLAString;

    readonly isGPU2Active: boolean;

    /**
     * Information about display devices
     */
    readonly displayInfo: IDLAString[];

    readonly displayWidth: number[];

    readonly displayHeight: number[];

    /**
     * Returns an array of objects describing each monitor. Guaranteed properties
     * are "screenWidth" and "screenHeight". This is only implemented on Desktop.
     *
     * Windows additionally supplies "refreshRate" and "pseudoDisplay".
     *
     * OS X additionally supplies "scale".
     */
    readonly getMonitors: () => IDLjsval;

    readonly getFailures: (indices: Out<number[]>) => IDLACString[];

    /**
     * Ask about a feature, and return the status of that feature.
     * If the feature is not ok then aFailureId will give a unique failure Id
     * otherwise it will be empty.
     */
    readonly getFeatureStatus: (aFeature: number, aFailureId?: Out<IDLACString>) => number;

    readonly getFeatureSuggestedDriverVersion: (aFeature: number) => IDLAString;

    readonly getInfo: () => IDLjsval;

    readonly getFeatureLog: () => IDLjsval;

    readonly getFeatures: () => IDLjsval;

    readonly getActiveCrashGuards: () => IDLjsval;

    readonly controlGPUProcessForXPCShell: (aEnable: boolean) => boolean;
  }

  export interface nsIMenuBuilderRef {
    readonly name: "nsIMenuBuilder";
    readonly number: "{93f4a48f-d043-4f45-97fd-9771ea1af976}";
  }

  /**
   * An interface used to construct native toolbar or context menus from <menu>
   */
  export interface nsIMenuBuilder extends nsISupports {

    /**
     * Create the top level menu or a submenu. The implementation should create
     * a new context for this menu, so all subsequent methods will add new items
     * to this newly created menu.
     */
    readonly openContainer: (aLabel: IDLAString) => void;

    /**
     * Add a new menu item. All menu item details can be obtained from
     * the element. This method is not called for hidden elements or elements
     * with no or empty label. The icon should be loaded only if aCanLoadIcon
     * is true.
     */
    readonly addItemFor: (aElement: WebIDL.Element, aCanLoadIcon: boolean) => void;

    /**
     * Create a new separator.
     */
    readonly addSeparator: () => void;

    /**
     * Remove last added separator.
     * Sometimes it's needed to remove last added separator, otherwise it's not
     * possible to implement the postprocessing in one pass.
     * See http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#building-menus-and-toolbars
     */
    readonly undoAddSeparator: () => void;

    /**
     * Set the context to the parent menu.
     */
    readonly closeContainer: () => void;

    /**
     * Returns a JSON string representing the menu hierarchy. For a context menu,
     * it will be of the form:
     *  {
     *    type: "menu",
     *    children: [
     *      {
     *        type: "menuitem",
     *        label: "label",
     *        icon: "image.png"
     *      },
     *      {
     *        type: "separator",
     *      },
     *    ];
     */
    readonly toJSONString: () => IDLAString;

    /**
     * Invoke the action of the menuitem with assigned id aGeneratedItemId.
     *
     * @param aGeneratedItemId the menuitem id
     */
    readonly click: (aGeneratedItemId: IDLAString) => void;
  }

  export interface nsIAppWindowRef {
    readonly name: "nsIAppWindow";
    readonly number: "{d6d7a014-e28d-4c9d-8727-1cf6d870619b}";

    lowestZ: 0;

    loweredZ: 4;

    normalZ: 5;

    raisedZ: 6;

    highestZ: 9;
  }

  export interface nsIAppWindow extends nsISupports {

    /**
     * The docshell owning the XUL for this window.
     */
    readonly docShell: (nsIDocShell | null);

    /**
     * Indicates if this window is instrinsically sized.
     */
    intrinsicallySized: boolean;

    /**
     * The primary content shell.
     *
     * Note that this is a docshell tree item and therefore can not be assured of
     * what object it is. It could be an editor, a docshell, or a browser object.
     * Or down the road any other object that supports being a DocShellTreeItem
     * Query accordingly to determine the capabilities.
     */
    readonly primaryContentShell: (nsIDocShellTreeItem | null);

    /**
     * In multiprocess case we may not have primaryContentShell but
     * primaryRemoteTab.
     */
    readonly primaryRemoteTab: (nsIRemoteTab | null);

    readonly remoteTabAdded: (aTab: (nsIRemoteTab | null), aPrimary: boolean) => void;

    readonly remoteTabRemoved: (aTab: (nsIRemoteTab | null)) => void;

    /**
     * Tell this window that it has picked up a child XUL window
     * @param aChild the child window being added
     */
    readonly addChildWindow: (aChild: (nsIAppWindow | null)) => void;

    /**
     * Returns the difference between the inner window size (client size) and the
     * outer window size, in CSS pixels.
     */
    readonly outerToInnerHeightDifferenceInCSSPixels: number;

    readonly outerToInnerWidthDifferenceInCSSPixels: number;

    /**
     * Tell this window that it has lost a child XUL window
     * @param aChild the child window being removed
     */
    readonly removeChildWindow: (aChild: (nsIAppWindow | null)) => void;

    /**
     * Move the window to a centered position.
     * @param aRelative If not null, the window relative to which the window is
     *                  moved. See aScreen parameter for details.
     * @param aScreen   PR_TRUE to center the window relative to the screen
     *                  containing aRelative if aRelative is not null. If
     *                  aRelative is null then relative to the screen of the
     *                  opener window if it was initialized by passing it to
     *                  nsWebShellWindow::Initialize. Failing that relative to
     *                  the main screen.
     *                  PR_FALSE to center it relative to aRelative itself.
     * @param aAlert    PR_TRUE to move the window to an alert position,
     *                  generally centered horizontally and 1/3 down from the top.
     */
    readonly center: (aRelative: (nsIAppWindow | null), aScreen: boolean, aAlert: boolean) => void;

    /**
     * Shows the window as a modal window. That is, ensures that it is visible
     * and runs a local event loop, exiting only once the window has been closed.
     */
    readonly showModal: () => void;

    /**
     * Locks the aspect ratio for a window.
     * @param aShouldLock boolean
     */
    readonly lockAspectRatio: (aShouldLock: boolean) => void;

    zLevel: number;

    chromeFlags: number;

    /**
     * Begin assuming |chromeFlags| don't change hereafter, and assert
     * if they do change.  The state change is one-way and idempotent.
     */
    readonly assumeChromeFlagsAreFrozen: () => void;

    /**
     * Create a new window.
     * @param aChromeFlags see nsIWebBrowserChrome
     * @param aOpeningTab the RemoteTab that requested this new window be opened.
     *                    Can be left null.
     * @param aOpener The window which is requesting that this new window be opened.
     * @param aNextRemoteTabId The integer ID of the next remote tab actor to use.
     *        0 means there is no next remote tab actor to use.
     * @return the newly minted window
     */
    readonly createNewWindow: (aChromeFlags: number, aOpeningTab: (nsIRemoteTab | null), aOpener: (mozIDOMWindowProxy | null), aNextRemoteTabId: number) => (nsIAppWindow | null);

    XULBrowserWindow: (nsIXULBrowserWindow | null);
  }

  export interface rrIGraphicsRef {
    readonly name: "rrIGraphics";
    readonly number: "{941b2e20-8558-4881-b5ad-dc3a1f2d9678}";
  }

  export interface rrIGraphics extends nsISupports {

    readonly UpdateCanvas: (buffer: IDLjsval, width: number, height: number) => void;

    readonly ClearCanvas: () => void;
  }

  export interface mozIOSPreferencesRef {
    readonly name: "mozIOSPreferences";
    readonly number: "{65944815-e9ae-48bd-a2bf-f1108720950c}";

    dateTimeFormatStyleNone: 0;

    dateTimeFormatStyleShort: 1;

    dateTimeFormatStyleMedium: 2;

    dateTimeFormatStyleLong: 3;

    dateTimeFormatStyleFull: 4;
  }

  export interface mozIOSPreferences extends nsISupports {

    /**
     * Returns a list of locales used by the host environment for UI
     * localization.
     *
     * The result is a sorted list and we expect that the OS attempts to
     * use the top locale from the list for which it has data.
     *
     * Each element of the list is a valid locale ID that can be passed to ICU
     * and ECMA402 Intl APIs,
     * At the same time each element is a valid BCP47 language tag that can be
     * used for language negotiation.
     *
     * Example: ["en-US", "de", "pl", "sr-Cyrl", "zh-Hans-HK"]
     */
    readonly systemLocales: IDLACString[];

    /**
     * Returns a list of locales used by host environment for regional
     * preferences internationalization.
     *
     * The result is a sorted list and we expect that the OS attempts to
     * use the top locale from the list for which it has data.
     *
     * Each element of the list is a valid locale ID that can be passed to ICU
     * and ECMA402 Intl APIs,
     *
     * Example: ["en-US", "de", "pl", "sr-Cyrl", "zh-Hans-HK"]
     */
    readonly regionalPrefsLocales: IDLACString[];

    /**
     * Returns the best locale that the host environment is localized to.
     *
     * The result is a valid locale ID and it should be
     * used for all APIs that do not handle language negotiation.
     *
     * In any scenario involving language negotiation, systemLocales should
     * be preferred over the single value.
     *
     * Example: "zh-Hans-HK"
     */
    readonly systemLocale: IDLACString;

    /**
     * Returns the best possible date/time pattern for the host environment
     * taking into account date/time regional settings user defined in the OS
     * preferences.
     *
     * Notice, that depending on the OS it may take into account those settings
     * for all locales, or only if the locale matches the OS locale.
     *
     * It takes two integer arguments that must be valid `dateTimeFormatStyle*`
     * values (see constants defined above), and a string representing a
     * BCP47 locale.
     *
     * It returns a string with a LDML date/time pattern.
     *
     * If no pattern can be retrieved from the host environment, it will
     * lookup the best available pattern from ICU.
     *
     * Notice, this is a pretty unique method in this API in that it does
     * more than look up into host environment.
     * The reason for that is that constructing the right date/time pattern
     * requires a lot of OS-specific logic and it ends up being easier to just
     * handle all scenarios, including with cases where we fail to retrieve
     * anything from the OS, here.
     */
    readonly getDateTimePattern: (timeFormatStyle: number, dateFormatStyle: number, locale?: IDLACString) => IDLAString;
  }

  export interface nsIJSURIMutatorRef {
    readonly name: "nsIJSURIMutator";
    readonly number: "{3bd44535-08ea-478f-99b9-85fa1084e820}";
  }

  export interface nsIJSURIMutator extends nsISupports {
  }

  export interface nsICacheVisitorRef {
    readonly name: "nsICacheVisitor";
    readonly number: "{f8c08c4b-d778-49d1-a59b-866fdc500d95}";
  }

  export interface nsICacheVisitor extends nsISupports {

    /**
     * Called to provide information about a cache device.
     *
     * @param deviceID - specifies the device being visited.
     * @param deviceInfo - specifies information about this device.
     *
     * @return true to start visiting all entries for this device.
     * @return false to advance to the next device.
     */
    readonly visitDevice: (deviceID: string, deviceInfo: (nsICacheDeviceInfo | null)) => boolean;

    /**
     * Called to provide information about a cache entry.
     *
     * @param deviceID - specifies the device being visited.
     * @param entryInfo - specifies information about this entry.
     *
     * @return true to visit the next entry on the current device, or if the
     *   end of the device has been reached, advance to the next device.
     * @return false to advance to the next device.
     */
    readonly visitEntry: (deviceID: string, entryInfo: (nsICacheEntryInfo | null)) => boolean;
  }

  export interface IJSDebuggerRef {
    readonly name: "IJSDebugger";
    readonly number: "{a36fa816-31da-4b23-bc97-6412771f0867}";
  }

  /**
   * Do not use this interface. Instead, write:
   *     Components.utils.import("resource://gre/modules/jsdebugger.jsm");
   *     addDebuggerToGlobal(global);
   */
  export interface IJSDebugger extends nsISupports {

    /**
     * Define the global Debugger and RecordReplayControl constructors on a
     * given global.
     */
    readonly addClass: (global: IDLjsval) => void;
  }

  export interface nsIDOMXULControlElementRef {
    readonly name: "nsIDOMXULControlElement";
    readonly number: "{bdc1d047-6d22-4813-bc50-638ccb349c7d}";
  }

  export interface nsIDOMXULControlElement extends nsISupports {

    disabled: boolean;
  }

  export interface nsISensitiveInfoHiddenURIRef {
    readonly name: "nsISensitiveInfoHiddenURI";
    readonly number: "{a5761968-6e1a-4f2d-8191-ec749602b178}";
  }

  export interface nsISensitiveInfoHiddenURI extends nsISupports {

    /**
     * Returns the spec attribute with sensitive information hidden. This will
     * only affect uri with password. The password part of uri will be
     * transformed into "****".
     */
    readonly getSensitiveInfoHiddenSpec: () => IDLAUTF8String;
  }

  export interface nsIEnvironmentRef {
    readonly name: "nsIEnvironment";
    readonly number: "{101d5941-d820-4e85-a266-9a3469940807}";
  }

  /**
   * Scriptable access to the current process environment.
   *
   */
  export interface nsIEnvironment extends nsISupports {

    /**
     * Set the value of an environment variable.
     *
     * @param aName   the variable name to set.
     * @param aValue  the value to set.
     */
    readonly set: (aName: IDLAString, aValue: IDLAString) => void;

    /**
     * Get the value of an environment variable.
     *
     * @param aName   the variable name to retrieve.
     * @return        returns the value of the env variable. An empty string
     *                will be returned when the env variable does not exist or
     *                when the value itself is an empty string - please use
     *                |exists()| to probe whether the env variable exists
     *                or not.
     */
    readonly get: (aName: IDLAString) => IDLAString;

    /**
     * Check the existence of an environment variable.
     * This method checks whether an environment variable is present in
     * the environment or not.
     *
     * - For Unix/Linux platforms we follow the Unix definition:
     * An environment variable exists when |getenv()| returns a non-NULL value.
     * An environment variable does not exist when |getenv()| returns NULL.
     * - For non-Unix/Linux platforms we have to fall back to a
     * "portable" definition (which is incorrect for Unix/Linux!!!!)
     * which simply checks whether the string returned by |Get()| is empty
     * or not.
     *
     * @param aName   the variable name to probe.
     * @return        if the variable has been set, the value returned is
     *                PR_TRUE. If the variable was not defined in the
     *                environment PR_FALSE will be returned.
     */
    readonly exists: (aName: IDLAString) => boolean;
  }

  export interface nsIDNSServiceDiscoveryRef {
    readonly name: "nsIDNSServiceDiscovery";
    readonly number: "{6487899b-beb1-455a-ba65-e4fd465066d7}";
  }

  /**
   * The interface for DNS service discovery/registration/resolve
   */
  export interface nsIDNSServiceDiscovery extends nsISupports {

    /**
     * Browse for instances of a service.
     * @param   aServiceType
     *          the service type to be discovered, E.g. "_http._tcp".
     * @param   aListener
     *          callback interface for discovery notifications.
     * @return  An object that can be used to cancel the service discovery.
     */
    readonly startDiscovery: (aServiceType: IDLAUTF8String, aListener: (nsIDNSServiceDiscoveryListener | null)) => (nsICancelable | null);

    /**
     * Register a service that is discovered via |startDiscovery| and |resolveService| calls.
     * @param   aServiceInfo
     *          the service information to be registered.
     *          |port| and |aServiceType| are required attributes.
     * @param   aListener
     *          callback interface for registration notifications.
     * @return  An object that can be used to cancel the service registration.
     */
    readonly registerService: (aServiceInfo: (nsIDNSServiceInfo | null), aListener: (nsIDNSRegistrationListener | null)) => (nsICancelable | null);

    /**
     * Resolve a service name discovered via |startDiscovery| to a target host name, port number.
     * @param   aServiceInfo
     *          the service information to be registered.
     *          |serviceName|, |aServiceType|, and |domainName| are required attributes as reported to the |onServiceFound| callback.
     * @param   aListener
     *          callback interface for registration notifications.
     */
    readonly resolveService: (aServiceInfo: (nsIDNSServiceInfo | null), aListener: (nsIDNSServiceResolveListener | null)) => void;
  }

  export interface nsINSSComponentRef {
    readonly name: "nsINSSComponent";
    readonly number: "{a0a8f52b-ea18-4abc-a3ca-eccf704ffe63}";
  }

  export interface nsINSSComponent extends nsISupports {

    /**
     * If enabled by the preference "security.enterprise_roots.enabled", returns
     * an array of arrays of bytes representing the imported enterprise root
     * certificates (i.e. root certificates gleaned from the OS certificate
     * store). Returns an empty array otherwise.
     * Currently this is only implemented on Windows and MacOS X, so this
     * function returns an empty array on all other platforms.
     */
    readonly getEnterpriseRoots: () => number[][];

    /**
     * Similarly, but for intermediate certificates.
     */
    readonly getEnterpriseIntermediates: () => number[][];
  }

  export interface nsISDBRequestRef {
    readonly name: "nsISDBRequest";
    readonly number: "{13f05bcf-715c-427e-aac8-df9b2c1ec1e3}";
  }

  export interface nsISDBRequest extends nsISupports {

    readonly result: (nsIVariant | null);

    readonly resultCode: number;

    callback: (nsISDBCallback | null);
  }

  export interface nsIPushServiceRef {
    readonly name: "nsIPushService";
    readonly number: "{678ef584-bf25-47aa-ac84-03efc0865b68}";
  }

  /**
   * A service for components to subscribe and receive push messages from web
   * services. This functionality is exposed to content via the Push DOM API,
   * which uses service workers. This interface exists to support the DOM API,
   * and allows privileged code to receive messages without migrating to service
   * workers.
   */
  export interface nsIPushService extends nsISupports {

    /** Observer topic names, exported for convenience. */
    readonly pushTopic: IDLAString;

    readonly subscriptionChangeTopic: IDLAString;

    readonly subscriptionModifiedTopic: IDLAString;

    /**
     * Creates a push subscription for the given |scope| URL and |principal|.
     * If a subscription already exists for this |(scope, principal)| pair,
     * the callback will receive the existing record as the second argument.
     *
     * The |endpoint| property of the subscription record is a URL string
     * that can be used to send push messages to subscribers.
     *
     * Each incoming message fires a `push-message` observer notification, with
     * an `nsIPushMessage` as the subject and the |scope| as the data.
     *
     * If the server drops a subscription, a `push-subscription-change` observer
     * will be fired, with the subject set to |principal| and the data set to
     * |scope|. Servers may drop subscriptions at any time, so callers should
     * recreate subscriptions if desired.
     */
    readonly subscribe: (scope: IDLAString, principal: (nsIPrincipal | null), callback: (nsIPushSubscriptionCallback | nsIPushSubscriptionCallbackFunction | null)) => void;

    /**
     * Creates a restricted push subscription with the given public |key|. The
     * application server must use the corresponding private key to authenticate
     * message delivery requests, as described in draft-thomson-webpush-vapid.
     */
    readonly subscribeWithKey: (scope: IDLAString, principal: (nsIPrincipal | null), key: number[], callback: (nsIPushSubscriptionCallback | nsIPushSubscriptionCallbackFunction | null)) => void;

    /**
     * Removes a push subscription for the given |scope|.
     */
    readonly unsubscribe: (scope: IDLAString, principal: (nsIPrincipal | null), callback: (nsIUnsubscribeResultCallback | nsIUnsubscribeResultCallbackFunction | null)) => void;

    /**
     * Retrieves the subscription record associated with the given
     * |(scope, principal)| pair. If the subscription does not exist, the
     * callback will receive |null| as the second argument.
     */
    readonly getSubscription: (scope: IDLAString, principal: (nsIPrincipal | null), callback: (nsIPushSubscriptionCallback | nsIPushSubscriptionCallbackFunction | null)) => void;

    /**
     * Drops every subscription for the given |domain|, or all domains if
     * |domain| is "*".
     */
    readonly clearForDomain: (domain: IDLAString, callback: (nsIPushClearResultCallback | nsIPushClearResultCallbackFunction | null)) => void;
  }

  export interface nsIClearSiteDataCallbackRef {
    readonly name: "nsIClearSiteDataCallback";
    readonly number: "{9c311778-7c2c-4ad8-b439-b8a2786a20dd}";
  }

  type nsIClearSiteDataCallbackFunction = (rv: number) => void;

  export interface nsIClearSiteDataCallback extends nsISupports {

    /**
     * callback with the result from a call to clearSiteData
     */
    readonly callback: (rv: number) => void;
  }

  export interface nsIEditorStyleSheetsRef {
    readonly name: "nsIEditorStyleSheets";
    readonly number: "{4805e682-49b9-11d3-9ce4-ed60bd6cb5bc}";
  }

  export interface nsIEditorStyleSheets extends nsISupports {

    /** Load and apply the override style sheet, specified by aURL, to the
     * editor's document, replacing the last override style sheet added (if any).
     * This is always synchronous, so aURL should be a local file with only
     * local @imports. This action is not undoable. It is not intended for
     * "user" style sheets, only for editor developers to add sheets to change
     * display behavior for editing (like showing special cursors) that will
     * not be affected by loading "document" style sheets with addStyleSheet or
     * especially replaceStyleSheet.
     *
     * @param aURL The style sheet to be loaded and applied.
     */
    readonly replaceOverrideStyleSheet: (aURL: IDLAString) => void;

    /** Load and apply an override style sheet, specified by aURL, to
     * the editor's document, on top of any that are already there.
     * This is always synchronous, so the same caveats about local files and no
     * non-local @import as replaceOverrideStyleSheet apply here, too.
     *
     * @param aURL The style sheet to be loaded and applied.
     */
    readonly addOverrideStyleSheet: (aURL: IDLAString) => void;

    /** Remove the given override style sheet from the editor's document
     * This is always synchronous
     *
     * @param aURL The style sheet to be removed.
     */
    readonly removeOverrideStyleSheet: (aURL: IDLAString) => void;

    /** Enable or disable the given style sheet from the editor's document
     * This is always synchronous
     *
     * @param aURL  The style sheet to be enabled or disabled
     * @param aEnable true to enable, or false to disable the style sheet
     */
    readonly enableStyleSheet: (aURL: IDLAString, aEnable: boolean) => void;
  }

  export interface nsIServerTimingRef {
    readonly name: "nsIServerTiming";
    readonly number: "{c2d9e95b-9cc9-4f47-9ef6-1de0cf7ebc75}";
  }

  export interface nsIServerTiming extends nsISupports {

    readonly name: IDLACString;

    readonly duration: number;

    readonly description: IDLACString;
  }

  export interface nsIQuotaManagerServiceRef {
    readonly name: "nsIQuotaManagerService";
    readonly number: "{1b3d0a38-8151-4cf9-89fa-4f92c2ef0e7e}";
  }

  export interface nsIQuotaManagerService extends nsISupports {

    /**
     * Initializes storage directory. This can be used in tests to verify
     * upgrade methods.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    readonly init: () => (nsIQuotaRequest | null);

    /**
     * Initializes temporary storage. This can be used in tests to verify
     * temporary storage initialization.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    readonly initTemporaryStorage: () => (nsIQuotaRequest | null);

    /**
     * Initializes storage directory, temporary storage (if persistence type is
     * default or temporary) and directory for the given origin. This can be used
     * in tests to verify origin initialization.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     *
     * @param aPrincipal
     *        A principal for the origin whose directory is to be initialized.
     * @param aPersistenceType
     *        A string that tells what persistence type of origin will be
     *        initialized.
     * @param aClientType
     *        An optional string that tells what client type of origin will be
     *        initialized.
     */
    readonly initStorageAndOrigin: (aPrincipal: (nsIPrincipal | null), aPersistenceType: IDLACString, aClientType?: IDLAString) => (nsIQuotaRequest | null);

    /**
     * Schedules an asynchronous callback that will inspect all origins and
     * return the total amount of disk space being used by storages for each
     * origin separately.
     *
     * @param aCallback
     *        The callback that will be called when the usage is available.
     * @param aGetAll
     *        An optional boolean to indicate inspection of all origins,
     *        including internal ones.
     */
    readonly getUsage: (aCallback: (nsIQuotaUsageCallback | nsIQuotaUsageCallbackFunction | null), aGetAll?: boolean) => (nsIQuotaUsageRequest | null);

    /**
     * Schedules an asynchronous callback that will return the total amount of
     * disk space being used by storages for the given origin.
     *
     * @param aPrincipal
     *        A principal for the origin whose usage is being queried.
     * @param aCallback
     *        The callback that will be called when the usage is available.
     * @param aFromMemory
     *        An optional flag to indicate whether the cached usage should be
     *        obtained. The default value is false.  Note that this operation may
     *        still be delayed by other operations on the QM I/O thread that are
     *        peforming I/O.
     * Note:  Origin usage here represents total usage of an origin. However,
     *        cached usage here represents only non-persistent usage of an origin.
     */
    readonly getUsageForPrincipal: (aPrincipal: (nsIPrincipal | null), aCallback: (nsIQuotaUsageCallback | nsIQuotaUsageCallbackFunction | null), aFromMemory?: boolean) => (nsIQuotaUsageRequest | null);

    /**
     * Schedules an asynchronous callback that will inspect all origins and
     * just returns the origin strings of origins.
     *
     * @param aCallback
     *        The callback that will be called when the origin is collected.
     */
    readonly listOrigins: (aCallback: (nsIQuotaCallback | nsIQuotaCallbackFunction | null)) => (nsIQuotaRequest | null);

    /**
     * Removes all storages. The files may not be deleted immediately depending
     * on prohibitive concurrent operations.
     * Be careful, this removes *all* the data that has ever been stored!
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    readonly clear: () => (nsIQuotaRequest | null);

    /**
     * Removes all storages stored for the given pattern. The files may not be
     * deleted immediately depending on prohibitive concurrent operations.  In
     * terms of locks, it will get an exclusive multi directory lock for given
     * pattern.  For example, given pattern {"userContextId":1007} and set of 3
     * origins ["http://www.mozilla.org^userContextId=1007",
     * "http://www.example.org^userContextId=1007",
     * "http://www.example.org^userContextId=1008"], the method will only lock 2
     * origins ["http://www.mozilla.org^userContextId=1007",
     * "http://www.example.org^userContextId=1007"].
     *
     * @param aPattern
     *        A pattern for the origins whose storages are to be cleared.
     *        Currently this is expected to be a JSON representation of the
     *        OriginAttributesPatternDictionary defined in ChromeUtils.webidl.
     */
    readonly clearStoragesForOriginAttributesPattern: (aPattern: IDLAString) => (nsIQuotaRequest | null);

    /**
     * Removes all storages stored for the given principal. The files may not be
     * deleted immediately depending on prohibitive concurrent operations.
     *
     * @param aPrincipal
     *        A principal for the origin whose storages are to be cleared.
     * @param aPersistenceType
     *        An optional string that tells what persistence type of storages
     *        will be cleared.  If omitted (or void), all persistence types will
     *        be cleared for the principal.  If a single persistence type
     *        ("persistent", "temporary", or "default") is provided, then only
     *        that persistence directory will be considered.  Note that
     *        "persistent" is different than being "persisted" via persist() and
     *        is only for chrome principals.  See bug 1354500 for more info.
     *        In general, null is the right thing to pass here.
     * @param aClientType
     *        An optional string that tells what client type of storages
     *        will be cleared.  If omitted (or void), all client types will be
     *        cleared for the principal.  If a single client type is provided
     *        from Client.h, then only that client's storage will be cleared.
     *        If you want to clear multiple client types (but not all), then you
     *        must call this method multiple times.
     * @param aClearAll
     *        An optional boolean to indicate clearing all storages under the
     *        given origin.
     */
    readonly clearStoragesForPrincipal: (aPrincipal: (nsIPrincipal | null), aPersistenceType?: IDLACString, aClientType?: IDLAString, aClearAll?: boolean) => (nsIQuotaRequest | null);

    /**
     * Resets quota and storage management. This can be used to force
     * reinitialization of the temp storage, for example when the pref for
     * overriding the temp storage limit has changed.
     * Be carefull, this invalidates all live storages!
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     */
    readonly reset: () => (nsIQuotaRequest | null);

    /**
     * Resets all storages stored for the given principal.
     *
     * If the dom.quotaManager.testing preference is not true the call will be
     * a no-op.
     *
     * @param aPrincipal
     *        A principal for the origin whose storages are to be reset.
     * @param aPersistenceType
     *        An optional string that tells what persistence type of storages
     *        will be reset.  If omitted (or void), all persistence types will
     *        be cleared for the principal.  If a single persistence type
     *        ("persistent", "temporary", or "default") is provided, then only
     *        that persistence directory will be considered.  Note that
     *        "persistent" is different than being "persisted" via persist() and
     *        is only for chrome principals.  See bug 1354500 for more info.
     *        In general, null is the right thing to pass here.
     * @param aClientType
     *        An optional string that tells what client type of storages
     *        will be reset.  If omitted (or void), all client types will be
     *        cleared for the principal.  If a single client type is provided
     *        from Client.h, then only that client's storage will be cleared.
     *        If you want to clear multiple client types (but not all), then you
     *        must call this method multiple times.
     * @param aResetAll
     *        An optional boolean to indicate resetting all storages under the
     *        given origin.
     */
    readonly resetStoragesForPrincipal: (aPrincipal: (nsIPrincipal | null), aPersistenceType?: IDLACString, aClientType?: IDLAString, aResetAll?: boolean) => (nsIQuotaRequest | null);

    /**
     * Check if given origin is persisted.
     *
     * @param aPrincipal
     *        A principal for the origin which we want to check.
     */
    readonly persisted: (aPrincipal: (nsIPrincipal | null)) => (nsIQuotaRequest | null);

    /**
     * Persist given origin.
     *
     * @param aPrincipal
     *        A principal for the origin which we want to persist.
     */
    readonly persist: (aPrincipal: (nsIPrincipal | null)) => (nsIQuotaRequest | null);

    /**
     * Given an origin, asynchronously calculate its group quota usage and quota
     * limit. An origin's group is the set of all origins that share the same
     * eTLD+1. This method is intended to be used for our implementation of the
     * StorageManager.estimate() method. When we fix bug 1305665 and stop tracking
     * quota limits on a group basis, this method will switch to operating on
     * origins. Callers should strongly consider whether they want to be using
     * getUsageForPrincipal() instead.
     *
     * This mechanism uses cached quota values and does not perform any I/O on its
     * own, but it may be delayed by QuotaManager operations that do need to
     * perform I/O on the QuotaManager I/O thread.
     *
     * @param aPrincipal
     *        A principal for the origin (group) which we want to estimate.
     */
    readonly estimate: (aPrincipal: (nsIPrincipal | null)) => (nsIQuotaRequest | null);
  }

  export interface nsILocalFileWinRef {
    readonly name: "nsILocalFileWin";
    readonly number: "{e7a3a954-384b-4aeb-a5f7-55626b0de9be}";

    /**
     * Windows specific file attributes.
     */
    WFA_SEARCH_INDEXED: 1;

    WFA_READONLY: 2;

    WFA_READWRITE: 4;
  }

  export interface nsILocalFileWin extends nsIFile {

    /**
     *  initWithCommandLine
     *
     *  Initialize this object based on the main app path of a commandline
     *  handler.
     *
     *   @param aCommandLine
     *       the commandline to parse an app path out of.
     */
    readonly initWithCommandLine: (aCommandLine: IDLAString) => void;

    /**
     * getVersionInfoValue
     *
     * Retrieve a metadata field from the file's VERSIONINFO block.
     * Throws NS_ERROR_FAILURE if no value is found, or the value is empty.
     *
     * @param   aField         The field to look up.
     *
     */
    readonly getVersionInfoField: (aField: string) => IDLAString;

    /**
     * The canonical path of the file, which avoids short/long
     * pathname inconsistencies. The nsIFile persistent
     * descriptor is not guaranteed to be canonicalized (it may
     * persist either the long or the short path name). The format of
     * the canonical path will vary with the underlying file system:
     * it will typically be the short pathname on filesystems that
     * support both short and long path forms.
     */
    readonly canonicalPath: IDLAString;

    /**
     * fileAttributesWin
     *
     * Set or get windows specific file attributes.
     *
     * Throws NS_ERROR_FILE_INVALID_PATH for an invalid file.
     * Throws NS_ERROR_FAILURE if the set or get fails.
     */
    fileAttributesWin: number;
  }

  export interface nsITextInputProcessorCallbackRef {
    readonly name: "nsITextInputProcessorCallback";
    readonly number: "{23d5f242-adb5-46f1-8766-90d1bf0383df}";
  }

  type nsITextInputProcessorCallbackFunction = (aTextInputProcessor: (nsITextInputProcessor | null), aNotification: (nsITextInputProcessorNotification | null)) => boolean;

  /**
   * nsITextInputProcessorCallback is a callback interface for JS to implement
   * IME.  IME implemented by JS can implement onNotify() function and must send
   * it to nsITextInputProcessor at initializing.  Then, onNotify() will be
   * called with nsITextInputProcessorNotification instance.
   * The reason why onNotify() uses string simply is that if we will support
   * other notifications such as text changes and selection changes, we need to
   * notify IME of some other information.  Then, only changing
   * nsITextInputProcessorNotification interface is better for compatibility.
   */
  export interface nsITextInputProcessorCallback extends nsISupports {

    /**
     * When Gecko notifies IME of something or requests something to IME,
     * this is called.
     *
     * @param aTextInputProcessor Reference to the nsITextInputProcessor service
     *                            which is the original receiver of the request
     *                            or notification.
     * @param aNotification       Stores type of notifications and additional
     *                            information.
     * @return                    Return true if it succeeded or does nothing.
     *                            Otherwise, return false.
     *
     * Example #1 The simplest implementation of nsITextInputProcessorCallback is:
     *
     *   function simpleCallback(aTIP, aNotification)
     *   {
     *     try {
     *       switch (aNotification.type) {
     *         case "request-to-commit":
     *           aTIP.commitComposition();
     *           break;
     *         case "request-to-cancel":
     *           aTIP.cancelComposition();
     *           break;
     *       }
     *     } catch (e) {
     *       return false;
     *     }
     *     return true;
     *   }
     *
     *   var TIP = Components.classes["@mozilla.org/text-input-processor;1"].
     *               createInstance(Components.interfaces.nsITextInputProcessor);
     *   if (!TIP.init(window, simpleCallback)) {
     *     return;
     *   }
     */
    readonly onNotify: (aTextInputProcessor: (nsITextInputProcessor | null), aNotification: (nsITextInputProcessorNotification | null)) => boolean;
  }

  export interface nsIContentPermissionRequesterRef {
    readonly name: "nsIContentPermissionRequester";
    readonly number: "{f8577124-6a5f-486f-ae04-c5bcae911eb5}";
  }

  /**
   *  Interface provides the way to get the visibility and
   *  the notification.
   */
  export interface nsIContentPermissionRequester extends nsISupports {

    /**
     * The function to get the visibility.
     */
    readonly getVisibility: (callback: (nsIContentPermissionRequestCallback | null)) => void;

    /**
     * The callback to get the notification of visibility change.
     */
    onVisibilityChange: (nsIContentPermissionRequestCallback | null);
  }

  export interface nsIFileStreamRef {
    readonly name: "nsIFileStream";
    readonly number: "{82cf605a-8393-4550-83ab-43cd5578e006}";

    /**
     * See the same constant in nsIFileInputStream. The deferred open will
     * be performed when one of the following is called:
     *   - Seek
     *   - Tell
     *   - SetEOF
     *   - Available
     *   - Read
     *   - Flush
     *   - Write
     *   - GetSize
     *   - GetLastModified
     *
     * @note Using this flag results in the file not being opened
     *       during the call to Init.  This means that any errors that might
     *       happen when this flag is not set would happen during the
     *       first read or write. The file is not locked when Init is called,
     *       so it might be deleted before we try to read from it and if the
     *       file is to be created, then it will not appear on the disk until
     *       the first write.
     */
    DEFER_OPEN: 1;
  }

  /**
   * A stream that allows you to read from a file or stream to a file.
   */
  export interface nsIFileStream extends nsISupports {

    /**
     * @param file          file to read from or stream to
     * @param ioFlags       file open flags listed in prio.h (see
     *                      PR_Open documentation) or -1 to open the
     *                      file in default mode (PR_RDWR).
     * @param perm          file mode bits listed in prio.h or -1 to
     *                      use the default value (0)
     * @param behaviorFlags flags specifying various behaviors of the class
     *        (see enumerations in the class)
     */
    readonly init: (file: (nsIFile | null), ioFlags: number, perm: number, behaviorFlags: number) => void;
  }

  export interface mozIStorageVacuumParticipantRef {
    readonly name: "mozIStorageVacuumParticipant";
    readonly number: "{8f367508-1d9a-4d3f-be0c-ac11b6dd7dbf}";
  }

  /**
   * This interface contains the information that the Storage service needs to
   * vacuum a database.  This interface is created as a service through the
   * category manager with the category "vacuum-participant".
   * Please see https://developer.mozilla.org/en/mozIStorageVacuumParticipant for
   * more information.
   */
  export interface mozIStorageVacuumParticipant extends nsISupports {

    /**
     * The expected page size in bytes for the database.  The vacuum manager will
     * try to correct the page size during idle based on this value.
     *
     * @note If the database is using the WAL journal mode, the page size won't
     *        be changed to the requested value.  See bug 634374.
     * @note Valid page size values are powers of 2 between 512 and 65536.
     *       The suggested value is mozIStorageConnection::defaultPageSize.
     */
    readonly expectedDatabasePageSize: number;

    /**
     * Connection to the database file to be vacuumed.
     */
    readonly databaseConnection: (mozIStorageConnection | null);

    /**
     * Notifies when a vacuum operation begins.  Listeners should avoid using the
     * database till onEndVacuum is received.
     *
     * @return true to proceed with the vacuum, false if the participant wants to
     *         opt-out for now, it will be retried later.  Useful when participant
     *         is running some other heavy operation that can't be interrupted.
     *
     * @note When a vacuum operation starts or ends it will also dispatch a global
     *       "heavy-io-task" notification through the observer service with the
     *       data argument being either "vacuum-begin" or "vacuum-end".
     */
    readonly onBeginVacuum: () => boolean;

    /**
     * Notifies when a vacuum operation ends.
     *
     * @param aSucceeded
     *        reports if the vacuum succeeded or failed.
     */
    readonly onEndVacuum: (aSucceeded: boolean) => void;
  }

  export interface nsITokenDialogsRef {
    readonly name: "nsITokenDialogs";
    readonly number: "{a1cbc159-468c-495d-8068-61dd538cbcca}";
  }

  export interface nsITokenDialogs extends nsISupports {

    /**
     * Displays notification dialog to the user that they are expected to
     * authenticate to the token using its "protected authentication path" feature.
     */
    readonly displayProtectedAuth: (ctx: (nsIInterfaceRequestor | null), runnable: (nsIProtectedAuthThread | null)) => void;
  }

  export interface nsIQuotaOriginsResultRef {
    readonly name: "nsIQuotaOriginsResult";
    readonly number: "{5d8c2fbe-9ccc-4bab-8f03-8591dfc8e351}";
  }

  export interface nsIQuotaOriginsResult extends nsISupports {

    readonly origin: IDLACString;
  }

  export interface nsIProtocolHandlerRef {
    readonly name: "nsIProtocolHandler";
    readonly number: "{a87210e6-7c8c-41f7-864d-df809015193e}";

    /**************************************************************************
     * Constants for the protocol flags (the first is the default mask, the
     * others are deviations):
     *
     * NOTE: Implementation must ignore any flags they do not understand.
     */
    /**
     * standard full URI with authority component and concept of relative
     * URIs (http, ftp, ...)
     */
    URI_STD: 0;

    /**
     * no concept of relative URIs (about, javascript, finger, ...)
     */
    URI_NORELATIVE: 1;

    /**
     * no authority component (file, ...)
     */
    URI_NOAUTH: 2;

    /**
     * This protocol handler can be proxied via a proxy (socks or http)
     * (e.g., irc, smtp, http, etc.).  If the protocol supports transparent
     * proxying, the handler should implement nsIProxiedProtocolHandler.
     *
     * If it supports only HTTP proxying, then it need not support
     * nsIProxiedProtocolHandler, but should instead set the ALLOWS_PROXY_HTTP
     * flag (see below).
     *
     * @see nsIProxiedProtocolHandler
     */
    ALLOWS_PROXY: 4;

    /**
     * This protocol handler can be proxied using a http proxy (e.g., http,
     * ftp, etc.).  nsIIOService::newChannelFromURI will feed URIs from this
     * protocol handler to the HTTP protocol handler instead.  This flag is
     * ignored if ALLOWS_PROXY is not set.
     */
    ALLOWS_PROXY_HTTP: 8;

    /**
     * The URIs for this protocol have no inherent security context, so
     * documents loaded via this protocol should inherit the security context
     * from the document that loads them.
     */
    URI_INHERITS_SECURITY_CONTEXT: 16;

    /**
     * "Automatic" loads that would replace the document (e.g. <meta> refresh,
     * certain types of XLinks, possibly other loads that the application
     * decides are not user triggered) are not allowed if the originating (NOT
     * the target) URI has this protocol flag.  Note that the decision as to
     * what constitutes an "automatic" load is made externally, by the caller
     * of nsIScriptSecurityManager::CheckLoadURI.  See documentation for that
     * method for more information.
     *
     * A typical protocol that might want to set this flag is a protocol that
     * shows highly untrusted content in a viewing area that the user expects
     * to have a lot of control over, such as an e-mail reader.
     */
    URI_FORBIDS_AUTOMATIC_DOCUMENT_REPLACEMENT: 32;

    /**
     * +-------------------------------------------------------------------+
     * |                                                                   |
     * |  ALL PROTOCOL HANDLERS MUST SET ONE OF THE FOLLOWING FIVE FLAGS.  |
     * |                                                                   |
     * +-------------------------------------------------------------------+
     *
     * These flags are used to determine who is allowed to load URIs for this
     * protocol.  Note that if a URI is nested, only the flags for the
     * innermost URI matter.  See nsINestedURI.
     *
     * If none of these five flags are set, the URI must be treated as if it
     * had the URI_LOADABLE_BY_ANYONE flag set, for compatibility with protocol
     * handlers written against Gecko 1.8 or earlier.  In this case, there may
     * be run-time warning messages indicating that a "default insecure"
     * assumption is being made.  At some point in the futures (Mozilla 2.0,
     * most likely), these warnings will become errors.
     */
    /**
     * The URIs for this protocol can be loaded by anyone.  For example, any
     * website should be allowed to trigger a load of a URI for this protocol.
     * Web-safe protocols like "http" should set this flag.
     */
    URI_LOADABLE_BY_ANYONE: 64;

    /**
     * The URIs for this protocol are UNSAFE if loaded by untrusted (web)
     * content and may only be loaded by privileged code (for example, code
     * which has the system principal).  Various internal protocols should set
     * this flag.
     */
    URI_DANGEROUS_TO_LOAD: 128;

    /**
     * The URIs for this protocol point to resources that are part of the
     * application's user interface.  There are cases when such resources may
     * be made accessible to untrusted content such as web pages, so this is
     * less restrictive than URI_DANGEROUS_TO_LOAD but more restrictive than
     * URI_LOADABLE_BY_ANYONE.  See the documentation for
     * nsIScriptSecurityManager::CheckLoadURI.
     */
    URI_IS_UI_RESOURCE: 256;

    /**
     * Loading of URIs for this protocol from other origins should only be
     * allowed if those origins should have access to the local filesystem.
     * It's up to the application to decide what origins should have such
     * access.  Protocols like "file" that point to local data should set this
     * flag.
     */
    URI_IS_LOCAL_FILE: 512;

    /**
     * The URIs for this protocol can be loaded only by callers with a
     * principal that subsumes this uri. For example, privileged code and
     * websites that are same origin as this uri.
     */
    URI_LOADABLE_BY_SUBSUMERS: 1024;

    /**
     * Channels using this protocol never call OnDataAvailable
     * on the listener passed to AsyncOpen and they therefore
     * do not return any data that we can use.
     */
    URI_DOES_NOT_RETURN_DATA: 2048;

    /**
     * URIs for this protocol are considered to be local resources.  This could
     * be a local file (URI_IS_LOCAL_FILE), a UI resource (URI_IS_UI_RESOURCE),
     * or something else that would not hit the network.
     */
    URI_IS_LOCAL_RESOURCE: 4096;

    /**
     * URIs for this protocol execute script when they are opened.
     */
    URI_OPENING_EXECUTES_SCRIPT: 8192;

    /**
     * Loading channels from this protocol has side-effects that make
     * it unsuitable for saving to a local file.
     */
    URI_NON_PERSISTABLE: 16384;

    /**
     * URIs for this protocol require the webapps permission on the principal
     * when opening URIs for a different domain. See bug#773886
     */
    URI_CROSS_ORIGIN_NEEDS_WEBAPPS_PERM: 32768;

    /**
     * Channels for this protocol don't need to spin the event loop to handle
     * Open() and reads on the resulting stream.
     */
    URI_SYNC_LOAD_IS_OK: 65536;

    /**
     * All the origins whose URI has this scheme are considered potentially
     * trustworthy.
     * Per the SecureContext spec, https: and wss: should be considered
     * a priori secure, and implementations may consider other,
     * implementation-specific URI schemes as secure.
     */
    URI_IS_POTENTIALLY_TRUSTWORTHY: 131072;

    /**
     * This URI may be fetched and the contents are visible to anyone. This is
     * semantically equivalent to the resource being served with all-access CORS
     * headers.
     */
    URI_FETCHABLE_BY_ANYONE: 262144;

    /**
     * If this flag is set, then the origin for this protocol is the full URI
     * spec, not just the scheme + host + port.
     *
     * Note: this is not supported in Firefox.  It is currently only available
     * in Thunderbird and SeaMonkey.
     */
    ORIGIN_IS_FULL_SPEC: 524288;

    /**
     * If this flag is set, the URI does not always allow content using the same
     * protocol to link to it.
     */
    URI_SCHEME_NOT_SELF_LINKABLE: 1048576;

    /**
     * The URIs for this protocol can be loaded by extensions.
     */
    URI_LOADABLE_BY_EXTENSIONS: 2097152;

    /**
     * The URIs for this protocol can not be loaded into private contexts.
     */
    URI_DISALLOW_IN_PRIVATE_CONTEXT: 4194304;

    /**
     * This protocol handler forbids accessing cookies e.g. for mail related
     * protocols. Only used in Mailnews (comm-central).
     */
    URI_FORBIDS_COOKIE_ACCESS: 8388608;
  }

  /**
   * nsIProtocolHandler
   */
  export interface nsIProtocolHandler extends nsISupports {

    /**
     * The scheme of this protocol (e.g., "file").
     */
    readonly scheme: IDLACString;

    /**
     * The default port is the port that this protocol normally uses.
     * If a port does not make sense for the protocol (e.g., "about:")
     * then -1 will be returned.
     */
    readonly defaultPort: number;

    /**
     * Returns the protocol specific flags (see flag definitions below).
     */
    readonly protocolFlags: number;

    /**
     * Constructs a new channel from the given URI for this protocol handler and
     * sets the loadInfo for the constructed channel.
     */
    readonly newChannel: (aURI: (nsIURI | null), aLoadinfo: (nsILoadInfo | null)) => (nsIChannel | null);

    /**
     * Allows a protocol to override blacklisted ports.
     *
     * This method will be called when there is an attempt to connect to a port
     * that is blacklisted.  For example, for most protocols, port 25 (Simple Mail
     * Transfer) is banned.  When a URI containing this "known-to-do-bad-things"
     * port number is encountered, this function will be called to ask if the
     * protocol handler wants to override the ban.
     */
    readonly allowPort: (port: number, scheme: string) => boolean;
  }

  export interface nsINavHistoryContainerResultNodeRef {
    readonly name: "nsINavHistoryContainerResultNode";
    readonly number: "{3e9cc95f-0d93-45f1-894f-908eeb9866d7}";

    STATE_CLOSED: 0;

    STATE_LOADING: 1;

    STATE_OPENED: 2;
  }

  export interface nsINavHistoryContainerResultNode extends nsINavHistoryResultNode {

    /**
     * Base class for container results. This includes all types of groupings.
     * Bookmark folders and places queries will be QueryResultNodes which extends
     * these items.
     */
    /**
     * Set this to allow descent into the container. When closed, attempting
     * to call getChildren or childCount will result in an error. You should
     * set this to false when you are done reading.
     *
     * For HOST and DAY groupings, doing this is free since the children have
     * been precomputed. For queries and bookmark folders, being open means they
     * will keep themselves up-to-date by listening for updates and re-querying
     * as needed.
     */
    containerOpen: boolean;

    /**
     * Indicates whether the container is closed, loading, or opened.  Loading
     * implies that the container has been opened asynchronously and has not yet
     * fully opened.
     */
    readonly state: number;

    /**
     * This indicates whether this node "may" have children, and can be used
     * when the container is open or closed. When the container is closed, it
     * will give you an exact answer if the node can easily be populated (for
     * example, a bookmark folder). If not (for example, a complex history query),
     * it will return true. When the container is open, it will always be
     * accurate. It is intended to be used to see if we should draw the "+" next
     * to a tree item.
     */
    readonly hasChildren: boolean;

    /**
     * This gives you the children of the nodes. It is preferrable to use this
     * interface over the array one, since it avoids creating an nsIArray object
     * and the interface is already the correct type.
     *
     * @throws NS_ERROR_NOT_AVAILABLE if containerOpen is false.
     */
    readonly childCount: number;

    readonly getChild: (aIndex: number) => (nsINavHistoryResultNode | null);

    /**
     * Get the index of a direct child in this container.
     *
     * @param aNode
     *        a result node.
     *
     * @return aNode's index in this container.
     * @throws NS_ERROR_NOT_AVAILABLE if containerOpen is false.
     * @throws NS_ERROR_INVALID_ARG if aNode isn't a direct child of this
     * container.
     */
    readonly getChildIndex: (aNode: (nsINavHistoryResultNode | null)) => number;
  }

  export interface nsIUrlClassifierFeatureResultRef {
    readonly name: "nsIUrlClassifierFeatureResult";
    readonly number: "{ccb88140-5d66-4873-9815-a1b98d6cdc92}";
  }

  /**
   * The result of the classifier operation is this interface.
   * See asyncClassifyLocalWithFeatures() in nsIURIClassifier.idl.
   */
  export interface nsIUrlClassifierFeatureResult extends nsISupports {

    readonly uri: (nsIURI | null);

    readonly feature: (nsIUrlClassifierFeature | null);

    readonly list: IDLACString;
  }

  export interface nsIAsyncShutdownCompletionCallbackRef {
    readonly name: "nsIAsyncShutdownCompletionCallback";
    readonly number: "{910c9309-1da0-4dd0-8bdb-a325a38c604e}";
  }

  type nsIAsyncShutdownCompletionCallbackFunction = () => void;

  /**
   * Callback invoked once all blockers of a barrier have been removed.
   */
  export interface nsIAsyncShutdownCompletionCallback extends nsISupports {

    /**
     * The operation has been completed.
     */
    readonly done: () => void;
  }
}
