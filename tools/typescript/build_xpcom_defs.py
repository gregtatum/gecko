# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, # You can obtain one at http://mozilla.org/MPL/2.0/.

import os
import sys
import argparse
from traceback import print_exc
import tempfile
from shutil import rmtree
import logging

from xpidl import xpidl

# Setup the logging.
LOG = logging.getLogger(__name__)
LOG.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
handler.setLevel(logging.DEBUG)
LOG.addHandler(handler)

idl_header = """/// <reference path="types.d.ts" />
/// <reference path="../webidl/webidl.d.ts" />
/*
 * DO NOT EDIT. THIS FILE IS AUTOMATICALLY GENERATED.
 */

declare namespace XPCOM {
"""

idl_footer = """
}
"""

lists_header = """/// <reference path="idl.d.ts" />
/*
 * DO NOT EDIT. THIS FILE IS AUTOMATICALLY GENERATED.
 */

declare namespace XPCOM {
"""

lists_footer = """
}
"""

# Some IDLs use JavaScript keywords. This map will rewrite the names to something safe.
NAMEMAP = {
    'debugger': 'aDebugger',
    'function': 'aFunction',
}

def js_name(name):
    return NAMEMAP.get(name, name)

# This map converts IDL types into valid TypeScript types.
BUILTINS = {
    'boolean': 'boolean',
    'void': 'void',
    'octet': 'number',
    'short': 'number',
    'long': 'number',
    'long long': 'number',
    'unsigned short': 'number',
    'unsigned long': 'number',
    'unsigned long long': 'number',
    'float': 'number',
    'double': 'number',
    'char': 'string',
    'string': 'string',
    'wchar': 'string',
    'wstring': 'string',
}

NATIVES = [
    'AString',
    'ACString',
    'AUTF8String',
    'jsval',
    'Promise',
]

def is_scriptable(idl_type):
    if idl_type is None:
        return False

    if isinstance(idl_type, xpidl.Interface):
        return idl_type.attributes.scriptable and not idl_type.attributes.noscript

    if isinstance(idl_type, xpidl.Method) or isinstance(idl_type, xpidl.Attribute):
        return not idl_type.noscript and not idl_type.notxpcom

    if isinstance(idl_type, xpidl.Native):
        if idl_type.name in NATIVES:
             return True
        if idl_type.name == 'nsDocShellLoadStatePtr':
            return False
        return not idl_type.isPtr(None) and not idl_type.isRef(None)

    if isinstance(idl_type, xpidl.Array):
        return is_scriptable(idl_type.type)

    if isinstance(idl_type, xpidl.LegacyArray):
        return is_scriptable(idl_type.type)

    return True

def js_type(idl_type, resolve_function = False):
    if not is_scriptable(idl_type):
        raise Exception("How did we get here?")

    if isinstance(idl_type, InterfaceReference) or isinstance(idl_type, InterfaceFromReference):
        return idl_type.name

    if isinstance(idl_type, xpidl.WebIDL):
        return 'WebIDL.%s' % idl_type.name

    if isinstance(idl_type, xpidl.Interface):
        if resolve_function and idl_type.attributes.function:
            return '(%s | %sFunction | null)' % (idl_type.name, idl_type.name)
        return '(%s | null)' % idl_type.name

    if isinstance(idl_type, xpidl.Builtin):
        if idl_type.name in BUILTINS:
            return BUILTINS.get(idl_type.name)
        print('Unknown builtin %s' % idl_type.name)
        return idl_type.name

    if isinstance(idl_type, xpidl.Native):
        return 'IDL%s' % idl_type.name

    if isinstance(idl_type, xpidl.Array) or isinstance(idl_type, xpidl.LegacyArray):
        return '%s[]' % js_type(idl_type.type, resolve_function)

    if isinstance(idl_type, xpidl.CEnum):
        return idl_type.name

    if isinstance(idl_type, str):
        print('Unknown string type: %s' % idl_type)
        return idl_type

    print('Unknown type: %s' % repr(idl_type))
    return idl_type.name

def build_comments(production, prefix = True):
    if production.doccomments is None:
        return []

    lines = []
    for doccomment in production.doccomments:
        comment_lines = list(map(lambda l: l.rstrip(), doccomment.split('\n')))
        while len(comment_lines) > 0 and len(comment_lines[0]) == 0:
            comment_lines.pop(0)
        while len(comment_lines) > 0 and len(comment_lines[-1]) == 0:
            comment_lines.pop()
        if len(comment_lines) == 0:
            continue

        if comment_lines[0][0:2] == '/*' and \
           all(map(lambda p: len(comment_lines[p].lstrip()) == 0 or comment_lines[p].lstrip()[0] == '*', range(1, len(comment_lines)))):
            for line in range(1, len(comment_lines)):
                comment_lines[line] = ' %s' % comment_lines[line].lstrip()

        lines.extend(comment_lines)

    if prefix:
        lines.insert(0, '')
    return lines

def indent(lines, depth):
    if not isinstance(lines, list):
        return indent([lines], depth)[0]
    return list(map(lambda l: (l.rjust(len(l) + depth) if len(l) > 0 else ''), lines))

class InterfaceReference:
    def __init__(self, generic):
        self.generic = generic

    @property
    def name(self):
        return chr(self.generic.id + 65)

class InterfaceFromReference:
    def __init__(self, generic):
        self.generic = generic

    @property
    def name(self):
        return 'InterfaceFor<%s>' % chr(self.generic.id + 65)

GENERIC_COUNT = 0
class Generic:
    def __init__(self):
        global GENERIC_COUNT

        self.id = GENERIC_COUNT
        GENERIC_COUNT += 1

    def __str__(self):
        return '%s extends InterfaceRef' % chr(self.id + 65)

class InterfaceDefinition:
    def __init__(self, idl):
        self.idl = idl
        self.name = idl.name

    def members(self, type):
        for member in list(self.idl.members):
            if isinstance(member, type):
                yield member

    def resolve_method(self, method, manager):
        if not is_scriptable(method):
            self.idl.members.remove(method)
            return

        method.realtype = manager.resolve_type(method.realtype)

        if not is_scriptable(method.realtype):
            self.idl.members.remove(method)
            return

        optional = False
        method.generics = []
        for param in method.params:
            if optional:
                param.optional = True
            elif param.optional:
                optional = True
            param.name = js_name(param.name)
            if param.iid_is is not None:
                generic = Generic()
                method.generics.append(generic)
                param.realtype = InterfaceFromReference(generic)
                for iid_param in method.params:
                    if iid_param.name == param.iid_is:
                        iid_param.realtype = InterfaceReference(generic)
            else:
                param.realtype = manager.resolve_type(param.realtype)
                if not is_scriptable(param.realtype):
                    self.idl.members.remove(method)
                    return

        if js_type(method.realtype) == 'void' and len(method.params) > 0 and method.params[-1].retval:
            method.realtype = method.params.pop().realtype

        if len(method.params) > 0 and method.params[-1].size_is is not None:
            method.params.pop()

    def resolve(self, manager):
        for attr in self.members(xpidl.Attribute):
            if not is_scriptable(attr):
                self.idl.members.remove(attr)
                continue
            attr.realtype = manager.resolve_type(attr.realtype)
            if not is_scriptable(attr.realtype):
                self.idl.members.remove(attr)

        for method in self.members(xpidl.Method):
            self.resolve_method(method, manager)

        if len(list(self.members(xpidl.Method))) == 0:
            self.idl.attributes.function = False

    def build_method(self, method):
        def build_param(param):
            optional = ''
            if param.optional:
                optional = '?'

            if param.name == 'default':
                # "default" is a reserved word in TypeScript and will create a type
                # error. Rename it to something that won't break.
                param.name = 'defaultValue'

            if param.paramtype == 'in':
                param_type = js_type(param.realtype, True)
            elif param.paramtype == 'out':
                param_type = 'Out<%s>' % js_type(param.realtype)
            elif param.paramtype == 'inout':
                param_type = 'InOut<%s>' % js_type(param.realtype)

            return '%s%s: %s' % (param.name, optional, param_type)

        generics = ''
        if len(method.generics) > 0:
            generics = '<%s>' % ', '.join([g.__str__() for g in method.generics])
        params = map(build_param, method.params)
        return '%s(%s) => %s' % (generics, ', '.join(params), js_type(method.realtype))

    def build_method_interface(self, method):
        return 'type %sFunction = %s;' % (self.name, self.build_method(method))

    def build_method_property(self, method):
        return 'readonly %s: %s;' % (method.name, self.build_method(method))

    def build_const(self, const):
        return '%s: %s;' % (const.name, const.value(const.iface))

    def build_attribute(self, attr):
        readonly = ''
        if attr.readonly:
            readonly = 'readonly '
        return '%s%s: %s;' % (readonly, attr.name, js_type(attr.realtype))

    def build_cenum(self, enum):
        result = []
        result.append('export enum %s {' % enum.name)
        for variant in enum.variants:
            result.append('  %s = %s,' % (variant.name, variant.value))
        result.append('}')
        return result

    def build_cenum_variants(self, enum):
        result = []
        for variant in enum.variants:
            result.append('%s: %s;' % (variant.name, variant.value))
        return result

    def build_interface(self):
        result = []

        for cenum in self.members(xpidl.CEnum):
            result.append('')
            result.extend(build_comments(cenum, False))
            result.extend(self.build_cenum(cenum))

        result.extend([
            '',
            'export interface %sRef {' % self.name,
            '  readonly name: "%s";' % self.name,
            '  readonly number: "{%s}";' % self.idl.attributes.uuid,
        ])

        for cenum in self.members(xpidl.CEnum):
            result.append('')
            result.extend(indent(self.build_cenum_variants(cenum), 2))

        for const in self.members(xpidl.ConstMember):
            result.extend(indent(build_comments(const, True), 2))
            result.append(indent(self.build_const(const), 2))

        result.append('}')

        if self.name == 'nsISupports':
            return result

        if self.idl.attributes.function:
            result.append('')
            result.append(self.build_method_interface(list(self.members(xpidl.Method))[0]))

        base = self.idl.base
        if base is None:
            base = "nsISupports"

        result.append('')
        result.extend(build_comments(self.idl, False))
        result.append('export interface %s extends %s {' % (self.name, base))

        for member in self.idl.members:
            if isinstance(member, xpidl.Attribute):
                result.extend(indent(build_comments(member, True), 2))
                result.append(indent(self.build_attribute(member), 2))

            if isinstance(member, xpidl.Method):
                result.extend(indent(build_comments(member, True), 2))
                result.append(indent(self.build_method_property(member), 2))

        result.append('}')
        return result[1:]

class DefinitionManager:
    def __init__(self):
        self.interfaces = {}

    def append_idl(self, idl):
        for production in idl.productions:
            if isinstance(production, xpidl.Interface) and is_scriptable(production):
                self.interfaces[production.name] = InterfaceDefinition(production)

    def resolve(self):
        for interface in list(self.interfaces.values()):
            interface.resolve(self)

    def resolve_type(self, idl_type):
        if isinstance(idl_type, xpidl.Typedef):
            return self.resolve_type(idl_type.realtype)

        if isinstance(idl_type, xpidl.Forward):
            if not idl_type.name in self.interfaces:
                return None
            return self.interfaces.get(idl_type.name).idl

        if isinstance(idl_type, xpidl.Array) or isinstance(idl_type, xpidl.LegacyArray):
            idl_type.type = self.resolve_type(idl_type.type)

        return idl_type

    def write_lists(self, fp):
        fp.write(lists_header)
        fp.write('  export interface InterfaceRefs {\n')
        for iface in self.interfaces.values():
            fp.write('    %s: %sRef;\n' % (iface.name, iface.name))
        fp.write('  }\n')
        fp.write('\n  export interface Interfaces {\n')
        for iface in self.interfaces.values():
            fp.write('    %s: %s;\n' % (iface.name, iface.name))
        fp.write('  }\n')
        fp.write(lists_footer)

    def write_interfaces(self, fp):
        result = []
        for interface in self.interfaces.values():
            result.append('')
            result.extend(indent(interface.build_interface(), 2))

        fp.write(idl_header)
        fp.write('\n'.join(result[1:]))
        fp.write(idl_footer)

# This function is bound to `./mach typescript xpcom`
def main(argv):
    LOG.info("Generating TypeScript definitions for XPCOM bindings")
    parser = argparse.ArgumentParser()
    parser.add_argument('bindings_conf',
                        help='The bindings config file.')
    parser.add_argument('target',
                        help='The directory to write to.')

    args = parser.parse_args(argv)

    LOG.info(' - "bindings_conf" set to: %s' % args.bindings_conf)
    LOG.info(' - "target" set to: %s' % args.target)

    tempdir = tempfile.mkdtemp()
    try:
        LOG.info("Loading the IDL parser using temp directory %s" % tempdir)
        parser = xpidl.IDLParser(outputdir=tempdir)

        LOG.info("Executing the file: %s" % args.bindings_conf)
        glbl = {}
        execfile(args.bindings_conf, glbl)
        webidlconfig = glbl['DOMInterfaces']

        LOG.info("Read stdin for the list of files to process")
        # This list comes from stdin and is sent to this script via the mach command.
        dirs = set()
        files = []
        for line in sys.stdin:
            filename = line.strip()
            dirs.add(os.path.dirname(filename))
            files.append(filename)

        manager = DefinitionManager()

        LOG.info("Start processing the files")
        for filename in files:
            LOG.debug("Parse: %s" % filename)
            idl_data = open(filename).read()
            idl = parser.parse(idl_data, filename)
            idl.resolve(list(dirs), parser, webidlconfig)
            manager.append_idl(idl)

        manager.resolve()

        idl_path = os.path.join(args.target, 'idl.d.ts')
        LOG.info("Writing: %s" % idl_path)
        with open(idl_path, 'w') as fp:
            manager.write_interfaces(fp)

        interface_lists = os.path.join(args.target, 'interface_lists.d.ts')
        LOG.info("Writing: %s" % interface_lists)
        with open(interface_lists, 'w') as fp:
            manager.write_lists(fp)

    finally:
        rmtree(tempdir)

if __name__ == '__main__':
    main(sys.argv[1:])
