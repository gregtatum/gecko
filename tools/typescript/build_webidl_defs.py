# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, # You can obtain one at http://mozilla.org/MPL/2.0/.

import os
import re
import sys
import json
import argparse
import tempfile
from shutil import rmtree

import WebIDL

header = """/// <reference path="types.d.ts" />
/*
 * DO NOT EDIT. THIS FILE IS AUTOMATICALLY GENERATED.
 */

declare namespace WebIDL {
"""

footer = """
}
"""

enum_name_re = re.compile(r"""[^a-zA-Z]""")
def enum_name(value):
    if len(value) == 0:
        return '_empty'
    name = re.sub(enum_name_re, '_', value)
    return name[0].upper() + name[1:]

js_name_re = re.compile(r"""^[a-zA-Z_][a-zA-Z0-9_]*$""")
def js_name(identifier):
    if js_name_re.match(identifier.name) is None:
        return '"%s"' % identifier.name
    return identifier.name

def js_type_not_nullable(webidl_type):
    if isinstance(webidl_type, WebIDL.IDLUnionType):
        return ' | '.join(map(js_type, webidl_type.memberTypes))

    if isinstance(webidl_type, WebIDL.IDLSequenceType):
        return '%s[]' % js_type(webidl_type.inner)

    if isinstance(webidl_type, WebIDL.IDLRecordType):
        return 'Record<%s, %s>' % (js_type(webidl_type.keyType), js_type(webidl_type.inner))

    if isinstance(webidl_type, WebIDL.IDLPromiseType):
        return 'Promise<%s>' % js_type(webidl_type.inner)

    if isinstance(webidl_type, WebIDL.IDLExternalInterface):
        return 'XPCOM.%s' % webidl_type.name

    if isinstance(webidl_type, WebIDL.IDLCallbackType):
        return webidl_type.name

    if isinstance(webidl_type, WebIDL.IDLWrapperType):
        return webidl_type.name

    if isinstance(webidl_type, WebIDL.IDLBuiltinType):
        if webidl_type.isString():
            return 'string'
        if webidl_type.isBoolean():
            return 'boolean'
        if webidl_type.isNumeric():
            return 'number'
        if webidl_type.isAny():
            return 'any'
        if webidl_type.isDate():
            return 'Date'
        if webidl_type.isObject():
            return 'object'
        if webidl_type.isVoid():
            return 'void'

        return webidl_type.name

    print("Not sure about type %s" % repr(webidl_type))
    return webidl_type.name

def js_type(webidl_type):
    if isinstance(webidl_type, WebIDL.IDLNullableType):
        return '%s | null' % js_type_not_nullable(webidl_type.inner)
    return js_type_not_nullable(webidl_type)

def indent(lines, depth):
    if not isinstance(lines, list):
        return indent([lines], depth)[0]
    return map(lambda l: (l.rjust(len(l) + depth) if len(l) > 0 else ''), lines)

def build_enum(enum):
    result = []

    for value in enum.values():
        result.append('%s = "%s",' % (enum_name(value), value))

    return ['enum %s {' % enum.identifier.name] + indent(result, 2) + ['}']

def build_argument(argument):
    optional = '?' if argument.optional else ''
    return '%s%s: %s' % (js_name(argument.identifier), optional, js_type(argument.type))

def build_dictionary(dictionary):
    result = []

    for member in dictionary.members:
        if isinstance(member, WebIDL.IDLArgument):
            result.append(build_argument(member))

    return ['interface %s {' % dictionary.identifier.name] + indent(result, 2) + ['}']

def build_attribute(attr):
    static = 'static ' if attr.isStatic() else ''
    readonly = 'readonly ' if attr.readonly else ''
    return '%s%s%s: %s' % (static, readonly, js_name(attr.identifier), js_type(attr.type))

def build_methods(method):
    return ['%s(%s): %s' % (js_name(method.identifier), ', '.join(params), returnType)
            for (params, returnType) in build_method_signatures(method)]

def build_interface(iface):
    result = []

    for constr in iface.namedConstructors:
        print("Hello %s" % constr.identifier.name)

    for member in iface.members:
        if isinstance(member, WebIDL.IDLAttribute):
            result.append('%s;' % build_attribute(member))
        if isinstance(member, WebIDL.IDLMethod):
            result.extend(['%s;' % method for method in build_methods(member)])

    return ['class %s {' % iface.identifier.name] + indent(result, 2) + ['}']

def build_method_signatures(method):
    for (returnType, arguments) in method.signatures():
        yield ([build_argument(arg) for arg in arguments], js_type(returnType))

def build_callback(callback):
    return ['function %s(%s): %s;' % (callback.identifier.name, ', '.join(params), returnType)
            for (params, returnType) in build_method_signatures(callback)]

def main(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument('filelists',
                        help='The file-lists.json file.')
    parser.add_argument('target',
                        help='The directory to write to.')

    args = parser.parse_args(argv)

    fh = open(args.filelists)
    files = json.load(fh)['webidls']
    fh.close()

    tempdir = tempfile.mkdtemp()
    seen = set()
    try:
        parser = WebIDL.Parser(tempdir)
        for filename in files:
            if filename in seen:
                continue
            seen.add(filename)
            f = open(filename, 'rb')
            data = f.read()
            f.close()
            parser.parse(data, filename)
        productions = parser.finish()

        with open(os.path.join(args.target, 'webidl.d.ts'), 'w') as fp:
            fp.write(header)

            for production in productions:
                if isinstance(production, WebIDL.IDLCallback):
                    fp.write('\n')
                    fp.write('\n'.join(indent(build_callback(production), 2)))

                elif isinstance(production, WebIDL.IDLInterface):
                    fp.write('\n')
                    fp.write('\n'.join(indent(build_interface(production), 2)))

                elif isinstance(production, WebIDL.IDLEnum):
                    fp.write('\n')
                    fp.write('\n'.join(indent(build_enum(production), 2)))

                elif isinstance(production, WebIDL.IDLDictionary):
                    fp.write('\n')
                    fp.write('\n'.join(indent(build_dictionary(production), 2)))

            fp.write(footer)
    finally:
        rmtree(tempdir)

if __name__ == '__main__':
    main(sys.argv[1:])
